0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1ef0ebd8434222f67b5e768fe8e8745c3dbb2102;test/e2e/empty_dir_wrapper.go[test/e2e/empty_dir_wrapper.go][test/e2e/storage/empty_dir_wrapper.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// These numbers are obtained empirically.
0000000000000000000000000000000000000000;;		// If you make them too low, you'll get flaky
0000000000000000000000000000000000000000;;		// tests instead of failing ones if the race bug reappears.
0000000000000000000000000000000000000000;;		// If you make volume counts or pod counts too high,
0000000000000000000000000000000000000000;;		// the tests may fail because mounting configmap/git_repo
0000000000000000000000000000000000000000;;		// volumes is not very fast and the tests may time out
0000000000000000000000000000000000000000;;		// waiting for pods to become Running.
0000000000000000000000000000000000000000;;		// And of course the higher are the numbers, the
0000000000000000000000000000000000000000;;		// slower are the tests.
0000000000000000000000000000000000000000;;		wrappedVolumeRaceConfigMapVolumeCount    = 50
0000000000000000000000000000000000000000;;		wrappedVolumeRaceConfigMapPodCount       = 5
0000000000000000000000000000000000000000;;		wrappedVolumeRaceConfigMapIterationCount = 3
0000000000000000000000000000000000000000;;		wrappedVolumeRaceGitRepoVolumeCount      = 50
0000000000000000000000000000000000000000;;		wrappedVolumeRaceGitRepoPodCount         = 5
0000000000000000000000000000000000000000;;		wrappedVolumeRaceGitRepoIterationCount   = 3
0000000000000000000000000000000000000000;;		wrappedVolumeRaceRCNamePrefix            = "wrapped-volume-race-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("EmptyDir wrapper volumes", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("emptydir-wrapper")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not conflict [Volume]", func() {
0000000000000000000000000000000000000000;;			name := "emptydir-wrapper-test-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			volumeName := "secret-volume"
0000000000000000000000000000000000000000;;			volumeMountPath := "/etc/secret-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			secret := &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string][]byte{
0000000000000000000000000000000000000000;;					"data-1": []byte("value-1\n"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gitVolumeName := "git-volume"
0000000000000000000000000000000000000000;;			gitVolumeMountPath := "/etc/git-volume"
0000000000000000000000000000000000000000;;			gitURL, gitRepo, gitCleanup := createGitServer(f)
0000000000000000000000000000000000000000;;			defer gitCleanup()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "pod-secrets-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: volumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;									SecretName: name,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: gitVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								GitRepo: &v1.GitRepoVolumeSource{
0000000000000000000000000000000000000000;;									Repository: gitURL,
0000000000000000000000000000000000000000;;									Directory:  gitRepo,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "secret-test",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/test-webserver:e2e",
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      volumeName,
0000000000000000000000000000000000000000;;									MountPath: volumeMountPath,
0000000000000000000000000000000000000000;;									ReadOnly:  true,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:      gitVolumeName,
0000000000000000000000000000000000000000;;									MountPath: gitVolumeMountPath,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod = f.PodClient().CreateSync(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				By("Cleaning up the secret")
0000000000000000000000000000000000000000;;				if err := f.ClientSet.Core().Secrets(f.Namespace.Name).Delete(secret.Name, nil); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("unable to delete secret %v: %v", secret.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("Cleaning up the git vol pod")
0000000000000000000000000000000000000000;;				if err = f.ClientSet.Core().Pods(f.Namespace.Name).Delete(pod.Name, metav1.NewDeleteOptions(0)); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("unable to delete git vol pod %v: %v", pod.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The following two tests check for the problem fixed in #29641.
0000000000000000000000000000000000000000;;		// In order to reproduce it you need to revert the fix, e.g. via
0000000000000000000000000000000000000000;;		// git revert -n df1e925143daf34199b55ffb91d0598244888cce
0000000000000000000000000000000000000000;;		// or
0000000000000000000000000000000000000000;;		// curl -sL https://github.com/kubernetes/kubernetes/pull/29641.patch | patch -p1 -R
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// After that these tests will fail because some of the pods
0000000000000000000000000000000000000000;;		// they create never enter Running state.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// They need to be [Serial] and [Slow] because they try to induce
0000000000000000000000000000000000000000;;		// the race by creating pods with many volumes and container volume mounts,
0000000000000000000000000000000000000000;;		// which takes considerable time and may interfere with other tests.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Probably should also try making tests for secrets and downwardapi,
0000000000000000000000000000000000000000;;		// but these cases are harder because tmpfs-based emptyDir
0000000000000000000000000000000000000000;;		// appears to be less prone to the race problem.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not cause race condition when used for configmaps [Serial] [Slow] [Volume]", func() {
0000000000000000000000000000000000000000;;			configMapNames := createConfigmapsForRace(f)
0000000000000000000000000000000000000000;;			defer deleteConfigMaps(f, configMapNames)
0000000000000000000000000000000000000000;;			volumes, volumeMounts := makeConfigMapVolumes(configMapNames)
0000000000000000000000000000000000000000;;			for i := 0; i < wrappedVolumeRaceConfigMapIterationCount; i++ {
0000000000000000000000000000000000000000;;				testNoWrappedVolumeRace(f, volumes, volumeMounts, wrappedVolumeRaceConfigMapPodCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not cause race condition when used for git_repo [Serial] [Slow] [Volume]", func() {
0000000000000000000000000000000000000000;;			gitURL, gitRepo, cleanup := createGitServer(f)
0000000000000000000000000000000000000000;;			defer cleanup()
0000000000000000000000000000000000000000;;			volumes, volumeMounts := makeGitRepoVolumes(gitURL, gitRepo)
0000000000000000000000000000000000000000;;			for i := 0; i < wrappedVolumeRaceGitRepoIterationCount; i++ {
0000000000000000000000000000000000000000;;				testNoWrappedVolumeRace(f, volumes, volumeMounts, wrappedVolumeRaceGitRepoPodCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createGitServer(f *framework.Framework) (gitURL string, gitRepo string, cleanup func()) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		gitServerPodName := "git-server-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		containerPort := 8000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels := map[string]string{"name": gitServerPodName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gitServerPod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   gitServerPodName,
0000000000000000000000000000000000000000;;				Labels: labels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:            "git-repo",
0000000000000000000000000000000000000000;;						Image:           "gcr.io/google_containers/fakegitserver:0.1",
0000000000000000000000000000000000000000;;						ImagePullPolicy: "IfNotPresent",
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{ContainerPort: int32(containerPort)},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.PodClient().CreateSync(gitServerPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Portal IP and port
0000000000000000000000000000000000000000;;		httpPort := 2345
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gitServerSvc := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "git-server-svc",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: labels,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       "http-portal",
0000000000000000000000000000000000000000;;						Port:       int32(httpPort),
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(containerPort),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gitServerSvc, err = f.ClientSet.Core().Services(f.Namespace.Name).Create(gitServerSvc); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to create test git server service %s: %v", gitServerSvc.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "http://" + gitServerSvc.Spec.ClusterIP + ":" + strconv.Itoa(httpPort), "test", func() {
0000000000000000000000000000000000000000;;			By("Cleaning up the git server pod")
0000000000000000000000000000000000000000;;			if err := f.ClientSet.Core().Pods(f.Namespace.Name).Delete(gitServerPod.Name, metav1.NewDeleteOptions(0)); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to delete git server pod %v: %v", gitServerPod.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Cleaning up the git server svc")
0000000000000000000000000000000000000000;;			if err := f.ClientSet.Core().Services(f.Namespace.Name).Delete(gitServerSvc.Name, nil); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to delete git server svc %v: %v", gitServerSvc.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeGitRepoVolumes(gitURL, gitRepo string) (volumes []v1.Volume, volumeMounts []v1.VolumeMount) {
0000000000000000000000000000000000000000;;		for i := 0; i < wrappedVolumeRaceGitRepoVolumeCount; i++ {
0000000000000000000000000000000000000000;;			volumeName := fmt.Sprintf("racey-git-repo-%d", i)
0000000000000000000000000000000000000000;;			volumes = append(volumes, v1.Volume{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					GitRepo: &v1.GitRepoVolumeSource{
0000000000000000000000000000000000000000;;						Repository: gitURL,
0000000000000000000000000000000000000000;;						Directory:  gitRepo,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			volumeMounts = append(volumeMounts, v1.VolumeMount{
0000000000000000000000000000000000000000;;				Name:      volumeName,
0000000000000000000000000000000000000000;;				MountPath: fmt.Sprintf("/etc/git-volume-%d", i),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createConfigmapsForRace(f *framework.Framework) (configMapNames []string) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating %d configmaps", wrappedVolumeRaceConfigMapVolumeCount))
0000000000000000000000000000000000000000;;		for i := 0; i < wrappedVolumeRaceConfigMapVolumeCount; i++ {
0000000000000000000000000000000000000000;;			configMapName := fmt.Sprintf("racey-configmap-%d", i)
0000000000000000000000000000000000000000;;			configMapNames = append(configMapNames, configMapName)
0000000000000000000000000000000000000000;;			configMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Name:      configMapName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					"data-1": "value-1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteConfigMaps(f *framework.Framework, configMapNames []string) {
0000000000000000000000000000000000000000;;		By("Cleaning up the configMaps")
0000000000000000000000000000000000000000;;		for _, configMapName := range configMapNames {
0000000000000000000000000000000000000000;;			err := f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Delete(configMapName, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "unable to delete configMap %v", configMapName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeConfigMapVolumes(configMapNames []string) (volumes []v1.Volume, volumeMounts []v1.VolumeMount) {
0000000000000000000000000000000000000000;;		for i, configMapName := range configMapNames {
0000000000000000000000000000000000000000;;			volumeName := fmt.Sprintf("racey-configmap-%d", i)
0000000000000000000000000000000000000000;;			volumes = append(volumes, v1.Volume{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;						LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;							Name: configMapName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Items: []v1.KeyToPath{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:  "data-1",
0000000000000000000000000000000000000000;;								Path: "data-1",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			volumeMounts = append(volumeMounts, v1.VolumeMount{
0000000000000000000000000000000000000000;;				Name:      volumeName,
0000000000000000000000000000000000000000;;				MountPath: fmt.Sprintf("/etc/config-%d", i),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testNoWrappedVolumeRace(f *framework.Framework, volumes []v1.Volume, volumeMounts []v1.VolumeMount, podCount int32) {
0000000000000000000000000000000000000000;;		rcName := wrappedVolumeRaceRCNamePrefix + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;		Expect(len(nodeList.Items)).To(BeNumerically(">", 0))
0000000000000000000000000000000000000000;;		targetNode := nodeList.Items[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating RC which spawns configmap-volume pods")
0000000000000000000000000000000000000000;;		affinity := &v1.Affinity{
0000000000000000000000000000000000000000;;			NodeAffinity: &v1.NodeAffinity{
0000000000000000000000000000000000000000;;				RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;					NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Key:      "kubernetes.io/hostname",
0000000000000000000000000000000000000000;;									Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;									Values:   []string{targetNode.Name},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: rcName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: &podCount,
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"name": rcName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": rcName},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    "test-container",
0000000000000000000000000000000000000000;;								Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Command: []string{"sleep", "10000"},
0000000000000000000000000000000000000000;;								Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;									Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;										v1.ResourceCPU: resource.MustParse("10m"),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								VolumeMounts: volumeMounts,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Affinity:  affinity,
0000000000000000000000000000000000000000;;						DNSPolicy: v1.DNSDefault,
0000000000000000000000000000000000000000;;						Volumes:   volumes,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := f.ClientSet.Core().ReplicationControllers(f.Namespace.Name).Create(rc)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "error creating replication controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			err := framework.DeleteRCAndPods(f.ClientSet, f.InternalClientset, f.Namespace.Name, rcName)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := framework.PodsCreated(f.ClientSet, f.Namespace.Name, rcName, podCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Ensuring each pod is running")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the pods to enter the running state. Waiting loops until the pods
0000000000000000000000000000000000000000;;		// are running so non-running pods cause a timeout for this test.
0000000000000000000000000000000000000000;;		for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;			if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = f.WaitForPodRunning(pod.Name)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed waiting for pod %s to enter running state", pod.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
