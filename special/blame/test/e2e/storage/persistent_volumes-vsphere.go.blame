0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
fab7df78a1367134c1d54b3a56c6aa9166dc83fd;test/e2e/persistent_volumes-vsphere.go[test/e2e/persistent_volumes-vsphere.go][test/e2e/storage/persistent_volumes-vsphere.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		vsphere "k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Testing configurations of single a PV/PVC pair attached to a vSphere Disk
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("PersistentVolumes:vsphere", func() {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			c          clientset.Interface
0000000000000000000000000000000000000000;;			ns         string
0000000000000000000000000000000000000000;;			volumePath string
0000000000000000000000000000000000000000;;			pv         *v1.PersistentVolume
0000000000000000000000000000000000000000;;			pvc        *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;			clientPod  *v1.Pod
0000000000000000000000000000000000000000;;			pvConfig   framework.PersistentVolumeConfig
0000000000000000000000000000000000000000;;			pvcConfig  framework.PersistentVolumeClaimConfig
0000000000000000000000000000000000000000;;			vsp        *vsphere.VSphere
0000000000000000000000000000000000000000;;			err        error
0000000000000000000000000000000000000000;;			node       types.NodeName
0000000000000000000000000000000000000000;;			volLabel   labels.Set
0000000000000000000000000000000000000000;;			selector   *metav1.LabelSelector
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("pv")
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Test Setup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			1. Create volume (vmdk)
0000000000000000000000000000000000000000;;			2. Create PV with volume path for the vmdk.
0000000000000000000000000000000000000000;;			3. Create PVC to bind with PV.
0000000000000000000000000000000000000000;;			4. Create a POD using the PVC.
0000000000000000000000000000000000000000;;			5. Verify Disk and Attached to the node.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("vsphere")
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			clientPod = nil
0000000000000000000000000000000000000000;;			pvc = nil
0000000000000000000000000000000000000000;;			pv = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volLabel = labels.Set{framework.VolumeSelectorKey: ns}
0000000000000000000000000000000000000000;;			selector = metav1.SetAsLabelSelector(volLabel)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if vsp == nil {
0000000000000000000000000000000000000000;;				vsp, err = vsphere.GetVSphere()
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if volumePath == "" {
0000000000000000000000000000000000000000;;				volumePath, err = createVSphereVolume(vsp, nil)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				pvConfig = framework.PersistentVolumeConfig{
0000000000000000000000000000000000000000;;					NamePrefix: "vspherepv-",
0000000000000000000000000000000000000000;;					Labels:     volLabel,
0000000000000000000000000000000000000000;;					PVSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						VsphereVolume: &v1.VsphereVirtualDiskVolumeSource{
0000000000000000000000000000000000000000;;							VolumePath: volumePath,
0000000000000000000000000000000000000000;;							FSType:     "ext4",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Prebind: nil,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pvcConfig = framework.PersistentVolumeClaimConfig{
0000000000000000000000000000000000000000;;					Annotations: map[string]string{
0000000000000000000000000000000000000000;;						v1.BetaStorageClassAnnotation: "",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Selector: selector,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Creating the PV and PVC")
0000000000000000000000000000000000000000;;			pv, pvc, err = framework.CreatePVPVC(c, pvConfig, pvcConfig, ns, false)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.WaitOnPVandPVC(c, ns, pv, pvc))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating the Client Pod")
0000000000000000000000000000000000000000;;			clientPod, err = framework.CreateClientPod(c, ns, pvc)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			node := types.NodeName(clientPod.Spec.NodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Verify disk should be attached to the node")
0000000000000000000000000000000000000000;;			isAttached, err := verifyVSphereDiskAttached(vsp, volumePath, node)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(isAttached).To(BeTrue(), "disk is not attached with the node")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			framework.Logf("AfterEach: Cleaning up test resources")
0000000000000000000000000000000000000000;;			if c != nil {
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.DeletePodWithWait(f, c, clientPod), "AfterEach: failed to delete pod ", clientPod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if pv != nil {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.DeletePersistentVolume(c, pv.Name), "AfterEach: failed to delete PV ", pv.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pvc != nil {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.DeletePersistentVolumeClaim(c, pvc.Name, ns), "AfterEach: failed to delete PVC ", pvc.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Clean up
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			1. Wait and verify volume is detached from the node
0000000000000000000000000000000000000000;;			2. Delete PV
0000000000000000000000000000000000000000;;			3. Delete Volume (vmdk)
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		framework.AddCleanupAction(func() {
0000000000000000000000000000000000000000;;			if len(volumePath) > 0 {
0000000000000000000000000000000000000000;;				framework.ExpectNoError(waitForVSphereDiskToDetach(vsp, volumePath, node))
0000000000000000000000000000000000000000;;				vsp.DeleteVolume(volumePath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Delete the PVC and then the pod.  Expect the pod to succeed in unmounting and detaching PD on delete.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Test Steps:
0000000000000000000000000000000000000000;;			1. Delete PVC.
0000000000000000000000000000000000000000;;			2. Delete POD, POD deletion should succeed.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach", func() {
0000000000000000000000000000000000000000;;			By("Deleting the Claim")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePersistentVolumeClaim(c, pvc.Name, ns), "Failed to delete PVC ", pvc.Name)
0000000000000000000000000000000000000000;;			pvc = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the Pod")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePodWithWait(f, c, clientPod), "Failed to delete pod ", clientPod.Name)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Delete the PV and then the pod.  Expect the pod to succeed in unmounting and detaching PD on delete.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Test Steps:
0000000000000000000000000000000000000000;;			1. Delete PV.
0000000000000000000000000000000000000000;;			2. Delete POD, POD deletion should succeed.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		It("should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach", func() {
0000000000000000000000000000000000000000;;			By("Deleting the Persistent Volume")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePersistentVolume(c, pv.Name), "Failed to delete PV ", pv.Name)
0000000000000000000000000000000000000000;;			pv = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the pod")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePodWithWait(f, c, clientPod), "Failed to delete pod ", clientPod.Name)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			This test verifies that a volume mounted to a pod remains mounted after a kubelet restarts.
0000000000000000000000000000000000000000;;			Steps:
0000000000000000000000000000000000000000;;			1. Write to the volume
0000000000000000000000000000000000000000;;			2. Restart kubelet
0000000000000000000000000000000000000000;;			3. Verify that written file is accessible after kubelet restart
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		It("should test that a file written to the vspehre volume mount before kubelet restart can be read after restart [Disruptive]", func() {
0000000000000000000000000000000000000000;;			testKubeletRestartsAndRestoresMount(c, f, clientPod, pvc, pv)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			This test verifies that a volume mounted to a pod that is deleted while the kubelet is down
0000000000000000000000000000000000000000;;			unmounts volume when the kubelet returns.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Steps:
0000000000000000000000000000000000000000;;			1. Verify volume is mounted on the node.
0000000000000000000000000000000000000000;;			2. Stop kubelet.
0000000000000000000000000000000000000000;;			3. Delete pod.
0000000000000000000000000000000000000000;;			4. Start kubelet.
0000000000000000000000000000000000000000;;			5. Verify that volume mount not to be found.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		It("should test that a vspehre volume mounted to a pod that is deleted while the kubelet is down unmounts when the kubelet returns [Disruptive]", func() {
0000000000000000000000000000000000000000;;			testVolumeUnmountsFromDeletedPod(c, f, clientPod, pvc, pv)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			This test verifies that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Steps:
0000000000000000000000000000000000000000;;			1. Delete Namespace.
0000000000000000000000000000000000000000;;			2. Wait for namespace to get deleted. (Namespace deletion should trigger deletion of belonging pods)
0000000000000000000000000000000000000000;;			3. Verify volume should be detached from the node.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		It("should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume", func() {
0000000000000000000000000000000000000000;;			By("Deleting the Namespace")
0000000000000000000000000000000000000000;;			err := c.CoreV1().Namespaces().Delete(ns, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = framework.WaitForNamespacesDeleted(c, []string{ns}, 3*time.Minute)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Verifying Persistent Disk detaches")
0000000000000000000000000000000000000000;;			waitForVSphereDiskToDetach(vsp, volumePath, node)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
