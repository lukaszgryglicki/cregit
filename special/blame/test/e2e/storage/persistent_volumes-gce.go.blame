0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
15b884e0b5268bc9d6de6d924d674bd3c55bc4f1;test/e2e/persistent_volumes-gce.go[test/e2e/persistent_volumes-gce.go][test/e2e/storage/persistent_volumes-gce.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyGCEDiskAttached performs a sanity check to verify the PD attached to the node
0000000000000000000000000000000000000000;;	func verifyGCEDiskAttached(diskName string, nodeName types.NodeName) bool {
0000000000000000000000000000000000000000;;		gceCloud, err := framework.GetGCECloud()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		isAttached, err := gceCloud.DiskIsAttached(diskName, nodeName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return isAttached
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// initializeGCETestSpec creates a PV, PVC, and ClientPod that will run until killed by test or clean up.
0000000000000000000000000000000000000000;;	func initializeGCETestSpec(c clientset.Interface, ns string, pvConfig framework.PersistentVolumeConfig, pvcConfig framework.PersistentVolumeClaimConfig, isPrebound bool) (*v1.Pod, *v1.PersistentVolume, *v1.PersistentVolumeClaim) {
0000000000000000000000000000000000000000;;		By("Creating the PV and PVC")
0000000000000000000000000000000000000000;;		pv, pvc, err := framework.CreatePVPVC(c, pvConfig, pvcConfig, ns, isPrebound)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitOnPVandPVC(c, ns, pv, pvc))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating the Client Pod")
0000000000000000000000000000000000000000;;		clientPod, err := framework.CreateClientPod(c, ns, pvc)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return clientPod, pv, pvc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Testing configurations of single a PV/PVC pair attached to a GCE PD
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("PersistentVolumes:GCEPD", func() {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			c         clientset.Interface
0000000000000000000000000000000000000000;;			diskName  string
0000000000000000000000000000000000000000;;			ns        string
0000000000000000000000000000000000000000;;			err       error
0000000000000000000000000000000000000000;;			pv        *v1.PersistentVolume
0000000000000000000000000000000000000000;;			pvc       *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;			clientPod *v1.Pod
0000000000000000000000000000000000000000;;			pvConfig  framework.PersistentVolumeConfig
0000000000000000000000000000000000000000;;			pvcConfig framework.PersistentVolumeClaimConfig
0000000000000000000000000000000000000000;;			volLabel  labels.Set
0000000000000000000000000000000000000000;;			selector  *metav1.LabelSelector
0000000000000000000000000000000000000000;;			node      types.NodeName
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("pv")
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Enforce binding only within test space via selector labels
0000000000000000000000000000000000000000;;			volLabel = labels.Set{framework.VolumeSelectorKey: ns}
0000000000000000000000000000000000000000;;			selector = metav1.SetAsLabelSelector(volLabel)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;			By("Initializing Test Spec")
0000000000000000000000000000000000000000;;			diskName, err = framework.CreatePDWithRetry()
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			pvConfig = framework.PersistentVolumeConfig{
0000000000000000000000000000000000000000;;				NamePrefix: "gce-",
0000000000000000000000000000000000000000;;				Labels:     volLabel,
0000000000000000000000000000000000000000;;				PVSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;						PDName:   diskName,
0000000000000000000000000000000000000000;;						FSType:   "ext3",
0000000000000000000000000000000000000000;;						ReadOnly: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Prebind: nil,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pvcConfig = framework.PersistentVolumeClaimConfig{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					v1.BetaStorageClassAnnotation: "",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Selector: selector,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clientPod, pv, pvc = initializeGCETestSpec(c, ns, pvConfig, pvcConfig, false)
0000000000000000000000000000000000000000;;			node = types.NodeName(clientPod.Spec.NodeName)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			framework.Logf("AfterEach: Cleaning up test resources")
0000000000000000000000000000000000000000;;			if c != nil {
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.DeletePodWithWait(f, c, clientPod))
0000000000000000000000000000000000000000;;				if errs := framework.PVPVCCleanup(c, ns, pv, pvc); len(errs) > 0 {
0000000000000000000000000000000000000000;;					framework.Failf("AfterEach: Failed to delete PVC and/or PV. Errors: %v", utilerrors.NewAggregate(errs))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				clientPod, pv, pvc, node = nil, nil, nil, ""
0000000000000000000000000000000000000000;;				if diskName != "" {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.DeletePDWithRetry(diskName))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attach a persistent disk to a pod using a PVC.
0000000000000000000000000000000000000000;;		// Delete the PVC and then the pod.  Expect the pod to succeed in unmounting and detaching PD on delete.
0000000000000000000000000000000000000000;;		It("should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the Claim")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePersistentVolumeClaim(c, pvc.Name, ns), "Unable to delete PVC ", pvc.Name)
0000000000000000000000000000000000000000;;			Expect(verifyGCEDiskAttached(diskName, node)).To(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the Pod")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePodWithWait(f, c, clientPod), "Failed to delete pod ", clientPod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Verifying Persistent Disk detach")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(waitForPDDetach(diskName, node), "PD ", diskName, " did not detach")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attach a persistent disk to a pod using a PVC.
0000000000000000000000000000000000000000;;		// Delete the PV and then the pod.  Expect the pod to succeed in unmounting and detaching PD on delete.
0000000000000000000000000000000000000000;;		It("should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the Persistent Volume")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePersistentVolume(c, pv.Name), "Failed to delete PV ", pv.Name)
0000000000000000000000000000000000000000;;			Expect(verifyGCEDiskAttached(diskName, node)).To(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the client pod")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePodWithWait(f, c, clientPod), "Failed to delete pod ", clientPod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Verifying Persistent Disk detaches")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(waitForPDDetach(diskName, node), "PD ", diskName, " did not detach")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test that a Pod and PVC attached to a GCEPD successfully unmounts and detaches when the encompassing Namespace is deleted.
0000000000000000000000000000000000000000;;		It("should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the Namespace")
0000000000000000000000000000000000000000;;			err := c.CoreV1().Namespaces().Delete(ns, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = framework.WaitForNamespacesDeleted(c, []string{ns}, framework.DefaultNamespaceDeletionTimeout)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Verifying Persistent Disk detaches")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(waitForPDDetach(diskName, node), "PD ", diskName, " did not detach")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
