0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2bfbbbaf692c59c906242990fddc8ee37f4eef8c;test/e2e/volumes.go[test/e2e/volumes.go][test/e2e/storage/volumes.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * This test checks that various VolumeSources are working.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * There are two ways, how to test the volumes:
0000000000000000000000000000000000000000;;	 * 1) With containerized server (NFS, Ceph, Gluster, iSCSI, ...)
0000000000000000000000000000000000000000;;	 * The test creates a server pod, exporting simple 'index.html' file.
0000000000000000000000000000000000000000;;	 * Then it uses appropriate VolumeSource to import this file into a client pod
0000000000000000000000000000000000000000;;	 * and checks that the pod can see the file. It does so by importing the file
0000000000000000000000000000000000000000;;	 * into web server root and loadind the index.html from it.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * These tests work only when privileged containers are allowed, exporting
0000000000000000000000000000000000000000;;	 * various filesystems (NFS, GlusterFS, ...) usually needs some mounting or
0000000000000000000000000000000000000000;;	 * other privileged magic in the server pod.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Note that the server containers are for testing purposes only and should not
0000000000000000000000000000000000000000;;	 * be used in production.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * 2) With server outside of Kubernetes (Cinder, ...)
0000000000000000000000000000000000000000;;	 * Appropriate server (e.g. OpenStack Cinder) must exist somewhere outside
0000000000000000000000000000000000000000;;	 * the tested Kubernetes cluster. The test itself creates a new volume,
0000000000000000000000000000000000000000;;	 * and checks, that Kubernetes can use it as a volume.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// test/e2e/common/volumes.go duplicates the GlusterFS test from this file.  Any changes made to this
0000000000000000000000000000000000000000;;	// test should be made there as well.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeleteCinderVolume(name string) error {
0000000000000000000000000000000000000000;;		// Try to delete the volume for several seconds - it takes
0000000000000000000000000000000000000000;;		// a while for the plugin to detach it.
0000000000000000000000000000000000000000;;		var output []byte
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		timeout := time.Second * 120
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting up to %v for removal of cinder volume %s", timeout, name)
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < timeout; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;			output, err = exec.Command("cinder", "delete", name).CombinedOutput()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				framework.Logf("Cinder volume %s deleted", name)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Logf("Failed to delete volume %s: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("Giving up deleting volume %s: %v\n%s", name, err, string(output[:]))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These tests need privileged containers, which are disabled by default.
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Volumes", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("volume")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If 'false', the test won't clear its volumes upon completion. Useful for debugging,
0000000000000000000000000000000000000000;;		// note that namespace deletion is handled by delete-namespace flag
0000000000000000000000000000000000000000;;		clean := true
0000000000000000000000000000000000000000;;		// filled in BeforeEach
0000000000000000000000000000000000000000;;		var cs clientset.Interface
0000000000000000000000000000000000000000;;		var namespace *v1.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			cs = f.ClientSet
0000000000000000000000000000000000000000;;			namespace = f.Namespace
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// NFS
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("NFS", func() {
0000000000000000000000000000000000000000;;			It("should be mountable", func() {
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace:   namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:      "nfs",
0000000000000000000000000000000000000000;;					ServerImage: framework.NfsServerImage,
0000000000000000000000000000000000000000;;					ServerPorts: []int{2049},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				pod := framework.StartVolumeServer(cs, config)
0000000000000000000000000000000000000000;;				serverIP := pod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("NFS server IP address: %v", serverIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							NFS: &v1.NFSVolumeSource{
0000000000000000000000000000000000000000;;								Server:   serverIP,
0000000000000000000000000000000000000000;;								Path:     "/",
0000000000000000000000000000000000000000;;								ReadOnly: true,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Must match content of test/images/volumes-tester/nfs/index.html
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from NFS!",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, nil, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// Gluster
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("GlusterFS [Feature:Volumes]", func() {
0000000000000000000000000000000000000000;;			It("should be mountable", func() {
0000000000000000000000000000000000000000;;				//TODO (copejon) GFS is not supported on debian image.
0000000000000000000000000000000000000000;;				framework.SkipUnlessNodeOSDistroIs("gci")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace:   namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:      "gluster",
0000000000000000000000000000000000000000;;					ServerImage: framework.GlusterfsServerImage,
0000000000000000000000000000000000000000;;					ServerPorts: []int{24007, 24008, 49152},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				pod := framework.StartVolumeServer(cs, config)
0000000000000000000000000000000000000000;;				serverIP := pod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("Gluster server IP address: %v", serverIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// create Endpoints for the server
0000000000000000000000000000000000000000;;				endpoints := v1.Endpoints{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;						Kind:       "Endpoints",
0000000000000000000000000000000000000000;;						APIVersion: "v1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: config.Prefix + "-server",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Subsets: []v1.EndpointSubset{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Addresses: []v1.EndpointAddress{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									IP: serverIP,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Ports: []v1.EndpointPort{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:     "gluster",
0000000000000000000000000000000000000000;;									Port:     24007,
0000000000000000000000000000000000000000;;									Protocol: v1.ProtocolTCP,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				endClient := cs.Core().Endpoints(config.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						endClient.Delete(config.Prefix+"-server", nil)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := endClient.Create(&endpoints); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to create endpoints for Gluster server: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Glusterfs: &v1.GlusterfsVolumeSource{
0000000000000000000000000000000000000000;;								EndpointsName: config.Prefix + "-server",
0000000000000000000000000000000000000000;;								// 'test_vol' comes from test/images/volumes-tester/gluster/run_gluster.sh
0000000000000000000000000000000000000000;;								Path:     "test_vol",
0000000000000000000000000000000000000000;;								ReadOnly: true,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Must match content of test/images/volumes-tester/gluster/index.html
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from GlusterFS!",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, nil, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// iSCSI
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The test needs privileged containers, which are disabled by default.
0000000000000000000000000000000000000000;;		// Also, make sure that iscsiadm utility and iscsi target kernel modules
0000000000000000000000000000000000000000;;		// are installed on all nodes!
0000000000000000000000000000000000000000;;		// Run the test with "go run hack/e2e.go ... --ginkgo.focus=iSCSI"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("iSCSI [Feature:Volumes]", func() {
0000000000000000000000000000000000000000;;			It("should be mountable", func() {
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace:   namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:      "iscsi",
0000000000000000000000000000000000000000;;					ServerImage: framework.IscsiServerImage,
0000000000000000000000000000000000000000;;					ServerPorts: []int{3260},
0000000000000000000000000000000000000000;;					ServerVolumes: map[string]string{
0000000000000000000000000000000000000000;;						// iSCSI container needs to insert modules from the host
0000000000000000000000000000000000000000;;						"/lib/modules": "/lib/modules",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				pod := framework.StartVolumeServer(cs, config)
0000000000000000000000000000000000000000;;				serverIP := pod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("iSCSI server IP address: %v", serverIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							ISCSI: &v1.ISCSIVolumeSource{
0000000000000000000000000000000000000000;;								TargetPortal: serverIP + ":3260",
0000000000000000000000000000000000000000;;								// from test/images/volumes-tester/iscsi/initiatorname.iscsi
0000000000000000000000000000000000000000;;								IQN:    "iqn.2003-01.org.linux-iscsi.f21.x8664:sn.4b0aae584f7c",
0000000000000000000000000000000000000000;;								Lun:    0,
0000000000000000000000000000000000000000;;								FSType: "ext2",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Must match content of test/images/volumes-tester/iscsi/block.tar.gz
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from iSCSI",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fsGroup := int64(1234)
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, &fsGroup, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// Ceph RBD
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("Ceph RBD [Feature:Volumes]", func() {
0000000000000000000000000000000000000000;;			It("should be mountable", func() {
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace:   namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:      "rbd",
0000000000000000000000000000000000000000;;					ServerImage: framework.RbdServerImage,
0000000000000000000000000000000000000000;;					ServerPorts: []int{6789},
0000000000000000000000000000000000000000;;					ServerVolumes: map[string]string{
0000000000000000000000000000000000000000;;						// iSCSI container needs to insert modules from the host
0000000000000000000000000000000000000000;;						"/lib/modules": "/lib/modules",
0000000000000000000000000000000000000000;;						"/sys":         "/sys",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				pod := framework.StartVolumeServer(cs, config)
0000000000000000000000000000000000000000;;				serverIP := pod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("Ceph server IP address: %v", serverIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// create secrets for the server
0000000000000000000000000000000000000000;;				secret := v1.Secret{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;						Kind:       "Secret",
0000000000000000000000000000000000000000;;						APIVersion: "v1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: config.Prefix + "-secret",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						// from test/images/volumes-tester/rbd/keyring
0000000000000000000000000000000000000000;;						"key": []byte("AQDRrKNVbEevChAAEmRC+pW/KBVHxa0w/POILA=="),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Type: "kubernetes.io/rbd",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				secClient := cs.Core().Secrets(config.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						secClient.Delete(config.Prefix+"-secret", nil)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := secClient.Create(&secret); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to create secrets for Ceph RBD: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							RBD: &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;								CephMonitors: []string{serverIP},
0000000000000000000000000000000000000000;;								RBDPool:      "rbd",
0000000000000000000000000000000000000000;;								RBDImage:     "foo",
0000000000000000000000000000000000000000;;								RadosUser:    "admin",
0000000000000000000000000000000000000000;;								SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: config.Prefix + "-secret",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								FSType: "ext2",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Must match content of test/images/volumes-tester/rbd/create_block.sh
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from RBD",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fsGroup := int64(1234)
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, &fsGroup, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// Ceph
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("CephFS [Feature:Volumes]", func() {
0000000000000000000000000000000000000000;;			It("should be mountable", func() {
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace:   namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:      "cephfs",
0000000000000000000000000000000000000000;;					ServerImage: framework.CephServerImage,
0000000000000000000000000000000000000000;;					ServerPorts: []int{6789},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				pod := framework.StartVolumeServer(cs, config)
0000000000000000000000000000000000000000;;				serverIP := pod.Status.PodIP
0000000000000000000000000000000000000000;;				framework.Logf("Ceph server IP address: %v", serverIP)
0000000000000000000000000000000000000000;;				By("sleeping a bit to give ceph server time to initialize")
0000000000000000000000000000000000000000;;				time.Sleep(20 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// create ceph secret
0000000000000000000000000000000000000000;;				secret := &v1.Secret{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;						Kind:       "Secret",
0000000000000000000000000000000000000000;;						APIVersion: "v1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: config.Prefix + "-secret",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// Must use the ceph keyring at contrib/for-tests/volumes-ceph/ceph/init.sh
0000000000000000000000000000000000000000;;					// and encode in base64
0000000000000000000000000000000000000000;;					Data: map[string][]byte{
0000000000000000000000000000000000000000;;						"key": []byte("AQAMgXhVwBCeDhAA9nlPaFyfUSatGD4drFWDvQ=="),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Type: "kubernetes.io/cephfs",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						if err := cs.Core().Secrets(namespace.Name).Delete(secret.Name, nil); err != nil {
0000000000000000000000000000000000000000;;							framework.Failf("unable to delete secret %v: %v", secret.Name, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if secret, err = cs.Core().Secrets(namespace.Name).Create(secret); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("unable to create test secret %s: %v", secret.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							CephFS: &v1.CephFSVolumeSource{
0000000000000000000000000000000000000000;;								Monitors:  []string{serverIP + ":6789"},
0000000000000000000000000000000000000000;;								User:      "kube",
0000000000000000000000000000000000000000;;								SecretRef: &v1.LocalObjectReference{Name: config.Prefix + "-secret"},
0000000000000000000000000000000000000000;;								ReadOnly:  true,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Must match content of test/images/volumes-tester/ceph/index.html
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello Ceph!",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, nil, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// OpenStack Cinder
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This test assumes that OpenStack client tools are installed
0000000000000000000000000000000000000000;;		// (/usr/bin/nova, /usr/bin/cinder and /usr/bin/keystone)
0000000000000000000000000000000000000000;;		// and that the usual OpenStack authentication env. variables are set
0000000000000000000000000000000000000000;;		// (OS_USERNAME, OS_PASSWORD, OS_TENANT_NAME at least).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("Cinder [Feature:Volumes]", func() {
0000000000000000000000000000000000000000;;			It("should be mountable", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("openstack")
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace: namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:    "cinder",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// We assume that namespace.Name is a random string
0000000000000000000000000000000000000000;;				volumeName := namespace.Name
0000000000000000000000000000000000000000;;				By("creating a test Cinder volume")
0000000000000000000000000000000000000000;;				output, err := exec.Command("cinder", "create", "--display-name="+volumeName, "1").CombinedOutput()
0000000000000000000000000000000000000000;;				outputString := string(output[:])
0000000000000000000000000000000000000000;;				framework.Logf("cinder output:\n%s", outputString)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					// Ignore any cleanup errors, there is not much we can do about
0000000000000000000000000000000000000000;;					// them. They were already logged.
0000000000000000000000000000000000000000;;					DeleteCinderVolume(volumeName)
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Parse 'id'' from stdout. Expected format:
0000000000000000000000000000000000000000;;				// |     attachments     |                  []                  |
0000000000000000000000000000000000000000;;				// |  availability_zone  |                 nova                 |
0000000000000000000000000000000000000000;;				// ...
0000000000000000000000000000000000000000;;				// |          id         | 1d6ff08f-5d1c-41a4-ad72-4ef872cae685 |
0000000000000000000000000000000000000000;;				volumeID := ""
0000000000000000000000000000000000000000;;				for _, line := range strings.Split(outputString, "\n") {
0000000000000000000000000000000000000000;;					fields := strings.Fields(line)
0000000000000000000000000000000000000000;;					if len(fields) != 5 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if fields[1] != "id" {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					volumeID = fields[3]
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("Volume ID: %s", volumeID)
0000000000000000000000000000000000000000;;				Expect(volumeID).NotTo(Equal(""))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.Logf("Running volumeTestCleanup")
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Cinder: &v1.CinderVolumeSource{
0000000000000000000000000000000000000000;;								VolumeID: volumeID,
0000000000000000000000000000000000000000;;								FSType:   "ext3",
0000000000000000000000000000000000000000;;								ReadOnly: false,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Randomize index.html to make sure we don't see the
0000000000000000000000000000000000000000;;						// content from previous test runs.
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from Cinder from namespace " + volumeName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.InjectHtml(cs, config, tests[0].Volume, tests[0].ExpectedContent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fsGroup := int64(1234)
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, &fsGroup, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// GCE PD
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("PD", func() {
0000000000000000000000000000000000000000;;			// Flaky issue: #43977
0000000000000000000000000000000000000000;;			It("should be mountable [Flaky]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace: namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:    "pd",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a test gce pd volume")
0000000000000000000000000000000000000000;;				volumeName, err := framework.CreatePDWithRetry()
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					// - Get NodeName from the pod spec to which the volume is mounted.
0000000000000000000000000000000000000000;;					// - Force detach and delete.
0000000000000000000000000000000000000000;;					pod, err := f.PodClient().Get(config.Prefix+"-client", metav1.GetOptions{})
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred(), "Failed getting pod %q.", config.Prefix+"-client")
0000000000000000000000000000000000000000;;					detachAndDeletePDs(volumeName, []types.NodeName{types.NodeName(pod.Spec.NodeName)})
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.Logf("Running volumeTestCleanup")
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName:   volumeName,
0000000000000000000000000000000000000000;;								FSType:   "ext3",
0000000000000000000000000000000000000000;;								ReadOnly: false,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Randomize index.html to make sure we don't see the
0000000000000000000000000000000000000000;;						// content from previous test runs.
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from GCE from namespace " + volumeName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.InjectHtml(cs, config, tests[0].Volume, tests[0].ExpectedContent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fsGroup := int64(1234)
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, &fsGroup, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// ConfigMap
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("ConfigMap", func() {
0000000000000000000000000000000000000000;;			It("should be mountable", func() {
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace: namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:    "configmap",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				configMap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;						Kind:       "ConfigMap",
0000000000000000000000000000000000000000;;						APIVersion: "v1",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: config.Prefix + "-map",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Data: map[string]string{
0000000000000000000000000000000000000000;;						"first":  "this is the first file",
0000000000000000000000000000000000000000;;						"second": "this is the second file",
0000000000000000000000000000000000000000;;						"third":  "this is the third file",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, err := cs.Core().ConfigMaps(namespace.Name).Create(configMap); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("unable to create test configmap: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					_ = cs.Core().ConfigMaps(namespace.Name).Delete(configMap.Name, nil)
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Test one ConfigMap mounted several times to test #28502
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;								LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: config.Prefix + "-map",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Items: []v1.KeyToPath{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:  "first",
0000000000000000000000000000000000000000;;										Path: "firstfile",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File:            "firstfile",
0000000000000000000000000000000000000000;;						ExpectedContent: "this is the first file",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;								LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: config.Prefix + "-map",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Items: []v1.KeyToPath{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:  "second",
0000000000000000000000000000000000000000;;										Path: "secondfile",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File:            "secondfile",
0000000000000000000000000000000000000000;;						ExpectedContent: "this is the second file",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, nil, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// vSphere
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("vsphere [Feature:Volumes]", func() {
0000000000000000000000000000000000000000;;			It("should be mountable", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("vsphere")
0000000000000000000000000000000000000000;;				var (
0000000000000000000000000000000000000000;;					volumePath string
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace: namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:    "vsphere",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("creating a test vsphere volume")
0000000000000000000000000000000000000000;;				vsp, err := vsphere.GetVSphere()
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				volumePath, err = createVSphereVolume(vsp, nil)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					vsp.DeleteVolume(volumePath)
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.Logf("Running volumeTestCleanup")
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							VsphereVolume: &v1.VsphereVirtualDiskVolumeSource{
0000000000000000000000000000000000000000;;								VolumePath: volumePath,
0000000000000000000000000000000000000000;;								FSType:     "ext4",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Randomize index.html to make sure we don't see the
0000000000000000000000000000000000000000;;						// content from previous test runs.
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from vSphere from namespace " + namespace.Name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.InjectHtml(cs, config, tests[0].Volume, tests[0].ExpectedContent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fsGroup := int64(1234)
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, &fsGroup, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		// Azure Disk
0000000000000000000000000000000000000000;;		////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;		SIGDescribe("Azure Disk [Feature:Volumes]", func() {
0000000000000000000000000000000000000000;;			It("should be mountable [Slow]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("azure")
0000000000000000000000000000000000000000;;				config := framework.VolumeTestConfig{
0000000000000000000000000000000000000000;;					Namespace: namespace.Name,
0000000000000000000000000000000000000000;;					Prefix:    "azure",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a test azure disk volume")
0000000000000000000000000000000000000000;;				volumeName, err := framework.CreatePDWithRetry()
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					framework.DeletePDWithRetry(volumeName)
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if clean {
0000000000000000000000000000000000000000;;						framework.Logf("Running volumeTestCleanup")
0000000000000000000000000000000000000000;;						framework.VolumeTestCleanup(f, config)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				fsType := "ext4"
0000000000000000000000000000000000000000;;				readOnly := false
0000000000000000000000000000000000000000;;				diskName := volumeName[(strings.LastIndex(volumeName, "/") + 1):]
0000000000000000000000000000000000000000;;				tests := []framework.VolumeTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Volume: v1.VolumeSource{
0000000000000000000000000000000000000000;;							AzureDisk: &v1.AzureDiskVolumeSource{
0000000000000000000000000000000000000000;;								DiskName:    diskName,
0000000000000000000000000000000000000000;;								DataDiskURI: volumeName,
0000000000000000000000000000000000000000;;								FSType:      &fsType,
0000000000000000000000000000000000000000;;								ReadOnly:    &readOnly,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						File: "index.html",
0000000000000000000000000000000000000000;;						// Randomize index.html to make sure we don't see the
0000000000000000000000000000000000000000;;						// content from previous test runs.
0000000000000000000000000000000000000000;;						ExpectedContent: "Hello from Azure from namespace " + volumeName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.InjectHtml(cs, config, tests[0].Volume, tests[0].ExpectedContent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fsGroup := int64(1234)
0000000000000000000000000000000000000000;;				framework.TestVolumeClient(cs, config, &fsGroup, tests)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
