0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
89c0bb14bc0b3b39902711963173135c8e89b38c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		k8stype "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		vsphere "k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		VmfsDatastore                              = "sharedVmfs-0"
0000000000000000000000000000000000000000;;		VsanDatastore                              = "vsanDatastore"
0000000000000000000000000000000000000000;;		Datastore                                  = "datastore"
0000000000000000000000000000000000000000;;		Policy_DiskStripes                         = "diskStripes"
0000000000000000000000000000000000000000;;		Policy_HostFailuresToTolerate              = "hostFailuresToTolerate"
0000000000000000000000000000000000000000;;		Policy_CacheReservation                    = "cacheReservation"
0000000000000000000000000000000000000000;;		Policy_ObjectSpaceReservation              = "objectSpaceReservation"
0000000000000000000000000000000000000000;;		Policy_IopsLimit                           = "iopsLimit"
0000000000000000000000000000000000000000;;		DiskFormat                                 = "diskformat"
0000000000000000000000000000000000000000;;		ThinDisk                                   = "thin"
0000000000000000000000000000000000000000;;		SpbmStoragePolicy                          = "storagepolicyname"
0000000000000000000000000000000000000000;;		BronzeStoragePolicy                        = "bronze"
0000000000000000000000000000000000000000;;		HostFailuresToTolerateCapabilityVal        = "0"
0000000000000000000000000000000000000000;;		CacheReservationCapabilityVal              = "20"
0000000000000000000000000000000000000000;;		DiskStripesCapabilityVal                   = "1"
0000000000000000000000000000000000000000;;		ObjectSpaceReservationCapabilityVal        = "30"
0000000000000000000000000000000000000000;;		IopsLimitCapabilityVal                     = "100"
0000000000000000000000000000000000000000;;		StripeWidthCapabilityVal                   = "2"
0000000000000000000000000000000000000000;;		DiskStripesCapabilityInvalidVal            = "14"
0000000000000000000000000000000000000000;;		HostFailuresToTolerateCapabilityInvalidVal = "4"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	   Test to verify the storage policy based management for dynamic volume provisioning inside kubernetes.
0000000000000000000000000000000000000000;;	   There are 2 ways to achive it:
0000000000000000000000000000000000000000;;	   1. Specify VSAN storage capabilities in the storage-class.
0000000000000000000000000000000000000000;;	   2. Use existing vCenter SPBM storage policies.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   Valid VSAN storage capabilities are mentioned below:
0000000000000000000000000000000000000000;;	   1. hostFailuresToTolerate
0000000000000000000000000000000000000000;;	   2. forceProvisioning
0000000000000000000000000000000000000000;;	   3. cacheReservation
0000000000000000000000000000000000000000;;	   4. diskStripes
0000000000000000000000000000000000000000;;	   5. objectSpaceReservation
0000000000000000000000000000000000000000;;	   6. iopsLimit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   Steps
0000000000000000000000000000000000000000;;	   1. Create StorageClass with.
0000000000000000000000000000000000000000;;	   		a. VSAN storage capabilities set to valid/invalid values (or)
0000000000000000000000000000000000000000;;			b. Use existing vCenter SPBM storage policies.
0000000000000000000000000000000000000000;;	   2. Create PVC which uses the StorageClass created in step 1.
0000000000000000000000000000000000000000;;	   3. Wait for PV to be provisioned.
0000000000000000000000000000000000000000;;	   4. Wait for PVC's status to become Bound
0000000000000000000000000000000000000000;;	   5. Create pod using PVC on specific node.
0000000000000000000000000000000000000000;;	   6. Wait for Disk to be attached to the node.
0000000000000000000000000000000000000000;;	   7. Delete pod and Wait for Volume Disk to be detached from the Node.
0000000000000000000000000000000000000000;;	   8. Delete PVC, PV and Storage Class
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("vSphere Storage policy support for dynamic provisioning", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("volume-vsan-policy")
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			client       clientset.Interface
0000000000000000000000000000000000000000;;			namespace    string
0000000000000000000000000000000000000000;;			scParameters map[string]string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("vsphere")
0000000000000000000000000000000000000000;;			client = f.ClientSet
0000000000000000000000000000000000000000;;			namespace = f.Namespace.Name
0000000000000000000000000000000000000000;;			scParameters = make(map[string]string)
0000000000000000000000000000000000000000;;			nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;			if !(len(nodeList.Items) > 0) {
0000000000000000000000000000000000000000;;				framework.Failf("Unable to find ready and schedulable Node")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Valid policy.
0000000000000000000000000000000000000000;;		It("verify VSAN storage capability with valid hostFailuresToTolerate and cacheReservation values is honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for VSAN policy hostFailuresToTolerate: %s, cacheReservation: %s", HostFailuresToTolerateCapabilityVal, CacheReservationCapabilityVal))
0000000000000000000000000000000000000000;;			scParameters[Policy_HostFailuresToTolerate] = HostFailuresToTolerateCapabilityVal
0000000000000000000000000000000000000000;;			scParameters[Policy_CacheReservation] = CacheReservationCapabilityVal
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for VSAN storage capabilities: %+v", scParameters)
0000000000000000000000000000000000000000;;			invokeValidPolicyTest(f, client, namespace, scParameters)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Valid policy.
0000000000000000000000000000000000000000;;		It("verify VSAN storage capability with valid diskStripes and objectSpaceReservation values is honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for VSAN policy diskStripes: %s, objectSpaceReservation: %s", DiskStripesCapabilityVal, ObjectSpaceReservationCapabilityVal))
0000000000000000000000000000000000000000;;			scParameters[Policy_DiskStripes] = "1"
0000000000000000000000000000000000000000;;			scParameters[Policy_ObjectSpaceReservation] = "30"
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for VSAN storage capabilities: %+v", scParameters)
0000000000000000000000000000000000000000;;			invokeValidPolicyTest(f, client, namespace, scParameters)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Valid policy.
0000000000000000000000000000000000000000;;		It("verify VSAN storage capability with valid diskStripes and objectSpaceReservation values and a VSAN datastore is honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for VSAN policy diskStripes: %s, objectSpaceReservation: %s", DiskStripesCapabilityVal, ObjectSpaceReservationCapabilityVal))
0000000000000000000000000000000000000000;;			scParameters[Policy_DiskStripes] = DiskStripesCapabilityVal
0000000000000000000000000000000000000000;;			scParameters[Policy_ObjectSpaceReservation] = ObjectSpaceReservationCapabilityVal
0000000000000000000000000000000000000000;;			scParameters[Datastore] = VsanDatastore
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for VSAN storage capabilities: %+v", scParameters)
0000000000000000000000000000000000000000;;			invokeValidPolicyTest(f, client, namespace, scParameters)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Valid policy.
0000000000000000000000000000000000000000;;		It("verify VSAN storage capability with valid objectSpaceReservation and iopsLimit values is honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for VSAN policy objectSpaceReservation: %s, iopsLimit: %s", ObjectSpaceReservationCapabilityVal, IopsLimitCapabilityVal))
0000000000000000000000000000000000000000;;			scParameters[Policy_ObjectSpaceReservation] = ObjectSpaceReservationCapabilityVal
0000000000000000000000000000000000000000;;			scParameters[Policy_IopsLimit] = IopsLimitCapabilityVal
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for VSAN storage capabilities: %+v", scParameters)
0000000000000000000000000000000000000000;;			invokeValidPolicyTest(f, client, namespace, scParameters)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Invalid VSAN storage capabilties parameters.
0000000000000000000000000000000000000000;;		It("verify VSAN storage capability with invalid capability name objectSpaceReserve is not honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for VSAN policy objectSpaceReserve: %s, stripeWidth: %s", ObjectSpaceReservationCapabilityVal, StripeWidthCapabilityVal))
0000000000000000000000000000000000000000;;			scParameters["objectSpaceReserve"] = ObjectSpaceReservationCapabilityVal
0000000000000000000000000000000000000000;;			scParameters[Policy_DiskStripes] = StripeWidthCapabilityVal
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for VSAN storage capabilities: %+v", scParameters)
0000000000000000000000000000000000000000;;			err := invokeInvalidPolicyTestNeg(client, namespace, scParameters)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;			errorMsg := "invalid option \\\"objectSpaceReserve\\\" for volume plugin kubernetes.io/vsphere-volume"
0000000000000000000000000000000000000000;;			if !strings.Contains(err.Error(), errorMsg) {
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), errorMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Invalid policy on a VSAN test bed.
0000000000000000000000000000000000000000;;		// diskStripes value has to be between 1 and 12.
0000000000000000000000000000000000000000;;		It("verify VSAN storage capability with invalid diskStripes value is not honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for VSAN policy diskStripes: %s, cacheReservation: %s", DiskStripesCapabilityInvalidVal, CacheReservationCapabilityVal))
0000000000000000000000000000000000000000;;			scParameters[Policy_DiskStripes] = DiskStripesCapabilityInvalidVal
0000000000000000000000000000000000000000;;			scParameters[Policy_CacheReservation] = CacheReservationCapabilityVal
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for VSAN storage capabilities: %+v", scParameters)
0000000000000000000000000000000000000000;;			err := invokeInvalidPolicyTestNeg(client, namespace, scParameters)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;			errorMsg := "Invalid value for " + Policy_DiskStripes + "."
0000000000000000000000000000000000000000;;			if !strings.Contains(err.Error(), errorMsg) {
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), errorMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Invalid policy on a VSAN test bed.
0000000000000000000000000000000000000000;;		// hostFailuresToTolerate value has to be between 0 and 3 including.
0000000000000000000000000000000000000000;;		It("verify VSAN storage capability with invalid hostFailuresToTolerate value is not honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for VSAN policy hostFailuresToTolerate: %s", HostFailuresToTolerateCapabilityInvalidVal))
0000000000000000000000000000000000000000;;			scParameters[Policy_HostFailuresToTolerate] = HostFailuresToTolerateCapabilityInvalidVal
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for VSAN storage capabilities: %+v", scParameters)
0000000000000000000000000000000000000000;;			err := invokeInvalidPolicyTestNeg(client, namespace, scParameters)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;			errorMsg := "Invalid value for " + Policy_HostFailuresToTolerate + "."
0000000000000000000000000000000000000000;;			if !strings.Contains(err.Error(), errorMsg) {
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), errorMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specify a valid VSAN policy on a non-VSAN test bed.
0000000000000000000000000000000000000000;;		// The test should fail.
0000000000000000000000000000000000000000;;		It("verify VSAN storage capability with non-vsan datastore is not honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for VSAN policy diskStripes: %s, objectSpaceReservation: %s and a non-VSAN datastore: %s", DiskStripesCapabilityVal, ObjectSpaceReservationCapabilityVal, VmfsDatastore))
0000000000000000000000000000000000000000;;			scParameters[Policy_DiskStripes] = DiskStripesCapabilityVal
0000000000000000000000000000000000000000;;			scParameters[Policy_ObjectSpaceReservation] = ObjectSpaceReservationCapabilityVal
0000000000000000000000000000000000000000;;			scParameters[Datastore] = VmfsDatastore
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for VSAN storage capabilities: %+v", scParameters)
0000000000000000000000000000000000000000;;			err := invokeInvalidPolicyTestNeg(client, namespace, scParameters)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;			errorMsg := "The specified datastore: \\\"" + VmfsDatastore + "\\\" is not a VSAN datastore. " +
0000000000000000000000000000000000000000;;				"The policy parameters will work only with VSAN Datastore."
0000000000000000000000000000000000000000;;			if !strings.Contains(err.Error(), errorMsg) {
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), errorMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("verify an existing and compatible SPBM policy is honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for SPBM policy: %s", os.Getenv("VSPHERE_SPBM_GOLD_POLICY")))
0000000000000000000000000000000000000000;;			goldPolicy := os.Getenv("VSPHERE_SPBM_GOLD_POLICY")
0000000000000000000000000000000000000000;;			Expect(goldPolicy).NotTo(BeEmpty())
0000000000000000000000000000000000000000;;			scParameters[SpbmStoragePolicy] = goldPolicy
0000000000000000000000000000000000000000;;			scParameters[DiskFormat] = ThinDisk
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for SPBM storage policy: %+v", scParameters)
0000000000000000000000000000000000000000;;			invokeValidPolicyTest(f, client, namespace, scParameters)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("verify if a SPBM policy is not honored on a non-compatible datastore for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for SPBM policy: %s and datastore: %s", os.Getenv("VSPHERE_SPBM_TAG_POLICY"), VsanDatastore))
0000000000000000000000000000000000000000;;			tagPolicy := os.Getenv("VSPHERE_SPBM_TAG_POLICY")
0000000000000000000000000000000000000000;;			Expect(tagPolicy).NotTo(BeEmpty())
0000000000000000000000000000000000000000;;			scParameters[SpbmStoragePolicy] = tagPolicy
0000000000000000000000000000000000000000;;			scParameters[Datastore] = VsanDatastore
0000000000000000000000000000000000000000;;			scParameters[DiskFormat] = ThinDisk
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for SPBM storage policy on a non-compatible datastore: %+v", scParameters)
0000000000000000000000000000000000000000;;			err := invokeInvalidPolicyTestNeg(client, namespace, scParameters)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;			errorMsg := "User specified datastore: \\\"" + VsanDatastore + "\\\" is not compatible with the storagePolicy: \\\"" + os.Getenv("VSPHERE_SPBM_TAG_POLICY") + "\\\""
0000000000000000000000000000000000000000;;			if !strings.Contains(err.Error(), errorMsg) {
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), errorMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("verify if a non-existing SPBM policy is not honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for SPBM policy: %s", BronzeStoragePolicy))
0000000000000000000000000000000000000000;;			scParameters[SpbmStoragePolicy] = BronzeStoragePolicy
0000000000000000000000000000000000000000;;			scParameters[DiskFormat] = ThinDisk
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for non-existing SPBM storage policy: %+v", scParameters)
0000000000000000000000000000000000000000;;			err := invokeInvalidPolicyTestNeg(client, namespace, scParameters)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;			errorMsg := "no pbm profile found with name: \\\"" + BronzeStoragePolicy + "\\"
0000000000000000000000000000000000000000;;			if !strings.Contains(err.Error(), errorMsg) {
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), errorMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("verify an if a SPBM policy and VSAN capabilities cannot be honored for dynamically provisioned pvc using storageclass", func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Invoking Test for SPBM policy: %s with VSAN storage capabilities", os.Getenv("VSPHERE_SPBM_GOLD_POLICY")))
0000000000000000000000000000000000000000;;			goldPolicy := os.Getenv("VSPHERE_SPBM_GOLD_POLICY")
0000000000000000000000000000000000000000;;			Expect(goldPolicy).NotTo(BeEmpty())
0000000000000000000000000000000000000000;;			scParameters[SpbmStoragePolicy] = goldPolicy
0000000000000000000000000000000000000000;;			Expect(scParameters[SpbmStoragePolicy]).NotTo(BeEmpty())
0000000000000000000000000000000000000000;;			scParameters[Policy_DiskStripes] = DiskStripesCapabilityVal
0000000000000000000000000000000000000000;;			scParameters[DiskFormat] = ThinDisk
0000000000000000000000000000000000000000;;			framework.Logf("Invoking Test for SPBM storage policy and VSAN capabilities together: %+v", scParameters)
0000000000000000000000000000000000000000;;			err := invokeInvalidPolicyTestNeg(client, namespace, scParameters)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;			errorMsg := "Cannot specify storage policy capabilities along with storage policy name. Please specify only one."
0000000000000000000000000000000000000000;;			if !strings.Contains(err.Error(), errorMsg) {
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), errorMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func invokeValidPolicyTest(f *framework.Framework, client clientset.Interface, namespace string, scParameters map[string]string) {
0000000000000000000000000000000000000000;;		By("Creating Storage Class With storage policy params")
0000000000000000000000000000000000000000;;		storageclass, err := client.StorageV1().StorageClasses().Create(getVSphereStorageClassSpec("storagepolicysc", scParameters))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Failed to create storage class with err: %v", err))
0000000000000000000000000000000000000000;;		defer client.StorageV1().StorageClasses().Delete(storageclass.Name, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating PVC using the Storage Class")
0000000000000000000000000000000000000000;;		pvclaim, err := framework.CreatePVC(client, namespace, getVSphereClaimSpecWithStorageClassAnnotation(namespace, storageclass))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		defer framework.DeletePersistentVolumeClaim(client, pvclaim.Name, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pvclaims []*v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		pvclaims = append(pvclaims, pvclaim)
0000000000000000000000000000000000000000;;		By("Waiting for claim to be in bound phase")
0000000000000000000000000000000000000000;;		persistentvolumes, err := framework.WaitForPVClaimBoundPhase(client, pvclaims)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating pod to attach PV to the node")
0000000000000000000000000000000000000000;;		// Create pod to attach Volume to Node
0000000000000000000000000000000000000000;;		pod, err := framework.CreatePod(client, namespace, pvclaims, false, "")
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vsp, err := vsphere.GetVSphere()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		By("Verify the volume is accessible and available in the pod")
0000000000000000000000000000000000000000;;		verifyVSphereVolumesAccessible(pod, persistentvolumes, vsp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Deleting pod")
0000000000000000000000000000000000000000;;		framework.DeletePodWithWait(f, client, pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for volumes to be detached from the node")
0000000000000000000000000000000000000000;;		waitForVSphereDiskToDetach(vsp, persistentvolumes[0].Spec.VsphereVolume.VolumePath, k8stype.NodeName(pod.Spec.NodeName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func invokeInvalidPolicyTestNeg(client clientset.Interface, namespace string, scParameters map[string]string) error {
0000000000000000000000000000000000000000;;		By("Creating Storage Class With storage policy params")
0000000000000000000000000000000000000000;;		storageclass, err := client.StorageV1().StorageClasses().Create(getVSphereStorageClassSpec("storagepolicysc", scParameters))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Failed to create storage class with err: %v", err))
0000000000000000000000000000000000000000;;		defer client.StorageV1().StorageClasses().Delete(storageclass.Name, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating PVC using the Storage Class")
0000000000000000000000000000000000000000;;		pvclaim, err := framework.CreatePVC(client, namespace, getVSphereClaimSpecWithStorageClassAnnotation(namespace, storageclass))
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		defer framework.DeletePersistentVolumeClaim(client, pvclaim.Name, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for claim to be in bound phase")
0000000000000000000000000000000000000000;;		err = framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, client, pvclaim.Namespace, pvclaim.Name, framework.Poll, 2*time.Minute)
0000000000000000000000000000000000000000;;		Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventList, err := client.CoreV1().Events(pvclaim.Namespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		return fmt.Errorf("Failure message: %+q", eventList.Items[0].Message)
0000000000000000000000000000000000000000;;	}
