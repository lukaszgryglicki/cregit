0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
fab7df78a1367134c1d54b3a56c6aa9166dc83fd;test/e2e/vsphere_utils.go[test/e2e/vsphere_utils.go][test/e2e/storage/vsphere_utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		k8stype "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		vsphere "k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sanity check for vSphere testing.  Verify the persistent disk attached to the node.
0000000000000000000000000000000000000000;;	func verifyVSphereDiskAttached(vsp *vsphere.VSphere, volumePath string, nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			isAttached bool
0000000000000000000000000000000000000000;;			err        error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if vsp == nil {
0000000000000000000000000000000000000000;;			vsp, err = vsphere.GetVSphere()
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		isAttached, err = vsp.DiskIsAttached(volumePath, nodeName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return isAttached, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait until vsphere vmdk is deteched from the given node or time out after 5 minutes
0000000000000000000000000000000000000000;;	func waitForVSphereDiskToDetach(vsp *vsphere.VSphere, volumePath string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err            error
0000000000000000000000000000000000000000;;			diskAttached   = true
0000000000000000000000000000000000000000;;			detachTimeout  = 5 * time.Minute
0000000000000000000000000000000000000000;;			detachPollTime = 10 * time.Second
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if vsp == nil {
0000000000000000000000000000000000000000;;			vsp, err = vsphere.GetVSphere()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = wait.Poll(detachPollTime, detachTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			diskAttached, err = verifyVSphereDiskAttached(vsp, volumePath, nodeName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !diskAttached {
0000000000000000000000000000000000000000;;				framework.Logf("Volume %q appears to have successfully detached from %q.",
0000000000000000000000000000000000000000;;					volumePath, nodeName)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Waiting for Volume %q to detach from %q.", volumePath, nodeName)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if diskAttached {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Gave up waiting for Volume %q to detach from %q after %v", volumePath, nodeName, detachTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// function to create vsphere volume spec with given VMDK volume path, Reclaim Policy and labels
0000000000000000000000000000000000000000;;	func getVSpherePersistentVolumeSpec(volumePath string, persistentVolumeReclaimPolicy v1.PersistentVolumeReclaimPolicy, labels map[string]string) *v1.PersistentVolume {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			pvConfig framework.PersistentVolumeConfig
0000000000000000000000000000000000000000;;			pv       *v1.PersistentVolume
0000000000000000000000000000000000000000;;			claimRef *v1.ObjectReference
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		pvConfig = framework.PersistentVolumeConfig{
0000000000000000000000000000000000000000;;			NamePrefix: "vspherepv-",
0000000000000000000000000000000000000000;;			PVSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				VsphereVolume: &v1.VsphereVirtualDiskVolumeSource{
0000000000000000000000000000000000000000;;					VolumePath: volumePath,
0000000000000000000000000000000000000000;;					FSType:     "ext4",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Prebind: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv = &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: pvConfig.NamePrefix,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeGidAnnotationKey: "777",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: persistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse("2Gi"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: pvConfig.PVSource,
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ClaimRef: claimRef,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels != nil {
0000000000000000000000000000000000000000;;			pv.Labels = labels
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// function to get vsphere persistent volume spec with given selector labels.
0000000000000000000000000000000000000000;;	func getVSpherePersistentVolumeClaimSpec(namespace string, labels map[string]string) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			pvc *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		pvc = &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "pvc-",
0000000000000000000000000000000000000000;;				Namespace:    namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("2Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels != nil {
0000000000000000000000000000000000000000;;			pvc.Spec.Selector = &metav1.LabelSelector{MatchLabels: labels}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pvc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// function to create vmdk volume
0000000000000000000000000000000000000000;;	func createVSphereVolume(vsp *vsphere.VSphere, volumeOptions *vsphere.VolumeOptions) (string, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			volumePath string
0000000000000000000000000000000000000000;;			err        error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if volumeOptions == nil {
0000000000000000000000000000000000000000;;			volumeOptions = new(vsphere.VolumeOptions)
0000000000000000000000000000000000000000;;			volumeOptions.CapacityKB = 2097152
0000000000000000000000000000000000000000;;			volumeOptions.Name = "e2e-vmdk-" + strconv.FormatInt(time.Now().UnixNano(), 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumePath, err = vsp.CreateVolume(volumeOptions)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return volumePath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// function to write content to the volume backed by given PVC
0000000000000000000000000000000000000000;;	func writeContentToVSpherePV(client clientset.Interface, pvc *v1.PersistentVolumeClaim, expectedContent string) {
0000000000000000000000000000000000000000;;		runInPodWithVolume(client, pvc.Namespace, pvc.Name, "echo "+expectedContent+" > /mnt/test/data")
0000000000000000000000000000000000000000;;		framework.Logf("Done with writing content to volume")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// function to verify content is matching on the volume backed for given PVC
0000000000000000000000000000000000000000;;	func verifyContentOfVSpherePV(client clientset.Interface, pvc *v1.PersistentVolumeClaim, expectedContent string) {
0000000000000000000000000000000000000000;;		runInPodWithVolume(client, pvc.Namespace, pvc.Name, "grep '"+expectedContent+"' /mnt/test/data")
0000000000000000000000000000000000000000;;		framework.Logf("Successfully verified content of the volume")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVSphereStorageClassSpec(name string, scParameters map[string]string) *storage.StorageClass {
0000000000000000000000000000000000000000;;		var sc *storage.StorageClass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc = &storage.StorageClass{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "StorageClass",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Provisioner: "kubernetes.io/vsphere-volume",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if scParameters != nil {
0000000000000000000000000000000000000000;;			sc.Parameters = scParameters
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVSphereClaimSpecWithStorageClassAnnotation(ns string, storageclass *storage.StorageClass) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		scAnnotation := make(map[string]string)
0000000000000000000000000000000000000000;;		scAnnotation[v1.BetaStorageClassAnnotation] = storageclass.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "pvc-",
0000000000000000000000000000000000000000;;				Namespace:    ns,
0000000000000000000000000000000000000000;;				Annotations:  scAnnotation,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("2Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return claim
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func to get pod spec with given volume claim, node selector labels and command
0000000000000000000000000000000000000000;;	func getVSpherePodSpecWithClaim(claimName string, nodeSelectorKV map[string]string, command string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "pod-pvc-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "volume-tester",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command: []string{"/bin/sh"},
0000000000000000000000000000000000000000;;						Args:    []string{"-c", command},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "my-volume",
0000000000000000000000000000000000000000;;								MountPath: "/mnt/test",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "my-volume",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;								ClaimName: claimName,
0000000000000000000000000000000000000000;;								ReadOnly:  false,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if nodeSelectorKV != nil {
0000000000000000000000000000000000000000;;			pod.Spec.NodeSelector = nodeSelectorKV
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func to get pod spec with given volume paths, node selector lables and container commands
0000000000000000000000000000000000000000;;	func getVSpherePodSpecWithVolumePaths(volumePaths []string, keyValuelabel map[string]string, commands []string) *v1.Pod {
0000000000000000000000000000000000000000;;		var volumeMounts []v1.VolumeMount
0000000000000000000000000000000000000000;;		var volumes []v1.Volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, volumePath := range volumePaths {
0000000000000000000000000000000000000000;;			name := fmt.Sprintf("volume%v", index+1)
0000000000000000000000000000000000000000;;			volumeMounts = append(volumeMounts, v1.VolumeMount{Name: name, MountPath: "/mnt/" + name})
0000000000000000000000000000000000000000;;			vsphereVolume := new(v1.VsphereVirtualDiskVolumeSource)
0000000000000000000000000000000000000000;;			vsphereVolume.VolumePath = volumePath
0000000000000000000000000000000000000000;;			vsphereVolume.FSType = "ext4"
0000000000000000000000000000000000000000;;			volumes = append(volumes, v1.Volume{Name: name})
0000000000000000000000000000000000000000;;			volumes[index].VolumeSource.VsphereVolume = vsphereVolume
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if commands == nil || len(commands) == 0 {
0000000000000000000000000000000000000000;;			commands = []string{
0000000000000000000000000000000000000000;;				"/bin/sh",
0000000000000000000000000000000000000000;;				"-c",
0000000000000000000000000000000000000000;;				"while true; do sleep 2; done",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "vsphere-e2e-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:         "vsphere-e2e-container-" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;						Image:        "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command:      commands,
0000000000000000000000000000000000000000;;						VolumeMounts: volumeMounts,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Volumes:       volumes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if keyValuelabel != nil {
0000000000000000000000000000000000000000;;			pod.Spec.NodeSelector = keyValuelabel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyFilesExistOnVSphereVolume(namespace string, podName string, filePaths []string) {
0000000000000000000000000000000000000000;;		for _, filePath := range filePaths {
0000000000000000000000000000000000000000;;			_, err := framework.RunKubectl("exec", fmt.Sprintf("--namespace=%s", namespace), podName, "--", "/bin/ls", filePath)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("failed to verify file: %q on the pod: %q", filePath, podName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createEmptyFilesOnVSphereVolume(namespace string, podName string, filePaths []string) {
0000000000000000000000000000000000000000;;		for _, filePath := range filePaths {
0000000000000000000000000000000000000000;;			err := framework.CreateEmptyFileOnPod(namespace, podName, filePath)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verify volumes are attached to the node and are accessible in pod
0000000000000000000000000000000000000000;;	func verifyVSphereVolumesAccessible(pod *v1.Pod, persistentvolumes []*v1.PersistentVolume, vsp *vsphere.VSphere) {
0000000000000000000000000000000000000000;;		nodeName := pod.Spec.NodeName
0000000000000000000000000000000000000000;;		namespace := pod.Namespace
0000000000000000000000000000000000000000;;		for index, pv := range persistentvolumes {
0000000000000000000000000000000000000000;;			// Verify disks are attached to the node
0000000000000000000000000000000000000000;;			isAttached, err := verifyVSphereDiskAttached(vsp, pv.Spec.VsphereVolume.VolumePath, k8stype.NodeName(nodeName))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(isAttached).To(BeTrue(), fmt.Sprintf("disk %v is not attached with the node", pv.Spec.VsphereVolume.VolumePath))
0000000000000000000000000000000000000000;;			// Verify Volumes are accessible
0000000000000000000000000000000000000000;;			filepath := filepath.Join("/mnt/", fmt.Sprintf("volume%v", index+1), "/emptyFile.txt")
0000000000000000000000000000000000000000;;			_, err = framework.LookForStringInPodExec(namespace, pod.Name, []string{"/bin/touch", filepath}, "", time.Minute)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
