0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f0263b2258c068c632c9283a8eb419d11c265952;test/e2e/volume_provisioning.go[test/e2e/volume_provisioning.go][test/e2e/storage/volume_provisioning.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/session"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		rbacv1beta1 "k8s.io/api/rbac/v1beta1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		storagebeta "k8s.io/api/storage/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		storageutil "k8s.io/kubernetes/pkg/apis/storage/v1/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageClassTest struct {
0000000000000000000000000000000000000000;;		name           string
0000000000000000000000000000000000000000;;		cloudProviders []string
0000000000000000000000000000000000000000;;		provisioner    string
0000000000000000000000000000000000000000;;		parameters     map[string]string
0000000000000000000000000000000000000000;;		claimSize      string
0000000000000000000000000000000000000000;;		expectedSize   string
0000000000000000000000000000000000000000;;		pvCheck        func(volume *v1.PersistentVolume) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Plugin name of the external provisioner
0000000000000000000000000000000000000000;;		externalPluginName = "example.com/nfs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testDynamicProvisioning(t storageClassTest, client clientset.Interface, claim *v1.PersistentVolumeClaim, class *storage.StorageClass) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if class != nil {
0000000000000000000000000000000000000000;;			By("creating a StorageClass " + class.Name)
0000000000000000000000000000000000000000;;			class, err = client.StorageV1().StorageClasses().Create(class)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				framework.Logf("deleting storage class %s", class.Name)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(client.StorageV1().StorageClasses().Delete(class.Name, nil))
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("creating a claim")
0000000000000000000000000000000000000000;;		claim, err = client.CoreV1().PersistentVolumeClaims(claim.Namespace).Create(claim)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			framework.Logf("deleting claim %q/%q", claim.Namespace, claim.Name)
0000000000000000000000000000000000000000;;			// typically this claim has already been deleted
0000000000000000000000000000000000000000;;			err = client.CoreV1().PersistentVolumeClaims(claim.Namespace).Delete(claim.Name, nil)
0000000000000000000000000000000000000000;;			if err != nil && !apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;				framework.Failf("Error deleting claim %q. Error: %v", claim.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		err = framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, client, claim.Namespace, claim.Name, framework.Poll, framework.ClaimProvisionTimeout)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("checking the claim")
0000000000000000000000000000000000000000;;		// Get new copy of the claim
0000000000000000000000000000000000000000;;		claim, err = client.CoreV1().PersistentVolumeClaims(claim.Namespace).Get(claim.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the bound PV
0000000000000000000000000000000000000000;;		pv, err := client.CoreV1().PersistentVolumes().Get(claim.Spec.VolumeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check sizes
0000000000000000000000000000000000000000;;		expectedCapacity := resource.MustParse(t.expectedSize)
0000000000000000000000000000000000000000;;		pvCapacity := pv.Spec.Capacity[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		Expect(pvCapacity.Value()).To(Equal(expectedCapacity.Value()), "pvCapacity is not equal to expectedCapacity")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestedCapacity := resource.MustParse(t.claimSize)
0000000000000000000000000000000000000000;;		claimCapacity := claim.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		Expect(claimCapacity.Value()).To(Equal(requestedCapacity.Value()), "claimCapacity is not equal to requestedCapacity")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check PV properties
0000000000000000000000000000000000000000;;		By("checking the PV")
0000000000000000000000000000000000000000;;		Expect(pv.Spec.PersistentVolumeReclaimPolicy).To(Equal(v1.PersistentVolumeReclaimDelete))
0000000000000000000000000000000000000000;;		expectedAccessModes := []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}
0000000000000000000000000000000000000000;;		Expect(pv.Spec.AccessModes).To(Equal(expectedAccessModes))
0000000000000000000000000000000000000000;;		Expect(pv.Spec.ClaimRef.Name).To(Equal(claim.ObjectMeta.Name))
0000000000000000000000000000000000000000;;		Expect(pv.Spec.ClaimRef.Namespace).To(Equal(claim.ObjectMeta.Namespace))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the checker
0000000000000000000000000000000000000000;;		if t.pvCheck != nil {
0000000000000000000000000000000000000000;;			err = t.pvCheck(pv)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We start two pods:
0000000000000000000000000000000000000000;;		// - The first writes 'hello word' to the /mnt/test (= the volume).
0000000000000000000000000000000000000000;;		// - The second one runs grep 'hello world' on /mnt/test.
0000000000000000000000000000000000000000;;		// If both succeed, Kubernetes actually allocated something that is
0000000000000000000000000000000000000000;;		// persistent across pods.
0000000000000000000000000000000000000000;;		By("checking the created volume is writable")
0000000000000000000000000000000000000000;;		runInPodWithVolume(client, claim.Namespace, claim.Name, "echo 'hello world' > /mnt/test/data")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("checking the created volume is readable and retains data")
0000000000000000000000000000000000000000;;		runInPodWithVolume(client, claim.Namespace, claim.Name, "grep 'hello world' /mnt/test/data")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("deleting claim %q/%q", claim.Namespace, claim.Name))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(client.CoreV1().PersistentVolumeClaims(claim.Namespace).Delete(claim.Name, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the PV to get deleted. Technically, the first few delete
0000000000000000000000000000000000000000;;		// attempts may fail, as the volume is still attached to a node because
0000000000000000000000000000000000000000;;		// kubelet is slowly cleaning up the previous pod, however it should succeed
0000000000000000000000000000000000000000;;		// in a couple of minutes. Wait 20 minutes to recover from random cloud
0000000000000000000000000000000000000000;;		// hiccups.
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("deleting the claim's PV %q", pv.Name))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForPersistentVolumeDeleted(client, pv.Name, 5*time.Second, 20*time.Minute))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkAWSEBS checks properties of an AWS EBS. Test framework does not
0000000000000000000000000000000000000000;;	// instantiate full AWS provider, therefore we need use ec2 API directly.
0000000000000000000000000000000000000000;;	func checkAWSEBS(volume *v1.PersistentVolume, volumeType string, encrypted bool) error {
0000000000000000000000000000000000000000;;		diskName := volume.Spec.AWSElasticBlockStore.VolumeID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var client *ec2.EC2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokens := strings.Split(diskName, "/")
0000000000000000000000000000000000000000;;		volumeID := tokens[len(tokens)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zone := framework.TestContext.CloudConfig.Zone
0000000000000000000000000000000000000000;;		if len(zone) > 0 {
0000000000000000000000000000000000000000;;			region := zone[:len(zone)-1]
0000000000000000000000000000000000000000;;			cfg := aws.Config{Region: &region}
0000000000000000000000000000000000000000;;			framework.Logf("using region %s", region)
0000000000000000000000000000000000000000;;			client = ec2.New(session.New(), &cfg)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			framework.Logf("no region configured")
0000000000000000000000000000000000000000;;			client = ec2.New(session.New())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := &ec2.DescribeVolumesInput{
0000000000000000000000000000000000000000;;			VolumeIds: []*string{&volumeID},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info, err := client.DescribeVolumes(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error querying ec2 for volume %q: %v", volumeID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(info.Volumes) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no volumes found for volume %q", volumeID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(info.Volumes) > 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("multiple volumes found for volume %q", volumeID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsVolume := info.Volumes[0]
0000000000000000000000000000000000000000;;		if awsVolume.VolumeType == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected volume type %q, got nil", volumeType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *awsVolume.VolumeType != volumeType {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected volume type %q, got %q", volumeType, *awsVolume.VolumeType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if encrypted && awsVolume.Encrypted == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected encrypted volume, got no encryption")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if encrypted && !*awsVolume.Encrypted {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected encrypted volume, got %v", *awsVolume.Encrypted)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkGCEPD(volume *v1.PersistentVolume, volumeType string) error {
0000000000000000000000000000000000000000;;		cloud, err := framework.GetGCECloud()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diskName := volume.Spec.GCEPersistentDisk.PDName
0000000000000000000000000000000000000000;;		disk, err := cloud.GetDiskByNameUnknownZone(diskName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(disk.Type, volumeType) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected disk type %q, expected suffix %q", disk.Type, volumeType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Dynamic Provisioning", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("volume-provisioning")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// filled in BeforeEach
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("DynamicProvisioner", func() {
0000000000000000000000000000000000000000;;			It("should provision storage with different parameters [Slow]", func() {
0000000000000000000000000000000000000000;;				cloudZone := getRandomCloudZone(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// This test checks that dynamic provisioning can provision a volume
0000000000000000000000000000000000000000;;				// that can be used to persist data among pods.
0000000000000000000000000000000000000000;;				tests := []storageClassTest{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"SSD PD on GCE/GKE",
0000000000000000000000000000000000000000;;						[]string{"gce", "gke"},
0000000000000000000000000000000000000000;;						"kubernetes.io/gce-pd",
0000000000000000000000000000000000000000;;						map[string]string{
0000000000000000000000000000000000000000;;							"type": "pd-ssd",
0000000000000000000000000000000000000000;;							"zone": cloudZone,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						"1.5Gi",
0000000000000000000000000000000000000000;;						"2Gi",
0000000000000000000000000000000000000000;;						func(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;							return checkGCEPD(volume, "pd-ssd")
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"HDD PD on GCE/GKE",
0000000000000000000000000000000000000000;;						[]string{"gce", "gke"},
0000000000000000000000000000000000000000;;						"kubernetes.io/gce-pd",
0000000000000000000000000000000000000000;;						map[string]string{
0000000000000000000000000000000000000000;;							"type": "pd-standard",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						"1.5Gi",
0000000000000000000000000000000000000000;;						"2Gi",
0000000000000000000000000000000000000000;;						func(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;							return checkGCEPD(volume, "pd-standard")
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// AWS
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"gp2 EBS on AWS",
0000000000000000000000000000000000000000;;						[]string{"aws"},
0000000000000000000000000000000000000000;;						"kubernetes.io/aws-ebs",
0000000000000000000000000000000000000000;;						map[string]string{
0000000000000000000000000000000000000000;;							"type": "gp2",
0000000000000000000000000000000000000000;;							"zone": cloudZone,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						"1.5Gi",
0000000000000000000000000000000000000000;;						"2Gi",
0000000000000000000000000000000000000000;;						func(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;							return checkAWSEBS(volume, "gp2", false)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"io1 EBS on AWS",
0000000000000000000000000000000000000000;;						[]string{"aws"},
0000000000000000000000000000000000000000;;						"kubernetes.io/aws-ebs",
0000000000000000000000000000000000000000;;						map[string]string{
0000000000000000000000000000000000000000;;							"type":      "io1",
0000000000000000000000000000000000000000;;							"iopsPerGB": "50",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						"3.5Gi",
0000000000000000000000000000000000000000;;						"4Gi", // 4 GiB is minimum for io1
0000000000000000000000000000000000000000;;						func(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;							return checkAWSEBS(volume, "io1", false)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"sc1 EBS on AWS",
0000000000000000000000000000000000000000;;						[]string{"aws"},
0000000000000000000000000000000000000000;;						"kubernetes.io/aws-ebs",
0000000000000000000000000000000000000000;;						map[string]string{
0000000000000000000000000000000000000000;;							"type": "sc1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						"500Gi", // minimum for sc1
0000000000000000000000000000000000000000;;						"500Gi",
0000000000000000000000000000000000000000;;						func(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;							return checkAWSEBS(volume, "sc1", false)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"st1 EBS on AWS",
0000000000000000000000000000000000000000;;						[]string{"aws"},
0000000000000000000000000000000000000000;;						"kubernetes.io/aws-ebs",
0000000000000000000000000000000000000000;;						map[string]string{
0000000000000000000000000000000000000000;;							"type": "st1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						"500Gi", // minimum for st1
0000000000000000000000000000000000000000;;						"500Gi",
0000000000000000000000000000000000000000;;						func(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;							return checkAWSEBS(volume, "st1", false)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"encrypted EBS on AWS",
0000000000000000000000000000000000000000;;						[]string{"aws"},
0000000000000000000000000000000000000000;;						"kubernetes.io/aws-ebs",
0000000000000000000000000000000000000000;;						map[string]string{
0000000000000000000000000000000000000000;;							"encrypted": "true",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						"1Gi",
0000000000000000000000000000000000000000;;						"1Gi",
0000000000000000000000000000000000000000;;						func(volume *v1.PersistentVolume) error {
0000000000000000000000000000000000000000;;							return checkAWSEBS(volume, "gp2", true)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// OpenStack generic tests (works on all OpenStack deployments)
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"generic Cinder volume on OpenStack",
0000000000000000000000000000000000000000;;						[]string{"openstack"},
0000000000000000000000000000000000000000;;						"kubernetes.io/cinder",
0000000000000000000000000000000000000000;;						map[string]string{},
0000000000000000000000000000000000000000;;						"1.5Gi",
0000000000000000000000000000000000000000;;						"2Gi",
0000000000000000000000000000000000000000;;						nil, // there is currently nothing to check on OpenStack
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"Cinder volume with empty volume type and zone on OpenStack",
0000000000000000000000000000000000000000;;						[]string{"openstack"},
0000000000000000000000000000000000000000;;						"kubernetes.io/cinder",
0000000000000000000000000000000000000000;;						map[string]string{
0000000000000000000000000000000000000000;;							"type":         "",
0000000000000000000000000000000000000000;;							"availability": "",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						"1.5Gi",
0000000000000000000000000000000000000000;;						"2Gi",
0000000000000000000000000000000000000000;;						nil, // there is currently nothing to check on OpenStack
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// vSphere generic test
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"generic vSphere volume",
0000000000000000000000000000000000000000;;						[]string{"vsphere"},
0000000000000000000000000000000000000000;;						"kubernetes.io/vsphere-volume",
0000000000000000000000000000000000000000;;						map[string]string{},
0000000000000000000000000000000000000000;;						"1.5Gi",
0000000000000000000000000000000000000000;;						"1.5Gi",
0000000000000000000000000000000000000000;;						nil,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"Azure disk volume with empty sku and location",
0000000000000000000000000000000000000000;;						[]string{"azure"},
0000000000000000000000000000000000000000;;						"kubernetes.io/azure-disk",
0000000000000000000000000000000000000000;;						map[string]string{},
0000000000000000000000000000000000000000;;						"1Gi",
0000000000000000000000000000000000000000;;						"1Gi",
0000000000000000000000000000000000000000;;						nil,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var betaTest *storageClassTest
0000000000000000000000000000000000000000;;				for i, t := range tests {
0000000000000000000000000000000000000000;;					// Beware of clojure, use local variables instead of those from
0000000000000000000000000000000000000000;;					// outer scope
0000000000000000000000000000000000000000;;					test := t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !framework.ProviderIs(test.cloudProviders...) {
0000000000000000000000000000000000000000;;						framework.Logf("Skipping %q: cloud providers is not %v", test.name, test.cloudProviders)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Remember the last supported test for subsequent test of beta API
0000000000000000000000000000000000000000;;					betaTest = &test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("Testing " + test.name)
0000000000000000000000000000000000000000;;					suffix := fmt.Sprintf("%d", i)
0000000000000000000000000000000000000000;;					class := newStorageClass(test, ns, suffix)
0000000000000000000000000000000000000000;;					claim := newClaim(test, ns, suffix)
0000000000000000000000000000000000000000;;					claim.Spec.StorageClassName = &class.Name
0000000000000000000000000000000000000000;;					testDynamicProvisioning(test, c, claim, class)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Run the last test with storage.k8s.io/v1beta1 and beta annotation on pvc
0000000000000000000000000000000000000000;;				if betaTest != nil {
0000000000000000000000000000000000000000;;					By("Testing " + betaTest.name + " with beta volume provisioning")
0000000000000000000000000000000000000000;;					class := newBetaStorageClass(*betaTest, "beta")
0000000000000000000000000000000000000000;;					// we need to create the class manually, testDynamicProvisioning does not accept beta class
0000000000000000000000000000000000000000;;					class, err := c.StorageV1beta1().StorageClasses().Create(class)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					defer deleteStorageClass(c, class.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					claim := newClaim(*betaTest, ns, "beta")
0000000000000000000000000000000000000000;;					claim.Annotations = map[string]string{
0000000000000000000000000000000000000000;;						v1.BetaStorageClassAnnotation: class.Name,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					testDynamicProvisioning(*betaTest, c, claim, nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// NOTE: Slow!  The test will wait up to 5 minutes (framework.ClaimProvisionTimeout)
0000000000000000000000000000000000000000;;			// when there is no regression.
0000000000000000000000000000000000000000;;			It("should not provision a volume in an unmanaged GCE zone. [Slow]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;				var suffix string = "unmananged"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Discovering an unmanaged zone")
0000000000000000000000000000000000000000;;				allZones := sets.NewString()     // all zones in the project
0000000000000000000000000000000000000000;;				managedZones := sets.NewString() // subset of allZones
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				gceCloud, err := framework.GetGCECloud()
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Get all k8s managed zones
0000000000000000000000000000000000000000;;				managedZones, err = gceCloud.GetAllZones()
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Get a list of all zones in the project
0000000000000000000000000000000000000000;;				zones, err := gceCloud.GetComputeService().Zones.List(framework.TestContext.CloudConfig.ProjectID).Do()
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				for _, z := range zones.Items {
0000000000000000000000000000000000000000;;					allZones.Insert(z.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Get the subset of zones not managed by k8s
0000000000000000000000000000000000000000;;				var unmanagedZone string
0000000000000000000000000000000000000000;;				var popped bool
0000000000000000000000000000000000000000;;				unmanagedZones := allZones.Difference(managedZones)
0000000000000000000000000000000000000000;;				// And select one of them at random.
0000000000000000000000000000000000000000;;				if unmanagedZone, popped = unmanagedZones.PopAny(); !popped {
0000000000000000000000000000000000000000;;					framework.Skipf("No unmanaged zones found.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating a StorageClass for the unmanaged zone")
0000000000000000000000000000000000000000;;				test := storageClassTest{
0000000000000000000000000000000000000000;;					name:        "unmanaged_zone",
0000000000000000000000000000000000000000;;					provisioner: "kubernetes.io/gce-pd",
0000000000000000000000000000000000000000;;					parameters:  map[string]string{"zone": unmanagedZone},
0000000000000000000000000000000000000000;;					claimSize:   "1Gi",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sc := newStorageClass(test, ns, suffix)
0000000000000000000000000000000000000000;;				sc, err = c.StorageV1().StorageClasses().Create(sc)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				defer deleteStorageClass(c, sc.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating a claim and expecting it to timeout")
0000000000000000000000000000000000000000;;				pvc := newClaim(test, ns, suffix)
0000000000000000000000000000000000000000;;				pvc.Spec.StorageClassName = &sc.Name
0000000000000000000000000000000000000000;;				pvc, err = c.CoreV1().PersistentVolumeClaims(ns).Create(pvc)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.DeletePersistentVolumeClaim(c, pvc.Name, ns), "Failed to delete PVC ", pvc.Name)
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// The claim should timeout phase:Pending
0000000000000000000000000000000000000000;;				err = framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, c, ns, pvc.Name, 2*time.Second, framework.ClaimProvisionTimeout)
0000000000000000000000000000000000000000;;				Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf(err.Error())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should test that deleting a claim before the volume is provisioned deletes the volume.", func() {
0000000000000000000000000000000000000000;;				// This case tests for the regressions of a bug fixed by PR #21268
0000000000000000000000000000000000000000;;				// REGRESSION: Deleting the PVC before the PV is provisioned can result in the PV
0000000000000000000000000000000000000000;;				// not being deleted.
0000000000000000000000000000000000000000;;				// NOTE:  Polls until no PVs are detected, times out at 5 minutes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("openstack", "gce", "aws", "gke", "vsphere", "azure")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				const raceAttempts int = 100
0000000000000000000000000000000000000000;;				var residualPVs []*v1.PersistentVolume
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creating and deleting PersistentVolumeClaims %d times", raceAttempts))
0000000000000000000000000000000000000000;;				test := storageClassTest{
0000000000000000000000000000000000000000;;					name:        "deletion race",
0000000000000000000000000000000000000000;;					provisioner: "", // Use a native one based on current cloud provider
0000000000000000000000000000000000000000;;					claimSize:   "1Gi",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				class := newStorageClass(test, ns, "race")
0000000000000000000000000000000000000000;;				class, err := c.StorageV1().StorageClasses().Create(class)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				defer deleteStorageClass(c, class.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// To increase chance of detection, attempt multiple iterations
0000000000000000000000000000000000000000;;				for i := 0; i < raceAttempts; i++ {
0000000000000000000000000000000000000000;;					suffix := fmt.Sprintf("race-%d", i)
0000000000000000000000000000000000000000;;					claim := newClaim(test, ns, suffix)
0000000000000000000000000000000000000000;;					claim.Spec.StorageClassName = &class.Name
0000000000000000000000000000000000000000;;					tmpClaim, err := framework.CreatePVC(c, ns, claim)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.DeletePersistentVolumeClaim(c, tmpClaim.Name, ns))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Checking for residual PersistentVolumes associated with StorageClass %s", class.Name))
0000000000000000000000000000000000000000;;				residualPVs, err = waitForProvisionedVolumesDeleted(c, class.Name)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				// Cleanup the test resources before breaking
0000000000000000000000000000000000000000;;				defer deleteProvisionedVolumesAndDisks(c, residualPVs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Report indicators of regression
0000000000000000000000000000000000000000;;				if len(residualPVs) > 0 {
0000000000000000000000000000000000000000;;					framework.Logf("Remaining PersistentVolumes:")
0000000000000000000000000000000000000000;;					for i, pv := range residualPVs {
0000000000000000000000000000000000000000;;						framework.Logf("\t%d) %s", i+1, pv.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					framework.Failf("Expected 0 PersistentVolumes remaining. Found %d", len(residualPVs))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("0 PersistentVolumes remain.")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("DynamicProvisioner External", func() {
0000000000000000000000000000000000000000;;			It("should let an external dynamic provisioner create and delete persistent volumes [Slow]", func() {
0000000000000000000000000000000000000000;;				// external dynamic provisioner pods need additional permissions provided by the
0000000000000000000000000000000000000000;;				// persistent-volume-provisioner role
0000000000000000000000000000000000000000;;				framework.BindClusterRole(c.Rbac(), "system:persistent-volume-provisioner", ns,
0000000000000000000000000000000000000000;;					rbacv1beta1.Subject{Kind: rbacv1beta1.ServiceAccountKind, Namespace: ns, Name: "default"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err := framework.WaitForAuthorizationUpdate(c.AuthorizationV1beta1(),
0000000000000000000000000000000000000000;;					serviceaccount.MakeUsername(ns, "default"),
0000000000000000000000000000000000000000;;					"", "get", schema.GroupResource{Group: "storage.k8s.io", Resource: "storageclasses"}, true)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err, "Failed to update authorization: %v", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating an external dynamic provisioner pod")
0000000000000000000000000000000000000000;;				pod := startExternalProvisioner(c, ns)
0000000000000000000000000000000000000000;;				defer framework.DeletePodOrFail(c, ns, pod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a StorageClass")
0000000000000000000000000000000000000000;;				test := storageClassTest{
0000000000000000000000000000000000000000;;					name:         "external provisioner test",
0000000000000000000000000000000000000000;;					provisioner:  externalPluginName,
0000000000000000000000000000000000000000;;					claimSize:    "1500Mi",
0000000000000000000000000000000000000000;;					expectedSize: "1500Mi",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				class := newStorageClass(test, ns, "external")
0000000000000000000000000000000000000000;;				className := class.Name
0000000000000000000000000000000000000000;;				claim := newClaim(test, ns, "external")
0000000000000000000000000000000000000000;;				// the external provisioner understands Beta only right now, see
0000000000000000000000000000000000000000;;				// https://github.com/kubernetes-incubator/external-storage/issues/37
0000000000000000000000000000000000000000;;				// claim.Spec.StorageClassName = &className
0000000000000000000000000000000000000000;;				claim.Annotations = map[string]string{
0000000000000000000000000000000000000000;;					v1.BetaStorageClassAnnotation: className,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a claim with a external provisioning annotation")
0000000000000000000000000000000000000000;;				testDynamicProvisioning(test, c, claim, class)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SIGDescribe("DynamicProvisioner Default", func() {
0000000000000000000000000000000000000000;;			It("should create and delete default persistent volumes [Slow]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("openstack", "gce", "aws", "gke", "vsphere", "azure")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a claim with no annotation")
0000000000000000000000000000000000000000;;				test := storageClassTest{
0000000000000000000000000000000000000000;;					name:         "default",
0000000000000000000000000000000000000000;;					claimSize:    "2Gi",
0000000000000000000000000000000000000000;;					expectedSize: "2Gi",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				claim := newClaim(test, ns, "default")
0000000000000000000000000000000000000000;;				testDynamicProvisioning(test, c, claim, nil)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Modifying the default storage class can be disruptive to other tests that depend on it
0000000000000000000000000000000000000000;;			It("should be disabled by changing the default annotation[Slow] [Serial] [Disruptive]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("openstack", "gce", "aws", "gke", "vsphere", "azure")
0000000000000000000000000000000000000000;;				scName := getDefaultStorageClassName(c)
0000000000000000000000000000000000000000;;				test := storageClassTest{
0000000000000000000000000000000000000000;;					name:      "default",
0000000000000000000000000000000000000000;;					claimSize: "2Gi",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("setting the is-default StorageClass annotation to false")
0000000000000000000000000000000000000000;;				verifyDefaultStorageClass(c, scName, true)
0000000000000000000000000000000000000000;;				defer updateDefaultStorageClass(c, scName, "true")
0000000000000000000000000000000000000000;;				updateDefaultStorageClass(c, scName, "false")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a claim with default storageclass and expecting it to timeout")
0000000000000000000000000000000000000000;;				claim := newClaim(test, ns, "default")
0000000000000000000000000000000000000000;;				claim, err := c.CoreV1().PersistentVolumeClaims(ns).Create(claim)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.DeletePersistentVolumeClaim(c, claim.Name, ns))
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// The claim should timeout phase:Pending
0000000000000000000000000000000000000000;;				err = framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, c, ns, claim.Name, 2*time.Second, framework.ClaimProvisionTimeout)
0000000000000000000000000000000000000000;;				Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf(err.Error())
0000000000000000000000000000000000000000;;				claim, err = c.CoreV1().PersistentVolumeClaims(ns).Get(claim.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				Expect(claim.Status.Phase).To(Equal(v1.ClaimPending))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Modifying the default storage class can be disruptive to other tests that depend on it
0000000000000000000000000000000000000000;;			It("should be disabled by removing the default annotation[Slow] [Serial] [Disruptive]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("openstack", "gce", "aws", "gke", "vsphere", "azure")
0000000000000000000000000000000000000000;;				scName := getDefaultStorageClassName(c)
0000000000000000000000000000000000000000;;				test := storageClassTest{
0000000000000000000000000000000000000000;;					name:      "default",
0000000000000000000000000000000000000000;;					claimSize: "2Gi",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("removing the is-default StorageClass annotation")
0000000000000000000000000000000000000000;;				verifyDefaultStorageClass(c, scName, true)
0000000000000000000000000000000000000000;;				defer updateDefaultStorageClass(c, scName, "true")
0000000000000000000000000000000000000000;;				updateDefaultStorageClass(c, scName, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a claim with default storageclass and expecting it to timeout")
0000000000000000000000000000000000000000;;				claim := newClaim(test, ns, "default")
0000000000000000000000000000000000000000;;				claim, err := c.CoreV1().PersistentVolumeClaims(ns).Create(claim)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.DeletePersistentVolumeClaim(c, claim.Name, ns))
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// The claim should timeout phase:Pending
0000000000000000000000000000000000000000;;				err = framework.WaitForPersistentVolumeClaimPhase(v1.ClaimBound, c, ns, claim.Name, 2*time.Second, framework.ClaimProvisionTimeout)
0000000000000000000000000000000000000000;;				Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.Logf(err.Error())
0000000000000000000000000000000000000000;;				claim, err = c.CoreV1().PersistentVolumeClaims(ns).Get(claim.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				Expect(claim.Status.Phase).To(Equal(v1.ClaimPending))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDefaultStorageClassName(c clientset.Interface) string {
0000000000000000000000000000000000000000;;		list, err := c.StorageV1().StorageClasses().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error listing storage classes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var scName string
0000000000000000000000000000000000000000;;		for _, sc := range list.Items {
0000000000000000000000000000000000000000;;			if storageutil.IsDefaultAnnotation(sc.ObjectMeta) {
0000000000000000000000000000000000000000;;				if len(scName) != 0 {
0000000000000000000000000000000000000000;;					framework.Failf("Multiple default storage classes found: %q and %q", scName, sc.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				scName = sc.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(scName) == 0 {
0000000000000000000000000000000000000000;;			framework.Failf("No default storage class found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("Default storage class: %q", scName)
0000000000000000000000000000000000000000;;		return scName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyDefaultStorageClass(c clientset.Interface, scName string, expectedDefault bool) {
0000000000000000000000000000000000000000;;		sc, err := c.StorageV1().StorageClasses().Get(scName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(storageutil.IsDefaultAnnotation(sc.ObjectMeta)).To(Equal(expectedDefault))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateDefaultStorageClass(c clientset.Interface, scName string, defaultStr string) {
0000000000000000000000000000000000000000;;		sc, err := c.StorageV1().StorageClasses().Get(scName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultStr == "" {
0000000000000000000000000000000000000000;;			delete(sc.Annotations, storageutil.BetaIsDefaultStorageClassAnnotation)
0000000000000000000000000000000000000000;;			delete(sc.Annotations, storageutil.IsDefaultStorageClassAnnotation)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if sc.Annotations == nil {
0000000000000000000000000000000000000000;;				sc.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.Annotations[storageutil.BetaIsDefaultStorageClassAnnotation] = defaultStr
0000000000000000000000000000000000000000;;			sc.Annotations[storageutil.IsDefaultStorageClassAnnotation] = defaultStr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc, err = c.StorageV1().StorageClasses().Update(sc)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedDefault := false
0000000000000000000000000000000000000000;;		if defaultStr == "true" {
0000000000000000000000000000000000000000;;			expectedDefault = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyDefaultStorageClass(c, scName, expectedDefault)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClaim(t storageClassTest, ns, suffix string) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		claim := v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "pvc-",
0000000000000000000000000000000000000000;;				Namespace:    ns,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse(t.claimSize),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &claim
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runInPodWithVolume runs a command in a pod with given claim mounted to /mnt directory.
0000000000000000000000000000000000000000;;	func runInPodWithVolume(c clientset.Interface, ns, claimName, command string) {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "pvc-volume-tester-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "volume-tester",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command: []string{"/bin/sh"},
0000000000000000000000000000000000000000;;						Args:    []string{"-c", command},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "my-volume",
0000000000000000000000000000000000000000;;								MountPath: "/mnt/test",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "my-volume",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;								ClaimName: claimName,
0000000000000000000000000000000000000000;;								ReadOnly:  false,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, err := c.CoreV1().Pods(ns).Create(pod)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Failed to create pod: %v", err)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			framework.DeletePodOrFail(c, ns, pod.Name)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForPodSuccessInNamespaceSlow(c, pod.Name, pod.Namespace))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDefaultPluginName() string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case framework.ProviderIs("gke"), framework.ProviderIs("gce"):
0000000000000000000000000000000000000000;;			return "kubernetes.io/gce-pd"
0000000000000000000000000000000000000000;;		case framework.ProviderIs("aws"):
0000000000000000000000000000000000000000;;			return "kubernetes.io/aws-ebs"
0000000000000000000000000000000000000000;;		case framework.ProviderIs("openstack"):
0000000000000000000000000000000000000000;;			return "kubernetes.io/cinder"
0000000000000000000000000000000000000000;;		case framework.ProviderIs("vsphere"):
0000000000000000000000000000000000000000;;			return "kubernetes.io/vsphere-volume"
0000000000000000000000000000000000000000;;		case framework.ProviderIs("azure"):
0000000000000000000000000000000000000000;;			return "kubernetes.io/azure-disk"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStorageClass(t storageClassTest, ns string, suffix string) *storage.StorageClass {
0000000000000000000000000000000000000000;;		pluginName := t.provisioner
0000000000000000000000000000000000000000;;		if pluginName == "" {
0000000000000000000000000000000000000000;;			pluginName = getDefaultPluginName()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if suffix == "" {
0000000000000000000000000000000000000000;;			suffix = "sc"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &storage.StorageClass{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "StorageClass",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				// Name must be unique, so let's base it on namespace name
0000000000000000000000000000000000000000;;				Name: ns + "-" + suffix,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Provisioner: pluginName,
0000000000000000000000000000000000000000;;			Parameters:  t.parameters,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove when storage.k8s.io/v1beta1 and beta storage class annotations
0000000000000000000000000000000000000000;;	// are removed.
0000000000000000000000000000000000000000;;	func newBetaStorageClass(t storageClassTest, suffix string) *storagebeta.StorageClass {
0000000000000000000000000000000000000000;;		pluginName := t.provisioner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pluginName == "" {
0000000000000000000000000000000000000000;;			pluginName = getDefaultPluginName()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if suffix == "" {
0000000000000000000000000000000000000000;;			suffix = "default"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &storagebeta.StorageClass{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "StorageClass",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: suffix + "-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Provisioner: pluginName,
0000000000000000000000000000000000000000;;			Parameters:  t.parameters,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startExternalProvisioner(c clientset.Interface, ns string) *v1.Pod {
0000000000000000000000000000000000000000;;		podClient := c.CoreV1().Pods(ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provisionerPod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "external-provisioner-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "nfs-provisioner",
0000000000000000000000000000000000000000;;						Image: "quay.io/kubernetes_incubator/nfs-provisioner:v1.0.6",
0000000000000000000000000000000000000000;;						SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;							Capabilities: &v1.Capabilities{
0000000000000000000000000000000000000000;;								Add: []v1.Capability{"DAC_READ_SEARCH"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"-provisioner=" + externalPluginName,
0000000000000000000000000000000000000000;;							"-grace-period=0",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{Name: "nfs", ContainerPort: 2049},
0000000000000000000000000000000000000000;;							{Name: "mountd", ContainerPort: 20048},
0000000000000000000000000000000000000000;;							{Name: "rpcbind", ContainerPort: 111},
0000000000000000000000000000000000000000;;							{Name: "rpcbind-udp", ContainerPort: 111, Protocol: v1.ProtocolUDP},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "POD_IP",
0000000000000000000000000000000000000000;;								ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;									FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;										FieldPath: "status.podIP",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						ImagePullPolicy: v1.PullIfNotPresent,
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "export-volume",
0000000000000000000000000000000000000000;;								MountPath: "/export",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "export-volume",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		provisionerPod, err := podClient.Create(provisionerPod)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Failed to create %s pod: %v", provisionerPod.Name, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForPodRunningInNamespace(c, provisionerPod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("locating the provisioner pod")
0000000000000000000000000000000000000000;;		pod, err := podClient.Get(provisionerPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Cannot locate the provisioner pod %v: %v", provisionerPod.Name, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForProvisionedVolumesDelete is a polling wrapper to scan all PersistentVolumes for any associated to the test's
0000000000000000000000000000000000000000;;	// StorageClass.  Returns either an error and nil values or the remaining PVs and their count.
0000000000000000000000000000000000000000;;	func waitForProvisionedVolumesDeleted(c clientset.Interface, scName string) ([]*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		var remainingPVs []*v1.PersistentVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := wait.Poll(10*time.Second, 300*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			remainingPVs = []*v1.PersistentVolume{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allPVs, err := c.CoreV1().PersistentVolumes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pv := range allPVs.Items {
0000000000000000000000000000000000000000;;				if v1helper.GetPersistentVolumeClass(&pv) == scName {
0000000000000000000000000000000000000000;;					remainingPVs = append(remainingPVs, &pv)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(remainingPVs) > 0 {
0000000000000000000000000000000000000000;;				return false, nil // Poll until no PVs remain
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true, nil // No PVs remain
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return remainingPVs, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteStorageClass deletes the passed in StorageClass and catches errors other than "Not Found"
0000000000000000000000000000000000000000;;	func deleteStorageClass(c clientset.Interface, className string) {
0000000000000000000000000000000000000000;;		err := c.StorageV1().StorageClasses().Delete(className, nil)
0000000000000000000000000000000000000000;;		if err != nil && !apierrs.IsNotFound(err) {
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteProvisionedVolumes [gce||gke only]  iteratively deletes persistent volumes and attached GCE PDs.
0000000000000000000000000000000000000000;;	func deleteProvisionedVolumesAndDisks(c clientset.Interface, pvs []*v1.PersistentVolume) {
0000000000000000000000000000000000000000;;		for _, pv := range pvs {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePDWithRetry(pv.Spec.PersistentVolumeSource.GCEPersistentDisk.PDName))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.DeletePersistentVolume(c, pv.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRandomCloudZone(c clientset.Interface) string {
0000000000000000000000000000000000000000;;		nodes, err := c.CoreV1().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// collect values of zone label from all nodes
0000000000000000000000000000000000000000;;		zones := sets.NewString()
0000000000000000000000000000000000000000;;		for _, node := range nodes.Items {
0000000000000000000000000000000000000000;;			if zone, found := node.Labels[kubeletapis.LabelZoneFailureDomain]; found {
0000000000000000000000000000000000000000;;				zones.Insert(zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// return "" in case that no node has zone label
0000000000000000000000000000000000000000;;		zone, _ := zones.PopAny()
0000000000000000000000000000000000000000;;		return zone
0000000000000000000000000000000000000000;;	}
