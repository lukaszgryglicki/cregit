0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
fab7df78a1367134c1d54b3a56c6aa9166dc83fd;test/e2e/vsphere_volume_placement.go[test/e2e/vsphere_volume_placement.go][test/e2e/storage/vsphere_volume_placement.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		vsphere "k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Volume Placement", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("volume-placement")
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			c                  clientset.Interface
0000000000000000000000000000000000000000;;			ns                 string
0000000000000000000000000000000000000000;;			vsp                *vsphere.VSphere
0000000000000000000000000000000000000000;;			volumePaths        []string
0000000000000000000000000000000000000000;;			node1Name          string
0000000000000000000000000000000000000000;;			node1KeyValueLabel map[string]string
0000000000000000000000000000000000000000;;			node2Name          string
0000000000000000000000000000000000000000;;			node2KeyValueLabel map[string]string
0000000000000000000000000000000000000000;;			isNodeLabeled      bool
0000000000000000000000000000000000000000;;			err                error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("vsphere")
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.WaitForAllNodesSchedulable(c, framework.TestContext.NodeSchedulableTimeout))
0000000000000000000000000000000000000000;;			if !isNodeLabeled {
0000000000000000000000000000000000000000;;				node1Name, node1KeyValueLabel, node2Name, node2KeyValueLabel = testSetupVolumePlacement(c, ns)
0000000000000000000000000000000000000000;;				isNodeLabeled = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("creating vmdk")
0000000000000000000000000000000000000000;;			vsp, err = vsphere.GetVSphere()
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			volumePath, err := createVSphereVolume(vsp, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			volumePaths = append(volumePaths, volumePath)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			for _, volumePath := range volumePaths {
0000000000000000000000000000000000000000;;				vsp.DeleteVolume(volumePath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumePaths = nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Steps
0000000000000000000000000000000000000000;;			1. Remove labels assigned to node 1 and node 2
0000000000000000000000000000000000000000;;			2. Delete VMDK volume
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		framework.AddCleanupAction(func() {
0000000000000000000000000000000000000000;;			if len(node1KeyValueLabel) > 0 {
0000000000000000000000000000000000000000;;				framework.RemoveLabelOffNode(c, node1Name, "vsphere_e2e_label")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(node2KeyValueLabel) > 0 {
0000000000000000000000000000000000000000;;				framework.RemoveLabelOffNode(c, node2Name, "vsphere_e2e_label")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Steps
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			1. Create pod Spec with volume path of the vmdk and NodeSelector set to label assigned to node1.
0000000000000000000000000000000000000000;;			2. Create pod and wait for pod to become ready.
0000000000000000000000000000000000000000;;			3. Verify volume is attached to the node1.
0000000000000000000000000000000000000000;;			4. Create empty file on the volume to verify volume is writable.
0000000000000000000000000000000000000000;;			5. Verify newly created file and previously created files exist on the volume.
0000000000000000000000000000000000000000;;			6. Delete pod.
0000000000000000000000000000000000000000;;			7. Wait for volume to be detached from the node1.
0000000000000000000000000000000000000000;;			8. Repeat Step 1 to 7 and make sure back to back pod creation on same worker node with the same volume is working as expected.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create and delete pod with the same volume source on the same worker node", func() {
0000000000000000000000000000000000000000;;			var volumeFiles []string
0000000000000000000000000000000000000000;;			pod := createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;			// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;			newEmptyFileName := fmt.Sprintf("/mnt/volume1/%v_1.txt", ns)
0000000000000000000000000000000000000000;;			volumeFiles = append(volumeFiles, newEmptyFileName)
0000000000000000000000000000000000000000;;			createAndVerifyFilesOnVolume(ns, pod.Name, []string{newEmptyFileName}, volumeFiles)
0000000000000000000000000000000000000000;;			deletePodAndWaitForVolumeToDetach(f, c, pod, vsp, node1Name, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating pod on the same node: %v", node1Name))
0000000000000000000000000000000000000000;;			pod = createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;			// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;			newEmptyFileName = fmt.Sprintf("/mnt/volume1/%v_2.txt", ns)
0000000000000000000000000000000000000000;;			volumeFiles = append(volumeFiles, newEmptyFileName)
0000000000000000000000000000000000000000;;			createAndVerifyFilesOnVolume(ns, pod.Name, []string{newEmptyFileName}, volumeFiles)
0000000000000000000000000000000000000000;;			deletePodAndWaitForVolumeToDetach(f, c, pod, vsp, node1Name, volumePaths)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Steps
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			1. Create pod Spec with volume path of the vmdk1 and NodeSelector set to node1's label.
0000000000000000000000000000000000000000;;			2. Create pod and wait for POD to become ready.
0000000000000000000000000000000000000000;;			3. Verify volume is attached to the node1.
0000000000000000000000000000000000000000;;			4. Create empty file on the volume to verify volume is writable.
0000000000000000000000000000000000000000;;			5. Verify newly created file and previously created files exist on the volume.
0000000000000000000000000000000000000000;;			6. Delete pod.
0000000000000000000000000000000000000000;;			7. Wait for volume to be detached from the node1.
0000000000000000000000000000000000000000;;			8. Create pod Spec with volume path of the vmdk1 and NodeSelector set to node2's label.
0000000000000000000000000000000000000000;;			9. Create pod and wait for pod to become ready.
0000000000000000000000000000000000000000;;			10. Verify volume is attached to the node2.
0000000000000000000000000000000000000000;;			11. Create empty file on the volume to verify volume is writable.
0000000000000000000000000000000000000000;;			12. Verify newly created file and previously created files exist on the volume.
0000000000000000000000000000000000000000;;			13. Delete pod.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create and delete pod with the same volume source attach/detach to different worker nodes", func() {
0000000000000000000000000000000000000000;;			var volumeFiles []string
0000000000000000000000000000000000000000;;			pod := createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, volumePaths)
0000000000000000000000000000000000000000;;			// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;			// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;			newEmptyFileName := fmt.Sprintf("/mnt/volume1/%v_1.txt", ns)
0000000000000000000000000000000000000000;;			volumeFiles = append(volumeFiles, newEmptyFileName)
0000000000000000000000000000000000000000;;			createAndVerifyFilesOnVolume(ns, pod.Name, []string{newEmptyFileName}, volumeFiles)
0000000000000000000000000000000000000000;;			deletePodAndWaitForVolumeToDetach(f, c, pod, vsp, node1Name, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating pod on the another node: %v", node2Name))
0000000000000000000000000000000000000000;;			pod = createPodWithVolumeAndNodeSelector(c, ns, vsp, node2Name, node2KeyValueLabel, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newEmptyFileName = fmt.Sprintf("/mnt/volume1/%v_2.txt", ns)
0000000000000000000000000000000000000000;;			volumeFiles = append(volumeFiles, newEmptyFileName)
0000000000000000000000000000000000000000;;			// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;			// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;			createAndVerifyFilesOnVolume(ns, pod.Name, []string{newEmptyFileName}, volumeFiles)
0000000000000000000000000000000000000000;;			deletePodAndWaitForVolumeToDetach(f, c, pod, vsp, node2Name, volumePaths)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Test multiple volumes from same datastore within the same pod
0000000000000000000000000000000000000000;;			1. Create volumes - vmdk2
0000000000000000000000000000000000000000;;			2. Create pod Spec with volume path of vmdk1 (vmdk1 is created in test setup) and vmdk2.
0000000000000000000000000000000000000000;;			3. Create pod using spec created in step-2 and wait for pod to become ready.
0000000000000000000000000000000000000000;;			4. Verify both volumes are attached to the node on which pod are created. Write some data to make sure volume are accessible.
0000000000000000000000000000000000000000;;			5. Delete pod.
0000000000000000000000000000000000000000;;			6. Wait for vmdk1 and vmdk2 to be detached from node.
0000000000000000000000000000000000000000;;			7. Create pod using spec created in step-2 and wait for pod to become ready.
0000000000000000000000000000000000000000;;			8. Verify both volumes are attached to the node on which PODs are created. Verify volume contents are matching with the content written in step 4.
0000000000000000000000000000000000000000;;			9. Delete POD.
0000000000000000000000000000000000000000;;			10. Wait for vmdk1 and vmdk2 to be detached from node.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create and delete pod with multiple volumes from same datastore", func() {
0000000000000000000000000000000000000000;;			By("creating another vmdk")
0000000000000000000000000000000000000000;;			volumePath, err := createVSphereVolume(vsp, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			volumePaths = append(volumePaths, volumePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating pod on the node: %v with volume: %v and volume: %v", node1Name, volumePaths[0], volumePaths[1]))
0000000000000000000000000000000000000000;;			pod := createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, volumePaths)
0000000000000000000000000000000000000000;;			// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;			// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;			volumeFiles := []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("/mnt/volume1/%v_1.txt", ns),
0000000000000000000000000000000000000000;;				fmt.Sprintf("/mnt/volume2/%v_1.txt", ns),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			createAndVerifyFilesOnVolume(ns, pod.Name, volumeFiles, volumeFiles)
0000000000000000000000000000000000000000;;			deletePodAndWaitForVolumeToDetach(f, c, pod, vsp, node1Name, volumePaths)
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating pod on the node: %v with volume :%v and volume: %v", node1Name, volumePaths[0], volumePaths[1]))
0000000000000000000000000000000000000000;;			pod = createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, volumePaths)
0000000000000000000000000000000000000000;;			// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;			// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;			newEmptyFilesNames := []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("/mnt/volume1/%v_2.txt", ns),
0000000000000000000000000000000000000000;;				fmt.Sprintf("/mnt/volume2/%v_2.txt", ns),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeFiles = append(volumeFiles, newEmptyFilesNames[0])
0000000000000000000000000000000000000000;;			volumeFiles = append(volumeFiles, newEmptyFilesNames[1])
0000000000000000000000000000000000000000;;			createAndVerifyFilesOnVolume(ns, pod.Name, newEmptyFilesNames, volumeFiles)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Test multiple volumes from different datastore within the same pod
0000000000000000000000000000000000000000;;			1. Create volumes - vmdk2 on non default shared datastore.
0000000000000000000000000000000000000000;;			2. Create pod Spec with volume path of vmdk1 (vmdk1 is created in test setup on default datastore) and vmdk2.
0000000000000000000000000000000000000000;;			3. Create pod using spec created in step-2 and wait for pod to become ready.
0000000000000000000000000000000000000000;;			4. Verify both volumes are attached to the node on which pod are created. Write some data to make sure volume are accessible.
0000000000000000000000000000000000000000;;			5. Delete pod.
0000000000000000000000000000000000000000;;			6. Wait for vmdk1 and vmdk2 to be detached from node.
0000000000000000000000000000000000000000;;			7. Create pod using spec created in step-2 and wait for pod to become ready.
0000000000000000000000000000000000000000;;			8. Verify both volumes are attached to the node on which PODs are created. Verify volume contents are matching with the content written in step 4.
0000000000000000000000000000000000000000;;			9. Delete POD.
0000000000000000000000000000000000000000;;			10. Wait for vmdk1 and vmdk2 to be detached from node.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		It("should create and delete pod with multiple volumes from different datastore", func() {
0000000000000000000000000000000000000000;;			By("creating another vmdk on non default shared datastore")
0000000000000000000000000000000000000000;;			var volumeOptions *vsphere.VolumeOptions
0000000000000000000000000000000000000000;;			volumeOptions = new(vsphere.VolumeOptions)
0000000000000000000000000000000000000000;;			volumeOptions.CapacityKB = 2097152
0000000000000000000000000000000000000000;;			volumeOptions.Name = "e2e-vmdk-" + strconv.FormatInt(time.Now().UnixNano(), 10)
0000000000000000000000000000000000000000;;			volumeOptions.Datastore = os.Getenv("VSPHERE_SECOND_SHARED_DATASTORE")
0000000000000000000000000000000000000000;;			volumePath, err := createVSphereVolume(vsp, volumeOptions)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			volumePaths = append(volumePaths, volumePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating pod on the node: %v with volume :%v  and volume: %v", node1Name, volumePaths[0], volumePaths[1]))
0000000000000000000000000000000000000000;;			pod := createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;			// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;			volumeFiles := []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("/mnt/volume1/%v_1.txt", ns),
0000000000000000000000000000000000000000;;				fmt.Sprintf("/mnt/volume2/%v_1.txt", ns),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			createAndVerifyFilesOnVolume(ns, pod.Name, volumeFiles, volumeFiles)
0000000000000000000000000000000000000000;;			deletePodAndWaitForVolumeToDetach(f, c, pod, vsp, node1Name, volumePaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating pod on the node: %v with volume :%v  and volume: %v", node1Name, volumePaths[0], volumePaths[1]))
0000000000000000000000000000000000000000;;			pod = createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, volumePaths)
0000000000000000000000000000000000000000;;			// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;			// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;			newEmptyFileNames := []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("/mnt/volume1/%v_2.txt", ns),
0000000000000000000000000000000000000000;;				fmt.Sprintf("/mnt/volume2/%v_2.txt", ns),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeFiles = append(volumeFiles, newEmptyFileNames[0])
0000000000000000000000000000000000000000;;			volumeFiles = append(volumeFiles, newEmptyFileNames[1])
0000000000000000000000000000000000000000;;			createAndVerifyFilesOnVolume(ns, pod.Name, newEmptyFileNames, volumeFiles)
0000000000000000000000000000000000000000;;			deletePodAndWaitForVolumeToDetach(f, c, pod, vsp, node1Name, volumePaths)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Test Back-to-back pod creation/deletion with different volume sources on the same worker node
0000000000000000000000000000000000000000;;			    1. Create volumes - vmdk2
0000000000000000000000000000000000000000;;			    2. Create pod Spec - pod-SpecA with volume path of vmdk1 and NodeSelector set to label assigned to node1.
0000000000000000000000000000000000000000;;			    3. Create pod Spec - pod-SpecB with volume path of vmdk2 and NodeSelector set to label assigned to node1.
0000000000000000000000000000000000000000;;			    4. Create pod-A using pod-SpecA and wait for pod to become ready.
0000000000000000000000000000000000000000;;			    5. Create pod-B using pod-SpecB and wait for POD to become ready.
0000000000000000000000000000000000000000;;			    6. Verify volumes are attached to the node.
0000000000000000000000000000000000000000;;			    7. Create empty file on the volume to make sure volume is accessible. (Perform this step on pod-A and pod-B)
0000000000000000000000000000000000000000;;			    8. Verify file created in step 5 is present on the volume. (perform this step on pod-A and pod-B)
0000000000000000000000000000000000000000;;			    9. Delete pod-A and pod-B
0000000000000000000000000000000000000000;;			    10. Repeatedly (5 times) perform step 4 to 9 and verify associated volume's content is matching.
0000000000000000000000000000000000000000;;			    11. Wait for vmdk1 and vmdk2 to be detached from node.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		It("test back to back pod creation and deletion with different volume sources on the same worker node", func() {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				podA                *v1.Pod
0000000000000000000000000000000000000000;;				podB                *v1.Pod
0000000000000000000000000000000000000000;;				testvolumePathsPodA []string
0000000000000000000000000000000000000000;;				testvolumePathsPodB []string
0000000000000000000000000000000000000000;;				podAFiles           []string
0000000000000000000000000000000000000000;;				podBFiles           []string
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				By("clean up undeleted pods")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.DeletePodWithWait(f, c, podA), "defer: Failed to delete pod ", podA.Name)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.DeletePodWithWait(f, c, podB), "defer: Failed to delete pod ", podB.Name)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("wait for volumes to be detached from the node: %v", node1Name))
0000000000000000000000000000000000000000;;				for _, volumePath := range volumePaths {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(waitForVSphereDiskToDetach(vsp, volumePath, types.NodeName(node1Name)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testvolumePathsPodA = append(testvolumePathsPodA, volumePaths[0])
0000000000000000000000000000000000000000;;			// Create another VMDK Volume
0000000000000000000000000000000000000000;;			By("creating another vmdk")
0000000000000000000000000000000000000000;;			volumePath, err := createVSphereVolume(vsp, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			volumePaths = append(volumePaths, volumePath)
0000000000000000000000000000000000000000;;			testvolumePathsPodB = append(testvolumePathsPodA, volumePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for index := 0; index < 5; index++ {
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creating pod-A on the node: %v with volume: %v", node1Name, testvolumePathsPodA[0]))
0000000000000000000000000000000000000000;;				podA = createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, testvolumePathsPodA)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creating pod-B on the node: %v with volume: %v", node1Name, testvolumePathsPodB[0]))
0000000000000000000000000000000000000000;;				podB = createPodWithVolumeAndNodeSelector(c, ns, vsp, node1Name, node1KeyValueLabel, testvolumePathsPodB)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podAFileName := fmt.Sprintf("/mnt/volume1/podA_%v_%v.txt", ns, index+1)
0000000000000000000000000000000000000000;;				podBFileName := fmt.Sprintf("/mnt/volume1/podB_%v_%v.txt", ns, index+1)
0000000000000000000000000000000000000000;;				podAFiles = append(podAFiles, podAFileName)
0000000000000000000000000000000000000000;;				podBFiles = append(podBFiles, podBFileName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;				By("Creating empty file on volume mounted on pod-A")
0000000000000000000000000000000000000000;;				framework.CreateEmptyFileOnPod(ns, podA.Name, podAFileName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating empty file volume mounted on pod-B")
0000000000000000000000000000000000000000;;				framework.CreateEmptyFileOnPod(ns, podB.Name, podBFileName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;				By("Verify newly Created file and previously created files present on volume mounted on pod-A")
0000000000000000000000000000000000000000;;				verifyFilesExistOnVSphereVolume(ns, podA.Name, podAFiles)
0000000000000000000000000000000000000000;;				By("Verify newly Created file and previously created files present on volume mounted on pod-B")
0000000000000000000000000000000000000000;;				verifyFilesExistOnVSphereVolume(ns, podB.Name, podBFiles)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Deleting pod-A")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.DeletePodWithWait(f, c, podA), "Failed to delete pod ", podA.Name)
0000000000000000000000000000000000000000;;				By("Deleting pod-B")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.DeletePodWithWait(f, c, podB), "Failed to delete pod ", podB.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testSetupVolumePlacement(client clientset.Interface, namespace string) (node1Name string, node1KeyValueLabel map[string]string, node2Name string, node2KeyValueLabel map[string]string) {
0000000000000000000000000000000000000000;;		nodes := framework.GetReadySchedulableNodesOrDie(client)
0000000000000000000000000000000000000000;;		if len(nodes.Items) < 2 {
0000000000000000000000000000000000000000;;			framework.Skipf("Requires at least %d nodes (not %d)", 2, len(nodes.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node1Name = nodes.Items[0].Name
0000000000000000000000000000000000000000;;		node2Name = nodes.Items[1].Name
0000000000000000000000000000000000000000;;		node1LabelValue := "vsphere_e2e_" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		node1KeyValueLabel = make(map[string]string)
0000000000000000000000000000000000000000;;		node1KeyValueLabel["vsphere_e2e_label"] = node1LabelValue
0000000000000000000000000000000000000000;;		framework.AddOrUpdateLabelOnNode(client, node1Name, "vsphere_e2e_label", node1LabelValue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node2LabelValue := "vsphere_e2e_" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		node2KeyValueLabel = make(map[string]string)
0000000000000000000000000000000000000000;;		node2KeyValueLabel["vsphere_e2e_label"] = node2LabelValue
0000000000000000000000000000000000000000;;		framework.AddOrUpdateLabelOnNode(client, node2Name, "vsphere_e2e_label", node2LabelValue)
0000000000000000000000000000000000000000;;		return node1Name, node1KeyValueLabel, node2Name, node2KeyValueLabel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPodWithVolumeAndNodeSelector(client clientset.Interface, namespace string, vsp *vsphere.VSphere, nodeName string, nodeKeyValueLabel map[string]string, volumePaths []string) *v1.Pod {
0000000000000000000000000000000000000000;;		var pod *v1.Pod
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating pod on the node: %v", nodeName))
0000000000000000000000000000000000000000;;		podspec := getVSpherePodSpecWithVolumePaths(volumePaths, nodeKeyValueLabel, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod, err = client.CoreV1().Pods(namespace).Create(podspec)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		By("Waiting for pod to be ready")
0000000000000000000000000000000000000000;;		Expect(framework.WaitForPodNameRunningInNamespace(client, pod.Name, namespace)).To(Succeed())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Verify volume is attached to the node:%v", nodeName))
0000000000000000000000000000000000000000;;		for _, volumePath := range volumePaths {
0000000000000000000000000000000000000000;;			isAttached, err := verifyVSphereDiskAttached(vsp, volumePath, types.NodeName(nodeName))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(isAttached).To(BeTrue(), "disk:"+volumePath+" is not attached with the node")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAndVerifyFilesOnVolume(namespace string, podname string, newEmptyfilesToCreate []string, filesToCheck []string) {
0000000000000000000000000000000000000000;;		// Create empty files on the mounted volumes on the pod to verify volume is writable
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating empty file on volume mounted on: %v", podname))
0000000000000000000000000000000000000000;;		createEmptyFilesOnVSphereVolume(namespace, podname, newEmptyfilesToCreate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify newly and previously created files present on the volume mounted on the pod
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Verify newly Created file and previously created files present on volume mounted on: %v", podname))
0000000000000000000000000000000000000000;;		verifyFilesExistOnVSphereVolume(namespace, podname, filesToCheck)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deletePodAndWaitForVolumeToDetach(f *framework.Framework, c clientset.Interface, pod *v1.Pod, vsp *vsphere.VSphere, nodeName string, volumePaths []string) {
0000000000000000000000000000000000000000;;		By("Deleting pod")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.DeletePodWithWait(f, c, pod), "Failed to delete pod ", pod.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for volume to be detached from the node")
0000000000000000000000000000000000000000;;		for _, volumePath := range volumePaths {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(waitForVSphereDiskToDetach(vsp, volumePath, types.NodeName(nodeName)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
