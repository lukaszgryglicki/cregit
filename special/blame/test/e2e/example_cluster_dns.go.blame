0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
eef9071219a732a822465b5fb8930d8390c6d48e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		dnsReadyTimeout = time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const queryDnsPythonTemplate string = `
0000000000000000000000000000000000000000;;	import socket
0000000000000000000000000000000000000000;;	try:
0000000000000000000000000000000000000000;;		socket.gethostbyname('%s')
0000000000000000000000000000000000000000;;		print 'ok'
0000000000000000000000000000000000000000;;	except:
0000000000000000000000000000000000000000;;		print 'err'`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("ClusterDns [Feature:Example]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("cluster-dns")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create pod that uses dns", func() {
0000000000000000000000000000000000000000;;			mkpath := func(file string) string {
0000000000000000000000000000000000000000;;				return filepath.Join(framework.TestContext.RepoRoot, "examples/cluster-dns", file)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// contrary to the example, this test does not use contexts, for simplicity
0000000000000000000000000000000000000000;;			// namespaces are passed directly.
0000000000000000000000000000000000000000;;			// Also, for simplicity, we don't use yamls with namespaces, but we
0000000000000000000000000000000000000000;;			// create testing namespaces instead.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			backendRcYaml := mkpath("dns-backend-rc.yaml")
0000000000000000000000000000000000000000;;			backendRcName := "dns-backend"
0000000000000000000000000000000000000000;;			backendSvcYaml := mkpath("dns-backend-service.yaml")
0000000000000000000000000000000000000000;;			backendSvcName := "dns-backend"
0000000000000000000000000000000000000000;;			backendPodName := "dns-backend"
0000000000000000000000000000000000000000;;			frontendPodYaml := mkpath("dns-frontend-pod.yaml")
0000000000000000000000000000000000000000;;			frontendPodName := "dns-frontend"
0000000000000000000000000000000000000000;;			frontendPodContainerName := "dns-frontend"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podOutput := "Hello World!"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// we need two namespaces anyway, so let's forget about
0000000000000000000000000000000000000000;;			// the one created in BeforeEach and create two new ones.
0000000000000000000000000000000000000000;;			namespaces := []*v1.Namespace{nil, nil}
0000000000000000000000000000000000000000;;			for i := range namespaces {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				namespaces[i], err = f.CreateNamespace(fmt.Sprintf("dnsexample%d", i), nil)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, ns := range namespaces {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("create", "-f", backendRcYaml, getNsCmdFlag(ns))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, ns := range namespaces {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("create", "-f", backendSvcYaml, getNsCmdFlag(ns))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for objects
0000000000000000000000000000000000000000;;			for _, ns := range namespaces {
0000000000000000000000000000000000000000;;				framework.WaitForControlledPodsRunning(c, ns.Name, backendRcName, api.Kind("ReplicationController"))
0000000000000000000000000000000000000000;;				framework.WaitForService(c, ns.Name, backendSvcName, true, framework.Poll, framework.ServiceStartTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// it is not enough that pods are running because they may be set to running, but
0000000000000000000000000000000000000000;;			// the application itself may have not been initialized. Just query the application.
0000000000000000000000000000000000000000;;			for _, ns := range namespaces {
0000000000000000000000000000000000000000;;				label := labels.SelectorFromSet(labels.Set(map[string]string{"name": backendRcName}))
0000000000000000000000000000000000000000;;				options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;				pods, err := c.Core().Pods(ns.Name).List(options)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				err = framework.PodsResponding(c, ns.Name, backendPodName, false, pods)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "waiting for all pods to respond")
0000000000000000000000000000000000000000;;				framework.Logf("found %d backend pods responding in namespace %s", len(pods.Items), ns.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = framework.ServiceResponding(c, ns.Name, backendSvcName)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "waiting for the service to respond")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Now another tricky part:
0000000000000000000000000000000000000000;;			// It may happen that the service name is not yet in DNS.
0000000000000000000000000000000000000000;;			// So if we start our pod, it will fail. We must make sure
0000000000000000000000000000000000000000;;			// the name is already resolvable. So let's try to query DNS from
0000000000000000000000000000000000000000;;			// the pod we have, until we find our service name.
0000000000000000000000000000000000000000;;			// This complicated code may be removed if the pod itself retried after
0000000000000000000000000000000000000000;;			// dns error or timeout.
0000000000000000000000000000000000000000;;			// This code is probably unnecessary, but let's stay on the safe side.
0000000000000000000000000000000000000000;;			label := labels.SelectorFromSet(labels.Set(map[string]string{"name": backendPodName}))
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;			pods, err := c.Core().Pods(namespaces[0].Name).List(options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil || pods == nil || len(pods.Items) == 0 {
0000000000000000000000000000000000000000;;				framework.Failf("no running pods found")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podName := pods.Items[0].Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			queryDns := fmt.Sprintf(queryDnsPythonTemplate, backendSvcName+"."+namespaces[0].Name)
0000000000000000000000000000000000000000;;			_, err = framework.LookForStringInPodExec(namespaces[0].Name, podName, []string{"python", "-c", queryDns}, "ok", dnsReadyTimeout)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "waiting for output from pod exec")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updatedPodYaml := prepareResourceWithReplacedString(frontendPodYaml, "dns-backend.development.svc.cluster.local", fmt.Sprintf("dns-backend.%s.svc.cluster.local", namespaces[0].Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// create a pod in each namespace
0000000000000000000000000000000000000000;;			for _, ns := range namespaces {
0000000000000000000000000000000000000000;;				framework.NewKubectlCommand("create", "-f", "-", getNsCmdFlag(ns)).WithStdinData(updatedPodYaml).ExecOrDie()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait until the pods have been scheduler, i.e. are not Pending anymore. Remember
0000000000000000000000000000000000000000;;			// that we cannot wait for the pods to be running because our pods terminate by themselves.
0000000000000000000000000000000000000000;;			for _, ns := range namespaces {
0000000000000000000000000000000000000000;;				err := framework.WaitForPodNotPending(c, ns.Name, frontendPodName)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for pods to print their result
0000000000000000000000000000000000000000;;			for _, ns := range namespaces {
0000000000000000000000000000000000000000;;				_, err := framework.LookForStringInLog(ns.Name, frontendPodName, frontendPodContainerName, podOutput, framework.PodStartTimeout)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNsCmdFlag(ns *v1.Namespace) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("--namespace=%v", ns.Name)
0000000000000000000000000000000000000000;;	}
