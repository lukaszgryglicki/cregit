0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
a37ced112456755c80e644ff201aafd3d41d7fe8;test/e2e/portforward.go[test/e2e/portforward.go][test/e2e/kubectl/portforward.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OWNER = sig/cli
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		utilversion "k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		podName = "pfpod"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO support other ports besides 80
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		portForwardRegexp        = regexp.MustCompile("Forwarding from 127.0.0.1:([0-9]+) -> 80")
0000000000000000000000000000000000000000;;		portForwardPortToStdOutV = utilversion.MustParseSemantic("v1.3.0-alpha.4")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pfPod(expectedClientData, chunks, chunkSize, chunkIntervalMillis string, bindAddress string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   podName,
0000000000000000000000000000000000000000;;				Labels: map[string]string{"name": podName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "readiness",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/netexec:1.7",
0000000000000000000000000000000000000000;;						ReadinessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;							Handler: v1.Handler{
0000000000000000000000000000000000000000;;								Exec: &v1.ExecAction{
0000000000000000000000000000000000000000;;									Command: []string{
0000000000000000000000000000000000000000;;										"sh", "-c", "netstat -na | grep LISTEN | grep -v 8080 | grep 80",
0000000000000000000000000000000000000000;;									}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							InitialDelaySeconds: 5,
0000000000000000000000000000000000000000;;							TimeoutSeconds:      60,
0000000000000000000000000000000000000000;;							PeriodSeconds:       1,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "portforwardtester",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/portforwardtester:1.2",
0000000000000000000000000000000000000000;;						Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "BIND_PORT",
0000000000000000000000000000000000000000;;								Value: "80",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "EXPECTED_CLIENT_DATA",
0000000000000000000000000000000000000000;;								Value: expectedClientData,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "CHUNKS",
0000000000000000000000000000000000000000;;								Value: chunks,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "CHUNK_SIZE",
0000000000000000000000000000000000000000;;								Value: chunkSize,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "CHUNK_INTERVAL",
0000000000000000000000000000000000000000;;								Value: chunkIntervalMillis,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "BIND_ADDRESS",
0000000000000000000000000000000000000000;;								Value: bindAddress,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WaitForTerminatedContainer(f *framework.Framework, pod *v1.Pod, containerName string) error {
0000000000000000000000000000000000000000;;		return framework.WaitForPodCondition(f.ClientSet, f.Namespace.Name, pod.Name, "container terminated", framework.PodStartTimeout, func(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;			if len(testutils.TerminatedContainers(pod)[containerName]) > 0 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portForwardCommand struct {
0000000000000000000000000000000000000000;;		cmd  *exec.Cmd
0000000000000000000000000000000000000000;;		port int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop attempts to gracefully stop `kubectl port-forward`, only killing it if necessary.
0000000000000000000000000000000000000000;;	// This helps avoid spdy goroutine leaks in the Kubelet.
0000000000000000000000000000000000000000;;	func (c *portForwardCommand) Stop() {
0000000000000000000000000000000000000000;;		// SIGINT signals that kubectl port-forward should gracefully terminate
0000000000000000000000000000000000000000;;		if err := c.cmd.Process.Signal(syscall.SIGINT); err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("error sending SIGINT to kubectl port-forward: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to wait for a clean exit
0000000000000000000000000000000000000000;;		done := make(chan error)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			done <- c.cmd.Wait()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expired := time.NewTimer(wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		defer expired.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-done:
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				// success
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("error waiting for kubectl port-forward to exit: %v", err)
0000000000000000000000000000000000000000;;		case <-expired.C:
0000000000000000000000000000000000000000;;			framework.Logf("timed out waiting for kubectl port-forward to exit")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("trying to forcibly kill kubectl port-forward")
0000000000000000000000000000000000000000;;		framework.TryKill(c.cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runPortForward runs port-forward, warning, this may need root functionality on some systems.
0000000000000000000000000000000000000000;;	func runPortForward(ns, podName string, port int) *portForwardCommand {
0000000000000000000000000000000000000000;;		cmd := framework.KubectlCmd("port-forward", fmt.Sprintf("--namespace=%v", ns), podName, fmt.Sprintf(":%d", port))
0000000000000000000000000000000000000000;;		// This is somewhat ugly but is the only way to retrieve the port that was picked
0000000000000000000000000000000000000000;;		// by the port-forward command. We don't want to hard code the port as we have no
0000000000000000000000000000000000000000;;		// way of guaranteeing we can pick one that isn't in use, particularly on Jenkins.
0000000000000000000000000000000000000000;;		framework.Logf("starting port-forward command and streaming output")
0000000000000000000000000000000000000000;;		stdout, stderr, err := framework.StartCmdAndStreamOutput(cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to start port-forward command: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := make([]byte, 128)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// After v1.3.0-alpha.4 (#17030), kubectl port-forward outputs port
0000000000000000000000000000000000000000;;		// info to stdout, not stderr, so for version-skewed tests, look there
0000000000000000000000000000000000000000;;		// instead.
0000000000000000000000000000000000000000;;		var portOutput io.ReadCloser
0000000000000000000000000000000000000000;;		if useStdOut, err := framework.KubectlVersionGTE(portForwardPortToStdOutV); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to get kubectl version: %v", err)
0000000000000000000000000000000000000000;;		} else if useStdOut {
0000000000000000000000000000000000000000;;			portOutput = stdout
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			portOutput = stderr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		framework.Logf("reading from `kubectl port-forward` command's stdout")
0000000000000000000000000000000000000000;;		if n, err = portOutput.Read(buf); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to read from kubectl port-forward stdout: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portForwardOutput := string(buf[:n])
0000000000000000000000000000000000000000;;		match := portForwardRegexp.FindStringSubmatch(portForwardOutput)
0000000000000000000000000000000000000000;;		if len(match) != 2 {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to parse kubectl port-forward output: %s", portForwardOutput)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenPort, err := strconv.Atoi(match[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error converting %s to an int: %v", match[1], err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &portForwardCommand{
0000000000000000000000000000000000000000;;			cmd:  cmd,
0000000000000000000000000000000000000000;;			port: listenPort,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doTestConnectSendDisconnect(bindAddress string, f *framework.Framework) {
0000000000000000000000000000000000000000;;		By("Creating the target pod")
0000000000000000000000000000000000000000;;		pod := pfPod("", "10", "10", "100", fmt.Sprintf("%s", bindAddress))
0000000000000000000000000000000000000000;;		if _, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Couldn't create pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := f.WaitForPodReady(pod.Name); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Pod did not start running: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			logs, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, "portforwardtester")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Error getting pod log: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Logf("Pod log:\n%s", logs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Running 'kubectl port-forward'")
0000000000000000000000000000000000000000;;		cmd := runPortForward(f.Namespace.Name, pod.Name, 80)
0000000000000000000000000000000000000000;;		defer cmd.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Dialing the local port")
0000000000000000000000000000000000000000;;		conn, err := net.Dial("tcp", fmt.Sprintf("127.0.0.1:%d", cmd.port))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Couldn't connect to port %d: %v", cmd.port, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			By("Closing the connection to the local port")
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Reading data from the local port")
0000000000000000000000000000000000000000;;		fromServer, err := ioutil.ReadAll(conn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Unexpected error reading data from the server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := strings.Repeat("x", 100), string(fromServer); e != a {
0000000000000000000000000000000000000000;;			framework.Failf("Expected %q from server, got %q", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for the target pod to stop running")
0000000000000000000000000000000000000000;;		if err := WaitForTerminatedContainer(f, pod, "portforwardtester"); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Container did not terminate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying logs")
0000000000000000000000000000000000000000;;		logOutput, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, "portforwardtester")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error retrieving pod logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "Accepted client connection")
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "Done")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doTestMustConnectSendNothing(bindAddress string, f *framework.Framework) {
0000000000000000000000000000000000000000;;		By("Creating the target pod")
0000000000000000000000000000000000000000;;		pod := pfPod("abc", "1", "1", "1", fmt.Sprintf("%s", bindAddress))
0000000000000000000000000000000000000000;;		if _, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Couldn't create pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := f.WaitForPodReady(pod.Name); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Pod did not start running: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			logs, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, "portforwardtester")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Error getting pod log: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Logf("Pod log:\n%s", logs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Running 'kubectl port-forward'")
0000000000000000000000000000000000000000;;		cmd := runPortForward(f.Namespace.Name, pod.Name, 80)
0000000000000000000000000000000000000000;;		defer cmd.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Dialing the local port")
0000000000000000000000000000000000000000;;		conn, err := net.Dial("tcp", fmt.Sprintf("127.0.0.1:%d", cmd.port))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Couldn't connect to port %d: %v", cmd.port, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Closing the connection to the local port")
0000000000000000000000000000000000000000;;		conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for the target pod to stop running")
0000000000000000000000000000000000000000;;		if err := WaitForTerminatedContainer(f, pod, "portforwardtester"); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Container did not terminate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying logs")
0000000000000000000000000000000000000000;;		logOutput, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, "portforwardtester")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error retrieving pod logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "Accepted client connection")
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "Expected to read 3 bytes from client, but got 0 instead")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doTestMustConnectSendDisconnect(bindAddress string, f *framework.Framework) {
0000000000000000000000000000000000000000;;		By("Creating the target pod")
0000000000000000000000000000000000000000;;		pod := pfPod("abc", "10", "10", "100", fmt.Sprintf("%s", bindAddress))
0000000000000000000000000000000000000000;;		if _, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Couldn't create pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := f.WaitForPodReady(pod.Name); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Pod did not start running: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			logs, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, "portforwardtester")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Error getting pod log: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Logf("Pod log:\n%s", logs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Running 'kubectl port-forward'")
0000000000000000000000000000000000000000;;		cmd := runPortForward(f.Namespace.Name, pod.Name, 80)
0000000000000000000000000000000000000000;;		defer cmd.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Dialing the local port")
0000000000000000000000000000000000000000;;		addr, err := net.ResolveTCPAddr("tcp", fmt.Sprintf("127.0.0.1:%d", cmd.port))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error resolving tcp addr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, err := net.DialTCP("tcp", nil, addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Couldn't connect to port %d: %v", cmd.port, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			By("Closing the connection to the local port")
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Sending the expected data to the local port")
0000000000000000000000000000000000000000;;		fmt.Fprint(conn, "abc")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Closing the write half of the client's connection")
0000000000000000000000000000000000000000;;		conn.CloseWrite()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Reading data from the local port")
0000000000000000000000000000000000000000;;		fromServer, err := ioutil.ReadAll(conn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Unexpected error reading data from the server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := strings.Repeat("x", 100), string(fromServer); e != a {
0000000000000000000000000000000000000000;;			framework.Failf("Expected %q from server, got %q", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for the target pod to stop running")
0000000000000000000000000000000000000000;;		if err := WaitForTerminatedContainer(f, pod, "portforwardtester"); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Container did not terminate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying logs")
0000000000000000000000000000000000000000;;		logOutput, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, "portforwardtester")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error retrieving pod logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "^Accepted client connection$")
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "^Received expected client data$")
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "^Done$")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doTestOverWebSockets(bindAddress string, f *framework.Framework) {
0000000000000000000000000000000000000000;;		config, err := framework.LoadConfig()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "unable to get base config")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating the pod")
0000000000000000000000000000000000000000;;		pod := pfPod("def", "10", "10", "100", fmt.Sprintf("%s", bindAddress))
0000000000000000000000000000000000000000;;		if _, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Couldn't create pod: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := f.WaitForPodReady(pod.Name); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Pod did not start running: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			logs, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, "portforwardtester")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Error getting pod log: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Logf("Pod log:\n%s", logs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := f.ClientSet.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;			Namespace(f.Namespace.Name).
0000000000000000000000000000000000000000;;			Resource("pods").
0000000000000000000000000000000000000000;;			Name(pod.Name).
0000000000000000000000000000000000000000;;			Suffix("portforward").
0000000000000000000000000000000000000000;;			Param("ports", "80")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := req.URL()
0000000000000000000000000000000000000000;;		ws, err := framework.OpenWebSocketForURL(url, config, []string{"v4.channel.k8s.io"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to open websocket to %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Eventually(func() error {
0000000000000000000000000000000000000000;;			channel, msg, err := wsRead(ws)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to read completely from websocket %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if channel != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Got message from server that didn't start with channel 0 (data): %v", msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p := binary.LittleEndian.Uint16(msg); p != 80 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Received the wrong port: %d", p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, time.Minute, 10*time.Second).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Eventually(func() error {
0000000000000000000000000000000000000000;;			channel, msg, err := wsRead(ws)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to read completely from websocket %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if channel != 1 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Got message from server that didn't start with channel 1 (error): %v", msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p := binary.LittleEndian.Uint16(msg); p != 80 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Received the wrong port: %d", p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, time.Minute, 10*time.Second).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Sending the expected data to the local port")
0000000000000000000000000000000000000000;;		err = wsWrite(ws, 0, []byte("def"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to write to websocket %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Reading data from the local port")
0000000000000000000000000000000000000000;;		buf := bytes.Buffer{}
0000000000000000000000000000000000000000;;		expectedData := bytes.Repeat([]byte("x"), 100)
0000000000000000000000000000000000000000;;		Eventually(func() error {
0000000000000000000000000000000000000000;;			channel, msg, err := wsRead(ws)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to read completely from websocket %s: %v", url.String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if channel != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Got message from server that didn't start with channel 0 (data): %v", msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.Write(msg)
0000000000000000000000000000000000000000;;			if bytes.Equal(expectedData, buf.Bytes()) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Expected %q from server, got %q", expectedData, buf.Bytes())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, time.Minute, 10*time.Second).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying logs")
0000000000000000000000000000000000000000;;		logOutput, err := framework.GetPodLogs(f.ClientSet, f.Namespace.Name, pod.Name, "portforwardtester")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error retrieving pod logs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "^Accepted client connection$")
0000000000000000000000000000000000000000;;		verifyLogMessage(logOutput, "^Received expected client data$")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Kubectl Port forwarding", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("port-forwarding")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("With a server listening on 0.0.0.0", func() {
0000000000000000000000000000000000000000;;			framework.KubeDescribe("that expects a client request", func() {
0000000000000000000000000000000000000000;;				It("should support a client that connects, sends NO DATA, and disconnects", func() {
0000000000000000000000000000000000000000;;					doTestMustConnectSendNothing("0.0.0.0", f)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				It("should support a client that connects, sends DATA, and disconnects", func() {
0000000000000000000000000000000000000000;;					doTestMustConnectSendDisconnect("0.0.0.0", f)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.KubeDescribe("that expects NO client request", func() {
0000000000000000000000000000000000000000;;				It("should support a client that connects, sends DATA, and disconnects", func() {
0000000000000000000000000000000000000000;;					doTestConnectSendDisconnect("0.0.0.0", f)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should support forwarding over websockets", func() {
0000000000000000000000000000000000000000;;				doTestOverWebSockets("0.0.0.0", f)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// kubectl port-forward may need elevated privileges to do its job.
0000000000000000000000000000000000000000;;		framework.KubeDescribe("With a server listening on localhost", func() {
0000000000000000000000000000000000000000;;			framework.KubeDescribe("that expects a client request", func() {
0000000000000000000000000000000000000000;;				It("should support a client that connects, sends NO DATA, and disconnects", func() {
0000000000000000000000000000000000000000;;					doTestMustConnectSendNothing("localhost", f)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				It("should support a client that connects, sends DATA, and disconnects", func() {
0000000000000000000000000000000000000000;;					doTestMustConnectSendDisconnect("localhost", f)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.KubeDescribe("that expects NO client request", func() {
0000000000000000000000000000000000000000;;				It("should support a client that connects, sends DATA, and disconnects", func() {
0000000000000000000000000000000000000000;;					doTestConnectSendDisconnect("localhost", f)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should support forwarding over websockets", func() {
0000000000000000000000000000000000000000;;				doTestOverWebSockets("localhost", f)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyLogMessage(log, expected string) {
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(expected)
0000000000000000000000000000000000000000;;		lines := strings.Split(log, "\n")
0000000000000000000000000000000000000000;;		for i := range lines {
0000000000000000000000000000000000000000;;			if re.MatchString(lines[i]) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Failf("Missing %q from log: %s", expected, log)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wsRead(conn *websocket.Conn) (byte, []byte, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var data []byte
0000000000000000000000000000000000000000;;			err := websocket.Message.Receive(conn, &data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(data) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			channel := data[0]
0000000000000000000000000000000000000000;;			data = data[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return channel, data, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wsWrite(conn *websocket.Conn, channel byte, data []byte) error {
0000000000000000000000000000000000000000;;		frame := make([]byte, len(data)+1)
0000000000000000000000000000000000000000;;		frame[0] = channel
0000000000000000000000000000000000000000;;		copy(frame[1:], data)
0000000000000000000000000000000000000000;;		err := websocket.Message.Send(conn, frame)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
