0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
038d96e3b9eb66ed209392678c4e27466afb586b;test/e2e/proxy.go[test/e2e/proxy.go][test/e2e/kubectl/proxy.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OWNER = sig/cli
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Try all the proxy tests this many times (to catch even rare flakes).
0000000000000000000000000000000000000000;;		proxyAttempts = 20
0000000000000000000000000000000000000000;;		// Only print this many characters of the response (to keep the logs
0000000000000000000000000000000000000000;;		// legible).
0000000000000000000000000000000000000000;;		maxDisplayBodyLen = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have seen one of these calls take just over 15 seconds, so putting this at 30.
0000000000000000000000000000000000000000;;		proxyHTTPCallTimeout = 30 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Kubectl Proxy", func() {
0000000000000000000000000000000000000000;;		version := api.Registry.GroupOrDie(v1.GroupName).GroupVersion.Version
0000000000000000000000000000000000000000;;		Context("version "+version, func() {
0000000000000000000000000000000000000000;;			options := framework.FrameworkOptions{
0000000000000000000000000000000000000000;;				ClientQPS: -1.0,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f := framework.NewFramework("proxy", options, nil)
0000000000000000000000000000000000000000;;			prefix := "/api/" + version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Port here has to be kept in sync with default kubelet port.
0000000000000000000000000000000000000000;;			It("should proxy logs on node with explicit kubelet port [Conformance]", func() { nodeProxyTest(f, prefix+"/proxy/nodes/", ":10250/logs/") })
0000000000000000000000000000000000000000;;			It("should proxy logs on node [Conformance]", func() { nodeProxyTest(f, prefix+"/proxy/nodes/", "/logs/") })
0000000000000000000000000000000000000000;;			It("should proxy to cadvisor", func() { nodeProxyTest(f, prefix+"/proxy/nodes/", ":4194/containers/") })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should proxy logs on node with explicit kubelet port using proxy subresource [Conformance]", func() { nodeProxyTest(f, prefix+"/nodes/", ":10250/proxy/logs/") })
0000000000000000000000000000000000000000;;			It("should proxy logs on node using proxy subresource [Conformance]", func() { nodeProxyTest(f, prefix+"/nodes/", "/proxy/logs/") })
0000000000000000000000000000000000000000;;			It("should proxy to cadvisor using proxy subresource", func() { nodeProxyTest(f, prefix+"/nodes/", ":4194/proxy/containers/") })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// using the porter image to serve content, access the content
0000000000000000000000000000000000000000;;			// (of multiple pods?) from multiple (endpoints/services?)
0000000000000000000000000000000000000000;;			It("should proxy through a service and a pod [Conformance]", func() {
0000000000000000000000000000000000000000;;				start := time.Now()
0000000000000000000000000000000000000000;;				labels := map[string]string{"proxy-service-target": "true"}
0000000000000000000000000000000000000000;;				service, err := f.ClientSet.Core().Services(f.Namespace.Name).Create(&v1.Service{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						GenerateName: "proxy-service-",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;						Selector: labels,
0000000000000000000000000000000000000000;;						Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "portname1",
0000000000000000000000000000000000000000;;								Port:       80,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromString("dest1"),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "portname2",
0000000000000000000000000000000000000000;;								Port:       81,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(162),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "tlsportname1",
0000000000000000000000000000000000000000;;								Port:       443,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromString("tlsdest1"),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:       "tlsportname2",
0000000000000000000000000000000000000000;;								Port:       444,
0000000000000000000000000000000000000000;;								TargetPort: intstr.FromInt(462),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Make an RC with a single pod. The 'porter' image is
0000000000000000000000000000000000000000;;				// a simple server which serves the values of the
0000000000000000000000000000000000000000;;				// environmental variables below.
0000000000000000000000000000000000000000;;				By("starting an echo server on multiple ports")
0000000000000000000000000000000000000000;;				pods := []*v1.Pod{}
0000000000000000000000000000000000000000;;				cfg := testutils.RCConfig{
0000000000000000000000000000000000000000;;					Client:         f.ClientSet,
0000000000000000000000000000000000000000;;					InternalClient: f.InternalClientset,
0000000000000000000000000000000000000000;;					Image:          "gcr.io/google_containers/porter:4524579c0eb935c056c8e75563b4e1eda31587e0",
0000000000000000000000000000000000000000;;					Name:           service.Name,
0000000000000000000000000000000000000000;;					Namespace:      f.Namespace.Name,
0000000000000000000000000000000000000000;;					Replicas:       1,
0000000000000000000000000000000000000000;;					PollInterval:   time.Second,
0000000000000000000000000000000000000000;;					Env: map[string]string{
0000000000000000000000000000000000000000;;						"SERVE_PORT_80":   `<a href="/rewriteme">test</a>`,
0000000000000000000000000000000000000000;;						"SERVE_PORT_1080": `<a href="/rewriteme">test</a>`,
0000000000000000000000000000000000000000;;						"SERVE_PORT_160":  "foo",
0000000000000000000000000000000000000000;;						"SERVE_PORT_162":  "bar",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						"SERVE_TLS_PORT_443": `<a href="/tlsrewriteme">test</a>`,
0000000000000000000000000000000000000000;;						"SERVE_TLS_PORT_460": `tls baz`,
0000000000000000000000000000000000000000;;						"SERVE_TLS_PORT_462": `tls qux`,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ports: map[string]int{
0000000000000000000000000000000000000000;;						"dest1": 160,
0000000000000000000000000000000000000000;;						"dest2": 162,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						"tlsdest1": 460,
0000000000000000000000000000000000000000;;						"tlsdest2": 462,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ReadinessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;						Handler: v1.Handler{
0000000000000000000000000000000000000000;;							HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;								Port: intstr.FromInt(80),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						InitialDelaySeconds: 1,
0000000000000000000000000000000000000000;;						TimeoutSeconds:      5,
0000000000000000000000000000000000000000;;						PeriodSeconds:       10,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Labels:      labels,
0000000000000000000000000000000000000000;;					CreatedPods: &pods,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				Expect(framework.RunRC(cfg)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				defer framework.DeleteRCAndPods(f.ClientSet, f.InternalClientset, f.Namespace.Name, cfg.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Expect(framework.WaitForEndpoint(f.ClientSet, f.Namespace.Name, service.Name)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// table constructors
0000000000000000000000000000000000000000;;				// Try proxying through the service and directly to through the pod.
0000000000000000000000000000000000000000;;				svcProxyURL := func(scheme, port string) string {
0000000000000000000000000000000000000000;;					return prefix + "/proxy/namespaces/" + f.Namespace.Name + "/services/" + net.JoinSchemeNamePort(scheme, service.Name, port)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subresourceServiceProxyURL := func(scheme, port string) string {
0000000000000000000000000000000000000000;;					return prefix + "/namespaces/" + f.Namespace.Name + "/services/" + net.JoinSchemeNamePort(scheme, service.Name, port) + "/proxy"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podProxyURL := func(scheme, port string) string {
0000000000000000000000000000000000000000;;					return prefix + "/proxy/namespaces/" + f.Namespace.Name + "/pods/" + net.JoinSchemeNamePort(scheme, pods[0].Name, port)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subresourcePodProxyURL := func(scheme, port string) string {
0000000000000000000000000000000000000000;;					return prefix + "/namespaces/" + f.Namespace.Name + "/pods/" + net.JoinSchemeNamePort(scheme, pods[0].Name, port) + "/proxy"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// construct the table
0000000000000000000000000000000000000000;;				expectations := map[string]string{
0000000000000000000000000000000000000000;;					svcProxyURL("", "portname1") + "/": "foo",
0000000000000000000000000000000000000000;;					svcProxyURL("", "80") + "/":        "foo",
0000000000000000000000000000000000000000;;					svcProxyURL("", "portname2") + "/": "bar",
0000000000000000000000000000000000000000;;					svcProxyURL("", "81") + "/":        "bar",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					svcProxyURL("http", "portname1") + "/": "foo",
0000000000000000000000000000000000000000;;					svcProxyURL("http", "80") + "/":        "foo",
0000000000000000000000000000000000000000;;					svcProxyURL("http", "portname2") + "/": "bar",
0000000000000000000000000000000000000000;;					svcProxyURL("http", "81") + "/":        "bar",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					svcProxyURL("https", "tlsportname1") + "/": "tls baz",
0000000000000000000000000000000000000000;;					svcProxyURL("https", "443") + "/":          "tls baz",
0000000000000000000000000000000000000000;;					svcProxyURL("https", "tlsportname2") + "/": "tls qux",
0000000000000000000000000000000000000000;;					svcProxyURL("https", "444") + "/":          "tls qux",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					subresourceServiceProxyURL("", "portname1") + "/":         "foo",
0000000000000000000000000000000000000000;;					subresourceServiceProxyURL("http", "portname1") + "/":     "foo",
0000000000000000000000000000000000000000;;					subresourceServiceProxyURL("", "portname2") + "/":         "bar",
0000000000000000000000000000000000000000;;					subresourceServiceProxyURL("http", "portname2") + "/":     "bar",
0000000000000000000000000000000000000000;;					subresourceServiceProxyURL("https", "tlsportname1") + "/": "tls baz",
0000000000000000000000000000000000000000;;					subresourceServiceProxyURL("https", "tlsportname2") + "/": "tls qux",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					podProxyURL("", "1080") + "/": `<a href="` + podProxyURL("", "1080") + `/rewriteme">test</a>`,
0000000000000000000000000000000000000000;;					podProxyURL("", "160") + "/":  "foo",
0000000000000000000000000000000000000000;;					podProxyURL("", "162") + "/":  "bar",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					podProxyURL("http", "1080") + "/": `<a href="` + podProxyURL("http", "1080") + `/rewriteme">test</a>`,
0000000000000000000000000000000000000000;;					podProxyURL("http", "160") + "/":  "foo",
0000000000000000000000000000000000000000;;					podProxyURL("http", "162") + "/":  "bar",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("", "") + "/":         `<a href="` + subresourcePodProxyURL("", "") + `/rewriteme">test</a>`,
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("", "1080") + "/":     `<a href="` + subresourcePodProxyURL("", "1080") + `/rewriteme">test</a>`,
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("http", "1080") + "/": `<a href="` + subresourcePodProxyURL("http", "1080") + `/rewriteme">test</a>`,
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("", "160") + "/":      "foo",
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("http", "160") + "/":  "foo",
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("", "162") + "/":      "bar",
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("http", "162") + "/":  "bar",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("https", "443") + "/": `<a href="` + subresourcePodProxyURL("https", "443") + `/tlsrewriteme">test</a>`,
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("https", "460") + "/": "tls baz",
0000000000000000000000000000000000000000;;					subresourcePodProxyURL("https", "462") + "/": "tls qux",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// TODO: below entries don't work, but I believe we should make them work.
0000000000000000000000000000000000000000;;					// podPrefix + ":dest1": "foo",
0000000000000000000000000000000000000000;;					// podPrefix + ":dest2": "bar",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;				errs := []string{}
0000000000000000000000000000000000000000;;				errLock := sync.Mutex{}
0000000000000000000000000000000000000000;;				recordError := func(s string) {
0000000000000000000000000000000000000000;;					errLock.Lock()
0000000000000000000000000000000000000000;;					defer errLock.Unlock()
0000000000000000000000000000000000000000;;					errs = append(errs, s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d := time.Since(start)
0000000000000000000000000000000000000000;;				framework.Logf("setup took %v, starting test cases", d)
0000000000000000000000000000000000000000;;				numberTestCases := len(expectations)
0000000000000000000000000000000000000000;;				totalAttempts := numberTestCases * proxyAttempts
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("running %v cases, %v attempts per case, %v total attempts", numberTestCases, proxyAttempts, totalAttempts))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := 0; i < proxyAttempts; i++ {
0000000000000000000000000000000000000000;;					wg.Add(numberTestCases)
0000000000000000000000000000000000000000;;					for path, val := range expectations {
0000000000000000000000000000000000000000;;						go func(i int, path, val string) {
0000000000000000000000000000000000000000;;							defer wg.Done()
0000000000000000000000000000000000000000;;							// this runs the test case
0000000000000000000000000000000000000000;;							body, status, d, err := doProxy(f, path, i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								if serr, ok := err.(*errors.StatusError); ok {
0000000000000000000000000000000000000000;;									recordError(fmt.Sprintf("%v (%v; %v): path %v gave status error: %+v",
0000000000000000000000000000000000000000;;										i, status, d, path, serr.Status()))
0000000000000000000000000000000000000000;;								} else {
0000000000000000000000000000000000000000;;									recordError(fmt.Sprintf("%v: path %v gave error: %v", i, path, err))
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								return
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if status != http.StatusOK {
0000000000000000000000000000000000000000;;								recordError(fmt.Sprintf("%v: path %v gave status: %v", i, path, status))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if e, a := val, string(body); e != a {
0000000000000000000000000000000000000000;;								recordError(fmt.Sprintf("%v: path %v: wanted %v, got %v", i, path, e, a))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if d > proxyHTTPCallTimeout {
0000000000000000000000000000000000000000;;								recordError(fmt.Sprintf("%v: path %v took %v > %v", i, path, d, proxyHTTPCallTimeout))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}(i, path, val)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					wg.Wait()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(errs) != 0 {
0000000000000000000000000000000000000000;;					body, err := f.ClientSet.Core().Pods(f.Namespace.Name).GetLogs(pods[0].Name, &v1.PodLogOptions{}).Do().Raw()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						framework.Logf("Error getting logs for pod %s: %v", pods[0].Name, err)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						framework.Logf("Pod %s has the following error logs: %s", pods[0].Name, body)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					framework.Failf(strings.Join(errs, "\n"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doProxy(f *framework.Framework, path string, i int) (body []byte, statusCode int, d time.Duration, err error) {
0000000000000000000000000000000000000000;;		// About all of the proxy accesses in this file:
0000000000000000000000000000000000000000;;		// * AbsPath is used because it preserves the trailing '/'.
0000000000000000000000000000000000000000;;		// * Do().Raw() is used (instead of DoRaw()) because it will turn an
0000000000000000000000000000000000000000;;		//   error from apiserver proxy into an actual error, and there is no
0000000000000000000000000000000000000000;;		//   chance of the things we are talking to being confused for an error
0000000000000000000000000000000000000000;;		//   that apiserver would have emitted.
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		body, err = f.ClientSet.Core().RESTClient().Get().AbsPath(path).Do().StatusCode(&statusCode).Raw()
0000000000000000000000000000000000000000;;		d = time.Since(start)
0000000000000000000000000000000000000000;;		if len(body) > 0 {
0000000000000000000000000000000000000000;;			framework.Logf("(%v) %v: %s (%v; %v)", i, path, truncate(body, maxDisplayBodyLen), statusCode, d)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			framework.Logf("%v: %s (%v; %v)", path, "no body", statusCode, d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func truncate(b []byte, maxLen int) []byte {
0000000000000000000000000000000000000000;;		if len(b) <= maxLen-3 {
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b2 := append([]byte(nil), b[:maxLen-3]...)
0000000000000000000000000000000000000000;;		b2 = append(b2, '.', '.', '.')
0000000000000000000000000000000000000000;;		return b2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pickNode(cs clientset.Interface) (string, error) {
0000000000000000000000000000000000000000;;		// TODO: investigate why it doesn't work on master Node.
0000000000000000000000000000000000000000;;		nodes := framework.GetReadySchedulableNodesOrDie(cs)
0000000000000000000000000000000000000000;;		if len(nodes.Items) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no nodes exist, can't test node proxy")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes.Items[0].Name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodeProxyTest(f *framework.Framework, prefix, nodeDest string) {
0000000000000000000000000000000000000000;;		node, err := pickNode(f.ClientSet)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		// TODO: Change it to test whether all requests succeeded when requests
0000000000000000000000000000000000000000;;		// not reaching Kubelet issue is debugged.
0000000000000000000000000000000000000000;;		serviceUnavailableErrors := 0
0000000000000000000000000000000000000000;;		for i := 0; i < proxyAttempts; i++ {
0000000000000000000000000000000000000000;;			_, status, d, err := doProxy(f, prefix+node+nodeDest, i)
0000000000000000000000000000000000000000;;			if status == http.StatusServiceUnavailable {
0000000000000000000000000000000000000000;;				framework.Logf("Failed proxying node logs due to service unavailable: %v", err)
0000000000000000000000000000000000000000;;				time.Sleep(time.Second)
0000000000000000000000000000000000000000;;				serviceUnavailableErrors++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				Expect(status).To(Equal(http.StatusOK))
0000000000000000000000000000000000000000;;				Expect(d).To(BeNumerically("<", proxyHTTPCallTimeout))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if serviceUnavailableErrors > 0 {
0000000000000000000000000000000000000000;;			framework.Logf("error: %d requests to proxy node logs failed", serviceUnavailableErrors)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		maxFailures := int(math.Floor(0.1 * float64(proxyAttempts)))
0000000000000000000000000000000000000000;;		Expect(serviceUnavailableErrors).To(BeNumerically("<", maxFailures))
0000000000000000000000000000000000000000;;	}
