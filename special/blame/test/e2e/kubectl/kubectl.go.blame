0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8b969614f730f40b9a3a0da56eb476bf74911969;test/e2e/kubectl.go[test/e2e/kubectl.go][test/e2e/kubectl/kubectl.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OWNER = sig/cli
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubectl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"mime/multipart"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/elazarl/goproxy"
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		rbacv1beta1 "k8s.io/api/rbac/v1beta1"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		genericregistry "k8s.io/apiserver/pkg/registry/generic/registry"
0000000000000000000000000000000000000000;;		batchv2alpha1 "k8s.io/kubernetes/pkg/apis/batch/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		uexec "k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		utilversion "k8s.io/kubernetes/pkg/util/version"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/generated"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/scheduling"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		nautilusImage            = "gcr.io/google_containers/update-demo:nautilus"
0000000000000000000000000000000000000000;;		kittenImage              = "gcr.io/google_containers/update-demo:kitten"
0000000000000000000000000000000000000000;;		updateDemoSelector       = "name=update-demo"
0000000000000000000000000000000000000000;;		updateDemoContainer      = "update-demo"
0000000000000000000000000000000000000000;;		frontendSelector         = "app=guestbook,tier=frontend"
0000000000000000000000000000000000000000;;		redisMasterSelector      = "app=redis,role=master"
0000000000000000000000000000000000000000;;		redisSlaveSelector       = "app=redis,role=slave"
0000000000000000000000000000000000000000;;		goproxyContainer         = "goproxy"
0000000000000000000000000000000000000000;;		goproxyPodSelector       = "name=goproxy"
0000000000000000000000000000000000000000;;		netexecContainer         = "netexec"
0000000000000000000000000000000000000000;;		netexecPodSelector       = "name=netexec"
0000000000000000000000000000000000000000;;		kubectlProxyPort         = 8011
0000000000000000000000000000000000000000;;		guestbookStartupTimeout  = 10 * time.Minute
0000000000000000000000000000000000000000;;		guestbookResponseTimeout = 3 * time.Minute
0000000000000000000000000000000000000000;;		simplePodSelector        = "name=nginx"
0000000000000000000000000000000000000000;;		simplePodName            = "nginx"
0000000000000000000000000000000000000000;;		nginxDefaultOutput       = "Welcome to nginx!"
0000000000000000000000000000000000000000;;		simplePodPort            = 80
0000000000000000000000000000000000000000;;		pausePodSelector         = "name=pause"
0000000000000000000000000000000000000000;;		pausePodName             = "pause"
0000000000000000000000000000000000000000;;		runJobTimeout            = 5 * time.Minute
0000000000000000000000000000000000000000;;		busyboxImage             = "gcr.io/google_containers/busybox:1.24"
0000000000000000000000000000000000000000;;		nginxImage               = "gcr.io/google_containers/nginx-slim:0.7"
0000000000000000000000000000000000000000;;		newNginxImage            = "gcr.io/google_containers/nginx-slim:0.8"
0000000000000000000000000000000000000000;;		kubeCtlManifestPath      = "test/e2e/testing-manifests/kubectl"
0000000000000000000000000000000000000000;;		redisControllerFilename  = "redis-master-controller.json"
0000000000000000000000000000000000000000;;		redisServiceFilename     = "redis-master-service.json"
0000000000000000000000000000000000000000;;		nginxDeployment1Filename = "nginx-deployment1.yaml"
0000000000000000000000000000000000000000;;		nginxDeployment2Filename = "nginx-deployment2.yaml"
0000000000000000000000000000000000000000;;		nginxDeployment3Filename = "nginx-deployment3.yaml"
0000000000000000000000000000000000000000;;		redisImage               = "gcr.io/k8s-testimages/redis:e2e"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		proxyRegexp = regexp.MustCompile("Starting to serve on 127.0.0.1:([0-9]+)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extended pod logging options were introduced in #13780 (v1.1.0) so we don't expect tests
0000000000000000000000000000000000000000;;		// that rely on extended pod logging options to work on clusters before that.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(ihmccreery): remove once we don't care about v1.0 anymore, (tentatively in v1.3).
0000000000000000000000000000000000000000;;		extendedPodLogFilterVersion = utilversion.MustParseSemantic("v1.1.0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NodePorts were made optional in #12831 (v1.1.0) so we don't expect tests that used to
0000000000000000000000000000000000000000;;		// require NodePorts but no longer include them to work on clusters before that.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(ihmccreery): remove once we don't care about v1.0 anymore, (tentatively in v1.3).
0000000000000000000000000000000000000000;;		nodePortsOptionalVersion = utilversion.MustParseSemantic("v1.1.0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Jobs were introduced in v1.1, so we don't expect tests that rely on jobs to work on
0000000000000000000000000000000000000000;;		// clusters before that.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(ihmccreery): remove once we don't care about v1.0 anymore, (tentatively in v1.3).
0000000000000000000000000000000000000000;;		jobsVersion = utilversion.MustParseSemantic("v1.1.0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deployments were introduced by default in v1.2, so we don't expect tests that rely on
0000000000000000000000000000000000000000;;		// deployments to work on clusters before that.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(ihmccreery): remove once we don't care about v1.1 anymore, (tentatively in v1.4).
0000000000000000000000000000000000000000;;		deploymentsVersion = utilversion.MustParseSemantic("v1.2.0-alpha.7.726")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pod probe parameters were introduced in #15967 (v1.2) so we don't expect tests that use
0000000000000000000000000000000000000000;;		// these probe parameters to work on clusters before that.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(ihmccreery): remove once we don't care about v1.1 anymore, (tentatively in v1.4).
0000000000000000000000000000000000000000;;		podProbeParametersVersion = utilversion.MustParseSemantic("v1.2.0-alpha.4")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 'kubectl create quota' was introduced in #28351 (v1.4) so we don't expect tests that use
0000000000000000000000000000000000000000;;		// 'kubectl create quota' to work on kubectl clients before that.
0000000000000000000000000000000000000000;;		kubectlCreateQuotaVersion = utilversion.MustParseSemantic("v1.4.0-alpha.2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returning container command exit codes in kubectl run/exec was introduced in #26541 (v1.4)
0000000000000000000000000000000000000000;;		// so we don't expect tests that verifies return code to work on kubectl clients before that.
0000000000000000000000000000000000000000;;		kubectlContainerExitCodeVersion = utilversion.MustParseSemantic("v1.4.0-alpha.3")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CronJobGroupVersionResource = schema.GroupVersionResource{Group: batchv2alpha1.GroupName, Version: "v2alpha1", Resource: "cronjobs"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ScheduledJobGroupVersionResource = schema.GroupVersionResource{Group: batchv2alpha1.GroupName, Version: "v2alpha1", Resource: "scheduledjobs"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stops everything from filePath from namespace ns and checks if everything matching selectors from the given namespace is correctly stopped.
0000000000000000000000000000000000000000;;	// Aware of the kubectl example files map.
0000000000000000000000000000000000000000;;	func cleanupKubectlInputs(fileContents string, ns string, selectors ...string) {
0000000000000000000000000000000000000000;;		By("using delete to clean up resources")
0000000000000000000000000000000000000000;;		var nsArg string
0000000000000000000000000000000000000000;;		if ns != "" {
0000000000000000000000000000000000000000;;			nsArg = fmt.Sprintf("--namespace=%s", ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// support backward compatibility : file paths or raw json - since we are removing file path
0000000000000000000000000000000000000000;;		// dependencies from this test.
0000000000000000000000000000000000000000;;		framework.RunKubectlOrDieInput(fileContents, "delete", "--grace-period=0", "--force", "-f", "-", nsArg)
0000000000000000000000000000000000000000;;		framework.AssertCleanup(ns, selectors...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readTestFileOrDie(file string) []byte {
0000000000000000000000000000000000000000;;		return generated.ReadOrDie(path.Join(kubeCtlManifestPath, file))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runKubectlRetryOrDie(args ...string) string {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var output string
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			output, err = framework.RunKubectl(args...)
0000000000000000000000000000000000000000;;			if err == nil || (!strings.Contains(err.Error(), genericregistry.OptimisticLockErrorMsg) && !strings.Contains(err.Error(), "Operation cannot be fulfilled")) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Expect no errors to be present after retries are finished
0000000000000000000000000000000000000000;;		// Copied from framework #ExecOrDie
0000000000000000000000000000000000000000;;		framework.Logf("stdout: %q", output)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return output
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// duplicated setup to avoid polluting "normal" clients with alpha features which confuses the generated clients
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Kubectl alpha client", func() {
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("kubectl")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Customized Wait  / ForEach wrapper for this test.  These demonstrate the
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl run ScheduledJob", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var sjName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				sjName = "e2e-test-echo-scheduledjob"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("delete", "cronjobs", sjName, nsFlag)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create a ScheduledJob", func() {
0000000000000000000000000000000000000000;;				framework.SkipIfMissingResource(f.ClientPool, ScheduledJobGroupVersionResource, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				schedule := "*/5 * * * ?"
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", sjName, "--restart=OnFailure", "--generator=scheduledjob/v2alpha1",
0000000000000000000000000000000000000000;;					"--schedule="+schedule, "--image="+busyboxImage, nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the ScheduledJob " + sjName + " was created")
0000000000000000000000000000000000000000;;				sj, err := c.BatchV2alpha1().CronJobs(ns).Get(sjName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting ScheduledJob %s: %v", sjName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sj.Spec.Schedule != schedule {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating a ScheduledJob with correct schedule %s, but got %s", schedule, sj.Spec.Schedule)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containers := sj.Spec.JobTemplate.Spec.Template.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) != 1 || containers[0].Image != busyboxImage {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating ScheduledJob %s for 1 pod with expected image %s: %#v", sjName, busyboxImage, containers)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				restartPolicy := sj.Spec.JobTemplate.Spec.Template.Spec.RestartPolicy
0000000000000000000000000000000000000000;;				if sj.Spec.JobTemplate.Spec.Template.Spec.RestartPolicy != v1.RestartPolicyOnFailure {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating a ScheduledJob with correct restart policy %s, but got %s", v1.RestartPolicyOnFailure, restartPolicy)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl run CronJob", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var cjName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				cjName = "e2e-test-echo-cronjob"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("delete", "cronjobs", cjName, nsFlag)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create a CronJob", func() {
0000000000000000000000000000000000000000;;				framework.SkipIfMissingResource(f.ClientPool, CronJobGroupVersionResource, f.Namespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				schedule := "*/5 * * * ?"
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", cjName, "--restart=OnFailure", "--generator=cronjob/v2alpha1",
0000000000000000000000000000000000000000;;					"--schedule="+schedule, "--image="+busyboxImage, nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the CronJob " + cjName + " was created")
0000000000000000000000000000000000000000;;				sj, err := c.BatchV2alpha1().CronJobs(ns).Get(cjName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting CronJob %s: %v", cjName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sj.Spec.Schedule != schedule {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating a CronJob with correct schedule %s", schedule)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containers := sj.Spec.JobTemplate.Spec.Template.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) != 1 || containers[0].Image != busyboxImage {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating CronJob %s for 1 pod with expected image %s: %#v", cjName, busyboxImage, containers)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sj.Spec.JobTemplate.Spec.Template.Spec.RestartPolicy != v1.RestartPolicyOnFailure {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating a CronJob with correct restart policy for --restart=OnFailure")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = SIGDescribe("Kubectl client", func() {
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("kubectl")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reustable cluster state function.  This won't be adversly affected by lazy initialization of framework.
0000000000000000000000000000000000000000;;		clusterState := func() *framework.ClusterVerification {
0000000000000000000000000000000000000000;;			return f.NewClusterVerification(
0000000000000000000000000000000000000000;;				f.Namespace,
0000000000000000000000000000000000000000;;				framework.PodStateVerification{
0000000000000000000000000000000000000000;;					Selectors:   map[string]string{"app": "redis"},
0000000000000000000000000000000000000000;;					ValidPhases: []v1.PodPhase{v1.PodRunning /*v1.PodPending*/},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		forEachPod := func(podFunc func(p v1.Pod)) {
0000000000000000000000000000000000000000;;			clusterState().ForEach(podFunc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Customized Wait  / ForEach wrapper for this test.  These demonstrate the
0000000000000000000000000000000000000000;;		// idiomatic way to wrap the ClusterVerification structs for syntactic sugar in large
0000000000000000000000000000000000000000;;		// test files.
0000000000000000000000000000000000000000;;		// Print debug info if atLeast Pods are not found before the timeout
0000000000000000000000000000000000000000;;		waitForOrFailWithDebug := func(atLeast int) {
0000000000000000000000000000000000000000;;			pods, err := clusterState().WaitFor(atLeast, framework.PodStartTimeout)
0000000000000000000000000000000000000000;;			if err != nil || len(pods) < atLeast {
0000000000000000000000000000000000000000;;				// TODO: Generalize integrating debug info into these tests so we always get debug info when we need it
0000000000000000000000000000000000000000;;				framework.DumpAllNamespaceInfo(f.ClientSet, ns)
0000000000000000000000000000000000000000;;				framework.Failf("Verified %v of %v pods , error : %v", len(pods), atLeast, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Update Demo", func() {
0000000000000000000000000000000000000000;;			var nautilus, kitten []byte
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				updateDemoRoot := "test/fixtures/doc-yaml/user-guide/update-demo"
0000000000000000000000000000000000000000;;				nautilus = generated.ReadOrDie(filepath.Join(updateDemoRoot, "nautilus-rc.yaml"))
0000000000000000000000000000000000000000;;				kitten = generated.ReadOrDie(filepath.Join(updateDemoRoot, "kitten-rc.yaml"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			It("should create and stop a replication controller [Conformance]", func() {
0000000000000000000000000000000000000000;;				defer cleanupKubectlInputs(string(nautilus), ns, updateDemoSelector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a replication controller")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(nautilus[:]), "create", "-f", "-", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				framework.ValidateController(c, nautilusImage, 2, "update-demo", updateDemoSelector, getUDData("nautilus.jpg", ns), ns)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should scale a replication controller [Conformance]", func() {
0000000000000000000000000000000000000000;;				defer cleanupKubectlInputs(string(nautilus[:]), ns, updateDemoSelector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating a replication controller")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(nautilus[:]), "create", "-f", "-", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				framework.ValidateController(c, nautilusImage, 2, "update-demo", updateDemoSelector, getUDData("nautilus.jpg", ns), ns)
0000000000000000000000000000000000000000;;				By("scaling down the replication controller")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("scale", "rc", "update-demo-nautilus", "--replicas=1", "--timeout=5m", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				framework.ValidateController(c, nautilusImage, 1, "update-demo", updateDemoSelector, getUDData("nautilus.jpg", ns), ns)
0000000000000000000000000000000000000000;;				By("scaling up the replication controller")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("scale", "rc", "update-demo-nautilus", "--replicas=2", "--timeout=5m", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				framework.ValidateController(c, nautilusImage, 2, "update-demo", updateDemoSelector, getUDData("nautilus.jpg", ns), ns)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should do a rolling update of a replication controller [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("creating the initial replication controller")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(nautilus[:]), "create", "-f", "-", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				framework.ValidateController(c, nautilusImage, 2, "update-demo", updateDemoSelector, getUDData("nautilus.jpg", ns), ns)
0000000000000000000000000000000000000000;;				By("rolling-update to new replication controller")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(kitten[:]), "rolling-update", "update-demo-nautilus", "--update-period=1s", "-f", "-", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				framework.ValidateController(c, kittenImage, 2, "update-demo", updateDemoSelector, getUDData("kitten.jpg", ns), ns)
0000000000000000000000000000000000000000;;				// Everything will hopefully be cleaned up when the namespace is deleted.
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Guestbook application", func() {
0000000000000000000000000000000000000000;;			forEachGBFile := func(run func(s string)) {
0000000000000000000000000000000000000000;;				for _, gbAppFile := range []string{
0000000000000000000000000000000000000000;;					"examples/guestbook/frontend-deployment.yaml",
0000000000000000000000000000000000000000;;					"examples/guestbook/frontend-service.yaml",
0000000000000000000000000000000000000000;;					"examples/guestbook/redis-master-deployment.yaml",
0000000000000000000000000000000000000000;;					"examples/guestbook/redis-master-service.yaml",
0000000000000000000000000000000000000000;;					"examples/guestbook/redis-slave-deployment.yaml",
0000000000000000000000000000000000000000;;					"examples/guestbook/redis-slave-service.yaml",
0000000000000000000000000000000000000000;;				} {
0000000000000000000000000000000000000000;;					contents := generated.ReadOrDie(gbAppFile)
0000000000000000000000000000000000000000;;					run(string(contents))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create and stop a working application [Conformance]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(deploymentsVersion, c.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer forEachGBFile(func(contents string) {
0000000000000000000000000000000000000000;;					cleanupKubectlInputs(contents, ns)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				By("creating all guestbook components")
0000000000000000000000000000000000000000;;				forEachGBFile(func(contents string) {
0000000000000000000000000000000000000000;;					framework.Logf(contents)
0000000000000000000000000000000000000000;;					framework.RunKubectlOrDieInput(contents, "create", "-f", "-", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("validating guestbook app")
0000000000000000000000000000000000000000;;				validateGuestbookApp(c, ns)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Simple pod", func() {
0000000000000000000000000000000000000000;;			var podPath []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				podPath = generated.ReadOrDie(path.Join(kubeCtlManifestPath, "pod-with-readiness-probe.yaml"))
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("creating the pod from %v", string(podPath)))
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(podPath[:]), "create", "-f", "-", fmt.Sprintf("--namespace=%v", ns))
0000000000000000000000000000000000000000;;				Expect(framework.CheckPodsRunningReady(c, ns, []string{simplePodName}, framework.PodStartTimeout)).To(BeTrue())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				cleanupKubectlInputs(string(podPath[:]), ns, simplePodSelector)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should support exec", func() {
0000000000000000000000000000000000000000;;				By("executing a command in the container")
0000000000000000000000000000000000000000;;				execOutput := framework.RunKubectlOrDie("exec", fmt.Sprintf("--namespace=%v", ns), simplePodName, "echo", "running", "in", "container")
0000000000000000000000000000000000000000;;				if e, a := "running in container", strings.TrimSpace(execOutput); e != a {
0000000000000000000000000000000000000000;;					framework.Failf("Unexpected kubectl exec output. Wanted %q, got %q", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("executing a very long command in the container")
0000000000000000000000000000000000000000;;				veryLongData := make([]rune, 20000)
0000000000000000000000000000000000000000;;				for i := 0; i < len(veryLongData); i++ {
0000000000000000000000000000000000000000;;					veryLongData[i] = 'a'
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				execOutput = framework.RunKubectlOrDie("exec", fmt.Sprintf("--namespace=%v", ns), simplePodName, "echo", string(veryLongData))
0000000000000000000000000000000000000000;;				Expect(string(veryLongData)).To(Equal(strings.TrimSpace(execOutput)), "Unexpected kubectl exec output")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("executing a command in the container with noninteractive stdin")
0000000000000000000000000000000000000000;;				execOutput = framework.NewKubectlCommand("exec", fmt.Sprintf("--namespace=%v", ns), "-i", simplePodName, "cat").
0000000000000000000000000000000000000000;;					WithStdinData("abcd1234").
0000000000000000000000000000000000000000;;					ExecOrDie()
0000000000000000000000000000000000000000;;				if e, a := "abcd1234", execOutput; e != a {
0000000000000000000000000000000000000000;;					framework.Failf("Unexpected kubectl exec output. Wanted %q, got %q", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// pretend that we're a user in an interactive shell
0000000000000000000000000000000000000000;;				r, closer, err := newBlockingReader("echo hi\nexit\n")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Error creating blocking reader: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// NOTE this is solely for test cleanup!
0000000000000000000000000000000000000000;;				defer closer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("executing a command in the container with pseudo-interactive stdin")
0000000000000000000000000000000000000000;;				execOutput = framework.NewKubectlCommand("exec", fmt.Sprintf("--namespace=%v", ns), "-i", simplePodName, "bash").
0000000000000000000000000000000000000000;;					WithStdinReader(r).
0000000000000000000000000000000000000000;;					ExecOrDie()
0000000000000000000000000000000000000000;;				if e, a := "hi", strings.TrimSpace(execOutput); e != a {
0000000000000000000000000000000000000000;;					framework.Failf("Unexpected kubectl exec output. Wanted %q, got %q", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should support exec through an HTTP proxy", func() {
0000000000000000000000000000000000000000;;				// Note: We are skipping local since we want to verify an apiserver with HTTPS.
0000000000000000000000000000000000000000;;				// At this time local only supports plain HTTP.
0000000000000000000000000000000000000000;;				framework.SkipIfProviderIs("local")
0000000000000000000000000000000000000000;;				// Fail if the variable isn't set
0000000000000000000000000000000000000000;;				if framework.TestContext.Host == "" {
0000000000000000000000000000000000000000;;					framework.Failf("--host variable must be set to the full URI to the api server on e2e run.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Starting goproxy")
0000000000000000000000000000000000000000;;				testSrv, proxyLogs := startLocalProxy()
0000000000000000000000000000000000000000;;				defer testSrv.Close()
0000000000000000000000000000000000000000;;				proxyAddr := testSrv.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, proxyVar := range []string{"https_proxy", "HTTPS_PROXY"} {
0000000000000000000000000000000000000000;;					proxyLogs.Reset()
0000000000000000000000000000000000000000;;					By("Running kubectl via an HTTP proxy using " + proxyVar)
0000000000000000000000000000000000000000;;					output := framework.NewKubectlCommand(fmt.Sprintf("--namespace=%s", ns), "exec", "nginx", "echo", "running", "in", "container").
0000000000000000000000000000000000000000;;						WithEnv(append(os.Environ(), fmt.Sprintf("%s=%s", proxyVar, proxyAddr))).
0000000000000000000000000000000000000000;;						ExecOrDie()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Verify we got the normal output captured by the exec server
0000000000000000000000000000000000000000;;					expectedExecOutput := "running in container\n"
0000000000000000000000000000000000000000;;					if output != expectedExecOutput {
0000000000000000000000000000000000000000;;						framework.Failf("Unexpected kubectl exec output. Wanted %q, got  %q", expectedExecOutput, output)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Verify the proxy server logs saw the connection
0000000000000000000000000000000000000000;;					expectedProxyLog := fmt.Sprintf("Accepting CONNECT to %s", strings.TrimRight(strings.TrimLeft(framework.TestContext.Host, "https://"), "/api"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					proxyLog := proxyLogs.String()
0000000000000000000000000000000000000000;;					if !strings.Contains(proxyLog, expectedProxyLog) {
0000000000000000000000000000000000000000;;						framework.Failf("Missing expected log result on proxy server for %s. Expected: %q, got %q", proxyVar, expectedProxyLog, proxyLog)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should return command exit codes", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessKubectlVersionGTE(kubectlContainerExitCodeVersion)
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("execing into a container with a successful command")
0000000000000000000000000000000000000000;;				_, err := framework.NewKubectlCommand(nsFlag, "exec", "nginx", "--", "/bin/sh", "-c", "exit 0").Exec()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("execing into a container with a failing command")
0000000000000000000000000000000000000000;;				_, err = framework.NewKubectlCommand(nsFlag, "exec", "nginx", "--", "/bin/sh", "-c", "exit 42").Exec()
0000000000000000000000000000000000000000;;				ee, ok := err.(uexec.ExitError)
0000000000000000000000000000000000000000;;				Expect(ok).To(Equal(true))
0000000000000000000000000000000000000000;;				Expect(ee.ExitStatus()).To(Equal(42))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running a successful command")
0000000000000000000000000000000000000000;;				_, err = framework.NewKubectlCommand(nsFlag, "run", "-i", "--image="+busyboxImage, "--restart=Never", "success", "--", "/bin/sh", "-c", "exit 0").Exec()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running a failing command")
0000000000000000000000000000000000000000;;				_, err = framework.NewKubectlCommand(nsFlag, "run", "-i", "--image="+busyboxImage, "--restart=Never", "failure-1", "--", "/bin/sh", "-c", "exit 42").Exec()
0000000000000000000000000000000000000000;;				ee, ok = err.(uexec.ExitError)
0000000000000000000000000000000000000000;;				Expect(ok).To(Equal(true))
0000000000000000000000000000000000000000;;				Expect(ee.ExitStatus()).To(Equal(42))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running a failing command without --restart=Never")
0000000000000000000000000000000000000000;;				_, err = framework.NewKubectlCommand(nsFlag, "run", "-i", "--image="+busyboxImage, "--restart=OnFailure", "failure-2", "--", "/bin/sh", "-c", "cat && exit 42").
0000000000000000000000000000000000000000;;					WithStdinData("abcd1234").
0000000000000000000000000000000000000000;;					Exec()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running a failing command without --restart=Never, but with --rm")
0000000000000000000000000000000000000000;;				_, err = framework.NewKubectlCommand(nsFlag, "run", "-i", "--image="+busyboxImage, "--restart=OnFailure", "--rm", "failure-3", "--", "/bin/sh", "-c", "cat && exit 42").
0000000000000000000000000000000000000000;;					WithStdinData("abcd1234").
0000000000000000000000000000000000000000;;					Exec()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				framework.WaitForPodToDisappear(f.ClientSet, ns, "failure-3", labels.Everything(), 2*time.Second, wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running a failing command with --leave-stdin-open")
0000000000000000000000000000000000000000;;				_, err = framework.NewKubectlCommand(nsFlag, "run", "-i", "--image="+busyboxImage, "--restart=Never", "failure-4", "--leave-stdin-open", "--", "/bin/sh", "-c", "exit 42").
0000000000000000000000000000000000000000;;					WithStdinData("abcd1234").
0000000000000000000000000000000000000000;;					Exec()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should support inline execution and attach", func() {
0000000000000000000000000000000000000000;;				framework.SkipIfContainerRuntimeIs("rkt") // #23335
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(jobsVersion, c.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("executing a command with run and attach with stdin")
0000000000000000000000000000000000000000;;				runOutput := framework.NewKubectlCommand(nsFlag, "run", "run-test", "--image="+busyboxImage, "--restart=OnFailure", "--attach=true", "--stdin", "--", "sh", "-c", "cat && echo 'stdin closed'").
0000000000000000000000000000000000000000;;					WithStdinData("abcd1234").
0000000000000000000000000000000000000000;;					ExecOrDie()
0000000000000000000000000000000000000000;;				Expect(runOutput).To(ContainSubstring("abcd1234"))
0000000000000000000000000000000000000000;;				Expect(runOutput).To(ContainSubstring("stdin closed"))
0000000000000000000000000000000000000000;;				Expect(c.Batch().Jobs(ns).Delete("run-test", nil)).To(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("executing a command with run and attach without stdin")
0000000000000000000000000000000000000000;;				runOutput = framework.NewKubectlCommand(fmt.Sprintf("--namespace=%v", ns), "run", "run-test-2", "--image="+busyboxImage, "--restart=OnFailure", "--attach=true", "--leave-stdin-open=true", "--", "sh", "-c", "cat && echo 'stdin closed'").
0000000000000000000000000000000000000000;;					WithStdinData("abcd1234").
0000000000000000000000000000000000000000;;					ExecOrDie()
0000000000000000000000000000000000000000;;				Expect(runOutput).ToNot(ContainSubstring("abcd1234"))
0000000000000000000000000000000000000000;;				Expect(runOutput).To(ContainSubstring("stdin closed"))
0000000000000000000000000000000000000000;;				Expect(c.Batch().Jobs(ns).Delete("run-test-2", nil)).To(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("executing a command with run and attach with stdin with open stdin should remain running")
0000000000000000000000000000000000000000;;				runOutput = framework.NewKubectlCommand(nsFlag, "run", "run-test-3", "--image="+busyboxImage, "--restart=OnFailure", "--attach=true", "--leave-stdin-open=true", "--stdin", "--", "sh", "-c", "cat && echo 'stdin closed'").
0000000000000000000000000000000000000000;;					WithStdinData("abcd1234\n").
0000000000000000000000000000000000000000;;					ExecOrDie()
0000000000000000000000000000000000000000;;				Expect(runOutput).ToNot(ContainSubstring("stdin closed"))
0000000000000000000000000000000000000000;;				g := func(pods []*v1.Pod) sort.Interface { return sort.Reverse(controller.ActivePods(pods)) }
0000000000000000000000000000000000000000;;				runTestPod, _, err := util.GetFirstPod(f.InternalClientset.Core(), ns, labels.SelectorFromSet(map[string]string{"run": "run-test-3"}), 1*time.Minute, g)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					os.Exit(1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !framework.CheckPodsRunningReady(c, ns, []string{runTestPod.Name}, time.Minute) {
0000000000000000000000000000000000000000;;					framework.Failf("Pod %q of Job %q should still be running", runTestPod.Name, "run-test-3")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// NOTE: we cannot guarantee our output showed up in the container logs before stdin was closed, so we have
0000000000000000000000000000000000000000;;				// to loop test.
0000000000000000000000000000000000000000;;				err = wait.PollImmediate(time.Second, time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;					if !framework.CheckPodsRunningReady(c, ns, []string{runTestPod.Name}, 1*time.Second) {
0000000000000000000000000000000000000000;;						framework.Failf("Pod %q of Job %q should still be running", runTestPod.Name, "run-test-3")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					logOutput := framework.RunKubectlOrDie(nsFlag, "logs", runTestPod.Name)
0000000000000000000000000000000000000000;;					Expect(logOutput).ToNot(ContainSubstring("stdin closed"))
0000000000000000000000000000000000000000;;					return strings.Contains(logOutput, "abcd1234"), nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					os.Exit(1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Expect(c.Batch().Jobs(ns).Delete("run-test-3", nil)).To(BeNil())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should support port-forward", func() {
0000000000000000000000000000000000000000;;				By("forwarding the container port to a local port")
0000000000000000000000000000000000000000;;				cmd := runPortForward(ns, simplePodName, simplePodPort)
0000000000000000000000000000000000000000;;				defer cmd.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("curling local port output")
0000000000000000000000000000000000000000;;				localAddr := fmt.Sprintf("http://localhost:%d", cmd.port)
0000000000000000000000000000000000000000;;				body, err := curl(localAddr)
0000000000000000000000000000000000000000;;				framework.Logf("got: %s", body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed http.Get of forwarded port (%s): %v", localAddr, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !strings.Contains(body, nginxDefaultOutput) {
0000000000000000000000000000000000000000;;					framework.Failf("Container port output missing expected value. Wanted:'%s', got: %s", nginxDefaultOutput, body)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should handle in-cluster config", func() {
0000000000000000000000000000000000000000;;				By("adding rbac permissions")
0000000000000000000000000000000000000000;;				// grant the view permission widely to allow inspection of the `invalid` namespace and the default namespace
0000000000000000000000000000000000000000;;				framework.BindClusterRole(f.ClientSet.Rbac(), "view", f.Namespace.Name,
0000000000000000000000000000000000000000;;					rbacv1beta1.Subject{Kind: rbacv1beta1.ServiceAccountKind, Namespace: f.Namespace.Name, Name: "default"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err := framework.WaitForAuthorizationUpdate(f.ClientSet.AuthorizationV1beta1(),
0000000000000000000000000000000000000000;;					serviceaccount.MakeUsername(f.Namespace.Name, "default"),
0000000000000000000000000000000000000000;;					f.Namespace.Name, "list", schema.GroupResource{Resource: "pods"}, true)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("overriding icc with values provided by flags")
0000000000000000000000000000000000000000;;				kubectlPath := framework.TestContext.KubectlPath
0000000000000000000000000000000000000000;;				// we need the actual kubectl binary, not the script wrapper
0000000000000000000000000000000000000000;;				kubectlPathNormalizer := exec.Command("which", kubectlPath)
0000000000000000000000000000000000000000;;				if strings.HasSuffix(kubectlPath, "kubectl.sh") {
0000000000000000000000000000000000000000;;					kubectlPathNormalizer = exec.Command(kubectlPath, "path")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				kubectlPathNormalized, err := kubectlPathNormalizer.Output()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				kubectlPath = strings.TrimSpace(string(kubectlPathNormalized))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				inClusterHost := strings.TrimSpace(framework.RunHostCmdOrDie(ns, simplePodName, "printenv KUBERNETES_SERVICE_HOST"))
0000000000000000000000000000000000000000;;				inClusterPort := strings.TrimSpace(framework.RunHostCmdOrDie(ns, simplePodName, "printenv KUBERNETES_SERVICE_PORT"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.Logf("copying %s to the %s pod", kubectlPath, simplePodName)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("cp", kubectlPath, ns+"/"+simplePodName+":/tmp/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Build a kubeconfig file that will make use of the injected ca and token,
0000000000000000000000000000000000000000;;				// but point at the DNS host and the default namespace
0000000000000000000000000000000000000000;;				tmpDir, err := ioutil.TempDir("", "icc-override")
0000000000000000000000000000000000000000;;				overrideKubeconfigName := "icc-override.kubeconfig"
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				defer func() { os.Remove(tmpDir) }()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(ioutil.WriteFile(filepath.Join(tmpDir, overrideKubeconfigName), []byte(`
0000000000000000000000000000000000000000;;	kind: Config
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    api-version: v1
0000000000000000000000000000000000000000;;	    server: https://kubernetes.default.svc:443
0000000000000000000000000000000000000000;;	    certificate-authority: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
0000000000000000000000000000000000000000;;	  name: kubeconfig-cluster
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- context:
0000000000000000000000000000000000000000;;	    cluster: kubeconfig-cluster
0000000000000000000000000000000000000000;;	    namespace: default
0000000000000000000000000000000000000000;;	    user: kubeconfig-user
0000000000000000000000000000000000000000;;	  name: kubeconfig-context
0000000000000000000000000000000000000000;;	current-context: kubeconfig-context
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: kubeconfig-user
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    tokenFile: /var/run/secrets/kubernetes.io/serviceaccount/token
0000000000000000000000000000000000000000;;	`), os.FileMode(0755)))
0000000000000000000000000000000000000000;;				framework.Logf("copying override kubeconfig to the %s pod", simplePodName)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("cp", filepath.Join(tmpDir, overrideKubeconfigName), ns+"/"+simplePodName+":/tmp/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.ExpectNoError(ioutil.WriteFile(filepath.Join(tmpDir, "invalid-configmap-with-namespace.yaml"), []byte(`
0000000000000000000000000000000000000000;;	kind: ConfigMap
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: "configmap with namespace and invalid name"
0000000000000000000000000000000000000000;;	  namespace: configmap-namespace
0000000000000000000000000000000000000000;;	`), os.FileMode(0755)))
0000000000000000000000000000000000000000;;				framework.ExpectNoError(ioutil.WriteFile(filepath.Join(tmpDir, "invalid-configmap-without-namespace.yaml"), []byte(`
0000000000000000000000000000000000000000;;	kind: ConfigMap
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: "configmap without namespace and invalid name"
0000000000000000000000000000000000000000;;	`), os.FileMode(0755)))
0000000000000000000000000000000000000000;;				framework.Logf("copying configmap manifests to the %s pod", simplePodName)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("cp", filepath.Join(tmpDir, "invalid-configmap-with-namespace.yaml"), ns+"/"+simplePodName+":/tmp/")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("cp", filepath.Join(tmpDir, "invalid-configmap-without-namespace.yaml"), ns+"/"+simplePodName+":/tmp/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("getting pods with in-cluster configs")
0000000000000000000000000000000000000000;;				execOutput := framework.RunHostCmdOrDie(ns, simplePodName, "/tmp/kubectl get pods --v=7 2>&1")
0000000000000000000000000000000000000000;;				Expect(execOutput).To(MatchRegexp("nginx +1/1 +Running"))
0000000000000000000000000000000000000000;;				Expect(execOutput).To(ContainSubstring("Using in-cluster namespace"))
0000000000000000000000000000000000000000;;				Expect(execOutput).To(ContainSubstring("Using in-cluster configuration"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating an object containing a namespace with in-cluster config")
0000000000000000000000000000000000000000;;				_, err = framework.RunHostCmd(ns, simplePodName, "/tmp/kubectl create -f /tmp/invalid-configmap-with-namespace.yaml --v=7 2>&1")
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Using in-cluster namespace"))
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Using in-cluster configuration"))
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring(fmt.Sprintf("POST https://%s:%s/api/v1/namespaces/configmap-namespace/configmaps", inClusterHost, inClusterPort)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating an object not containing a namespace with in-cluster config")
0000000000000000000000000000000000000000;;				_, err = framework.RunHostCmd(ns, simplePodName, "/tmp/kubectl create -f /tmp/invalid-configmap-without-namespace.yaml --v=7 2>&1")
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Using in-cluster namespace"))
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Using in-cluster configuration"))
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring(fmt.Sprintf("POST https://%s:%s/api/v1/namespaces/%s/configmaps", inClusterHost, inClusterPort, f.Namespace.Name)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("trying to use kubectl with invalid token")
0000000000000000000000000000000000000000;;				_, err = framework.RunHostCmd(ns, simplePodName, "/tmp/kubectl get pods --token=invalid --v=7 2>&1")
0000000000000000000000000000000000000000;;				framework.Logf("got err %v", err)
0000000000000000000000000000000000000000;;				Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Using in-cluster namespace"))
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Using in-cluster configuration"))
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Authorization: Bearer invalid"))
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Response Status: 401 Unauthorized"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("trying to use kubectl with invalid server")
0000000000000000000000000000000000000000;;				_, err = framework.RunHostCmd(ns, simplePodName, "/tmp/kubectl get pods --server=invalid --v=6 2>&1")
0000000000000000000000000000000000000000;;				framework.Logf("got err %v", err)
0000000000000000000000000000000000000000;;				Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("Unable to connect to the server"))
0000000000000000000000000000000000000000;;				Expect(err).To(ContainSubstring("GET http://invalid/api"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("trying to use kubectl with invalid namespace")
0000000000000000000000000000000000000000;;				execOutput = framework.RunHostCmdOrDie(ns, simplePodName, "/tmp/kubectl get pods --namespace=invalid --v=6 2>&1")
0000000000000000000000000000000000000000;;				Expect(execOutput).To(ContainSubstring("No resources found"))
0000000000000000000000000000000000000000;;				Expect(execOutput).ToNot(ContainSubstring("Using in-cluster namespace"))
0000000000000000000000000000000000000000;;				Expect(execOutput).To(ContainSubstring("Using in-cluster configuration"))
0000000000000000000000000000000000000000;;				Expect(execOutput).To(MatchRegexp(fmt.Sprintf("GET http[s]?://%s:%s/api/v1/namespaces/invalid/pods", inClusterHost, inClusterPort)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("trying to use kubectl with kubeconfig")
0000000000000000000000000000000000000000;;				execOutput = framework.RunHostCmdOrDie(ns, simplePodName, "/tmp/kubectl get pods --kubeconfig=/tmp/"+overrideKubeconfigName+" --v=6 2>&1")
0000000000000000000000000000000000000000;;				Expect(execOutput).ToNot(ContainSubstring("Using in-cluster namespace"))
0000000000000000000000000000000000000000;;				Expect(execOutput).ToNot(ContainSubstring("Using in-cluster configuration"))
0000000000000000000000000000000000000000;;				Expect(execOutput).To(ContainSubstring("GET https://kubernetes.default.svc:443/api/v1/namespaces/default/pods"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl api-versions", func() {
0000000000000000000000000000000000000000;;			It("should check if v1 is in available api versions [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("validating api verions")
0000000000000000000000000000000000000000;;				output := framework.RunKubectlOrDie("api-versions")
0000000000000000000000000000000000000000;;				if !strings.Contains(output, "v1") {
0000000000000000000000000000000000000000;;					framework.Failf("No v1 in kubectl api-versions")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl apply", func() {
0000000000000000000000000000000000000000;;			It("should apply a new configuration to an existing RC", func() {
0000000000000000000000000000000000000000;;				controllerJson := readTestFileOrDie(redisControllerFilename)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				By("creating Redis RC")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(controllerJson), "create", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;				By("applying a modified configuration")
0000000000000000000000000000000000000000;;				stdin := modifyReplicationControllerConfiguration(string(controllerJson))
0000000000000000000000000000000000000000;;				framework.NewKubectlCommand("apply", "-f", "-", nsFlag).
0000000000000000000000000000000000000000;;					WithStdinReader(stdin).
0000000000000000000000000000000000000000;;					ExecOrDie()
0000000000000000000000000000000000000000;;				By("checking the result")
0000000000000000000000000000000000000000;;				forEachReplicationController(c, ns, "app", "redis", validateReplicationControllerConfiguration)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			It("should reuse port when apply to an existing SVC", func() {
0000000000000000000000000000000000000000;;				serviceJson := readTestFileOrDie(redisServiceFilename)
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating Redis SVC")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(serviceJson[:]), "create", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("getting the original port")
0000000000000000000000000000000000000000;;				originalNodePort := framework.RunKubectlOrDie("get", "service", "redis-master", nsFlag, "-o", "jsonpath={.spec.ports[0].port}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("applying the same configuration")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(serviceJson[:]), "apply", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("getting the port after applying configuration")
0000000000000000000000000000000000000000;;				currentNodePort := framework.RunKubectlOrDie("get", "service", "redis-master", nsFlag, "-o", "jsonpath={.spec.ports[0].port}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("checking the result")
0000000000000000000000000000000000000000;;				if originalNodePort != currentNodePort {
0000000000000000000000000000000000000000;;					framework.Failf("port should keep the same")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("apply set/view last-applied", func() {
0000000000000000000000000000000000000000;;				deployment1Yaml := readTestFileOrDie(nginxDeployment1Filename)
0000000000000000000000000000000000000000;;				deployment2Yaml := readTestFileOrDie(nginxDeployment2Filename)
0000000000000000000000000000000000000000;;				deployment3Yaml := readTestFileOrDie(nginxDeployment3Filename)
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("deployment replicas number is 2")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(deployment1Yaml[:]), "apply", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("check the last-applied matches expectations annotations")
0000000000000000000000000000000000000000;;				output := framework.RunKubectlOrDieInput(string(deployment1Yaml[:]), "apply", "view-last-applied", "-f", "-", nsFlag, "-o", "json")
0000000000000000000000000000000000000000;;				requiredString := "\"replicas\": 2"
0000000000000000000000000000000000000000;;				if !strings.Contains(output, requiredString) {
0000000000000000000000000000000000000000;;					framework.Failf("Missing %s in kubectl view-last-applied", requiredString)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("apply file doesn't have replicas")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(deployment2Yaml[:]), "apply", "set-last-applied", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("check last-applied has been updated, annotations doesn't replicas")
0000000000000000000000000000000000000000;;				output = framework.RunKubectlOrDieInput(string(deployment1Yaml[:]), "apply", "view-last-applied", "-f", "-", nsFlag, "-o", "json")
0000000000000000000000000000000000000000;;				requiredString = "\"replicas\": 2"
0000000000000000000000000000000000000000;;				if strings.Contains(output, requiredString) {
0000000000000000000000000000000000000000;;					framework.Failf("Missing %s in kubectl view-last-applied", requiredString)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("scale set replicas to 3")
0000000000000000000000000000000000000000;;				nginxDeploy := "nginx-deployment"
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("scale", "deployment", nginxDeploy, "--replicas=3", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("apply file doesn't have replicas but image changed")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(deployment3Yaml[:]), "apply", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verify replicas still is 3 and image has been updated")
0000000000000000000000000000000000000000;;				output = framework.RunKubectlOrDieInput(string(deployment3Yaml[:]), "get", "-f", "-", nsFlag, "-o", "json")
0000000000000000000000000000000000000000;;				requiredItems := []string{"\"replicas\": 3", "nginx-slim:0.7"}
0000000000000000000000000000000000000000;;				for _, item := range requiredItems {
0000000000000000000000000000000000000000;;					if !strings.Contains(output, item) {
0000000000000000000000000000000000000000;;						framework.Failf("Missing %s in kubectl apply", item)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl cluster-info", func() {
0000000000000000000000000000000000000000;;			It("should check if Kubernetes master services is included in cluster-info [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("validating cluster-info")
0000000000000000000000000000000000000000;;				output := framework.RunKubectlOrDie("cluster-info")
0000000000000000000000000000000000000000;;				// Can't check exact strings due to terminal control commands (colors)
0000000000000000000000000000000000000000;;				requiredItems := []string{"Kubernetes master", "is running at"}
0000000000000000000000000000000000000000;;				if framework.ProviderIs("gce", "gke") {
0000000000000000000000000000000000000000;;					requiredItems = append(requiredItems, "KubeDNS", "Heapster")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, item := range requiredItems {
0000000000000000000000000000000000000000;;					if !strings.Contains(output, item) {
0000000000000000000000000000000000000000;;						framework.Failf("Missing %s in kubectl cluster-info", item)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl describe", func() {
0000000000000000000000000000000000000000;;			It("should check if kubectl describe prints relevant information for rc and pods [Conformance]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(nodePortsOptionalVersion, c.Discovery())
0000000000000000000000000000000000000000;;				kv, err := framework.KubectlVersion()
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(kv, c.Discovery())
0000000000000000000000000000000000000000;;				controllerJson := readTestFileOrDie(redisControllerFilename)
0000000000000000000000000000000000000000;;				serviceJson := readTestFileOrDie(redisServiceFilename)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(controllerJson[:]), "create", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(serviceJson[:]), "create", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Waiting for Redis master to start.")
0000000000000000000000000000000000000000;;				waitForOrFailWithDebug(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Pod
0000000000000000000000000000000000000000;;				forEachPod(func(pod v1.Pod) {
0000000000000000000000000000000000000000;;					output := framework.RunKubectlOrDie("describe", "pod", pod.Name, nsFlag)
0000000000000000000000000000000000000000;;					requiredStrings := [][]string{
0000000000000000000000000000000000000000;;						{"Name:", "redis-master-"},
0000000000000000000000000000000000000000;;						{"Namespace:", ns},
0000000000000000000000000000000000000000;;						{"Node:"},
0000000000000000000000000000000000000000;;						{"Labels:", "app=redis"},
0000000000000000000000000000000000000000;;						{"role=master"},
0000000000000000000000000000000000000000;;						{"Annotations:"},
0000000000000000000000000000000000000000;;						{"Status:", "Running"},
0000000000000000000000000000000000000000;;						{"IP:"},
0000000000000000000000000000000000000000;;						{"Created By:", "ReplicationController/redis-master"},
0000000000000000000000000000000000000000;;						{"Controlled By:", "ReplicationController/redis-master"},
0000000000000000000000000000000000000000;;						{"Image:", redisImage},
0000000000000000000000000000000000000000;;						{"State:", "Running"},
0000000000000000000000000000000000000000;;						{"QoS Class:", "BestEffort"},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					checkOutput(output, requiredStrings)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Rc
0000000000000000000000000000000000000000;;				requiredStrings := [][]string{
0000000000000000000000000000000000000000;;					{"Name:", "redis-master"},
0000000000000000000000000000000000000000;;					{"Namespace:", ns},
0000000000000000000000000000000000000000;;					{"Selector:", "app=redis,role=master"},
0000000000000000000000000000000000000000;;					{"Labels:", "app=redis"},
0000000000000000000000000000000000000000;;					{"role=master"},
0000000000000000000000000000000000000000;;					{"Annotations:"},
0000000000000000000000000000000000000000;;					{"Replicas:", "1 current", "1 desired"},
0000000000000000000000000000000000000000;;					{"Pods Status:", "1 Running", "0 Waiting", "0 Succeeded", "0 Failed"},
0000000000000000000000000000000000000000;;					{"Pod Template:"},
0000000000000000000000000000000000000000;;					{"Image:", redisImage},
0000000000000000000000000000000000000000;;					{"Events:"}}
0000000000000000000000000000000000000000;;				checkKubectlOutputWithRetry(requiredStrings, "describe", "rc", "redis-master", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Service
0000000000000000000000000000000000000000;;				output := framework.RunKubectlOrDie("describe", "service", "redis-master", nsFlag)
0000000000000000000000000000000000000000;;				requiredStrings = [][]string{
0000000000000000000000000000000000000000;;					{"Name:", "redis-master"},
0000000000000000000000000000000000000000;;					{"Namespace:", ns},
0000000000000000000000000000000000000000;;					{"Labels:", "app=redis"},
0000000000000000000000000000000000000000;;					{"role=master"},
0000000000000000000000000000000000000000;;					{"Annotations:"},
0000000000000000000000000000000000000000;;					{"Selector:", "app=redis", "role=master"},
0000000000000000000000000000000000000000;;					{"Type:", "ClusterIP"},
0000000000000000000000000000000000000000;;					{"IP:"},
0000000000000000000000000000000000000000;;					{"Port:", "<unset>", "6379/TCP"},
0000000000000000000000000000000000000000;;					{"Endpoints:"},
0000000000000000000000000000000000000000;;					{"Session Affinity:", "None"}}
0000000000000000000000000000000000000000;;				checkOutput(output, requiredStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Node
0000000000000000000000000000000000000000;;				// It should be OK to list unschedulable Nodes here.
0000000000000000000000000000000000000000;;				nodes, err := c.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				node := nodes.Items[0]
0000000000000000000000000000000000000000;;				output = framework.RunKubectlOrDie("describe", "node", node.Name)
0000000000000000000000000000000000000000;;				requiredStrings = [][]string{
0000000000000000000000000000000000000000;;					{"Name:", node.Name},
0000000000000000000000000000000000000000;;					{"Labels:"},
0000000000000000000000000000000000000000;;					{"Annotations:"},
0000000000000000000000000000000000000000;;					{"CreationTimestamp:"},
0000000000000000000000000000000000000000;;					{"Conditions:"},
0000000000000000000000000000000000000000;;					{"Type", "Status", "LastHeartbeatTime", "LastTransitionTime", "Reason", "Message"},
0000000000000000000000000000000000000000;;					{"Addresses:"},
0000000000000000000000000000000000000000;;					{"Capacity:"},
0000000000000000000000000000000000000000;;					{"Version:"},
0000000000000000000000000000000000000000;;					{"Kernel Version:"},
0000000000000000000000000000000000000000;;					{"OS Image:"},
0000000000000000000000000000000000000000;;					{"Container Runtime Version:"},
0000000000000000000000000000000000000000;;					{"Kubelet Version:"},
0000000000000000000000000000000000000000;;					{"Kube-Proxy Version:"},
0000000000000000000000000000000000000000;;					{"Pods:"}}
0000000000000000000000000000000000000000;;				checkOutput(output, requiredStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Namespace
0000000000000000000000000000000000000000;;				output = framework.RunKubectlOrDie("describe", "namespace", ns)
0000000000000000000000000000000000000000;;				requiredStrings = [][]string{
0000000000000000000000000000000000000000;;					{"Name:", ns},
0000000000000000000000000000000000000000;;					{"Labels:"},
0000000000000000000000000000000000000000;;					{"Annotations:"},
0000000000000000000000000000000000000000;;					{"Status:", "Active"}}
0000000000000000000000000000000000000000;;				checkOutput(output, requiredStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Quota and limitrange are skipped for now.
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl expose", func() {
0000000000000000000000000000000000000000;;			It("should create services for rc [Conformance]", func() {
0000000000000000000000000000000000000000;;				controllerJson := readTestFileOrDie(redisControllerFilename)
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				redisPort := 6379
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("creating Redis RC")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				framework.Logf("namespace %v", ns)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(controllerJson[:]), "create", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// It may take a while for the pods to get registered in some cases, wait to be sure.
0000000000000000000000000000000000000000;;				By("Waiting for Redis master to start.")
0000000000000000000000000000000000000000;;				waitForOrFailWithDebug(1)
0000000000000000000000000000000000000000;;				forEachPod(func(pod v1.Pod) {
0000000000000000000000000000000000000000;;					framework.Logf("wait on redis-master startup in %v ", ns)
0000000000000000000000000000000000000000;;					framework.LookForStringInLog(ns, pod.Name, "redis-master", "The server is now ready to accept connections", framework.PodStartTimeout)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				validateService := func(name string, servicePort int, timeout time.Duration) {
0000000000000000000000000000000000000000;;					err := wait.Poll(framework.Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;						endpoints, err := c.Core().Endpoints(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							// log the real error
0000000000000000000000000000000000000000;;							framework.Logf("Get endpoints failed (interval %v): %v", framework.Poll, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							// if the error is API not found or could not find default credentials or TLS handshake timeout, try again
0000000000000000000000000000000000000000;;							if apierrs.IsNotFound(err) ||
0000000000000000000000000000000000000000;;								apierrs.IsUnauthorized(err) ||
0000000000000000000000000000000000000000;;								apierrs.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;								err = nil
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return false, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						uidToPort := framework.GetContainerPortsByPodUID(endpoints)
0000000000000000000000000000000000000000;;						if len(uidToPort) == 0 {
0000000000000000000000000000000000000000;;							framework.Logf("No endpoint found, retrying")
0000000000000000000000000000000000000000;;							return false, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if len(uidToPort) > 1 {
0000000000000000000000000000000000000000;;							framework.Failf("Too many endpoints found")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for _, port := range uidToPort {
0000000000000000000000000000000000000000;;							if port[0] != redisPort {
0000000000000000000000000000000000000000;;								framework.Failf("Wrong endpoint port: %d", port[0])
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					service, err := c.Core().Services(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if len(service.Spec.Ports) != 1 {
0000000000000000000000000000000000000000;;						framework.Failf("1 port is expected")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					port := service.Spec.Ports[0]
0000000000000000000000000000000000000000;;					if port.Port != int32(servicePort) {
0000000000000000000000000000000000000000;;						framework.Failf("Wrong service port: %d", port.Port)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if port.TargetPort.IntValue() != redisPort {
0000000000000000000000000000000000000000;;						framework.Failf("Wrong target port: %d", port.TargetPort.IntValue())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("exposing RC")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("expose", "rc", "redis-master", "--name=rm2", "--port=1234", fmt.Sprintf("--target-port=%d", redisPort), nsFlag)
0000000000000000000000000000000000000000;;				framework.WaitForService(c, ns, "rm2", true, framework.Poll, framework.ServiceStartTimeout)
0000000000000000000000000000000000000000;;				validateService("rm2", 1234, framework.ServiceStartTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("exposing service")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("expose", "service", "rm2", "--name=rm3", "--port=2345", fmt.Sprintf("--target-port=%d", redisPort), nsFlag)
0000000000000000000000000000000000000000;;				framework.WaitForService(c, ns, "rm3", true, framework.Poll, framework.ServiceStartTimeout)
0000000000000000000000000000000000000000;;				validateService("rm3", 2345, framework.ServiceStartTimeout)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl label", func() {
0000000000000000000000000000000000000000;;			var pod []byte
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				pod = readTestFileOrDie("pause-pod.yaml")
0000000000000000000000000000000000000000;;				By("creating the pod")
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(pod), "create", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;				Expect(framework.CheckPodsRunningReady(c, ns, []string{pausePodName}, framework.PodStartTimeout)).To(BeTrue())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				cleanupKubectlInputs(string(pod[:]), ns, pausePodSelector)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should update the label on a resource [Conformance]", func() {
0000000000000000000000000000000000000000;;				labelName := "testing-label"
0000000000000000000000000000000000000000;;				labelValue := "testing-label-value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("adding the label " + labelName + " with value " + labelValue + " to a pod")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("label", "pods", pausePodName, labelName+"="+labelValue, nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the pod has the label " + labelName + " with the value " + labelValue)
0000000000000000000000000000000000000000;;				output := framework.RunKubectlOrDie("get", "pod", pausePodName, "-L", labelName, nsFlag)
0000000000000000000000000000000000000000;;				if !strings.Contains(output, labelValue) {
0000000000000000000000000000000000000000;;					framework.Failf("Failed updating label " + labelName + " to the pod " + pausePodName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("removing the label " + labelName + " of a pod")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("label", "pods", pausePodName, labelName+"-", nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the pod doesn't have the label " + labelName)
0000000000000000000000000000000000000000;;				output = framework.RunKubectlOrDie("get", "pod", pausePodName, "-L", labelName, nsFlag)
0000000000000000000000000000000000000000;;				if strings.Contains(output, labelValue) {
0000000000000000000000000000000000000000;;					framework.Failf("Failed removing label " + labelName + " of the pod " + pausePodName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl logs", func() {
0000000000000000000000000000000000000000;;			var rc []byte
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			containerName := "redis-master"
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				rc = readTestFileOrDie(redisControllerFilename)
0000000000000000000000000000000000000000;;				By("creating an rc")
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(rc[:]), "create", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				cleanupKubectlInputs(string(rc[:]), ns, simplePodSelector)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to retrieve and filter logs [Conformance]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(extendedPodLogFilterVersion, c.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Split("something\n", "\n") returns ["something", ""], so
0000000000000000000000000000000000000000;;				// strip trailing newline first
0000000000000000000000000000000000000000;;				lines := func(out string) []string {
0000000000000000000000000000000000000000;;					return strings.Split(strings.TrimRight(out, "\n"), "\n")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Waiting for Redis master to start.")
0000000000000000000000000000000000000000;;				waitForOrFailWithDebug(1)
0000000000000000000000000000000000000000;;				forEachPod(func(pod v1.Pod) {
0000000000000000000000000000000000000000;;					By("checking for a matching strings")
0000000000000000000000000000000000000000;;					_, err := framework.LookForStringInLog(ns, pod.Name, containerName, "The server is now ready to accept connections", framework.PodStartTimeout)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("limiting log lines")
0000000000000000000000000000000000000000;;					out := framework.RunKubectlOrDie("log", pod.Name, containerName, nsFlag, "--tail=1")
0000000000000000000000000000000000000000;;					Expect(len(out)).NotTo(BeZero())
0000000000000000000000000000000000000000;;					Expect(len(lines(out))).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("limiting log bytes")
0000000000000000000000000000000000000000;;					out = framework.RunKubectlOrDie("log", pod.Name, containerName, nsFlag, "--limit-bytes=1")
0000000000000000000000000000000000000000;;					Expect(len(lines(out))).To(Equal(1))
0000000000000000000000000000000000000000;;					Expect(len(out)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("exposing timestamps")
0000000000000000000000000000000000000000;;					out = framework.RunKubectlOrDie("log", pod.Name, containerName, nsFlag, "--tail=1", "--timestamps")
0000000000000000000000000000000000000000;;					l := lines(out)
0000000000000000000000000000000000000000;;					Expect(len(l)).To(Equal(1))
0000000000000000000000000000000000000000;;					words := strings.Split(l[0], " ")
0000000000000000000000000000000000000000;;					Expect(len(words)).To(BeNumerically(">", 1))
0000000000000000000000000000000000000000;;					if _, err := time.Parse(time.RFC3339Nano, words[0]); err != nil {
0000000000000000000000000000000000000000;;						if _, err := time.Parse(time.RFC3339, words[0]); err != nil {
0000000000000000000000000000000000000000;;							framework.Failf("expected %q to be RFC3339 or RFC3339Nano", words[0])
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("restricting to a time range")
0000000000000000000000000000000000000000;;					// Note: we must wait at least two seconds,
0000000000000000000000000000000000000000;;					// because the granularity is only 1 second and
0000000000000000000000000000000000000000;;					// it could end up rounding the wrong way.
0000000000000000000000000000000000000000;;					time.Sleep(2500 * time.Millisecond) // ensure that startup logs on the node are seen as older than 1s
0000000000000000000000000000000000000000;;					recent_out := framework.RunKubectlOrDie("log", pod.Name, containerName, nsFlag, "--since=1s")
0000000000000000000000000000000000000000;;					recent := len(strings.Split(recent_out, "\n"))
0000000000000000000000000000000000000000;;					older_out := framework.RunKubectlOrDie("log", pod.Name, containerName, nsFlag, "--since=24h")
0000000000000000000000000000000000000000;;					older := len(strings.Split(older_out, "\n"))
0000000000000000000000000000000000000000;;					Expect(recent).To(BeNumerically("<", older), "expected recent(%v) to be less than older(%v)\nrecent lines:\n%v\nolder lines:\n%v\n", recent, older, recent_out, older_out)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl patch", func() {
0000000000000000000000000000000000000000;;			It("should add annotations for pods in rc [Conformance]", func() {
0000000000000000000000000000000000000000;;				controllerJson := readTestFileOrDie(redisControllerFilename)
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				By("creating Redis RC")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(string(controllerJson[:]), "create", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;				By("Waiting for Redis master to start.")
0000000000000000000000000000000000000000;;				waitForOrFailWithDebug(1)
0000000000000000000000000000000000000000;;				By("patching all pods")
0000000000000000000000000000000000000000;;				forEachPod(func(pod v1.Pod) {
0000000000000000000000000000000000000000;;					framework.RunKubectlOrDie("patch", "pod", pod.Name, nsFlag, "-p", "{\"metadata\":{\"annotations\":{\"x\":\"y\"}}}")
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("checking annotations")
0000000000000000000000000000000000000000;;				forEachPod(func(pod v1.Pod) {
0000000000000000000000000000000000000000;;					found := false
0000000000000000000000000000000000000000;;					for key, val := range pod.Annotations {
0000000000000000000000000000000000000000;;						if key == "x" && val == "y" {
0000000000000000000000000000000000000000;;							found = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !found {
0000000000000000000000000000000000000000;;						framework.Failf("Added annotation not found")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl version", func() {
0000000000000000000000000000000000000000;;			It("should check is all data is printed [Conformance]", func() {
0000000000000000000000000000000000000000;;				version := framework.RunKubectlOrDie("version")
0000000000000000000000000000000000000000;;				requiredItems := []string{"Client Version:", "Server Version:", "Major:", "Minor:", "GitCommit:"}
0000000000000000000000000000000000000000;;				for _, item := range requiredItems {
0000000000000000000000000000000000000000;;					if !strings.Contains(version, item) {
0000000000000000000000000000000000000000;;						framework.Failf("Required item %s not found in %s", item, version)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl run default", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var cleanUp func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				gte, err := framework.ServerVersionGTE(deploymentsVersion, c.Discovery())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to get server version: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if gte {
0000000000000000000000000000000000000000;;					name = "e2e-test-nginx-deployment"
0000000000000000000000000000000000000000;;					cleanUp = func() { framework.RunKubectlOrDie("delete", "deployment", name, nsFlag) }
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					name = "e2e-test-nginx-rc"
0000000000000000000000000000000000000000;;					cleanUp = func() { framework.RunKubectlOrDie("delete", "rc", name, nsFlag) }
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				cleanUp()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create an rc or deployment from an image [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("running the image " + nginxImage)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", name, "--image="+nginxImage, nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the pod controlled by " + name + " gets created")
0000000000000000000000000000000000000000;;				label := labels.SelectorFromSet(labels.Set(map[string]string{"run": name}))
0000000000000000000000000000000000000000;;				podlist, err := framework.WaitForPodsWithLabel(c, ns, label)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting pod controlled by %s: %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pods := podlist.Items
0000000000000000000000000000000000000000;;				if pods == nil || len(pods) != 1 || len(pods[0].Spec.Containers) != 1 || pods[0].Spec.Containers[0].Image != nginxImage {
0000000000000000000000000000000000000000;;					framework.RunKubectlOrDie("get", "pods", "-L", "run", nsFlag)
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating 1 pod with expected image %s. Number of pods = %v", nginxImage, len(pods))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl run rc", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var rcName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				rcName = "e2e-test-nginx-rc"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("delete", "rc", rcName, nsFlag)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create an rc from an image [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("running the image " + nginxImage)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", rcName, "--image="+nginxImage, "--generator=run/v1", nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the rc " + rcName + " was created")
0000000000000000000000000000000000000000;;				rc, err := c.Core().ReplicationControllers(ns).Get(rcName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting rc %s: %v", rcName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containers := rc.Spec.Template.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) != 1 || containers[0].Image != nginxImage {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating rc %s for 1 pod with expected image %s", rcName, nginxImage)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the pod controlled by rc " + rcName + " was created")
0000000000000000000000000000000000000000;;				label := labels.SelectorFromSet(labels.Set(map[string]string{"run": rcName}))
0000000000000000000000000000000000000000;;				podlist, err := framework.WaitForPodsWithLabel(c, ns, label)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting pod controlled by rc %s: %v", rcName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pods := podlist.Items
0000000000000000000000000000000000000000;;				if pods == nil || len(pods) != 1 || len(pods[0].Spec.Containers) != 1 || pods[0].Spec.Containers[0].Image != nginxImage {
0000000000000000000000000000000000000000;;					framework.RunKubectlOrDie("get", "pods", "-L", "run", nsFlag)
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating 1 pod with expected image %s. Number of pods = %v", nginxImage, len(pods))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("confirm that you can get logs from an rc")
0000000000000000000000000000000000000000;;				podNames := []string{}
0000000000000000000000000000000000000000;;				for _, pod := range pods {
0000000000000000000000000000000000000000;;					podNames = append(podNames, pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !framework.CheckPodsRunningReady(c, ns, podNames, framework.PodStartTimeout) {
0000000000000000000000000000000000000000;;					framework.Failf("Pods for rc %s were not ready", rcName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = framework.RunKubectl("logs", "rc/"+rcName, nsFlag)
0000000000000000000000000000000000000000;;				// a non-nil error is fine as long as we actually found a pod.
0000000000000000000000000000000000000000;;				if err != nil && !strings.Contains(err.Error(), " in pod ") {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting logs by rc %s: %v", rcName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl rolling-update", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var rcName string
0000000000000000000000000000000000000000;;			var c clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				c = f.ClientSet
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				rcName = "e2e-test-nginx-rc"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("delete", "rc", rcName, nsFlag)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should support rolling-update to same image [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("running the image " + nginxImage)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", rcName, "--image="+nginxImage, "--generator=run/v1", nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the rc " + rcName + " was created")
0000000000000000000000000000000000000000;;				rc, err := c.Core().ReplicationControllers(ns).Get(rcName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting rc %s: %v", rcName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containers := rc.Spec.Template.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) != 1 || containers[0].Image != nginxImage {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating rc %s for 1 pod with expected image %s", rcName, nginxImage)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.WaitForRCToStabilize(c, ns, rcName, framework.PodStartTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("rolling-update to same image controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				runKubectlRetryOrDie("rolling-update", rcName, "--update-period=1s", "--image="+nginxImage, "--image-pull-policy="+string(v1.PullIfNotPresent), nsFlag)
0000000000000000000000000000000000000000;;				framework.ValidateController(c, nginxImage, 1, rcName, "run="+rcName, noOpValidatorFn, ns)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl run deployment", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var dName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				dName = "e2e-test-nginx-deployment"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				err := wait.Poll(framework.Poll, 2*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;					out, err := framework.RunKubectl("delete", "deployment", dName, nsFlag)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if strings.Contains(err.Error(), "could not find default credentials") {
0000000000000000000000000000000000000000;;							err = nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return false, fmt.Errorf("kubectl delete failed output: %s, err: %v", out, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create a deployment from an image [Conformance]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(deploymentsVersion, c.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running the image " + nginxImage)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", dName, "--image="+nginxImage, "--generator=deployment/v1beta1", nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the deployment " + dName + " was created")
0000000000000000000000000000000000000000;;				d, err := c.Extensions().Deployments(ns).Get(dName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting deployment %s: %v", dName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containers := d.Spec.Template.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) != 1 || containers[0].Image != nginxImage {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating deployment %s for 1 pod with expected image %s", dName, nginxImage)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the pod controlled by deployment " + dName + " was created")
0000000000000000000000000000000000000000;;				label := labels.SelectorFromSet(labels.Set(map[string]string{"run": dName}))
0000000000000000000000000000000000000000;;				podlist, err := framework.WaitForPodsWithLabel(c, ns, label)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting pod controlled by deployment %s: %v", dName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pods := podlist.Items
0000000000000000000000000000000000000000;;				if pods == nil || len(pods) != 1 || len(pods[0].Spec.Containers) != 1 || pods[0].Spec.Containers[0].Image != nginxImage {
0000000000000000000000000000000000000000;;					framework.RunKubectlOrDie("get", "pods", "-L", "run", nsFlag)
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating 1 pod with expected image %s. Number of pods = %v", nginxImage, len(pods))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl run job", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var jobName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				jobName = "e2e-test-nginx-job"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("delete", "jobs", jobName, nsFlag)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create a job from an image when restart is OnFailure [Conformance]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(jobsVersion, c.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running the image " + nginxImage)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", jobName, "--restart=OnFailure", "--generator=job/v1", "--image="+nginxImage, nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the job " + jobName + " was created")
0000000000000000000000000000000000000000;;				job, err := c.Batch().Jobs(ns).Get(jobName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting job %s: %v", jobName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containers := job.Spec.Template.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) != 1 || containers[0].Image != nginxImage {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating job %s for 1 pod with expected image %s: %#v", jobName, nginxImage, containers)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if job.Spec.Template.Spec.RestartPolicy != v1.RestartPolicyOnFailure {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating a job with correct restart policy for --restart=OnFailure")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl run pod", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var podName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				podName = "e2e-test-nginx-pod"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("delete", "pods", podName, nsFlag)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create a pod from an image when restart is Never [Conformance]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(jobsVersion, c.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running the image " + nginxImage)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", podName, "--restart=Never", "--generator=run-pod/v1", "--image="+nginxImage, nsFlag)
0000000000000000000000000000000000000000;;				By("verifying the pod " + podName + " was created")
0000000000000000000000000000000000000000;;				pod, err := c.Core().Pods(ns).Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting pod %s: %v", podName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containers := pod.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) != 1 || containers[0].Image != nginxImage {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating pod %s with expected image %s", podName, nginxImage)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.Spec.RestartPolicy != v1.RestartPolicyNever {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating a pod with correct restart policy for --restart=Never")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl replace", func() {
0000000000000000000000000000000000000000;;			var nsFlag string
0000000000000000000000000000000000000000;;			var podName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				nsFlag = fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				podName = "e2e-test-nginx-pod"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("delete", "pods", podName, nsFlag)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should update a single-container pod's image [Conformance]", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(jobsVersion, c.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("running the image " + nginxImage)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("run", podName, "--generator=run-pod/v1", "--image="+nginxImage, "--labels=run="+podName, nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the pod " + podName + " is running")
0000000000000000000000000000000000000000;;				label := labels.SelectorFromSet(labels.Set(map[string]string{"run": podName}))
0000000000000000000000000000000000000000;;				err := testutils.WaitForPodsWithLabelRunning(c, ns, label)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting pod %s: %v", podName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the pod " + podName + " was created")
0000000000000000000000000000000000000000;;				podJson := framework.RunKubectlOrDie("get", "pod", podName, nsFlag, "-o", "json")
0000000000000000000000000000000000000000;;				if !strings.Contains(podJson, podName) {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to find pod %s in [%s]", podName, podJson)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("replace the image in the pod")
0000000000000000000000000000000000000000;;				podJson = strings.Replace(podJson, nginxImage, busyboxImage, 1)
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDieInput(podJson, "replace", "-f", "-", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the pod " + podName + " has the right image " + busyboxImage)
0000000000000000000000000000000000000000;;				pod, err := c.Core().Pods(ns).Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting deployment %s: %v", podName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containers := pod.Spec.Containers
0000000000000000000000000000000000000000;;				if containers == nil || len(containers) != 1 || containers[0].Image != busyboxImage {
0000000000000000000000000000000000000000;;					framework.Failf("Failed creating pod with expected image %s", busyboxImage)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl run --rm job", func() {
0000000000000000000000000000000000000000;;			jobName := "e2e-test-rm-busybox-job"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create a job from an image, then delete the job [Conformance]", func() {
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// The rkt runtime doesn't support attach, see #23335
0000000000000000000000000000000000000000;;				framework.SkipIfContainerRuntimeIs("rkt")
0000000000000000000000000000000000000000;;				framework.SkipUnlessServerVersionGTE(jobsVersion, c.Discovery())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("executing a command with run --rm and attach with stdin")
0000000000000000000000000000000000000000;;				t := time.NewTimer(runJobTimeout)
0000000000000000000000000000000000000000;;				defer t.Stop()
0000000000000000000000000000000000000000;;				runOutput := framework.NewKubectlCommand(nsFlag, "run", jobName, "--image="+busyboxImage, "--rm=true", "--generator=job/v1", "--restart=OnFailure", "--attach=true", "--stdin", "--", "sh", "-c", "cat && echo 'stdin closed'").
0000000000000000000000000000000000000000;;					WithStdinData("abcd1234").
0000000000000000000000000000000000000000;;					WithTimeout(t.C).
0000000000000000000000000000000000000000;;					ExecOrDie()
0000000000000000000000000000000000000000;;				Expect(runOutput).To(ContainSubstring("abcd1234"))
0000000000000000000000000000000000000000;;				Expect(runOutput).To(ContainSubstring("stdin closed"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the job " + jobName + " was deleted")
0000000000000000000000000000000000000000;;				_, err := c.Batch().Jobs(ns).Get(jobName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;				Expect(apierrs.IsNotFound(err)).To(BeTrue())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Proxy server", func() {
0000000000000000000000000000000000000000;;			// TODO: test proxy options (static, prefix, etc)
0000000000000000000000000000000000000000;;			It("should support proxy with --port 0 [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("starting the proxy server")
0000000000000000000000000000000000000000;;				port, cmd, err := startProxyServer()
0000000000000000000000000000000000000000;;				if cmd != nil {
0000000000000000000000000000000000000000;;					defer framework.TryKill(cmd)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to start proxy server: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("curling proxy /api/ output")
0000000000000000000000000000000000000000;;				localAddr := fmt.Sprintf("http://localhost:%d/api/", port)
0000000000000000000000000000000000000000;;				apiVersions, err := getAPIVersions(localAddr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Expected at least one supported apiversion, got error %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(apiVersions.Versions) < 1 {
0000000000000000000000000000000000000000;;					framework.Failf("Expected at least one supported apiversion, got %v", apiVersions)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should support --unix-socket=/path [Conformance]", func() {
0000000000000000000000000000000000000000;;				By("Starting the proxy")
0000000000000000000000000000000000000000;;				tmpdir, err := ioutil.TempDir("", "kubectl-proxy-unix")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to create temporary directory: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				path := filepath.Join(tmpdir, "test")
0000000000000000000000000000000000000000;;				defer os.Remove(path)
0000000000000000000000000000000000000000;;				defer os.Remove(tmpdir)
0000000000000000000000000000000000000000;;				cmd := framework.KubectlCmd("proxy", fmt.Sprintf("--unix-socket=%s", path))
0000000000000000000000000000000000000000;;				stdout, stderr, err := framework.StartCmdAndStreamOutput(cmd)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to start kubectl command: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer stdout.Close()
0000000000000000000000000000000000000000;;				defer stderr.Close()
0000000000000000000000000000000000000000;;				defer framework.TryKill(cmd)
0000000000000000000000000000000000000000;;				buf := make([]byte, 128)
0000000000000000000000000000000000000000;;				if _, err = stdout.Read(buf); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Expected output from kubectl proxy: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("retrieving proxy /api/ output")
0000000000000000000000000000000000000000;;				_, err = curlUnix("http://unused/api", path)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed get of /api at %s: %v", path, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This test must run [Serial] because it modifies the node so it doesn't allow pods to execute on
0000000000000000000000000000000000000000;;		// it, which will affect anything else running in parallel.
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl taint [Serial]", func() {
0000000000000000000000000000000000000000;;			It("should update the taint on a node", func() {
0000000000000000000000000000000000000000;;				testTaint := v1.Taint{
0000000000000000000000000000000000000000;;					Key:    fmt.Sprintf("kubernetes.io/e2e-taint-key-001-%s", string(uuid.NewUUID())),
0000000000000000000000000000000000000000;;					Value:  "testing-taint-value",
0000000000000000000000000000000000000000;;					Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nodeName := scheduling.GetNodeThatCanRunPod(f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("adding the taint " + testTaint.ToString() + " to a node")
0000000000000000000000000000000000000000;;				runKubectlRetryOrDie("taint", "nodes", nodeName, testTaint.ToString())
0000000000000000000000000000000000000000;;				defer framework.RemoveTaintOffNode(f.ClientSet, nodeName, testTaint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the node has the taint " + testTaint.ToString())
0000000000000000000000000000000000000000;;				output := runKubectlRetryOrDie("describe", "node", nodeName)
0000000000000000000000000000000000000000;;				requiredStrings := [][]string{
0000000000000000000000000000000000000000;;					{"Name:", nodeName},
0000000000000000000000000000000000000000;;					{"Taints:"},
0000000000000000000000000000000000000000;;					{testTaint.ToString()},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				checkOutput(output, requiredStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("removing the taint " + testTaint.ToString() + " of a node")
0000000000000000000000000000000000000000;;				runKubectlRetryOrDie("taint", "nodes", nodeName, testTaint.Key+":"+string(testTaint.Effect)+"-")
0000000000000000000000000000000000000000;;				By("verifying the node doesn't have the taint " + testTaint.Key)
0000000000000000000000000000000000000000;;				output = runKubectlRetryOrDie("describe", "node", nodeName)
0000000000000000000000000000000000000000;;				if strings.Contains(output, testTaint.Key) {
0000000000000000000000000000000000000000;;					framework.Failf("Failed removing taint " + testTaint.Key + " of the node " + nodeName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should remove all the taints with the same key off a node", func() {
0000000000000000000000000000000000000000;;				testTaint := v1.Taint{
0000000000000000000000000000000000000000;;					Key:    fmt.Sprintf("kubernetes.io/e2e-taint-key-002-%s", string(uuid.NewUUID())),
0000000000000000000000000000000000000000;;					Value:  "testing-taint-value",
0000000000000000000000000000000000000000;;					Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nodeName := scheduling.GetNodeThatCanRunPod(f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("adding the taint " + testTaint.ToString() + " to a node")
0000000000000000000000000000000000000000;;				runKubectlRetryOrDie("taint", "nodes", nodeName, testTaint.ToString())
0000000000000000000000000000000000000000;;				defer framework.RemoveTaintOffNode(f.ClientSet, nodeName, testTaint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the node has the taint " + testTaint.ToString())
0000000000000000000000000000000000000000;;				output := runKubectlRetryOrDie("describe", "node", nodeName)
0000000000000000000000000000000000000000;;				requiredStrings := [][]string{
0000000000000000000000000000000000000000;;					{"Name:", nodeName},
0000000000000000000000000000000000000000;;					{"Taints:"},
0000000000000000000000000000000000000000;;					{testTaint.ToString()},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				checkOutput(output, requiredStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				newTestTaint := v1.Taint{
0000000000000000000000000000000000000000;;					Key:    testTaint.Key,
0000000000000000000000000000000000000000;;					Value:  "another-testing-taint-value",
0000000000000000000000000000000000000000;;					Effect: v1.TaintEffectPreferNoSchedule,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("adding another taint " + newTestTaint.ToString() + " to the node")
0000000000000000000000000000000000000000;;				runKubectlRetryOrDie("taint", "nodes", nodeName, newTestTaint.ToString())
0000000000000000000000000000000000000000;;				defer framework.RemoveTaintOffNode(f.ClientSet, nodeName, newTestTaint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the node has the taint " + newTestTaint.ToString())
0000000000000000000000000000000000000000;;				output = runKubectlRetryOrDie("describe", "node", nodeName)
0000000000000000000000000000000000000000;;				requiredStrings = [][]string{
0000000000000000000000000000000000000000;;					{"Name:", nodeName},
0000000000000000000000000000000000000000;;					{"Taints:"},
0000000000000000000000000000000000000000;;					{newTestTaint.ToString()},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				checkOutput(output, requiredStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				noExecuteTaint := v1.Taint{
0000000000000000000000000000000000000000;;					Key:    testTaint.Key,
0000000000000000000000000000000000000000;;					Value:  "testing-taint-value-no-execute",
0000000000000000000000000000000000000000;;					Effect: v1.TaintEffectNoExecute,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("adding NoExecute taint " + noExecuteTaint.ToString() + " to the node")
0000000000000000000000000000000000000000;;				runKubectlRetryOrDie("taint", "nodes", nodeName, noExecuteTaint.ToString())
0000000000000000000000000000000000000000;;				defer framework.RemoveTaintOffNode(f.ClientSet, nodeName, noExecuteTaint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying the node has the taint " + noExecuteTaint.ToString())
0000000000000000000000000000000000000000;;				output = runKubectlRetryOrDie("describe", "node", nodeName)
0000000000000000000000000000000000000000;;				requiredStrings = [][]string{
0000000000000000000000000000000000000000;;					{"Name:", nodeName},
0000000000000000000000000000000000000000;;					{"Taints:"},
0000000000000000000000000000000000000000;;					{noExecuteTaint.ToString()},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				checkOutput(output, requiredStrings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("removing all taints that have the same key " + testTaint.Key + " of the node")
0000000000000000000000000000000000000000;;				runKubectlRetryOrDie("taint", "nodes", nodeName, testTaint.Key+"-")
0000000000000000000000000000000000000000;;				By("verifying the node doesn't have the taints that have the same key " + testTaint.Key)
0000000000000000000000000000000000000000;;				output = runKubectlRetryOrDie("describe", "node", nodeName)
0000000000000000000000000000000000000000;;				if strings.Contains(output, testTaint.Key) {
0000000000000000000000000000000000000000;;					framework.Failf("Failed removing taints " + testTaint.Key + " of the node " + nodeName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Kubectl create quota", func() {
0000000000000000000000000000000000000000;;			It("should create a quota without scopes", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessKubectlVersionGTE(kubectlCreateQuotaVersion)
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				quotaName := "million"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("calling kubectl quota")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("create", "quota", quotaName, "--hard=pods=1000000,services=1000000", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying that the quota was created")
0000000000000000000000000000000000000000;;				quota, err := c.Core().ResourceQuotas(ns).Get(quotaName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting quota %s: %v", quotaName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(quota.Spec.Scopes) != 0 {
0000000000000000000000000000000000000000;;					framework.Failf("Expected empty scopes, got %v", quota.Spec.Scopes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(quota.Spec.Hard) != 2 {
0000000000000000000000000000000000000000;;					framework.Failf("Expected two resources, got %v", quota.Spec.Hard)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r, found := quota.Spec.Hard[v1.ResourcePods]
0000000000000000000000000000000000000000;;				if expected := resource.MustParse("1000000"); !found || (&r).Cmp(expected) != 0 {
0000000000000000000000000000000000000000;;					framework.Failf("Expected pods=1000000, got %v", r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r, found = quota.Spec.Hard[v1.ResourceServices]
0000000000000000000000000000000000000000;;				if expected := resource.MustParse("1000000"); !found || (&r).Cmp(expected) != 0 {
0000000000000000000000000000000000000000;;					framework.Failf("Expected services=1000000, got %v", r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create a quota with scopes", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessKubectlVersionGTE(kubectlCreateQuotaVersion)
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				quotaName := "scopes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("calling kubectl quota")
0000000000000000000000000000000000000000;;				framework.RunKubectlOrDie("create", "quota", quotaName, "--hard=pods=1000000", "--scopes=BestEffort,NotTerminating", nsFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying that the quota was created")
0000000000000000000000000000000000000000;;				quota, err := c.Core().ResourceQuotas(ns).Get(quotaName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed getting quota %s: %v", quotaName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(quota.Spec.Scopes) != 2 {
0000000000000000000000000000000000000000;;					framework.Failf("Expected two scopes, got %v", quota.Spec.Scopes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				scopes := make(map[v1.ResourceQuotaScope]struct{})
0000000000000000000000000000000000000000;;				for _, scope := range quota.Spec.Scopes {
0000000000000000000000000000000000000000;;					scopes[scope] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, found := scopes[v1.ResourceQuotaScopeBestEffort]; !found {
0000000000000000000000000000000000000000;;					framework.Failf("Expected BestEffort scope, got %v", quota.Spec.Scopes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, found := scopes[v1.ResourceQuotaScopeNotTerminating]; !found {
0000000000000000000000000000000000000000;;					framework.Failf("Expected NotTerminating scope, got %v", quota.Spec.Scopes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should reject quota with invalid scopes", func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessKubectlVersionGTE(kubectlCreateQuotaVersion)
0000000000000000000000000000000000000000;;				nsFlag := fmt.Sprintf("--namespace=%v", ns)
0000000000000000000000000000000000000000;;				quotaName := "scopes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("calling kubectl quota")
0000000000000000000000000000000000000000;;				out, err := framework.RunKubectl("create", "quota", quotaName, "--hard=hard=pods=1000000", "--scopes=Foo", nsFlag)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					framework.Failf("Expected kubectl to fail, but it succeeded: %s", out)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks whether the output split by line contains the required elements.
0000000000000000000000000000000000000000;;	func checkOutputReturnError(output string, required [][]string) error {
0000000000000000000000000000000000000000;;		outputLines := strings.Split(output, "\n")
0000000000000000000000000000000000000000;;		currentLine := 0
0000000000000000000000000000000000000000;;		for _, requirement := range required {
0000000000000000000000000000000000000000;;			for currentLine < len(outputLines) && !strings.Contains(outputLines[currentLine], requirement[0]) {
0000000000000000000000000000000000000000;;				currentLine++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if currentLine == len(outputLines) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to find %s in %s", requirement[0], output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, item := range requirement[1:] {
0000000000000000000000000000000000000000;;				if !strings.Contains(outputLines[currentLine], item) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to find %s in %s", item, outputLines[currentLine])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkOutput(output string, required [][]string) {
0000000000000000000000000000000000000000;;		err := checkOutputReturnError(output, required)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkKubectlOutputWithRetry(required [][]string, args ...string) {
0000000000000000000000000000000000000000;;		var pollErr error
0000000000000000000000000000000000000000;;		wait.PollImmediate(time.Second, time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			output := framework.RunKubectlOrDie(args...)
0000000000000000000000000000000000000000;;			err := checkOutputReturnError(output, required)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				pollErr = err
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pollErr = nil
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if pollErr != nil {
0000000000000000000000000000000000000000;;			framework.Failf("%v", pollErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAPIVersions(apiEndpoint string) (*metav1.APIVersions, error) {
0000000000000000000000000000000000000000;;		body, err := curl(apiEndpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed http.Get of %s: %v", apiEndpoint, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var apiVersions metav1.APIVersions
0000000000000000000000000000000000000000;;		if err := json.Unmarshal([]byte(body), &apiVersions); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed to parse /api output %s: %v", body, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &apiVersions, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startProxyServer() (int, *exec.Cmd, error) {
0000000000000000000000000000000000000000;;		// Specifying port 0 indicates we want the os to pick a random port.
0000000000000000000000000000000000000000;;		cmd := framework.KubectlCmd("proxy", "-p", "0")
0000000000000000000000000000000000000000;;		stdout, stderr, err := framework.StartCmdAndStreamOutput(cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer stdout.Close()
0000000000000000000000000000000000000000;;		defer stderr.Close()
0000000000000000000000000000000000000000;;		buf := make([]byte, 128)
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		if n, err = stdout.Read(buf); err != nil {
0000000000000000000000000000000000000000;;			return -1, cmd, fmt.Errorf("Failed to read from kubectl proxy stdout: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := string(buf[:n])
0000000000000000000000000000000000000000;;		match := proxyRegexp.FindStringSubmatch(output)
0000000000000000000000000000000000000000;;		if len(match) == 2 {
0000000000000000000000000000000000000000;;			if port, err := strconv.Atoi(match[1]); err == nil {
0000000000000000000000000000000000000000;;				return port, cmd, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, cmd, fmt.Errorf("Failed to parse port from proxy stdout: %s", output)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func curlUnix(url string, path string) (string, error) {
0000000000000000000000000000000000000000;;		dial := func(proto, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;			return net.Dial("unix", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		transport := utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Dial: dial,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return curlTransport(url, transport)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func curlTransport(url string, transport *http.Transport) (string, error) {
0000000000000000000000000000000000000000;;		client := &http.Client{Transport: transport}
0000000000000000000000000000000000000000;;		resp, err := client.Get(url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(body[:]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func curl(url string) (string, error) {
0000000000000000000000000000000000000000;;		return curlTransport(url, utilnet.SetTransportDefaults(&http.Transport{}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateGuestbookApp(c clientset.Interface, ns string) {
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for all frontend pods to be Running.")
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{"tier": "frontend", "app": "guestbook"}))
0000000000000000000000000000000000000000;;		err := testutils.WaitForPodsWithLabelRunning(c, ns, label)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for frontend to serve content.")
0000000000000000000000000000000000000000;;		if !waitForGuestbookResponse(c, "get", "", `{"data": ""}`, guestbookStartupTimeout, ns) {
0000000000000000000000000000000000000000;;			framework.Failf("Frontend service did not start serving content in %v seconds.", guestbookStartupTimeout.Seconds())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Trying to add a new entry to the guestbook.")
0000000000000000000000000000000000000000;;		if !waitForGuestbookResponse(c, "set", "TestEntry", `{"message": "Updated"}`, guestbookResponseTimeout, ns) {
0000000000000000000000000000000000000000;;			framework.Failf("Cannot added new entry in %v seconds.", guestbookResponseTimeout.Seconds())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Verifying that added entry can be retrieved.")
0000000000000000000000000000000000000000;;		if !waitForGuestbookResponse(c, "get", "", `{"data": "TestEntry"}`, guestbookResponseTimeout, ns) {
0000000000000000000000000000000000000000;;			framework.Failf("Entry to guestbook wasn't correctly added in %v seconds.", guestbookResponseTimeout.Seconds())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns whether received expected response from guestbook on time.
0000000000000000000000000000000000000000;;	func waitForGuestbookResponse(c clientset.Interface, cmd, arg, expectedResponse string, timeout time.Duration, ns string) bool {
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < timeout; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;			res, err := makeRequestToGuestbook(c, cmd, arg, ns)
0000000000000000000000000000000000000000;;			if err == nil && res == expectedResponse {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Failed to get response from guestbook. err: %v, response: %s", err, res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeRequestToGuestbook(c clientset.Interface, cmd, value string, ns string) (string, error) {
0000000000000000000000000000000000000000;;		proxyRequest, errProxy := framework.GetServicesProxyRequest(c, c.Core().RESTClient().Get())
0000000000000000000000000000000000000000;;		if errProxy != nil {
0000000000000000000000000000000000000000;;			return "", errProxy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), framework.SingleCallTimeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err := proxyRequest.Namespace(ns).
0000000000000000000000000000000000000000;;			Context(ctx).
0000000000000000000000000000000000000000;;			Name("frontend").
0000000000000000000000000000000000000000;;			Suffix("/guestbook.php").
0000000000000000000000000000000000000000;;			Param("cmd", cmd).
0000000000000000000000000000000000000000;;			Param("key", "messages").
0000000000000000000000000000000000000000;;			Param("value", value).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Raw()
0000000000000000000000000000000000000000;;		return string(result), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateDemoData struct {
0000000000000000000000000000000000000000;;		Image string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const applyTestLabel = "kubectl.kubernetes.io/apply-test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readBytesFromFile(filename string) []byte {
0000000000000000000000000000000000000000;;		file, err := os.Open(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readReplicationControllerFromString(contents string) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		rc := v1.ReplicationController{}
0000000000000000000000000000000000000000;;		if err := yaml.Unmarshal([]byte(contents), &rc); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func modifyReplicationControllerConfiguration(contents string) io.Reader {
0000000000000000000000000000000000000000;;		rc := readReplicationControllerFromString(contents)
0000000000000000000000000000000000000000;;		rc.Labels[applyTestLabel] = "ADDED"
0000000000000000000000000000000000000000;;		rc.Spec.Selector[applyTestLabel] = "ADDED"
0000000000000000000000000000000000000000;;		rc.Spec.Template.Labels[applyTestLabel] = "ADDED"
0000000000000000000000000000000000000000;;		data, err := json.Marshal(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("json marshal failed: %s\n", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return bytes.NewReader(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func forEachReplicationController(c clientset.Interface, ns, selectorKey, selectorValue string, fn func(v1.ReplicationController)) {
0000000000000000000000000000000000000000;;		var rcs *v1.ReplicationControllerList
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for t := time.Now(); time.Since(t) < framework.PodListTimeout; time.Sleep(framework.Poll) {
0000000000000000000000000000000000000000;;			label := labels.SelectorFromSet(labels.Set(map[string]string{selectorKey: selectorValue}))
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;			rcs, err = c.Core().ReplicationControllers(ns).List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			if len(rcs.Items) > 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rcs == nil || len(rcs.Items) == 0 {
0000000000000000000000000000000000000000;;			framework.Failf("No replication controllers found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rc := range rcs.Items {
0000000000000000000000000000000000000000;;			fn(rc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateReplicationControllerConfiguration(rc v1.ReplicationController) {
0000000000000000000000000000000000000000;;		if rc.Name == "redis-master" {
0000000000000000000000000000000000000000;;			if _, ok := rc.Annotations[v1.LastAppliedConfigAnnotation]; !ok {
0000000000000000000000000000000000000000;;				framework.Failf("Annotation not found in modified configuration:\n%v\n", rc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if value, ok := rc.Labels[applyTestLabel]; !ok || value != "ADDED" {
0000000000000000000000000000000000000000;;				framework.Failf("Added label %s not found in modified configuration:\n%v\n", applyTestLabel, rc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getUDData creates a validator function based on the input string (i.e. kitten.jpg).
0000000000000000000000000000000000000000;;	// For example, if you send "kitten.jpg", this function verifies that the image jpg = kitten.jpg
0000000000000000000000000000000000000000;;	// in the container's json field.
0000000000000000000000000000000000000000;;	func getUDData(jpgExpected string, ns string) func(clientset.Interface, string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// getUDData validates data.json in the update-demo (returns nil if data is ok).
0000000000000000000000000000000000000000;;		return func(c clientset.Interface, podID string) error {
0000000000000000000000000000000000000000;;			framework.Logf("validating pod %s", podID)
0000000000000000000000000000000000000000;;			subResourceProxyAvailable, err := framework.ServerVersionGTE(framework.SubResourcePodProxyVersion, c.Discovery())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithTimeout(context.Background(), framework.SingleCallTimeout)
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var body []byte
0000000000000000000000000000000000000000;;			if subResourceProxyAvailable {
0000000000000000000000000000000000000000;;				body, err = c.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;					Namespace(ns).
0000000000000000000000000000000000000000;;					Resource("pods").
0000000000000000000000000000000000000000;;					SubResource("proxy").
0000000000000000000000000000000000000000;;					Name(podID).
0000000000000000000000000000000000000000;;					Suffix("data.json").
0000000000000000000000000000000000000000;;					Do().
0000000000000000000000000000000000000000;;					Raw()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				body, err = c.Core().RESTClient().Get().
0000000000000000000000000000000000000000;;					Prefix("proxy").
0000000000000000000000000000000000000000;;					Namespace(ns).
0000000000000000000000000000000000000000;;					Resource("pods").
0000000000000000000000000000000000000000;;					Name(podID).
0000000000000000000000000000000000000000;;					Suffix("data.json").
0000000000000000000000000000000000000000;;					Do().
0000000000000000000000000000000000000000;;					Raw()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if ctx.Err() != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to retrieve data from container: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("got data: %s", body)
0000000000000000000000000000000000000000;;			var data updateDemoData
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(body, &data); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Unmarshalled json jpg/img => %s , expecting %s .", data, jpgExpected)
0000000000000000000000000000000000000000;;			if strings.Contains(data.Image, jpgExpected) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("data served up in container is inaccurate, %s didn't contain %s", data, jpgExpected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func noOpValidatorFn(c clientset.Interface, podID string) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newBlockingReader returns a reader that allows reading the given string,
0000000000000000000000000000000000000000;;	// then blocks until Close() is called on the returned closer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We're explicitly returning the reader and closer separately, because
0000000000000000000000000000000000000000;;	// the closer needs to be the *os.File we get from os.Pipe(). This is required
0000000000000000000000000000000000000000;;	// so the exec of kubectl can pass the underlying file descriptor to the exec
0000000000000000000000000000000000000000;;	// syscall, instead of creating another os.Pipe and blocking on the io.Copy
0000000000000000000000000000000000000000;;	// between the source (e.g. stdin) and the write half of the pipe.
0000000000000000000000000000000000000000;;	func newBlockingReader(s string) (io.Reader, io.Closer, error) {
0000000000000000000000000000000000000000;;		r, w, err := os.Pipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write([]byte(s))
0000000000000000000000000000000000000000;;		return r, w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newStreamingUpload creates a new http.Request that will stream POST
0000000000000000000000000000000000000000;;	// a file to a URI.
0000000000000000000000000000000000000000;;	func newStreamingUpload(filePath string) (*io.PipeReader, *multipart.Writer, error) {
0000000000000000000000000000000000000000;;		file, err := os.Open(filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, w := io.Pipe()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		postBodyWriter := multipart.NewWriter(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go streamingUpload(file, filepath.Base(filePath), postBodyWriter, w)
0000000000000000000000000000000000000000;;		return r, postBodyWriter, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamingUpload streams a file via a pipe through a multipart.Writer.
0000000000000000000000000000000000000000;;	// Generally one should use newStreamingUpload instead of calling this directly.
0000000000000000000000000000000000000000;;	func streamingUpload(file *os.File, fileName string, postBodyWriter *multipart.Writer, w *io.PipeWriter) {
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		defer w.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up the form file
0000000000000000000000000000000000000000;;		fileWriter, err := postBodyWriter.CreateFormFile("file", fileName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Unable to to write file at %s to buffer. Error: %s", fileName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy kubectl binary into the file writer
0000000000000000000000000000000000000000;;		if _, err := io.Copy(fileWriter, file); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Unable to to copy file at %s into the file writer. Error: %s", fileName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nothing more should be written to this instance of the postBodyWriter
0000000000000000000000000000000000000000;;		if err := postBodyWriter.Close(); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Unable to close the writer for file upload. Error: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startLocalProxy() (srv *httptest.Server, logs *bytes.Buffer) {
0000000000000000000000000000000000000000;;		logs = &bytes.Buffer{}
0000000000000000000000000000000000000000;;		p := goproxy.NewProxyHttpServer()
0000000000000000000000000000000000000000;;		p.Verbose = true
0000000000000000000000000000000000000000;;		p.Logger = log.New(logs, "", 0)
0000000000000000000000000000000000000000;;		return httptest.NewServer(p), logs
0000000000000000000000000000000000000000;;	}
