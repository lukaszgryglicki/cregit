0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
432a7004abea09fed4c2fd7f38a64159a46071e5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/networking"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	The following Network Policy tests verify that policy object definitions
0000000000000000000000000000000000000000;;	are correctly enforced by a networking plugin. It accomplishes this by launching
0000000000000000000000000000000000000000;;	a simple netcat server, and two clients with different
0000000000000000000000000000000000000000;;	attributes. Each test case creates a network policy which should only allow
0000000000000000000000000000000000000000;;	connections from one of the clients. The test then asserts that the clients
0000000000000000000000000000000000000000;;	failed or succesfully connected as expected.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("NetworkPolicy", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("network-policy")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support a 'default-deny' policy [Feature:NetworkPolicy]", func() {
0000000000000000000000000000000000000000;;			ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Create a simple server.")
0000000000000000000000000000000000000000;;			podServer, service := createServerPodAndService(f, ns, "server", []int{80})
0000000000000000000000000000000000000000;;			defer cleanupServerPodAndService(f, podServer, service)
0000000000000000000000000000000000000000;;			framework.Logf("Waiting for Server to come up.")
0000000000000000000000000000000000000000;;			err := framework.WaitForPodRunningInNamespace(f.ClientSet, podServer)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a pod with name 'client-can-connect', which should be able to communicate with server.
0000000000000000000000000000000000000000;;			By("Creating client which will be able to contact the server since no policies are present.")
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "client-can-connect", service, 80)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a network policy denying all traffic.")
0000000000000000000000000000000000000000;;			policy := &networking.NetworkPolicy{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "deny-all",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{},
0000000000000000000000000000000000000000;;					Ingress:     []networking.NetworkPolicyIngressRule{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			policy, err = f.InternalClientset.Networking().NetworkPolicies(ns.Name).Create(policy)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer cleanupNetworkPolicy(f, policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a pod with name 'client-cannot-connect', which will attempt to comunicate with the server,
0000000000000000000000000000000000000000;;			// but should not be able to now that isolation is on.
0000000000000000000000000000000000000000;;			testCannotConnect(f, ns, "client-cannot-connect", service, 80)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should enforce policy based on PodSelector [Feature:NetworkPolicy]", func() {
0000000000000000000000000000000000000000;;			ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a simple server.")
0000000000000000000000000000000000000000;;			serverPod, service := createServerPodAndService(f, ns, "server", []int{80})
0000000000000000000000000000000000000000;;			defer cleanupServerPodAndService(f, serverPod, service)
0000000000000000000000000000000000000000;;			framework.Logf("Waiting for Server to come up.")
0000000000000000000000000000000000000000;;			err := framework.WaitForPodRunningInNamespace(f.ClientSet, serverPod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a network policy for the server which allows traffic from the pod 'client-a'.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			policy := &networking.NetworkPolicy{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "allow-client-a-via-pod-selector",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					// Apply this policy to the Server
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"pod-name": serverPod.Name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// Allow traffic only from client-a
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{{
0000000000000000000000000000000000000000;;						From: []networking.NetworkPolicyPeer{{
0000000000000000000000000000000000000000;;							PodSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;									"pod-name": "client-a",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			policy, err = f.InternalClientset.Networking().NetworkPolicies(ns.Name).Create(policy)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer cleanupNetworkPolicy(f, policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating client-a which should be able to contact the server.")
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "client-a", service, 80)
0000000000000000000000000000000000000000;;			testCannotConnect(f, ns, "client-b", service, 80)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should enforce policy based on Ports [Feature:NetworkPolicy]", func() {
0000000000000000000000000000000000000000;;			ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create Server with Service
0000000000000000000000000000000000000000;;			By("Creating a simple server.")
0000000000000000000000000000000000000000;;			serverPod, service := createServerPodAndService(f, ns, "server", []int{80, 81})
0000000000000000000000000000000000000000;;			defer cleanupServerPodAndService(f, serverPod, service)
0000000000000000000000000000000000000000;;			framework.Logf("Waiting for Server to come up.")
0000000000000000000000000000000000000000;;			err := framework.WaitForPodRunningInNamespace(f.ClientSet, serverPod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Testing pods can connect to both ports when no policy is present.")
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "basecase-reachable-80", service, 80)
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "basecase-reachable-81", service, 81)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a network policy for the Service which allows traffic only to one port.")
0000000000000000000000000000000000000000;;			policy := &networking.NetworkPolicy{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "allow-ingress-on-port-81",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					// Apply to server
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"pod-name": serverPod.Name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// Allow traffic only to one port.
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{{
0000000000000000000000000000000000000000;;						Ports: []networking.NetworkPolicyPort{{
0000000000000000000000000000000000000000;;							Port: &intstr.IntOrString{IntVal: 81},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			policy, err = f.InternalClientset.Networking().NetworkPolicies(ns.Name).Create(policy)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer cleanupNetworkPolicy(f, policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Testing pods can connect only to the port allowed by the policy.")
0000000000000000000000000000000000000000;;			testCannotConnect(f, ns, "client-a", service, 80)
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "client-b", service, 81)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should enforce multiple, stacked policies with overlapping podSelectors [Feature:NetworkPolicy]", func() {
0000000000000000000000000000000000000000;;			ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create Server with Service
0000000000000000000000000000000000000000;;			By("Creating a simple server.")
0000000000000000000000000000000000000000;;			serverPod, service := createServerPodAndService(f, ns, "server", []int{80, 81})
0000000000000000000000000000000000000000;;			defer cleanupServerPodAndService(f, serverPod, service)
0000000000000000000000000000000000000000;;			framework.Logf("Waiting for Server to come up.")
0000000000000000000000000000000000000000;;			err := framework.WaitForPodRunningInNamespace(f.ClientSet, serverPod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Testing pods can connect to both ports when no policy is present.")
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "test-a", service, 80)
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "test-b", service, 81)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a network policy for the Service which allows traffic only to one port.")
0000000000000000000000000000000000000000;;			policy := &networking.NetworkPolicy{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "allow-ingress-on-port-80",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					// Apply to server
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"pod-name": serverPod.Name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// Allow traffic only to one port.
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{{
0000000000000000000000000000000000000000;;						Ports: []networking.NetworkPolicyPort{{
0000000000000000000000000000000000000000;;							Port: &intstr.IntOrString{IntVal: 80},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			policy, err = f.InternalClientset.Networking().NetworkPolicies(ns.Name).Create(policy)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer cleanupNetworkPolicy(f, policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a network policy for the Service which allows traffic only to another port.")
0000000000000000000000000000000000000000;;			policy2 := &networking.NetworkPolicy{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "allow-ingress-on-port-81",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					// Apply to server
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"pod-name": serverPod.Name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// Allow traffic only to one port.
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{{
0000000000000000000000000000000000000000;;						Ports: []networking.NetworkPolicyPort{{
0000000000000000000000000000000000000000;;							Port: &intstr.IntOrString{IntVal: 81},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			policy2, err = f.InternalClientset.Networking().NetworkPolicies(ns.Name).Create(policy2)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer cleanupNetworkPolicy(f, policy2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Testing pods can connect to both ports when both policies are present.")
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "client-a", service, 80)
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "client-b", service, 81)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support allow-all policy [Feature:NetworkPolicy]", func() {
0000000000000000000000000000000000000000;;			ns := f.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create Server with Service
0000000000000000000000000000000000000000;;			By("Creating a simple server.")
0000000000000000000000000000000000000000;;			serverPod, service := createServerPodAndService(f, ns, "server", []int{80, 81})
0000000000000000000000000000000000000000;;			defer cleanupServerPodAndService(f, serverPod, service)
0000000000000000000000000000000000000000;;			framework.Logf("Waiting for Server to come up.")
0000000000000000000000000000000000000000;;			err := framework.WaitForPodRunningInNamespace(f.ClientSet, serverPod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Testing pods can connect to both ports when no policy is present.")
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "test-a", service, 80)
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "test-b", service, 81)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a network policy which allows all traffic.")
0000000000000000000000000000000000000000;;			policy := &networking.NetworkPolicy{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "allow-all",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					// Allow all traffic
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{{}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			policy, err = f.InternalClientset.Networking().NetworkPolicies(ns.Name).Create(policy)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer cleanupNetworkPolicy(f, policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Testing pods can connect to both ports when an 'allow-all' policy is present.")
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "client-a", service, 80)
0000000000000000000000000000000000000000;;			testCanConnect(f, ns, "client-b", service, 81)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should enforce policy based on NamespaceSelector [Feature:NetworkPolicy]", func() {
0000000000000000000000000000000000000000;;			nsA := f.Namespace
0000000000000000000000000000000000000000;;			nsBName := f.BaseName + "-b"
0000000000000000000000000000000000000000;;			// The CreateNamespace helper uses the input name as a Name Generator, so the namespace itself
0000000000000000000000000000000000000000;;			// will have a different name than what we are setting as the value of ns-name.
0000000000000000000000000000000000000000;;			// This is fine as long as we don't try to match the label as nsB.Name in our policy.
0000000000000000000000000000000000000000;;			nsB, err := f.CreateNamespace(nsBName, map[string]string{
0000000000000000000000000000000000000000;;				"ns-name": nsBName,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create Server with Service in NS-B
0000000000000000000000000000000000000000;;			By("Creating a webserver tied to a service.")
0000000000000000000000000000000000000000;;			serverPod, service := createServerPodAndService(f, nsA, "server", []int{80})
0000000000000000000000000000000000000000;;			defer cleanupServerPodAndService(f, serverPod, service)
0000000000000000000000000000000000000000;;			framework.Logf("Waiting for server to come up.")
0000000000000000000000000000000000000000;;			err = framework.WaitForPodRunningInNamespace(f.ClientSet, serverPod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create Policy for that service that allows traffic only via namespace B
0000000000000000000000000000000000000000;;			By("Creating a network policy for the server which allows traffic from namespace-b.")
0000000000000000000000000000000000000000;;			policy := &networking.NetworkPolicy{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "allow-ns-b-via-namespace-selector",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: networking.NetworkPolicySpec{
0000000000000000000000000000000000000000;;					// Apply to server
0000000000000000000000000000000000000000;;					PodSelector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;							"pod-name": serverPod.Name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// Allow traffic only from NS-B
0000000000000000000000000000000000000000;;					Ingress: []networking.NetworkPolicyIngressRule{{
0000000000000000000000000000000000000000;;						From: []networking.NetworkPolicyPeer{{
0000000000000000000000000000000000000000;;							NamespaceSelector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;								MatchLabels: map[string]string{
0000000000000000000000000000000000000000;;									"ns-name": nsBName,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			policy, err = f.InternalClientset.Networking().NetworkPolicies(nsA.Name).Create(policy)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer cleanupNetworkPolicy(f, policy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testCannotConnect(f, nsA, "client-a", service, 80)
0000000000000000000000000000000000000000;;			testCanConnect(f, nsB, "client-b", service, 80)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testCanConnect(f *framework.Framework, ns *v1.Namespace, podName string, service *v1.Service, targetPort int) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating client pod %s that should successfully connect to %s.", podName, service.Name))
0000000000000000000000000000000000000000;;		podClient := createNetworkClientPod(f, ns, podName, service, targetPort)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Cleaning up the pod %s", podName))
0000000000000000000000000000000000000000;;			if err := f.ClientSet.Core().Pods(ns.Name).Delete(podClient.Name, nil); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to cleanup pod %v: %v", podClient.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for %s to complete.", podClient.Name)
0000000000000000000000000000000000000000;;		err := framework.WaitForPodNoLongerRunningInNamespace(f.ClientSet, podClient.Name, ns.Name)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "Pod did not finish as expected.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for %s to complete.", podClient.Name)
0000000000000000000000000000000000000000;;		err = framework.WaitForPodSuccessInNamespace(f.ClientSet, podClient.Name, ns.Name)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("checking %s could communicate with server.", podClient.Name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testCannotConnect(f *framework.Framework, ns *v1.Namespace, podName string, service *v1.Service, targetPort int) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating client pod %s that should not be able to connect to %s.", podName, service.Name))
0000000000000000000000000000000000000000;;		podClient := createNetworkClientPod(f, ns, podName, service, targetPort)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Cleaning up the pod %s", podName))
0000000000000000000000000000000000000000;;			if err := f.ClientSet.Core().Pods(ns.Name).Delete(podClient.Name, nil); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("unable to cleanup pod %v: %v", podClient.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for %s to complete.", podClient.Name)
0000000000000000000000000000000000000000;;		err := framework.WaitForPodSuccessInNamespace(f.ClientSet, podClient.Name, ns.Name)
0000000000000000000000000000000000000000;;		Expect(err).To(HaveOccurred(), fmt.Sprintf("checking %s could not communicate with server.", podName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a server pod with a listening container for each port in ports[].
0000000000000000000000000000000000000000;;	// Will also assign a pod label with key: "pod-name" and label set to the given podname for later use by the network
0000000000000000000000000000000000000000;;	// policy.
0000000000000000000000000000000000000000;;	func createServerPodAndService(f *framework.Framework, namespace *v1.Namespace, podName string, ports []int) (*v1.Pod, *v1.Service) {
0000000000000000000000000000000000000000;;		// Because we have a variable amount of ports, we'll first loop through and generate our Containers for our pod,
0000000000000000000000000000000000000000;;		// and ServicePorts.for our Service.
0000000000000000000000000000000000000000;;		containers := []v1.Container{}
0000000000000000000000000000000000000000;;		servicePorts := []v1.ServicePort{}
0000000000000000000000000000000000000000;;		for _, port := range ports {
0000000000000000000000000000000000000000;;			// Build the containers for the server pod.
0000000000000000000000000000000000000000;;			containers = append(containers, v1.Container{
0000000000000000000000000000000000000000;;				Name:  fmt.Sprintf("%s-container-%d", podName, port),
0000000000000000000000000000000000000000;;				Image: "gcr.io/google_containers/redis:e2e",
0000000000000000000000000000000000000000;;				Args: []string{
0000000000000000000000000000000000000000;;					"/bin/sh",
0000000000000000000000000000000000000000;;					"-c",
0000000000000000000000000000000000000000;;					fmt.Sprintf("/bin/nc -kl %d", port),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Ports: []v1.ContainerPort{{ContainerPort: int32(port)}},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Build the Service Ports for the service.
0000000000000000000000000000000000000000;;			servicePorts = append(servicePorts, v1.ServicePort{
0000000000000000000000000000000000000000;;				Name:       fmt.Sprintf("%s-%d", podName, port),
0000000000000000000000000000000000000000;;				Port:       int32(port),
0000000000000000000000000000000000000000;;				TargetPort: intstr.FromInt(port),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating a server pod %s in namespace %s", podName, namespace.Name))
0000000000000000000000000000000000000000;;		pod, err := f.ClientSet.Core().Pods(namespace.Name).Create(&v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"pod-name": podName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers:    containers,
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Created pod %v", pod.ObjectMeta.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcName := fmt.Sprintf("svc-%s", podName)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating a service %s for pod %s in namespace %s", svcName, podName, namespace.Name))
0000000000000000000000000000000000000000;;		svc, err := f.ClientSet.Core().Services(namespace.Name).Create(&v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: svcName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: servicePorts,
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"pod-name": podName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Created service %s", svc.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod, svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cleanupServerPodAndService(f *framework.Framework, pod *v1.Pod, service *v1.Service) {
0000000000000000000000000000000000000000;;		By("Cleaning up the server.")
0000000000000000000000000000000000000000;;		if err := f.ClientSet.Core().Pods(pod.Namespace).Delete(pod.Name, nil); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to cleanup pod %v: %v", pod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By("Cleaning up the server's service.")
0000000000000000000000000000000000000000;;		if err := f.ClientSet.Core().Services(service.Namespace).Delete(service.Name, nil); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to cleanup svc %v: %v", service.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a client pod which will attempt a netcat to the provided service, on the specified port.
0000000000000000000000000000000000000000;;	// This client will attempt a oneshot connection, then die, without restarting the pod.
0000000000000000000000000000000000000000;;	// Test can then be asserted based on whether the pod quit with an error or not.
0000000000000000000000000000000000000000;;	func createNetworkClientPod(f *framework.Framework, namespace *v1.Namespace, podName string, targetService *v1.Service, targetPort int) *v1.Pod {
0000000000000000000000000000000000000000;;		pod, err := f.ClientSet.Core().Pods(namespace.Name).Create(&v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"pod-name": podName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  fmt.Sprintf("%s-container", podName),
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/redis:e2e",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"/bin/sh",
0000000000000000000000000000000000000000;;							"-c",
0000000000000000000000000000000000000000;;							fmt.Sprintf("/usr/bin/printf dummy-data | /bin/nc -w 8 %s.%s %d", targetService.Name, targetService.Namespace, targetPort),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cleanupNetworkPolicy(f *framework.Framework, policy *networking.NetworkPolicy) {
0000000000000000000000000000000000000000;;		By("Cleaning up the policy.")
0000000000000000000000000000000000000000;;		if err := f.InternalClientset.Networking().NetworkPolicies(policy.Namespace).Delete(policy.Name, nil); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("unable to cleanup policy %v: %v", policy.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
