0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
faa0267984391a10dd826cd4dcbcb8a8bb72d468;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/workload"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Etcd failure [Disruptive]", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("etcd-failure")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			// This test requires:
0000000000000000000000000000000000000000;;			// - SSH
0000000000000000000000000000000000000000;;			// - master access
0000000000000000000000000000000000000000;;			// ... so the provider check should be identical to the intersection of
0000000000000000000000000000000000000000;;			// providers that provide those capabilities.
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Expect(framework.RunRC(testutils.RCConfig{
0000000000000000000000000000000000000000;;				Client:    f.ClientSet,
0000000000000000000000000000000000000000;;				Name:      "baz",
0000000000000000000000000000000000000000;;				Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;				Image:     framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;				Replicas:  1,
0000000000000000000000000000000000000000;;			})).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should recover from network partition with master", func() {
0000000000000000000000000000000000000000;;			etcdFailTest(
0000000000000000000000000000000000000000;;				f,
0000000000000000000000000000000000000000;;				"sudo iptables -A INPUT -p tcp --destination-port 2379 -j DROP",
0000000000000000000000000000000000000000;;				"sudo iptables -D INPUT -p tcp --destination-port 2379 -j DROP",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should recover from SIGKILL", func() {
0000000000000000000000000000000000000000;;			etcdFailTest(
0000000000000000000000000000000000000000;;				f,
0000000000000000000000000000000000000000;;				"pgrep etcd | xargs -I {} sudo kill -9 {}",
0000000000000000000000000000000000000000;;				"echo 'do nothing. monit should restart etcd.'",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func etcdFailTest(f *framework.Framework, failCommand, fixCommand string) {
0000000000000000000000000000000000000000;;		doEtcdFailure(failCommand, fixCommand)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkExistingRCRecovers(f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		workload.TestReplicationControllerServeImageOrFail(f, "basic", framework.ServeHostnameImage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For this duration, etcd will be failed by executing a failCommand on the master.
0000000000000000000000000000000000000000;;	// If repeat is true, the failCommand will be called at a rate of once per second for
0000000000000000000000000000000000000000;;	// the failure duration. If repeat is false, failCommand will only be called once at the
0000000000000000000000000000000000000000;;	// beginning of the failure duration. After this duration, we execute a fixCommand on the
0000000000000000000000000000000000000000;;	// master and go on to assert that etcd and kubernetes components recover.
0000000000000000000000000000000000000000;;	const etcdFailureDuration = 20 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doEtcdFailure(failCommand, fixCommand string) {
0000000000000000000000000000000000000000;;		By("failing etcd")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		masterExec(failCommand)
0000000000000000000000000000000000000000;;		time.Sleep(etcdFailureDuration)
0000000000000000000000000000000000000000;;		masterExec(fixCommand)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func masterExec(cmd string) {
0000000000000000000000000000000000000000;;		result, err := framework.SSH(cmd, framework.GetMasterHost()+":22", framework.TestContext.Provider)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		if result.Code != 0 {
0000000000000000000000000000000000000000;;			framework.LogSSHResult(result)
0000000000000000000000000000000000000000;;			framework.Failf("master exec command returned non-zero")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkExistingRCRecovers(f *framework.Framework) {
0000000000000000000000000000000000000000;;		By("assert that the pre-existing replication controller recovers")
0000000000000000000000000000000000000000;;		podClient := f.ClientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;		rcSelector := labels.Set{"name": "baz"}.AsSelector()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("deleting pods from existing replication controller")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(wait.Poll(time.Millisecond*500, time.Second*60, func() (bool, error) {
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: rcSelector.String()}
0000000000000000000000000000000000000000;;			pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("apiserver returned error, as expected before recovery: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pods.Items) == 0 {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;				err = podClient.Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("apiserver has recovered")
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("waiting for replication controller to recover")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(wait.Poll(time.Millisecond*500, time.Second*60, func() (bool, error) {
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: rcSelector.String()}
0000000000000000000000000000000000000000;;			pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;				if pod.DeletionTimestamp == nil && podutil.IsPodReady(&pod) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	}
