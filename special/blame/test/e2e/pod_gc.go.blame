0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7bdbe9160f8485eab94acb32b218fc88f0a6d4c3;test/e2e/garbage_collector.go[test/e2e/garbage_collector.go][test/e2e/pod_gc.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test requires that --terminated-pod-gc-threshold=100 be set on the controller manager
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Slow by design (7 min)
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Pod garbage collector [Feature:PodGarbageCollector] [Slow]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("pod-garbage-collector")
0000000000000000000000000000000000000000;;		It("should handle the creation of 1000 pods", func() {
0000000000000000000000000000000000000000;;			var count int
0000000000000000000000000000000000000000;;			for count < 1000 {
0000000000000000000000000000000000000000;;				pod, err := createTerminatingPod(f)
0000000000000000000000000000000000000000;;				pod.ResourceVersion = ""
0000000000000000000000000000000000000000;;				pod.Status.Phase = v1.PodFailed
0000000000000000000000000000000000000000;;				pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).UpdateStatus(pod)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("err failing pod: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;				if count%50 == 0 {
0000000000000000000000000000000000000000;;					framework.Logf("count: %v", count)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.Logf("created: %v", count)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The gc controller polls every 30s and fires off a goroutine per
0000000000000000000000000000000000000000;;			// pod to terminate.
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			var pods *v1.PodList
0000000000000000000000000000000000000000;;			timeout := 2 * time.Minute
0000000000000000000000000000000000000000;;			gcThreshold := 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Waiting for gc controller to gc all but %d pods", gcThreshold))
0000000000000000000000000000000000000000;;			pollErr := wait.Poll(1*time.Minute, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				pods, err = f.ClientSet.Core().Pods(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("Failed to list pod %v", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(pods.Items) != gcThreshold {
0000000000000000000000000000000000000000;;					framework.Logf("Number of observed pods %v, waiting for %v", len(pods.Items), gcThreshold)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if pollErr != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to GC pods within %v, %v pods remaining, error: %v", timeout, len(pods.Items), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTerminatingPod(f *framework.Framework) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		uuid := uuid.NewUUID()
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: string(uuid),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  string(uuid),
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SchedulerName: "please don't schedule my pods",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;	}
