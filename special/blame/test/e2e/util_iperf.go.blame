0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
9f2ee1995756fb7d9e2f78c143e508eec9946495;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests network performance using iperf or other containers.
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type IPerfResults struct {
0000000000000000000000000000000000000000;;		BandwidthMap map[string]int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPerfResult struct modelling an iperf record....
0000000000000000000000000000000000000000;;	// 20160314154239,172.17.0.3,34152,172.17.0.2,5001,3,0.0-10.0,33843707904,27074774092
0000000000000000000000000000000000000000;;	type IPerfResult struct {
0000000000000000000000000000000000000000;;		date          string // field 1 in the csv
0000000000000000000000000000000000000000;;		cli           string // field 2 in the csv
0000000000000000000000000000000000000000;;		cliPort       int64  // ...
0000000000000000000000000000000000000000;;		server        string
0000000000000000000000000000000000000000;;		servPort      int64
0000000000000000000000000000000000000000;;		id            string
0000000000000000000000000000000000000000;;		interval      string
0000000000000000000000000000000000000000;;		transferBits  int64
0000000000000000000000000000000000000000;;		bandwidthBits int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a new result to the Results struct.
0000000000000000000000000000000000000000;;	func (i *IPerfResults) Add(ipr *IPerfResult) {
0000000000000000000000000000000000000000;;		if i.BandwidthMap == nil {
0000000000000000000000000000000000000000;;			i.BandwidthMap = map[string]int64{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.BandwidthMap[ipr.cli] = ipr.bandwidthBits
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToTSV exports an easily readable tab delimited format of all IPerfResults.
0000000000000000000000000000000000000000;;	func (i *IPerfResults) ToTSV() string {
0000000000000000000000000000000000000000;;		if len(i.BandwidthMap) < 1 {
0000000000000000000000000000000000000000;;			framework.Logf("Warning: no data in bandwidth map")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		for node, bandwidth := range i.BandwidthMap {
0000000000000000000000000000000000000000;;			asJson, _ := json.Marshal(node)
0000000000000000000000000000000000000000;;			buffer.WriteString("\t " + string(asJson) + "\t " + fmt.Sprintf("%E", float64(bandwidth)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buffer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewIPerf parses an IPerf CSV output line into an IPerfResult.
0000000000000000000000000000000000000000;;	func NewIPerf(csvLine string) *IPerfResult {
0000000000000000000000000000000000000000;;		slice := StrSlice(strings.Split(csvLine, ","))
0000000000000000000000000000000000000000;;		if len(slice) != 9 {
0000000000000000000000000000000000000000;;			framework.Failf("Incorrect fields in the output: %v (%v out of 9)", slice, len(slice))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := IPerfResult{}
0000000000000000000000000000000000000000;;		i.date = slice.get(0)
0000000000000000000000000000000000000000;;		i.cli = slice.get(1)
0000000000000000000000000000000000000000;;		i.cliPort = intOrFail("client port", slice.get(2))
0000000000000000000000000000000000000000;;		i.server = slice.get(3)
0000000000000000000000000000000000000000;;		i.servPort = intOrFail("server port", slice.get(4))
0000000000000000000000000000000000000000;;		i.id = slice.get(5)
0000000000000000000000000000000000000000;;		i.interval = slice.get(6)
0000000000000000000000000000000000000000;;		i.transferBits = intOrFail("transfer port", slice.get(7))
0000000000000000000000000000000000000000;;		i.bandwidthBits = intOrFail("bandwidth port", slice.get(8))
0000000000000000000000000000000000000000;;		return &i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StrSlice []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s StrSlice) get(i int) string {
0000000000000000000000000000000000000000;;		if i >= 0 && i < len(s) {
0000000000000000000000000000000000000000;;			return s[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// intOrFail is a convenience function for parsing integers.
0000000000000000000000000000000000000000;;	func intOrFail(debugName string, rawValue string) int64 {
0000000000000000000000000000000000000000;;		value, err := strconv.ParseInt(rawValue, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed parsing value %v from the string '%v' as an integer", debugName, rawValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
