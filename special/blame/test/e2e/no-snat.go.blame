0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
45be65257bc252c2a28c185e4061db469c31c2b0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		// . "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testPodPort  = 8080
0000000000000000000000000000000000000000;;		testPodImage = "gcr.io/google_containers/no-snat-test-amd64:1.0.1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testProxyPort  = 31235 // Firewall rule allows external traffic on ports 30000-32767. I just picked a random one.
0000000000000000000000000000000000000000;;		testProxyImage = "gcr.io/google_containers/no-snat-test-proxy-amd64:1.0.1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		testPod = v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "no-snat-test",
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"no-snat-test": "",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "no-snat-test",
0000000000000000000000000000000000000000;;						Image: testPodImage,
0000000000000000000000000000000000000000;;						Args:  []string{"--port", strconv.Itoa(testPodPort)},
0000000000000000000000000000000000000000;;						Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "POD_IP",
0000000000000000000000000000000000000000;;								ValueFrom: &v1.EnvVarSource{FieldRef: &v1.ObjectFieldSelector{FieldPath: "status.podIP"}},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testProxyPod = v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "no-snat-test-proxy",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				HostNetwork: true,
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "no-snat-test-proxy",
0000000000000000000000000000000000000000;;						Image: testProxyImage,
0000000000000000000000000000000000000000;;						Args:  []string{"--port", strconv.Itoa(testProxyPort)},
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								ContainerPort: testProxyPort,
0000000000000000000000000000000000000000;;								HostPort:      testProxyPort,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produces a pod spec that passes nip as NODE_IP env var using downward API
0000000000000000000000000000000000000000;;	func newTestPod(nodename string, nip string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := testPod
0000000000000000000000000000000000000000;;		node_ip := v1.EnvVar{
0000000000000000000000000000000000000000;;			Name:  "NODE_IP",
0000000000000000000000000000000000000000;;			Value: nip,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Spec.Containers[0].Env = append(pod.Spec.Containers[0].Env, node_ip)
0000000000000000000000000000000000000000;;		pod.Spec.NodeName = nodename
0000000000000000000000000000000000000000;;		return &pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestProxyPod(nodename string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := testProxyPod
0000000000000000000000000000000000000000;;		pod.Spec.NodeName = nodename
0000000000000000000000000000000000000000;;		return &pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getIP(iptype v1.NodeAddressType, node *v1.Node) (string, error) {
0000000000000000000000000000000000000000;;		for _, addr := range node.Status.Addresses {
0000000000000000000000000000000000000000;;			if addr.Type == iptype {
0000000000000000000000000000000000000000;;				return addr.Address, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("did not find %s on Node", iptype)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSchedulable(nodes []v1.Node) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			if node.Spec.Unschedulable == false {
0000000000000000000000000000000000000000;;				return &node, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("all Nodes were unschedulable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checknosnatURL(proxy, pip string, ips []string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("http://%s/checknosnat?target=%s&ips=%s", proxy, pip, strings.Join(ips, ","))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test verifies that a Pod on each node in a cluster can talk to Pods on every other node without SNAT.
0000000000000000000000000000000000000000;;	// We use the [Feature:NoSNAT] tag so that most jobs will skip this test by default.
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("NoSNAT [Feature:NoSNAT] [Slow]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("no-snat-test")
0000000000000000000000000000000000000000;;		It("Should be able to send traffic between Pods without SNAT", func() {
0000000000000000000000000000000000000000;;			cs := f.ClientSet
0000000000000000000000000000000000000000;;			pc := cs.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			nc := cs.Core().Nodes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("creating a test pod on each Node")
0000000000000000000000000000000000000000;;			nodes, err := nc.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			if len(nodes.Items) == 0 {
0000000000000000000000000000000000000000;;				framework.ExpectNoError(fmt.Errorf("no Nodes in the cluster"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, node := range nodes.Items {
0000000000000000000000000000000000000000;;				// find the Node's internal ip address to feed to the Pod
0000000000000000000000000000000000000000;;				inIP, err := getIP(v1.NodeInternalIP, &node)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// target Pod at Node and feed Pod Node's InternalIP
0000000000000000000000000000000000000000;;				pod := newTestPod(node.Name, inIP)
0000000000000000000000000000000000000000;;				_, err = pc.Create(pod)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// In some (most?) scenarios, the test harness doesn't run in the same network as the Pods,
0000000000000000000000000000000000000000;;			// which means it can't query Pods using their cluster-internal IPs. To get around this,
0000000000000000000000000000000000000000;;			// we create a Pod in a Node's host network, and have that Pod serve on a specific port of that Node.
0000000000000000000000000000000000000000;;			// We can then ask this proxy Pod to query the internal endpoints served by the test Pods.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Find the first schedulable node; masters are marked unschedulable. We don't put the proxy on the master
0000000000000000000000000000000000000000;;			// because in some (most?) deployments firewall rules don't allow external traffic to hit ports 30000-32767
0000000000000000000000000000000000000000;;			// on the master, but do allow this on the nodes.
0000000000000000000000000000000000000000;;			node, err := getSchedulable(nodes.Items)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			By("creating a no-snat-test-proxy Pod on Node " + node.Name + " port " + strconv.Itoa(testProxyPort) +
0000000000000000000000000000000000000000;;				" so we can target our test Pods through this Node's ExternalIP")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			extIP, err := getIP(v1.NodeExternalIP, node)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			proxyNodeIP := extIP + ":" + strconv.Itoa(testProxyPort)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = pc.Create(newTestProxyPod(node.Name))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("waiting for all of the no-snat-test pods to be scheduled and running")
0000000000000000000000000000000000000000;;			err = wait.PollImmediate(10*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;				pods, err := pc.List(metav1.ListOptions{LabelSelector: "no-snat-test"})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check all pods are running
0000000000000000000000000000000000000000;;				for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;					if pod.Status.Phase != v1.PodRunning {
0000000000000000000000000000000000000000;;						if pod.Status.Phase != v1.PodPending {
0000000000000000000000000000000000000000;;							return false, fmt.Errorf("expected pod to be in phase \"Pending\" or \"Running\"")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return false, nil // pod is still pending
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil // all pods are running
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("waiting for the no-snat-test-proxy Pod to be scheduled and running")
0000000000000000000000000000000000000000;;			err = wait.PollImmediate(10*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;				pod, err := pc.Get("no-snat-test-proxy", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.Status.Phase != v1.PodRunning {
0000000000000000000000000000000000000000;;					if pod.Status.Phase != v1.PodPending {
0000000000000000000000000000000000000000;;						return false, fmt.Errorf("expected pod to be in phase \"Pending\" or \"Running\"")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false, nil // pod is still pending
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil // pod is running
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("sending traffic from each pod to the others and checking that SNAT does not occur")
0000000000000000000000000000000000000000;;			pods, err := pc.List(metav1.ListOptions{LabelSelector: "no-snat-test"})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// collect pod IPs
0000000000000000000000000000000000000000;;			podIPs := []string{}
0000000000000000000000000000000000000000;;			for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;				podIPs = append(podIPs, pod.Status.PodIP+":"+strconv.Itoa(testPodPort))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// hit the /checknosnat endpoint on each Pod, tell each Pod to check all the other Pods
0000000000000000000000000000000000000000;;			// this test is O(n^2) but it doesn't matter because we only run this test on small clusters (~3 nodes)
0000000000000000000000000000000000000000;;			errs := []string{}
0000000000000000000000000000000000000000;;			client := http.Client{
0000000000000000000000000000000000000000;;				Timeout: 5 * time.Minute,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pip := range podIPs {
0000000000000000000000000000000000000000;;				ips := []string{}
0000000000000000000000000000000000000000;;				for _, ip := range podIPs {
0000000000000000000000000000000000000000;;					if ip == pip {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ips = append(ips, ip)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// hit /checknosnat on pip, via proxy
0000000000000000000000000000000000000000;;				resp, err := client.Get(checknosnatURL(proxyNodeIP, pip, ips))
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check error code on the response, if 500 record the body, which will describe the error
0000000000000000000000000000000000000000;;				if resp.StatusCode == 500 {
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;					errs = append(errs, string(body))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resp.Body.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// report the errors all at the end
0000000000000000000000000000000000000000;;			if len(errs) > 0 {
0000000000000000000000000000000000000000;;				str := strings.Join(errs, "\n")
0000000000000000000000000000000000000000;;				err := fmt.Errorf("/checknosnat failed in the following cases:\n%s", str)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
