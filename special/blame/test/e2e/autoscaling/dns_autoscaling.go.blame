0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8335ed59ceb96c80a455935b37f7b52b6140aac7;test/e2e/dns_autoscaling.go[test/e2e/dns_autoscaling.go][test/e2e/autoscaling/dns_autoscaling.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package autoscaling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DNSdefaultTimeout      = 5 * time.Minute
0000000000000000000000000000000000000000;;		ClusterAddonLabelKey   = "k8s-app"
0000000000000000000000000000000000000000;;		DNSLabelName           = "kube-dns"
0000000000000000000000000000000000000000;;		DNSAutoscalerLabelName = "kube-dns-autoscaler"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("DNS horizontal autoscaling", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("dns-autoscaling")
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;		var previousParams map[string]string
0000000000000000000000000000000000000000;;		var originDNSReplicasCount int
0000000000000000000000000000000000000000;;		var DNSParams_1 DNSParamsLinear
0000000000000000000000000000000000000000;;		var DNSParams_2 DNSParamsLinear
0000000000000000000000000000000000000000;;		var DNSParams_3 DNSParamsLinear
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeCount := len(framework.GetReadySchedulableNodesOrDie(c).Items)
0000000000000000000000000000000000000000;;			Expect(nodeCount).NotTo(BeZero())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Collecting original replicas count and DNS scaling params")
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			originDNSReplicasCount, err = getDNSReplicas(c)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pcm, err := fetchDNSScalingConfigMap(c)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			previousParams = pcm.Data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if nodeCount <= 500 {
0000000000000000000000000000000000000000;;				DNSParams_1 = DNSParamsLinear{
0000000000000000000000000000000000000000;;					nodesPerReplica: 1,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				DNSParams_2 = DNSParamsLinear{
0000000000000000000000000000000000000000;;					nodesPerReplica: 2,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				DNSParams_3 = DNSParamsLinear{
0000000000000000000000000000000000000000;;					nodesPerReplica: 3,
0000000000000000000000000000000000000000;;					coresPerReplica: 3,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// In large clusters, avoid creating/deleting too many DNS pods,
0000000000000000000000000000000000000000;;				// it is supposed to be correctness test, not performance one.
0000000000000000000000000000000000000000;;				// The default setup is: 256 cores/replica, 16 nodes/replica.
0000000000000000000000000000000000000000;;				// With nodeCount > 500, nodes/13, nodes/14, nodes/15 and nodes/16
0000000000000000000000000000000000000000;;				// are different numbers.
0000000000000000000000000000000000000000;;				DNSParams_1 = DNSParamsLinear{
0000000000000000000000000000000000000000;;					nodesPerReplica: 13,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				DNSParams_2 = DNSParamsLinear{
0000000000000000000000000000000000000000;;					nodesPerReplica: 14,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				DNSParams_3 = DNSParamsLinear{
0000000000000000000000000000000000000000;;					nodesPerReplica: 15,
0000000000000000000000000000000000000000;;					coresPerReplica: 15,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This test is separated because it is slow and need to run serially.
0000000000000000000000000000000000000000;;		// Will take around 5 minutes to run on a 4 nodes cluster.
0000000000000000000000000000000000000000;;		It("[Serial] [Slow] kube-dns-autoscaler should scale kube-dns pods when cluster size changed", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Replace the dns autoscaling parameters with testing parameters")
0000000000000000000000000000000000000000;;			err := updateDNSScalingConfigMap(c, packDNSScalingConfigMap(packLinearParams(&DNSParams_1)))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				By("Restoring intial dns autoscaling parameters")
0000000000000000000000000000000000000000;;				Expect(updateDNSScalingConfigMap(c, packDNSScalingConfigMap(previousParams))).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Wait for number of running and ready kube-dns pods recover")
0000000000000000000000000000000000000000;;				label := labels.SelectorFromSet(labels.Set(map[string]string{ClusterAddonLabelKey: DNSLabelName}))
0000000000000000000000000000000000000000;;				_, err := framework.WaitForPodsWithLabelRunningReady(c, metav1.NamespaceSystem, label, originDNSReplicasCount, DNSdefaultTimeout)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			By("Wait for kube-dns scaled to expected number")
0000000000000000000000000000000000000000;;			getExpectReplicasLinear := getExpectReplicasFuncLinear(c, &DNSParams_1)
0000000000000000000000000000000000000000;;			Expect(waitForDNSReplicasSatisfied(c, getExpectReplicasLinear, DNSdefaultTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalSizes := make(map[string]int)
0000000000000000000000000000000000000000;;			sum := 0
0000000000000000000000000000000000000000;;			for _, mig := range strings.Split(framework.TestContext.CloudConfig.NodeInstanceGroup, ",") {
0000000000000000000000000000000000000000;;				size, err := framework.GroupSize(mig)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Initial size of %s: %d", mig, size))
0000000000000000000000000000000000000000;;				originalSizes[mig] = size
0000000000000000000000000000000000000000;;				sum += size
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Manually increase cluster size")
0000000000000000000000000000000000000000;;			increasedSize := 0
0000000000000000000000000000000000000000;;			increasedSizes := make(map[string]int)
0000000000000000000000000000000000000000;;			for key, val := range originalSizes {
0000000000000000000000000000000000000000;;				increasedSizes[key] = val + 1
0000000000000000000000000000000000000000;;				increasedSize += increasedSizes[key]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			setMigSizes(increasedSizes)
0000000000000000000000000000000000000000;;			Expect(WaitForClusterSizeFunc(c,
0000000000000000000000000000000000000000;;				func(size int) bool { return size == increasedSize }, scaleUpTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Wait for kube-dns scaled to expected number")
0000000000000000000000000000000000000000;;			getExpectReplicasLinear = getExpectReplicasFuncLinear(c, &DNSParams_1)
0000000000000000000000000000000000000000;;			Expect(waitForDNSReplicasSatisfied(c, getExpectReplicasLinear, DNSdefaultTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Replace the dns autoscaling parameters with another testing parameters")
0000000000000000000000000000000000000000;;			err = updateDNSScalingConfigMap(c, packDNSScalingConfigMap(packLinearParams(&DNSParams_3)))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Wait for kube-dns scaled to expected number")
0000000000000000000000000000000000000000;;			getExpectReplicasLinear = getExpectReplicasFuncLinear(c, &DNSParams_3)
0000000000000000000000000000000000000000;;			Expect(waitForDNSReplicasSatisfied(c, getExpectReplicasLinear, DNSdefaultTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Restoring cluster size")
0000000000000000000000000000000000000000;;			setMigSizes(originalSizes)
0000000000000000000000000000000000000000;;			Expect(framework.WaitForClusterSize(c, sum, scaleDownTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Wait for kube-dns scaled to expected number")
0000000000000000000000000000000000000000;;			Expect(waitForDNSReplicasSatisfied(c, getExpectReplicasLinear, DNSdefaultTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Replace the dns autoscaling parameters with testing parameters")
0000000000000000000000000000000000000000;;			err := updateDNSScalingConfigMap(c, packDNSScalingConfigMap(packLinearParams(&DNSParams_1)))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				By("Restoring intial dns autoscaling parameters")
0000000000000000000000000000000000000000;;				Expect(updateDNSScalingConfigMap(c, packDNSScalingConfigMap(previousParams))).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			By("Wait for kube-dns scaled to expected number")
0000000000000000000000000000000000000000;;			getExpectReplicasLinear := getExpectReplicasFuncLinear(c, &DNSParams_1)
0000000000000000000000000000000000000000;;			Expect(waitForDNSReplicasSatisfied(c, getExpectReplicasLinear, DNSdefaultTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("--- Scenario: should scale kube-dns based on changed parameters ---")
0000000000000000000000000000000000000000;;			By("Replace the dns autoscaling parameters with another testing parameters")
0000000000000000000000000000000000000000;;			err = updateDNSScalingConfigMap(c, packDNSScalingConfigMap(packLinearParams(&DNSParams_3)))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			By("Wait for kube-dns scaled to expected number")
0000000000000000000000000000000000000000;;			getExpectReplicasLinear = getExpectReplicasFuncLinear(c, &DNSParams_3)
0000000000000000000000000000000000000000;;			Expect(waitForDNSReplicasSatisfied(c, getExpectReplicasLinear, DNSdefaultTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("--- Scenario: should re-create scaling parameters with default value when parameters got deleted ---")
0000000000000000000000000000000000000000;;			By("Delete the ConfigMap for autoscaler")
0000000000000000000000000000000000000000;;			err = deleteDNSScalingConfigMap(c)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Wait for the ConfigMap got re-created")
0000000000000000000000000000000000000000;;			_, err = waitForDNSConfigMapCreated(c, DNSdefaultTimeout)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Replace the dns autoscaling parameters with another testing parameters")
0000000000000000000000000000000000000000;;			err = updateDNSScalingConfigMap(c, packDNSScalingConfigMap(packLinearParams(&DNSParams_2)))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			By("Wait for kube-dns scaled to expected number")
0000000000000000000000000000000000000000;;			getExpectReplicasLinear = getExpectReplicasFuncLinear(c, &DNSParams_2)
0000000000000000000000000000000000000000;;			Expect(waitForDNSReplicasSatisfied(c, getExpectReplicasLinear, DNSdefaultTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("--- Scenario: should recover after autoscaler pod got deleted ---")
0000000000000000000000000000000000000000;;			By("Delete the autoscaler pod for kube-dns")
0000000000000000000000000000000000000000;;			Expect(deleteDNSAutoscalerPod(c)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Replace the dns autoscaling parameters with another testing parameters")
0000000000000000000000000000000000000000;;			err = updateDNSScalingConfigMap(c, packDNSScalingConfigMap(packLinearParams(&DNSParams_1)))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			By("Wait for kube-dns scaled to expected number")
0000000000000000000000000000000000000000;;			getExpectReplicasLinear = getExpectReplicasFuncLinear(c, &DNSParams_1)
0000000000000000000000000000000000000000;;			Expect(waitForDNSReplicasSatisfied(c, getExpectReplicasLinear, DNSdefaultTimeout)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DNSParamsLinear struct {
0000000000000000000000000000000000000000;;		nodesPerReplica float64
0000000000000000000000000000000000000000;;		coresPerReplica float64
0000000000000000000000000000000000000000;;		min             int
0000000000000000000000000000000000000000;;		max             int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type getExpectReplicasFunc func(c clientset.Interface) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getExpectReplicasFuncLinear(c clientset.Interface, params *DNSParamsLinear) getExpectReplicasFunc {
0000000000000000000000000000000000000000;;		return func(c clientset.Interface) int {
0000000000000000000000000000000000000000;;			var replicasFromNodes float64
0000000000000000000000000000000000000000;;			var replicasFromCores float64
0000000000000000000000000000000000000000;;			nodes := framework.GetReadySchedulableNodesOrDie(c).Items
0000000000000000000000000000000000000000;;			if params.nodesPerReplica > 0 {
0000000000000000000000000000000000000000;;				replicasFromNodes = math.Ceil(float64(len(nodes)) / params.nodesPerReplica)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if params.coresPerReplica > 0 {
0000000000000000000000000000000000000000;;				replicasFromCores = math.Ceil(float64(getScheduableCores(nodes)) / params.coresPerReplica)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return int(math.Max(1.0, math.Max(replicasFromNodes, replicasFromCores)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getScheduableCores(nodes []v1.Node) int64 {
0000000000000000000000000000000000000000;;		var sc resource.Quantity
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			if !node.Spec.Unschedulable {
0000000000000000000000000000000000000000;;				sc.Add(node.Status.Capacity[v1.ResourceCPU])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scInt64, scOk := sc.AsInt64()
0000000000000000000000000000000000000000;;		if !scOk {
0000000000000000000000000000000000000000;;			framework.Logf("Unable to compute integer values of schedulable cores in the cluster")
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scInt64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fetchDNSScalingConfigMap(c clientset.Interface) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		cm, err := c.Core().ConfigMaps(metav1.NamespaceSystem).Get(DNSAutoscalerLabelName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cm, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteDNSScalingConfigMap(c clientset.Interface) error {
0000000000000000000000000000000000000000;;		if err := c.Core().ConfigMaps(metav1.NamespaceSystem).Delete(DNSAutoscalerLabelName, nil); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("DNS autoscaling ConfigMap deleted.")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packLinearParams(params *DNSParamsLinear) map[string]string {
0000000000000000000000000000000000000000;;		paramsMap := make(map[string]string)
0000000000000000000000000000000000000000;;		paramsMap["linear"] = fmt.Sprintf("{\"nodesPerReplica\": %v,\"coresPerReplica\": %v,\"min\": %v,\"max\": %v}",
0000000000000000000000000000000000000000;;			params.nodesPerReplica,
0000000000000000000000000000000000000000;;			params.coresPerReplica,
0000000000000000000000000000000000000000;;			params.min,
0000000000000000000000000000000000000000;;			params.max)
0000000000000000000000000000000000000000;;		return paramsMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packDNSScalingConfigMap(params map[string]string) *v1.ConfigMap {
0000000000000000000000000000000000000000;;		configMap := v1.ConfigMap{}
0000000000000000000000000000000000000000;;		configMap.ObjectMeta.Name = DNSAutoscalerLabelName
0000000000000000000000000000000000000000;;		configMap.ObjectMeta.Namespace = metav1.NamespaceSystem
0000000000000000000000000000000000000000;;		configMap.Data = params
0000000000000000000000000000000000000000;;		return &configMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateDNSScalingConfigMap(c clientset.Interface, configMap *v1.ConfigMap) error {
0000000000000000000000000000000000000000;;		_, err := c.Core().ConfigMaps(metav1.NamespaceSystem).Update(configMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("DNS autoscaling ConfigMap updated.")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDNSReplicas(c clientset.Interface) (int, error) {
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{ClusterAddonLabelKey: DNSLabelName}))
0000000000000000000000000000000000000000;;		listOpts := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;		deployments, err := c.Extensions().Deployments(metav1.NamespaceSystem).List(listOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(deployments.Items) != 1 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("expected 1 DNS deployment, got %v", len(deployments.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment := deployments.Items[0]
0000000000000000000000000000000000000000;;		return int(*(deployment.Spec.Replicas)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteDNSAutoscalerPod(c clientset.Interface) error {
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{ClusterAddonLabelKey: DNSAutoscalerLabelName}))
0000000000000000000000000000000000000000;;		listOpts := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;		pods, err := c.Core().Pods(metav1.NamespaceSystem).List(listOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected 1 autoscaler pod, got %v", len(pods.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podName := pods.Items[0].Name
0000000000000000000000000000000000000000;;		if err := c.Core().Pods(metav1.NamespaceSystem).Delete(podName, nil); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("DNS autoscaling pod %v deleted.", podName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForDNSReplicasSatisfied(c clientset.Interface, getExpected getExpectReplicasFunc, timeout time.Duration) (err error) {
0000000000000000000000000000000000000000;;		var current int
0000000000000000000000000000000000000000;;		var expected int
0000000000000000000000000000000000000000;;		framework.Logf("Waiting up to %v for kube-dns to reach expected replicas", timeout)
0000000000000000000000000000000000000000;;		condition := func() (bool, error) {
0000000000000000000000000000000000000000;;			current, err = getDNSReplicas(c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expected = getExpected(c)
0000000000000000000000000000000000000000;;			if current != expected {
0000000000000000000000000000000000000000;;				framework.Logf("Replicas not as expected: got %v, expected %v", current, expected)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = wait.Poll(2*time.Second, timeout, condition); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("err waiting for DNS replicas to satisfy %v, got %v: %v", expected, current, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("kube-dns reaches expected replicas: %v", expected)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForDNSConfigMapCreated(c clientset.Interface, timeout time.Duration) (configMap *v1.ConfigMap, err error) {
0000000000000000000000000000000000000000;;		framework.Logf("Waiting up to %v for DNS autoscaling ConfigMap got re-created", timeout)
0000000000000000000000000000000000000000;;		condition := func() (bool, error) {
0000000000000000000000000000000000000000;;			configMap, err = fetchDNSScalingConfigMap(c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = wait.Poll(time.Second, timeout, condition); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("err waiting for DNS autoscaling ConfigMap got re-created: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return configMap, nil
0000000000000000000000000000000000000000;;	}
