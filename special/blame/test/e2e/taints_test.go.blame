0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
5101f8876b8ad2836c659335ee21c75312f79ae7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		_ "github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestTaint() v1.Taint {
0000000000000000000000000000000000000000;;		return v1.Taint{
0000000000000000000000000000000000000000;;			Key:       "kubernetes.io/e2e-evict-taint-key",
0000000000000000000000000000000000000000;;			Value:     "evictTaintVal",
0000000000000000000000000000000000000000;;			Effect:    v1.TaintEffectNoExecute,
0000000000000000000000000000000000000000;;			TimeAdded: metav1.Now(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a defaut pod for this test, with argument saying if the Pod should have
0000000000000000000000000000000000000000;;	// toleration for Taits used in this test.
0000000000000000000000000000000000000000;;	func createPodForTaintsTest(hasToleration bool, tolerationSeconds int, podName, ns string) *v1.Pod {
0000000000000000000000000000000000000000;;		grace := int64(1)
0000000000000000000000000000000000000000;;		if !hasToleration {
0000000000000000000000000000000000000000;;			return &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      podName,
0000000000000000000000000000000000000000;;					Namespace: ns,
0000000000000000000000000000000000000000;;					Labels:    map[string]string{"name": podName},
0000000000000000000000000000000000000000;;					DeletionGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "pause",
0000000000000000000000000000000000000000;;							Image: "kubernetes/pause",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if tolerationSeconds <= 0 {
0000000000000000000000000000000000000000;;				return &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      podName,
0000000000000000000000000000000000000000;;						Namespace: ns,
0000000000000000000000000000000000000000;;						Labels:    map[string]string{"name": podName},
0000000000000000000000000000000000000000;;						DeletionGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;						// default - tolerate forever
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "pause",
0000000000000000000000000000000000000000;;								Image: "kubernetes/pause",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{Key: "kubernetes.io/e2e-evict-taint-key", Value: "evictTaintVal", Effect: v1.TaintEffectNoExecute}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ts := int64(tolerationSeconds)
0000000000000000000000000000000000000000;;				return &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      podName,
0000000000000000000000000000000000000000;;						Namespace: ns,
0000000000000000000000000000000000000000;;						Labels:    map[string]string{"name": podName},
0000000000000000000000000000000000000000;;						DeletionGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "pause",
0000000000000000000000000000000000000000;;								Image: "kubernetes/pause",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						// default - tolerate forever
0000000000000000000000000000000000000000;;						Tolerations: []v1.Toleration{{Key: "kubernetes.io/e2e-evict-taint-key", Value: "evictTaintVal", Effect: v1.TaintEffectNoExecute, TolerationSeconds: &ts}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates and starts a controller (informer) that watches updates on a pod in given namespace with given name. It puts a new
0000000000000000000000000000000000000000;;	// struct into observedDeletion channel for every deletion it sees.
0000000000000000000000000000000000000000;;	func createTestController(cs clientset.Interface, observedDeletions chan struct{}, stopCh chan struct{}, podName, ns string) {
0000000000000000000000000000000000000000;;		_, controller := cache.NewInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					options.FieldSelector = fields.SelectorFromSet(fields.Set{"metadata.name": podName}).String()
0000000000000000000000000000000000000000;;					obj, err := cs.Core().Pods(ns).List(options)
0000000000000000000000000000000000000000;;					return runtime.Object(obj), err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					options.FieldSelector = fields.SelectorFromSet(fields.Set{"metadata.name": podName}).String()
0000000000000000000000000000000000000000;;					return cs.Core().Pods(ns).Watch(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&v1.Pod{},
0000000000000000000000000000000000000000;;			0,
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				DeleteFunc: func(oldObj interface{}) { observedDeletions <- struct{}{} },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		framework.Logf("Starting informer...")
0000000000000000000000000000000000000000;;		go controller.Run(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		KubeletPodDeletionDelaySeconds = 60
0000000000000000000000000000000000000000;;		AdditionalWaitPerDeleteSeconds = 5
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests the behavior of NoExecuteTaintManager. Following scenarios are included:
0000000000000000000000000000000000000000;;	// - eviction of non-tolerating pods from a tainted node,
0000000000000000000000000000000000000000;;	// - lack of eviction of tolerating pods from a tainted node,
0000000000000000000000000000000000000000;;	// - delayed eviction of short-tolerating pod from a tainted node,
0000000000000000000000000000000000000000;;	// - lack of eviction of short-tolerating pod after taint removal.
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("NoExecuteTaintManager [Serial]", func() {
0000000000000000000000000000000000000000;;		var cs clientset.Interface
0000000000000000000000000000000000000000;;		var nodeList *v1.NodeList
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("taint-control")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			cs = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			nodeList = &v1.NodeList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.WaitForAllNodesHealthy(cs, time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := framework.CheckTestingNSDeletedExcept(cs, ns)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. Run a pod
0000000000000000000000000000000000000000;;		// 2. Taint the node running this pod with a no-execute taint
0000000000000000000000000000000000000000;;		// 3. See if pod will get evicted
0000000000000000000000000000000000000000;;		It("evicts pods from tainted nodes", func() {
0000000000000000000000000000000000000000;;			podName := "taint-eviction-1"
0000000000000000000000000000000000000000;;			pod := createPodForTaintsTest(false, 0, podName, ns)
0000000000000000000000000000000000000000;;			observedDeletions := make(chan struct{}, 100)
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			createTestController(cs, observedDeletions, stopCh, podName, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Staring pod...")
0000000000000000000000000000000000000000;;			nodeName, err := testutils.RunPodAndGetNodeName(cs, pod, 2*time.Minute)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			framework.Logf("Pod is running on %v. Tainting Node", nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Trying to apply a taint on the Node")
0000000000000000000000000000000000000000;;			testTaint := getTestTaint()
0000000000000000000000000000000000000000;;			framework.AddOrUpdateTaintOnNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;			framework.ExpectNodeHasTaint(cs, nodeName, &testTaint)
0000000000000000000000000000000000000000;;			defer framework.RemoveTaintOffNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait a bit
0000000000000000000000000000000000000000;;			By("Waiting for Pod to be deleted")
0000000000000000000000000000000000000000;;			timeoutChannel := time.NewTimer(time.Duration(KubeletPodDeletionDelaySeconds+AdditionalWaitPerDeleteSeconds) * time.Second).C
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-timeoutChannel:
0000000000000000000000000000000000000000;;				framework.Failf("Failed to evict Pod")
0000000000000000000000000000000000000000;;			case <-observedDeletions:
0000000000000000000000000000000000000000;;				framework.Logf("Noticed Pod eviction. Test successful")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. Run a pod with toleration
0000000000000000000000000000000000000000;;		// 2. Taint the node running this pod with a no-execute taint
0000000000000000000000000000000000000000;;		// 3. See if pod wont get evicted
0000000000000000000000000000000000000000;;		It("doesn't evict pod with tolerations from tainted nodes", func() {
0000000000000000000000000000000000000000;;			podName := "taint-eviction-2"
0000000000000000000000000000000000000000;;			pod := createPodForTaintsTest(true, 0, podName, ns)
0000000000000000000000000000000000000000;;			observedDeletions := make(chan struct{}, 100)
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			createTestController(cs, observedDeletions, stopCh, podName, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Staring pod...")
0000000000000000000000000000000000000000;;			nodeName, err := testutils.RunPodAndGetNodeName(cs, pod, 2*time.Minute)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			framework.Logf("Pod is running on %v. Tainting Node", nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Trying to apply a taint on the Node")
0000000000000000000000000000000000000000;;			testTaint := getTestTaint()
0000000000000000000000000000000000000000;;			framework.AddOrUpdateTaintOnNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;			framework.ExpectNodeHasTaint(cs, nodeName, &testTaint)
0000000000000000000000000000000000000000;;			defer framework.RemoveTaintOffNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait a bit
0000000000000000000000000000000000000000;;			By("Waiting for Pod to be deleted")
0000000000000000000000000000000000000000;;			timeoutChannel := time.NewTimer(time.Duration(KubeletPodDeletionDelaySeconds+AdditionalWaitPerDeleteSeconds) * time.Second).C
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-timeoutChannel:
0000000000000000000000000000000000000000;;				framework.Logf("Pod wasn't evicted. Test successful")
0000000000000000000000000000000000000000;;			case <-observedDeletions:
0000000000000000000000000000000000000000;;				framework.Failf("Pod was evicted despite toleration")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. Run a pod with a finite toleration
0000000000000000000000000000000000000000;;		// 2. Taint the node running this pod with a no-execute taint
0000000000000000000000000000000000000000;;		// 3. See if pod wont get evicted before toleration time runs out
0000000000000000000000000000000000000000;;		// 4. See if pod will get evicted after toleration time runs out
0000000000000000000000000000000000000000;;		It("eventually evict pod with finite tolerations from tainted nodes", func() {
0000000000000000000000000000000000000000;;			podName := "taint-eviction-3"
0000000000000000000000000000000000000000;;			pod := createPodForTaintsTest(true, KubeletPodDeletionDelaySeconds+2*AdditionalWaitPerDeleteSeconds, podName, ns)
0000000000000000000000000000000000000000;;			observedDeletions := make(chan struct{}, 100)
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			createTestController(cs, observedDeletions, stopCh, podName, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Staring pod...")
0000000000000000000000000000000000000000;;			nodeName, err := testutils.RunPodAndGetNodeName(cs, pod, 2*time.Minute)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			framework.Logf("Pod is running on %v. Tainting Node", nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Trying to apply a taint on the Node")
0000000000000000000000000000000000000000;;			testTaint := getTestTaint()
0000000000000000000000000000000000000000;;			framework.AddOrUpdateTaintOnNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;			framework.ExpectNodeHasTaint(cs, nodeName, &testTaint)
0000000000000000000000000000000000000000;;			defer framework.RemoveTaintOffNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait a bit
0000000000000000000000000000000000000000;;			By("Waiting to see if a Pod won't be deleted")
0000000000000000000000000000000000000000;;			timeoutChannel := time.NewTimer(time.Duration(KubeletPodDeletionDelaySeconds+AdditionalWaitPerDeleteSeconds) * time.Second).C
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-timeoutChannel:
0000000000000000000000000000000000000000;;				framework.Logf("Pod wasn't evicted")
0000000000000000000000000000000000000000;;			case <-observedDeletions:
0000000000000000000000000000000000000000;;				framework.Failf("Pod was evicted despite toleration")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("Waiting for Pod to be deleted")
0000000000000000000000000000000000000000;;			timeoutChannel = time.NewTimer(time.Duration(KubeletPodDeletionDelaySeconds+AdditionalWaitPerDeleteSeconds) * time.Second).C
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-timeoutChannel:
0000000000000000000000000000000000000000;;				framework.Failf("Pod wasn't evicted")
0000000000000000000000000000000000000000;;			case <-observedDeletions:
0000000000000000000000000000000000000000;;				framework.Logf("Pod was evicted after toleration time run out. Test successful")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. Run a pod with short toleration
0000000000000000000000000000000000000000;;		// 2. Taint the node running this pod with a no-execute taint
0000000000000000000000000000000000000000;;		// 3. Wait some time
0000000000000000000000000000000000000000;;		// 4. Remove the taint
0000000000000000000000000000000000000000;;		// 5. See if Pod won't be evicted.
0000000000000000000000000000000000000000;;		It("removing taint cancels eviction", func() {
0000000000000000000000000000000000000000;;			podName := "taint-eviction-4"
0000000000000000000000000000000000000000;;			pod := createPodForTaintsTest(true, 2*AdditionalWaitPerDeleteSeconds, podName, ns)
0000000000000000000000000000000000000000;;			observedDeletions := make(chan struct{}, 100)
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			createTestController(cs, observedDeletions, stopCh, podName, ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Staring pod...")
0000000000000000000000000000000000000000;;			nodeName, err := testutils.RunPodAndGetNodeName(cs, pod, 2*time.Minute)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			framework.Logf("Pod is running on %v. Tainting Node", nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Trying to apply a taint on the Node")
0000000000000000000000000000000000000000;;			testTaint := getTestTaint()
0000000000000000000000000000000000000000;;			framework.AddOrUpdateTaintOnNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;			framework.ExpectNodeHasTaint(cs, nodeName, &testTaint)
0000000000000000000000000000000000000000;;			taintRemoved := false
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if !taintRemoved {
0000000000000000000000000000000000000000;;					framework.RemoveTaintOffNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait a bit
0000000000000000000000000000000000000000;;			By("Waiting short time to make sure Pod is queued for deletion")
0000000000000000000000000000000000000000;;			timeoutChannel := time.NewTimer(AdditionalWaitPerDeleteSeconds).C
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-timeoutChannel:
0000000000000000000000000000000000000000;;				framework.Logf("Pod wasn't evicted. Proceeding")
0000000000000000000000000000000000000000;;			case <-observedDeletions:
0000000000000000000000000000000000000000;;				framework.Failf("Pod was evicted despite toleration")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Removing taint from Node")
0000000000000000000000000000000000000000;;			framework.RemoveTaintOffNode(cs, nodeName, testTaint)
0000000000000000000000000000000000000000;;			taintRemoved = true
0000000000000000000000000000000000000000;;			By("Waiting some time to make sure that toleration time passed.")
0000000000000000000000000000000000000000;;			timeoutChannel = time.NewTimer(time.Duration(KubeletPodDeletionDelaySeconds+3*AdditionalWaitPerDeleteSeconds) * time.Second).C
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-timeoutChannel:
0000000000000000000000000000000000000000;;				framework.Logf("Pod wasn't evicted. Test successful")
0000000000000000000000000000000000000000;;			case <-observedDeletions:
0000000000000000000000000000000000000000;;				framework.Failf("Pod was evicted despite toleration")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
