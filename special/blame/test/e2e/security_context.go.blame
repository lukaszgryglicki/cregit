0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
9b13ee5ece6eb717e3e617f0b8b1c0f4694bec88;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* This test check that SecurityContext parameters specified at the
0000000000000000000000000000000000000000;;	 * pod or the container level work as intended. These tests cannot be
0000000000000000000000000000000000000000;;	 * run when the 'SecurityContextDeny' admission controller is not used
0000000000000000000000000000000000000000;;	 * so they are skipped by default.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scTestPod(hostIPC bool, hostPID bool) *v1.Pod {
0000000000000000000000000000000000000000;;		podName := "security-context-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        podName,
0000000000000000000000000000000000000000;;				Labels:      map[string]string{"name": podName},
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				HostIPC:         hostIPC,
0000000000000000000000000000000000000000;;				HostPID:         hostPID,
0000000000000000000000000000000000000000;;				SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "test-container",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Security Context [Feature:SecurityContext]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("security-context")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support pod.Spec.SecurityContext.SupplementalGroups", func() {
0000000000000000000000000000000000000000;;			pod := scTestPod(false, false)
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"id", "-G"}
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.SupplementalGroups = []int64{1234, 5678}
0000000000000000000000000000000000000000;;			groups := []string{"1234", "5678"}
0000000000000000000000000000000000000000;;			f.TestContainerOutput("pod.Spec.SecurityContext.SupplementalGroups", pod, 0, groups)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support pod.Spec.SecurityContext.RunAsUser", func() {
0000000000000000000000000000000000000000;;			pod := scTestPod(false, false)
0000000000000000000000000000000000000000;;			userID := int64(1001)
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.RunAsUser = &userID
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"sh", "-c", "id -u"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("pod.Spec.SecurityContext.RunAsUser", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("%v", userID),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support container.SecurityContext.RunAsUser", func() {
0000000000000000000000000000000000000000;;			pod := scTestPod(false, false)
0000000000000000000000000000000000000000;;			userID := int64(1001)
0000000000000000000000000000000000000000;;			overrideUserID := int64(1002)
0000000000000000000000000000000000000000;;			pod.Spec.SecurityContext.RunAsUser = &userID
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].SecurityContext = new(v1.SecurityContext)
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].SecurityContext.RunAsUser = &overrideUserID
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"sh", "-c", "id -u"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.TestContainerOutput("pod.Spec.SecurityContext.RunAsUser", pod, 0, []string{
0000000000000000000000000000000000000000;;				fmt.Sprintf("%v", overrideUserID),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support volume SELinux relabeling", func() {
0000000000000000000000000000000000000000;;			testPodSELinuxLabeling(f, false, false)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support volume SELinux relabeling when using hostIPC", func() {
0000000000000000000000000000000000000000;;			testPodSELinuxLabeling(f, true, false)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support volume SELinux relabeling when using hostPID", func() {
0000000000000000000000000000000000000000;;			testPodSELinuxLabeling(f, false, true)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support seccomp alpha unconfined annotation on the container [Feature:Seccomp]", func() {
0000000000000000000000000000000000000000;;			// TODO: port to SecurityContext as soon as seccomp is out of alpha
0000000000000000000000000000000000000000;;			pod := scTestPod(false, false)
0000000000000000000000000000000000000000;;			pod.Annotations[v1.SeccompContainerAnnotationKeyPrefix+"test-container"] = "unconfined"
0000000000000000000000000000000000000000;;			pod.Annotations[v1.SeccompPodAnnotationKey] = "docker/default"
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"grep", "ecc", "/proc/self/status"}
0000000000000000000000000000000000000000;;			f.TestContainerOutput(v1.SeccompPodAnnotationKey, pod, 0, []string{"0"}) // seccomp disabled
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support seccomp alpha unconfined annotation on the pod [Feature:Seccomp]", func() {
0000000000000000000000000000000000000000;;			// TODO: port to SecurityContext as soon as seccomp is out of alpha
0000000000000000000000000000000000000000;;			pod := scTestPod(false, false)
0000000000000000000000000000000000000000;;			pod.Annotations[v1.SeccompPodAnnotationKey] = "unconfined"
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"grep", "ecc", "/proc/self/status"}
0000000000000000000000000000000000000000;;			f.TestContainerOutput(v1.SeccompPodAnnotationKey, pod, 0, []string{"0"}) // seccomp disabled
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support seccomp alpha docker/default annotation [Feature:Seccomp]", func() {
0000000000000000000000000000000000000000;;			// TODO: port to SecurityContext as soon as seccomp is out of alpha
0000000000000000000000000000000000000000;;			pod := scTestPod(false, false)
0000000000000000000000000000000000000000;;			pod.Annotations[v1.SeccompContainerAnnotationKeyPrefix+"test-container"] = "docker/default"
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"grep", "ecc", "/proc/self/status"}
0000000000000000000000000000000000000000;;			f.TestContainerOutput(v1.SeccompPodAnnotationKey, pod, 0, []string{"2"}) // seccomp filtered
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support seccomp default which is unconfined [Feature:Seccomp]", func() {
0000000000000000000000000000000000000000;;			// TODO: port to SecurityContext as soon as seccomp is out of alpha
0000000000000000000000000000000000000000;;			pod := scTestPod(false, false)
0000000000000000000000000000000000000000;;			pod.Spec.Containers[0].Command = []string{"grep", "ecc", "/proc/self/status"}
0000000000000000000000000000000000000000;;			f.TestContainerOutput(v1.SeccompPodAnnotationKey, pod, 0, []string{"0"}) // seccomp disabled
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testPodSELinuxLabeling(f *framework.Framework, hostIPC bool, hostPID bool) {
0000000000000000000000000000000000000000;;		// Write and read a file with an empty_dir volume
0000000000000000000000000000000000000000;;		// with a pod with the MCS label s0:c0,c1
0000000000000000000000000000000000000000;;		pod := scTestPod(hostIPC, hostPID)
0000000000000000000000000000000000000000;;		volumeName := "test-volume"
0000000000000000000000000000000000000000;;		mountPath := "/mounted_volume"
0000000000000000000000000000000000000000;;		pod.Spec.Containers[0].VolumeMounts = []v1.VolumeMount{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:      volumeName,
0000000000000000000000000000000000000000;;				MountPath: mountPath,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Spec.Volumes = []v1.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					EmptyDir: &v1.EmptyDirVolumeSource{
0000000000000000000000000000000000000000;;						Medium: v1.StorageMediumDefault,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Spec.SecurityContext.SELinuxOptions = &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;			Level: "s0:c0,c1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Spec.Containers[0].Command = []string{"sleep", "6000"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := f.ClientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;		pod, err := client.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Error creating pod %v", pod)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForPodRunningInNamespace(f.ClientSet, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContent := "hello"
0000000000000000000000000000000000000000;;		testFilePath := mountPath + "/TEST"
0000000000000000000000000000000000000000;;		err = f.WriteFileViaContainer(pod.Name, pod.Spec.Containers[0].Name, testFilePath, testContent)
0000000000000000000000000000000000000000;;		Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		content, err := f.ReadFileViaContainer(pod.Name, pod.Spec.Containers[0].Name, testFilePath)
0000000000000000000000000000000000000000;;		Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;		Expect(content).To(ContainSubstring(testContent))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foundPod, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Confirm that the file can be accessed from a second
0000000000000000000000000000000000000000;;		// pod using host_path with the same MCS label
0000000000000000000000000000000000000000;;		volumeHostPath := fmt.Sprintf("%s/pods/%s/volumes/kubernetes.io~empty-dir/%s", framework.TestContext.KubeVolumeDir, foundPod.UID, volumeName)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("confirming a container with the same label can read the file under --volume-dir=%s", framework.TestContext.KubeVolumeDir))
0000000000000000000000000000000000000000;;		pod = scTestPod(hostIPC, hostPID)
0000000000000000000000000000000000000000;;		pod.Spec.NodeName = foundPod.Spec.NodeName
0000000000000000000000000000000000000000;;		volumeMounts := []v1.VolumeMount{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name:      volumeName,
0000000000000000000000000000000000000000;;				MountPath: mountPath,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumes := []v1.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;						Path: volumeHostPath,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Spec.Containers[0].VolumeMounts = volumeMounts
0000000000000000000000000000000000000000;;		pod.Spec.Volumes = volumes
0000000000000000000000000000000000000000;;		pod.Spec.Containers[0].Command = []string{"cat", testFilePath}
0000000000000000000000000000000000000000;;		pod.Spec.SecurityContext.SELinuxOptions = &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;			Level: "s0:c0,c1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.TestContainerOutput("Pod with same MCS label reading test file", pod, 0, []string{testContent})
0000000000000000000000000000000000000000;;		// Confirm that the same pod with a different MCS
0000000000000000000000000000000000000000;;		// label cannot access the volume
0000000000000000000000000000000000000000;;		pod = scTestPod(hostIPC, hostPID)
0000000000000000000000000000000000000000;;		pod.Spec.Volumes = volumes
0000000000000000000000000000000000000000;;		pod.Spec.Containers[0].VolumeMounts = volumeMounts
0000000000000000000000000000000000000000;;		pod.Spec.Containers[0].Command = []string{"sleep", "6000"}
0000000000000000000000000000000000000000;;		pod.Spec.SecurityContext.SELinuxOptions = &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;			Level: "s0:c2,c3",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = client.Create(pod)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Error creating pod %v", pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = f.WaitForPodRunning(pod.Name)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Error waiting for pod to run %v", pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		content, err = f.ReadFileViaContainer(pod.Name, "test-container", testFilePath)
0000000000000000000000000000000000000000;;		Expect(content).NotTo(ContainSubstring(testContent))
0000000000000000000000000000000000000000;;	}
