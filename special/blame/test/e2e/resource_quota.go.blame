0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8308c2400099c1db7c431d3e1e40b016ecbf6aff;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota/evaluator/core"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// how long to wait for a resource quota update to occur
0000000000000000000000000000000000000000;;		resourceQuotaTimeout = 30 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var classGold string = "gold"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("ResourceQuota", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("resourcequota")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a ResourceQuota and ensure its status is promptly calculated.", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota")
0000000000000000000000000000000000000000;;			quotaName := "test-quota"
0000000000000000000000000000000000000000;;			resourceQuota := newTestResourceQuota(quotaName)
0000000000000000000000000000000000000000;;			resourceQuota, err := createResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuota)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a ResourceQuota and capture the life of a service.", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota")
0000000000000000000000000000000000000000;;			quotaName := "test-quota"
0000000000000000000000000000000000000000;;			resourceQuota := newTestResourceQuota(quotaName)
0000000000000000000000000000000000000000;;			resourceQuota, err := createResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuota)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a Service")
0000000000000000000000000000000000000000;;			service := newTestServiceForQuota("test-service", v1.ServiceTypeClusterIP)
0000000000000000000000000000000000000000;;			service, err = f.ClientSet.Core().Services(f.Namespace.Name).Create(service)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status captures service creation")
0000000000000000000000000000000000000000;;			usedResources = v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceServices] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting a Service")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Services(f.Namespace.Name).Delete(service.Name, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceServices] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a ResourceQuota and capture the life of a secret.", func() {
0000000000000000000000000000000000000000;;			By("Discovering how many secrets are in namespace by default")
0000000000000000000000000000000000000000;;			found, unchanged := 0, 0
0000000000000000000000000000000000000000;;			wait.Poll(1*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				secrets, err := f.ClientSet.Core().Secrets(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				if len(secrets.Items) == found {
0000000000000000000000000000000000000000;;					// loop until the number of secrets has stabilized for 5 seconds
0000000000000000000000000000000000000000;;					unchanged++
0000000000000000000000000000000000000000;;					return unchanged > 4, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				unchanged = 0
0000000000000000000000000000000000000000;;				found = len(secrets.Items)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			defaultSecrets := fmt.Sprintf("%d", found)
0000000000000000000000000000000000000000;;			hardSecrets := fmt.Sprintf("%d", found+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota")
0000000000000000000000000000000000000000;;			quotaName := "test-quota"
0000000000000000000000000000000000000000;;			resourceQuota := newTestResourceQuota(quotaName)
0000000000000000000000000000000000000000;;			resourceQuota.Spec.Hard[v1.ResourceSecrets] = resource.MustParse(hardSecrets)
0000000000000000000000000000000000000000;;			resourceQuota, err := createResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuota)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceSecrets] = resource.MustParse(defaultSecrets)
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a Secret")
0000000000000000000000000000000000000000;;			secret := newTestSecretForQuota("test-secret")
0000000000000000000000000000000000000000;;			secret, err = f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status captures secret creation")
0000000000000000000000000000000000000000;;			usedResources = v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceSecrets] = resource.MustParse(hardSecrets)
0000000000000000000000000000000000000000;;			// we expect there to be two secrets because each namespace will receive
0000000000000000000000000000000000000000;;			// a service account token secret by default
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting a secret")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Secrets(f.Namespace.Name).Delete(secret.Name, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceSecrets] = resource.MustParse(defaultSecrets)
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a ResourceQuota and capture the life of a pod.", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota")
0000000000000000000000000000000000000000;;			quotaName := "test-quota"
0000000000000000000000000000000000000000;;			resourceQuota := newTestResourceQuota(quotaName)
0000000000000000000000000000000000000000;;			resourceQuota, err := createResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuota)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a Pod that fits quota")
0000000000000000000000000000000000000000;;			podName := "test-pod"
0000000000000000000000000000000000000000;;			requests := v1.ResourceList{}
0000000000000000000000000000000000000000;;			requests[v1.ResourceCPU] = resource.MustParse("500m")
0000000000000000000000000000000000000000;;			requests[v1.ResourceMemory] = resource.MustParse("252Mi")
0000000000000000000000000000000000000000;;			pod := newTestPodForQuota(f, podName, requests, v1.ResourceList{})
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			podToUpdate := pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring ResourceQuota status captures the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceCPU] = requests[v1.ResourceCPU]
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceMemory] = requests[v1.ResourceMemory]
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Not allowing a pod to be created that exceeds remaining quota")
0000000000000000000000000000000000000000;;			requests = v1.ResourceList{}
0000000000000000000000000000000000000000;;			requests[v1.ResourceCPU] = resource.MustParse("600m")
0000000000000000000000000000000000000000;;			requests[v1.ResourceMemory] = resource.MustParse("100Mi")
0000000000000000000000000000000000000000;;			pod = newTestPodForQuota(f, "fail-pod", requests, v1.ResourceList{})
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring a pod cannot update its resource requirements")
0000000000000000000000000000000000000000;;			// a pod cannot dynamically update its resource requirements.
0000000000000000000000000000000000000000;;			requests = v1.ResourceList{}
0000000000000000000000000000000000000000;;			requests[v1.ResourceCPU] = resource.MustParse("100m")
0000000000000000000000000000000000000000;;			requests[v1.ResourceMemory] = resource.MustParse("100Mi")
0000000000000000000000000000000000000000;;			podToUpdate.Spec.Containers[0].Resources.Requests = requests
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().Pods(f.Namespace.Name).Update(podToUpdate)
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring attempts to update pod resource requirements did not change quota usage")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the pod")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Pods(f.Namespace.Name).Delete(podName, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a ResourceQuota and capture the life of a configMap.", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota")
0000000000000000000000000000000000000000;;			quotaName := "test-quota"
0000000000000000000000000000000000000000;;			resourceQuota := newTestResourceQuota(quotaName)
0000000000000000000000000000000000000000;;			resourceQuota, err := createResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuota)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a ConfigMap")
0000000000000000000000000000000000000000;;			configMap := newTestConfigMapForQuota("test-configmap")
0000000000000000000000000000000000000000;;			configMap, err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Create(configMap)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status captures configMap creation")
0000000000000000000000000000000000000000;;			usedResources = v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceConfigMaps] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting a ConfigMap")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().ConfigMaps(f.Namespace.Name).Delete(configMap.Name, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceConfigMaps] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a ResourceQuota and capture the life of a replication controller.", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota")
0000000000000000000000000000000000000000;;			quotaName := "test-quota"
0000000000000000000000000000000000000000;;			resourceQuota := newTestResourceQuota(quotaName)
0000000000000000000000000000000000000000;;			resourceQuota, err := createResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuota)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceReplicationControllers] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a ReplicationController")
0000000000000000000000000000000000000000;;			replicationController := newTestReplicationControllerForQuota("test-rc", "nginx", 0)
0000000000000000000000000000000000000000;;			replicationController, err = f.ClientSet.Core().ReplicationControllers(f.Namespace.Name).Create(replicationController)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status captures replication controller creation")
0000000000000000000000000000000000000000;;			usedResources = v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceReplicationControllers] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting a ReplicationController")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().ReplicationControllers(f.Namespace.Name).Delete(replicationController.Name, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceReplicationControllers] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota")
0000000000000000000000000000000000000000;;			quotaName := "test-quota"
0000000000000000000000000000000000000000;;			resourceQuota := newTestResourceQuota(quotaName)
0000000000000000000000000000000000000000;;			resourceQuota, err := createResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuota)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePersistentVolumeClaims] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsStorage] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a PersistentVolumeClaim")
0000000000000000000000000000000000000000;;			pvc := newTestPersistentVolumeClaimForQuota("test-claim")
0000000000000000000000000000000000000000;;			pvc, err = f.ClientSet.Core().PersistentVolumeClaims(f.Namespace.Name).Create(pvc)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status captures persistent volume claim creation")
0000000000000000000000000000000000000000;;			usedResources = v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePersistentVolumeClaims] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsStorage] = resource.MustParse("1Gi")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting a PersistentVolumeClaim")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().PersistentVolumeClaims(f.Namespace.Name).Delete(pvc.Name, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePersistentVolumeClaims] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsStorage] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota")
0000000000000000000000000000000000000000;;			quotaName := "test-quota"
0000000000000000000000000000000000000000;;			resourceQuota := newTestResourceQuota(quotaName)
0000000000000000000000000000000000000000;;			resourceQuota, err := createResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuota)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePersistentVolumeClaims] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsStorage] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[core.V1ResourceByStorageClass(classGold, v1.ResourcePersistentVolumeClaims)] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[core.V1ResourceByStorageClass(classGold, v1.ResourceRequestsStorage)] = resource.MustParse("0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a PersistentVolumeClaim with storage class")
0000000000000000000000000000000000000000;;			pvc := newTestPersistentVolumeClaimForQuota("test-claim")
0000000000000000000000000000000000000000;;			pvc.Spec.StorageClassName = &classGold
0000000000000000000000000000000000000000;;			pvc, err = f.ClientSet.Core().PersistentVolumeClaims(f.Namespace.Name).Create(pvc)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status captures persistent volume claim creation")
0000000000000000000000000000000000000000;;			usedResources = v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePersistentVolumeClaims] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsStorage] = resource.MustParse("1Gi")
0000000000000000000000000000000000000000;;			usedResources[core.V1ResourceByStorageClass(classGold, v1.ResourcePersistentVolumeClaims)] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[core.V1ResourceByStorageClass(classGold, v1.ResourceRequestsStorage)] = resource.MustParse("1Gi")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting a PersistentVolumeClaim")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().PersistentVolumeClaims(f.Namespace.Name).Delete(pvc.Name, nil)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePersistentVolumeClaims] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsStorage] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[core.V1ResourceByStorageClass(classGold, v1.ResourcePersistentVolumeClaims)] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[core.V1ResourceByStorageClass(classGold, v1.ResourceRequestsStorage)] = resource.MustParse("0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, quotaName, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should verify ResourceQuota with terminating scopes.", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota with terminating scope")
0000000000000000000000000000000000000000;;			quotaTerminatingName := "quota-terminating"
0000000000000000000000000000000000000000;;			resourceQuotaTerminating, err := createResourceQuota(f.ClientSet, f.Namespace.Name, newTestResourceQuotaWithScope(quotaTerminatingName, v1.ResourceQuotaScopeTerminating))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring ResourceQuota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaTerminating.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota with not terminating scope")
0000000000000000000000000000000000000000;;			quotaNotTerminatingName := "quota-not-terminating"
0000000000000000000000000000000000000000;;			resourceQuotaNotTerminating, err := createResourceQuota(f.ClientSet, f.Namespace.Name, newTestResourceQuotaWithScope(quotaNotTerminatingName, v1.ResourceQuotaScopeNotTerminating))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring ResourceQuota status is calculated")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaNotTerminating.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a long running pod")
0000000000000000000000000000000000000000;;			podName := "test-pod"
0000000000000000000000000000000000000000;;			requests := v1.ResourceList{}
0000000000000000000000000000000000000000;;			requests[v1.ResourceCPU] = resource.MustParse("500m")
0000000000000000000000000000000000000000;;			requests[v1.ResourceMemory] = resource.MustParse("200Mi")
0000000000000000000000000000000000000000;;			limits := v1.ResourceList{}
0000000000000000000000000000000000000000;;			limits[v1.ResourceCPU] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			limits[v1.ResourceMemory] = resource.MustParse("400Mi")
0000000000000000000000000000000000000000;;			pod := newTestPodForQuota(f, podName, requests, limits)
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota with not terminating scope captures the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsCPU] = requests[v1.ResourceCPU]
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsMemory] = requests[v1.ResourceMemory]
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsCPU] = limits[v1.ResourceCPU]
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsMemory] = limits[v1.ResourceMemory]
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaNotTerminating.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota with terminating scope ignored the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaTerminating.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the pod")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Pods(f.Namespace.Name).Delete(podName, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaNotTerminating.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a terminating pod")
0000000000000000000000000000000000000000;;			podName = "terminating-pod"
0000000000000000000000000000000000000000;;			pod = newTestPodForQuota(f, podName, requests, limits)
0000000000000000000000000000000000000000;;			activeDeadlineSeconds := int64(3600)
0000000000000000000000000000000000000000;;			pod.Spec.ActiveDeadlineSeconds = &activeDeadlineSeconds
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota with terminating scope captures the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsCPU] = requests[v1.ResourceCPU]
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsMemory] = requests[v1.ResourceMemory]
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsCPU] = limits[v1.ResourceCPU]
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsMemory] = limits[v1.ResourceMemory]
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaTerminating.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota with not terminating scope ignored the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaNotTerminating.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the pod")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Pods(f.Namespace.Name).Delete(podName, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceRequestsMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsCPU] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourceLimitsMemory] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaTerminating.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should verify ResourceQuota with best effort scope.", func() {
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota with best effort scope")
0000000000000000000000000000000000000000;;			resourceQuotaBestEffort, err := createResourceQuota(f.ClientSet, f.Namespace.Name, newTestResourceQuotaWithScope("quota-besteffort", v1.ResourceQuotaScopeBestEffort))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring ResourceQuota status is calculated")
0000000000000000000000000000000000000000;;			usedResources := v1.ResourceList{}
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaBestEffort.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a ResourceQuota with not best effort scope")
0000000000000000000000000000000000000000;;			resourceQuotaNotBestEffort, err := createResourceQuota(f.ClientSet, f.Namespace.Name, newTestResourceQuotaWithScope("quota-not-besteffort", v1.ResourceQuotaScopeNotBestEffort))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring ResourceQuota status is calculated")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaNotBestEffort.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a best-effort pod")
0000000000000000000000000000000000000000;;			pod := newTestPodForQuota(f, podName, v1.ResourceList{}, v1.ResourceList{})
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota with best effort scope captures the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaBestEffort.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota with not best effort ignored the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaNotBestEffort.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the pod")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Pods(f.Namespace.Name).Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaBestEffort.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a not best-effort pod")
0000000000000000000000000000000000000000;;			requests := v1.ResourceList{}
0000000000000000000000000000000000000000;;			requests[v1.ResourceCPU] = resource.MustParse("500m")
0000000000000000000000000000000000000000;;			requests[v1.ResourceMemory] = resource.MustParse("200Mi")
0000000000000000000000000000000000000000;;			limits := v1.ResourceList{}
0000000000000000000000000000000000000000;;			limits[v1.ResourceCPU] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			limits[v1.ResourceMemory] = resource.MustParse("400Mi")
0000000000000000000000000000000000000000;;			pod = newTestPodForQuota(f, "burstable-pod", requests, limits)
0000000000000000000000000000000000000000;;			pod, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota with not best effort scope captures the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaNotBestEffort.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota with best effort scope ignored the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaBestEffort.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Deleting the pod")
0000000000000000000000000000000000000000;;			err = f.ClientSet.Core().Pods(f.Namespace.Name).Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Ensuring resource quota status released the pod usage")
0000000000000000000000000000000000000000;;			usedResources[v1.ResourcePods] = resource.MustParse("0")
0000000000000000000000000000000000000000;;			err = waitForResourceQuota(f.ClientSet, f.Namespace.Name, resourceQuotaNotBestEffort.Name, usedResources)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTestResourceQuotaWithScope returns a quota that enforces default constraints for testing with scopes
0000000000000000000000000000000000000000;;	func newTestResourceQuotaWithScope(name string, scope v1.ResourceQuotaScope) *v1.ResourceQuota {
0000000000000000000000000000000000000000;;		hard := v1.ResourceList{}
0000000000000000000000000000000000000000;;		hard[v1.ResourcePods] = resource.MustParse("5")
0000000000000000000000000000000000000000;;		switch scope {
0000000000000000000000000000000000000000;;		case v1.ResourceQuotaScopeTerminating, v1.ResourceQuotaScopeNotTerminating:
0000000000000000000000000000000000000000;;			hard[v1.ResourceRequestsCPU] = resource.MustParse("1")
0000000000000000000000000000000000000000;;			hard[v1.ResourceRequestsMemory] = resource.MustParse("500Mi")
0000000000000000000000000000000000000000;;			hard[v1.ResourceLimitsCPU] = resource.MustParse("2")
0000000000000000000000000000000000000000;;			hard[v1.ResourceLimitsMemory] = resource.MustParse("1Gi")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name},
0000000000000000000000000000000000000000;;			Spec:       v1.ResourceQuotaSpec{Hard: hard, Scopes: []v1.ResourceQuotaScope{scope}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTestResourceQuota returns a quota that enforces default constraints for testing
0000000000000000000000000000000000000000;;	func newTestResourceQuota(name string) *v1.ResourceQuota {
0000000000000000000000000000000000000000;;		hard := v1.ResourceList{}
0000000000000000000000000000000000000000;;		hard[v1.ResourcePods] = resource.MustParse("5")
0000000000000000000000000000000000000000;;		hard[v1.ResourceServices] = resource.MustParse("10")
0000000000000000000000000000000000000000;;		hard[v1.ResourceServicesNodePorts] = resource.MustParse("1")
0000000000000000000000000000000000000000;;		hard[v1.ResourceServicesLoadBalancers] = resource.MustParse("1")
0000000000000000000000000000000000000000;;		hard[v1.ResourceReplicationControllers] = resource.MustParse("10")
0000000000000000000000000000000000000000;;		hard[v1.ResourceQuotas] = resource.MustParse("1")
0000000000000000000000000000000000000000;;		hard[v1.ResourceCPU] = resource.MustParse("1")
0000000000000000000000000000000000000000;;		hard[v1.ResourceMemory] = resource.MustParse("500Mi")
0000000000000000000000000000000000000000;;		hard[v1.ResourceConfigMaps] = resource.MustParse("2")
0000000000000000000000000000000000000000;;		hard[v1.ResourceSecrets] = resource.MustParse("10")
0000000000000000000000000000000000000000;;		hard[v1.ResourcePersistentVolumeClaims] = resource.MustParse("10")
0000000000000000000000000000000000000000;;		hard[v1.ResourceRequestsStorage] = resource.MustParse("10Gi")
0000000000000000000000000000000000000000;;		hard[core.V1ResourceByStorageClass(classGold, v1.ResourcePersistentVolumeClaims)] = resource.MustParse("10")
0000000000000000000000000000000000000000;;		hard[core.V1ResourceByStorageClass(classGold, v1.ResourceRequestsStorage)] = resource.MustParse("10Gi")
0000000000000000000000000000000000000000;;		return &v1.ResourceQuota{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name},
0000000000000000000000000000000000000000;;			Spec:       v1.ResourceQuotaSpec{Hard: hard},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTestPodForQuota returns a pod that has the specified requests and limits
0000000000000000000000000000000000000000;;	func newTestPodForQuota(f *framework.Framework, name string, requests v1.ResourceList, limits v1.ResourceList) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "pause",
0000000000000000000000000000000000000000;;						Image: framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;						Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;							Requests: requests,
0000000000000000000000000000000000000000;;							Limits:   limits,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTestPersistentVolumeClaimForQuota returns a simple persistent volume claim
0000000000000000000000000000000000000000;;	func newTestPersistentVolumeClaimForQuota(name string) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		return &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;					v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;					v1.ReadWriteMany,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTestReplicationControllerForQuota returns a simple replication controller
0000000000000000000000000000000000000000;;	func newTestReplicationControllerForQuota(name, image string, replicas int32) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		return &v1.ReplicationController{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: func(i int32) *int32 { return &i }(replicas),
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"name": name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": name},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  name,
0000000000000000000000000000000000000000;;								Image: image,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTestServiceForQuota returns a simple service
0000000000000000000000000000000000000000;;	func newTestServiceForQuota(name string, serviceType v1.ServiceType) *v1.Service {
0000000000000000000000000000000000000000;;		return &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: serviceType,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       80,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestConfigMapForQuota(name string) *v1.ConfigMap {
0000000000000000000000000000000000000000;;		return &v1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string]string{
0000000000000000000000000000000000000000;;				"a": "b",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestSecretForQuota(name string) *v1.Secret {
0000000000000000000000000000000000000000;;		return &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"data-1": []byte("value-1\n"),
0000000000000000000000000000000000000000;;				"data-2": []byte("value-2\n"),
0000000000000000000000000000000000000000;;				"data-3": []byte("value-3\n"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createResourceQuota in the specified namespace
0000000000000000000000000000000000000000;;	func createResourceQuota(c clientset.Interface, namespace string, resourceQuota *v1.ResourceQuota) (*v1.ResourceQuota, error) {
0000000000000000000000000000000000000000;;		return c.Core().ResourceQuotas(namespace).Create(resourceQuota)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteResourceQuota with the specified name
0000000000000000000000000000000000000000;;	func deleteResourceQuota(c clientset.Interface, namespace, name string) error {
0000000000000000000000000000000000000000;;		return c.Core().ResourceQuotas(namespace).Delete(name, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait for resource quota status to show the expected used resources value
0000000000000000000000000000000000000000;;	func waitForResourceQuota(c clientset.Interface, ns, quotaName string, used v1.ResourceList) error {
0000000000000000000000000000000000000000;;		return wait.Poll(framework.Poll, resourceQuotaTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			resourceQuota, err := c.Core().ResourceQuotas(ns).Get(quotaName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// used may not yet be calculated
0000000000000000000000000000000000000000;;			if resourceQuota.Status.Used == nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// verify that the quota shows the expected used resource values
0000000000000000000000000000000000000000;;			for k, v := range used {
0000000000000000000000000000000000000000;;				if actualValue, found := resourceQuota.Status.Used[k]; !found || (actualValue.Cmp(v) != 0) {
0000000000000000000000000000000000000000;;					framework.Logf("resource %s, expected %s, actual %s", k, v.String(), actualValue.String())
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
