0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
2d7f570cb7fcee3c36ae1dde8e5755b7236633bc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batchv1 "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		batchv2alpha1 "k8s.io/api/batch/v2alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stagingClientPod(name, value string) clientv1.Pod {
0000000000000000000000000000000000000000;;		return clientv1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"name": "foo",
0000000000000000000000000000000000000000;;					"time": value,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: clientv1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []clientv1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "nginx",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;						Ports: []clientv1.ContainerPort{{ContainerPort: 80}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testingPod(name, value string) v1.Pod {
0000000000000000000000000000000000000000;;		return v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"name": "foo",
0000000000000000000000000000000000000000;;					"time": value,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "nginx",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{{ContainerPort: 80}},
0000000000000000000000000000000000000000;;						LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;							Handler: v1.Handler{
0000000000000000000000000000000000000000;;								HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;									Path: "/index.html",
0000000000000000000000000000000000000000;;									Port: intstr.FromInt(8080),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							InitialDelaySeconds: 30,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func observeCreation(w watch.Interface) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;			if event.Type != watch.Added {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to observe the creation: %v", event)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(30 * time.Second):
0000000000000000000000000000000000000000;;			framework.Failf("Timeout while waiting for observing the creation")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func observeObjectDeletion(w watch.Interface) (obj runtime.Object) {
0000000000000000000000000000000000000000;;		// output to give us a duration to failure.  Maybe we aren't getting the
0000000000000000000000000000000000000000;;		// full timeout for some reason.  My guess would be watch failure
0000000000000000000000000000000000000000;;		framework.Logf("Starting to observe pod deletion")
0000000000000000000000000000000000000000;;		deleted := false
0000000000000000000000000000000000000000;;		timeout := false
0000000000000000000000000000000000000000;;		timer := time.After(framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;		for !deleted && !timeout {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, normal := <-w.ResultChan():
0000000000000000000000000000000000000000;;				if !normal {
0000000000000000000000000000000000000000;;					framework.Failf("The channel was closed unexpectedly")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if event.Type == watch.Deleted {
0000000000000000000000000000000000000000;;					obj = event.Object
0000000000000000000000000000000000000000;;					deleted = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-timer:
0000000000000000000000000000000000000000;;				timeout = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !deleted {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to observe pod deletion")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func observerUpdate(w watch.Interface, expectedUpdate func(runtime.Object) bool) {
0000000000000000000000000000000000000000;;		timer := time.After(30 * time.Second)
0000000000000000000000000000000000000000;;		updated := false
0000000000000000000000000000000000000000;;		timeout := false
0000000000000000000000000000000000000000;;		for !updated && !timeout {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;				if event.Type == watch.Modified {
0000000000000000000000000000000000000000;;					if expectedUpdate(event.Object) {
0000000000000000000000000000000000000000;;						updated = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-timer:
0000000000000000000000000000000000000000;;				timeout = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !updated {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to observe pod update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Generated release_1_5 clientset", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("clientset")
0000000000000000000000000000000000000000;;		It("should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod", func() {
0000000000000000000000000000000000000000;;			podClient := f.ClientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			By("constructing the pod")
0000000000000000000000000000000000000000;;			name := "pod" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;			podCopy := testingPod(name, value)
0000000000000000000000000000000000000000;;			pod := &podCopy
0000000000000000000000000000000000000000;;			By("setting up watch")
0000000000000000000000000000000000000000;;			selector := labels.SelectorFromSet(labels.Set(map[string]string{"time": value})).String()
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector}
0000000000000000000000000000000000000000;;			pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to query for pods: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{
0000000000000000000000000000000000000000;;				LabelSelector:   selector,
0000000000000000000000000000000000000000;;				ResourceVersion: pods.ListMeta.ResourceVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w, err := podClient.Watch(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to set up watch: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			pod, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the pod is in kubernetes")
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{
0000000000000000000000000000000000000000;;				LabelSelector:   selector,
0000000000000000000000000000000000000000;;				ResourceVersion: pod.ResourceVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pods, err = podClient.List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to query for pods: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying pod creation was observed")
0000000000000000000000000000000000000000;;			observeCreation(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We need to wait for the pod to be scheduled, otherwise the deletion
0000000000000000000000000000000000000000;;			// will be carried out immediately rather than gracefully.
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.WaitForPodRunning(pod.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("deleting the pod gracefully")
0000000000000000000000000000000000000000;;			gracePeriod := int64(31)
0000000000000000000000000000000000000000;;			if err := podClient.Delete(pod.Name, metav1.NewDeleteOptions(gracePeriod)); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to delete pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the deletionTimestamp and deletionGracePeriodSeconds of the pod is set")
0000000000000000000000000000000000000000;;			observerUpdate(w, func(obj runtime.Object) bool {
0000000000000000000000000000000000000000;;				pod := obj.(*v1.Pod)
0000000000000000000000000000000000000000;;				return pod.ObjectMeta.DeletionTimestamp != nil && *pod.ObjectMeta.DeletionGracePeriodSeconds == gracePeriod
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestingCronJob(name string, value string) *batchv2alpha1.CronJob {
0000000000000000000000000000000000000000;;		parallelism := int32(1)
0000000000000000000000000000000000000000;;		completions := int32(1)
0000000000000000000000000000000000000000;;		return &batchv2alpha1.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				Labels: map[string]string{
0000000000000000000000000000000000000000;;					"time": value,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batchv2alpha1.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule:          "*/1 * * * ?",
0000000000000000000000000000000000000000;;				ConcurrencyPolicy: batchv2alpha1.AllowConcurrent,
0000000000000000000000000000000000000000;;				JobTemplate: batchv2alpha1.JobTemplateSpec{
0000000000000000000000000000000000000000;;					Spec: batchv1.JobSpec{
0000000000000000000000000000000000000000;;						Parallelism: &parallelism,
0000000000000000000000000000000000000000;;						Completions: &completions,
0000000000000000000000000000000000000000;;						Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;								Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name: "data",
0000000000000000000000000000000000000000;;										VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;											EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:  "c",
0000000000000000000000000000000000000000;;										Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;										VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;											{
0000000000000000000000000000000000000000;;												MountPath: "/data",
0000000000000000000000000000000000000000;;												Name:      "data",
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Generated release_1_5 clientset", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("clientset")
0000000000000000000000000000000000000000;;		It("should create v2alpha1 cronJobs, delete cronJobs, watch cronJobs", func() {
0000000000000000000000000000000000000000;;			var enabled bool
0000000000000000000000000000000000000000;;			groupList, err := f.ClientSet.Discovery().ServerGroups()
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			for _, group := range groupList.Groups {
0000000000000000000000000000000000000000;;				if group.Name == batchv2alpha1.GroupName {
0000000000000000000000000000000000000000;;					for _, version := range group.Versions {
0000000000000000000000000000000000000000;;						if version.Version == batchv2alpha1.SchemeGroupVersion.Version {
0000000000000000000000000000000000000000;;							enabled = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !enabled {
0000000000000000000000000000000000000000;;				framework.Logf("%s is not enabled, test skipped", batchv2alpha1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cronJobClient := f.ClientSet.BatchV2alpha1().CronJobs(f.Namespace.Name)
0000000000000000000000000000000000000000;;			By("constructing the cronJob")
0000000000000000000000000000000000000000;;			name := "cronjob" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;			cronJob := newTestingCronJob(name, value)
0000000000000000000000000000000000000000;;			By("setting up watch")
0000000000000000000000000000000000000000;;			selector := labels.SelectorFromSet(labels.Set(map[string]string{"time": value})).String()
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector}
0000000000000000000000000000000000000000;;			cronJobs, err := cronJobClient.List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to query for cronJobs: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(len(cronJobs.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{
0000000000000000000000000000000000000000;;				LabelSelector:   selector,
0000000000000000000000000000000000000000;;				ResourceVersion: cronJobs.ListMeta.ResourceVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w, err := cronJobClient.Watch(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to set up watch: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("creating the cronJob")
0000000000000000000000000000000000000000;;			cronJob, err = cronJobClient.Create(cronJob)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create cronJob: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the cronJob is in kubernetes")
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{
0000000000000000000000000000000000000000;;				LabelSelector:   selector,
0000000000000000000000000000000000000000;;				ResourceVersion: cronJob.ResourceVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cronJobs, err = cronJobClient.List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to query for cronJobs: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(len(cronJobs.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying cronJob creation was observed")
0000000000000000000000000000000000000000;;			observeCreation(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("deleting the cronJob")
0000000000000000000000000000000000000000;;			// Use DeletePropagationBackground so the CronJob is really gone when the call returns.
0000000000000000000000000000000000000000;;			propagationPolicy := metav1.DeletePropagationBackground
0000000000000000000000000000000000000000;;			if err := cronJobClient.Delete(cronJob.Name, &metav1.DeleteOptions{PropagationPolicy: &propagationPolicy}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to delete cronJob: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{LabelSelector: selector}
0000000000000000000000000000000000000000;;			cronJobs, err = cronJobClient.List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to list cronJobs to verify deletion: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(len(cronJobs.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Staging client repo client", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("clientset")
0000000000000000000000000000000000000000;;		It("should create pods, delete pods, watch pods", func() {
0000000000000000000000000000000000000000;;			podClient := f.StagingClient.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			By("constructing the pod")
0000000000000000000000000000000000000000;;			name := "pod" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;			podCopy := stagingClientPod(name, value)
0000000000000000000000000000000000000000;;			pod := &podCopy
0000000000000000000000000000000000000000;;			By("verifying no pod exists before the test")
0000000000000000000000000000000000000000;;			pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to query for pods: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			pod, err = podClient.Create(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the pod is in kubernetes")
0000000000000000000000000000000000000000;;			timeout := 1 * time.Minute
0000000000000000000000000000000000000000;;			if err := wait.PollImmediate(time.Second, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				pods, err = podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(pods.Items) == 1 {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Err : %s\n. Failed to wait for 1 pod to be created", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
