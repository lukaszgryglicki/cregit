0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
4ffe7b2058cf640850fcfbca70b345991ae00376;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package extension
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/admissionregistration/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		clientretry "k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Initializers", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("initializers")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Add failure traps once we have JustAfterEach
0000000000000000000000000000000000000000;;		// See https://github.com/onsi/ginkgo/issues/303
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be invisible to controllers by default", func() {
0000000000000000000000000000000000000000;;			ns := f.Namespace.Name
0000000000000000000000000000000000000000;;			c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podName := "uninitialized-pod"
0000000000000000000000000000000000000000;;			framework.Logf("Creating pod %s", podName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ch := make(chan struct{})
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				_, err := c.Core().Pods(ns).Create(newUninitializedPod(podName))
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				close(ch)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait to ensure the scheduler does not act on an uninitialized pod
0000000000000000000000000000000000000000;;			err := wait.PollImmediate(2*time.Second, 15*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				p, err := c.Core().Pods(ns).Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return len(p.Spec.NodeName) > 0, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Expect(err).To(Equal(wait.ErrWaitTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify that we can update an initializing pod
0000000000000000000000000000000000000000;;			pod, err := c.Core().Pods(ns).Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			pod.Annotations = map[string]string{"update-1": "test"}
0000000000000000000000000000000000000000;;			pod, err = c.Core().Pods(ns).Update(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify the list call filters out uninitialized pods
0000000000000000000000000000000000000000;;			pods, err := c.Core().Pods(ns).List(metav1.ListOptions{IncludeUninitialized: true})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(pods.Items).To(HaveLen(1))
0000000000000000000000000000000000000000;;			pods, err = c.Core().Pods(ns).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(pods.Items).To(HaveLen(0))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// clear initializers
0000000000000000000000000000000000000000;;			pod.Initializers = nil
0000000000000000000000000000000000000000;;			pod, err = c.Core().Pods(ns).Update(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// pod should now start running
0000000000000000000000000000000000000000;;			err = framework.WaitForPodRunningInNamespace(c, pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ensure create call returns
0000000000000000000000000000000000000000;;			<-ch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify that we cannot start the pod initializing again
0000000000000000000000000000000000000000;;			pod, err = c.Core().Pods(ns).Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			pod.Initializers = &metav1.Initializers{
0000000000000000000000000000000000000000;;				Pending: []metav1.Initializer{{Name: "Other"}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = c.Core().Pods(ns).Update(pod)
0000000000000000000000000000000000000000;;			if !errors.IsInvalid(err) || !strings.Contains(err.Error(), "immutable") {
0000000000000000000000000000000000000000;;				Fail(fmt.Sprintf("expected invalid error: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should dynamically register and apply initializers to pods [Serial]", func() {
0000000000000000000000000000000000000000;;			ns := f.Namespace.Name
0000000000000000000000000000000000000000;;			c := f.ClientSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			podName := "uninitialized-pod"
0000000000000000000000000000000000000000;;			framework.Logf("Creating pod %s", podName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// create and register an initializer
0000000000000000000000000000000000000000;;			initializerName := "pod.test.e2e.kubernetes.io"
0000000000000000000000000000000000000000;;			initializerConfigName := "e2e-test-initializer"
0000000000000000000000000000000000000000;;			_, err := c.AdmissionregistrationV1alpha1().InitializerConfigurations().Create(&v1alpha1.InitializerConfiguration{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: initializerConfigName},
0000000000000000000000000000000000000000;;				Initializers: []v1alpha1.Initializer{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: initializerName,
0000000000000000000000000000000000000000;;						Rules: []v1alpha1.Rule{
0000000000000000000000000000000000000000;;							{APIGroups: []string{""}, APIVersions: []string{"*"}, Resources: []string{"pods"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				framework.Skipf("dynamic configuration of initializers requires the alpha admissionregistration.k8s.io group to be enabled")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// we must remove the initializer when the test is complete and ensure no pods are pending for that initializer
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if err := c.AdmissionregistrationV1alpha1().InitializerConfigurations().Delete(initializerConfigName, nil); err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					framework.Logf("got error on deleting %s", initializerConfigName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// poller configuration is 1 second, wait at least that long
0000000000000000000000000000000000000000;;				time.Sleep(3 * time.Second)
0000000000000000000000000000000000000000;;				// clear our initializer from anyone who got it
0000000000000000000000000000000000000000;;				removeInitializersFromAllPods(c, initializerName)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// poller configuration is 1 second, wait at least that long
0000000000000000000000000000000000000000;;			time.Sleep(3 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// run create that blocks
0000000000000000000000000000000000000000;;			ch := make(chan struct{})
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer close(ch)
0000000000000000000000000000000000000000;;				_, err := c.Core().Pods(ns).Create(newPod(podName))
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait until the pod shows up uninitialized
0000000000000000000000000000000000000000;;			By("Waiting until the pod is visible to a client")
0000000000000000000000000000000000000000;;			var pod *v1.Pod
0000000000000000000000000000000000000000;;			err = wait.PollImmediate(2*time.Second, 15*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				pod, err = c.Core().Pods(ns).Get(podName, metav1.GetOptions{IncludeUninitialized: true})
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(pod.Initializers).NotTo(BeNil())
0000000000000000000000000000000000000000;;			Expect(pod.Initializers.Pending).To(HaveLen(1))
0000000000000000000000000000000000000000;;			Expect(pod.Initializers.Pending[0].Name).To(Equal(initializerName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// pretend we are an initializer
0000000000000000000000000000000000000000;;			By("Completing initialization")
0000000000000000000000000000000000000000;;			pod.Initializers = nil
0000000000000000000000000000000000000000;;			pod, err = c.Core().Pods(ns).Update(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ensure create call returns
0000000000000000000000000000000000000000;;			<-ch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// pod should now start running
0000000000000000000000000000000000000000;;			err = framework.WaitForPodRunningInNamespace(c, pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// bypass initialization by explicitly passing an empty pending list
0000000000000000000000000000000000000000;;			By("Setting an empty initializer as an admin to bypass initialization")
0000000000000000000000000000000000000000;;			podName = "preinitialized-pod"
0000000000000000000000000000000000000000;;			pod = newUninitializedPod(podName)
0000000000000000000000000000000000000000;;			pod.Initializers.Pending = nil
0000000000000000000000000000000000000000;;			pod, err = c.Core().Pods(ns).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(pod.Initializers).To(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// bypass initialization for mirror pods
0000000000000000000000000000000000000000;;			By("Creating a mirror pod that bypasses initialization")
0000000000000000000000000000000000000000;;			podName = "mirror-pod"
0000000000000000000000000000000000000000;;			pod = newPod(podName)
0000000000000000000000000000000000000000;;			pod.Annotations = map[string]string{
0000000000000000000000000000000000000000;;				v1.MirrorPodAnnotationKey: "true",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Spec.NodeName = "node-does-not-yet-exist"
0000000000000000000000000000000000000000;;			pod, err = c.Core().Pods(ns).Create(pod)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(pod.Initializers).To(BeNil())
0000000000000000000000000000000000000000;;			Expect(pod.Annotations[v1.MirrorPodAnnotationKey]).To(Equal("true"))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newUninitializedPod(podName string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := newPod(podName)
0000000000000000000000000000000000000000;;		pod.Initializers = &metav1.Initializers{
0000000000000000000000000000000000000000;;			Pending: []metav1.Initializer{{Name: "Test"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(podName string) *v1.Pod {
0000000000000000000000000000000000000000;;		containerName := fmt.Sprintf("%s-container", podName)
0000000000000000000000000000000000000000;;		port := 8080
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  containerName,
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/porter:4524579c0eb935c056c8e75563b4e1eda31587e0",
0000000000000000000000000000000000000000;;						Env:   []v1.EnvVar{{Name: fmt.Sprintf("SERVE_PORT_%d", port), Value: "foo"}},
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{{ContainerPort: int32(port)}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeInitializersFromAllPods walks all pods and ensures they don't have the provided initializer,
0000000000000000000000000000000000000000;;	// to guarantee completing the test doesn't block the entire cluster.
0000000000000000000000000000000000000000;;	func removeInitializersFromAllPods(c clientset.Interface, initializerName string) {
0000000000000000000000000000000000000000;;		pods, err := c.Core().Pods("").List(metav1.ListOptions{IncludeUninitialized: true})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range pods.Items {
0000000000000000000000000000000000000000;;			if p.Initializers == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := clientretry.RetryOnConflict(clientretry.DefaultRetry, func() error {
0000000000000000000000000000000000000000;;				pod, err := c.Core().Pods(p.Namespace).Get(p.Name, metav1.GetOptions{IncludeUninitialized: true})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.Initializers == nil {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var updated []metav1.Initializer
0000000000000000000000000000000000000000;;				for _, pending := range pod.Initializers.Pending {
0000000000000000000000000000000000000000;;					if pending.Name != initializerName {
0000000000000000000000000000000000000000;;						updated = append(updated, pending)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(updated) == len(pod.Initializers.Pending) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pod.Initializers.Pending = updated
0000000000000000000000000000000000000000;;				if len(updated) == 0 {
0000000000000000000000000000000000000000;;					pod.Initializers = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("Found initializer on pod %s in ns %s", pod.Name, pod.Namespace)
0000000000000000000000000000000000000000;;				_, err = c.Core().Pods(p.Namespace).Update(pod)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Unable to remove initializer from pod %s in ns %s: %v", p.Name, p.Namespace, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
