0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
cae3c946d30659d09f7ca1618845b0988d26e04e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dnsTestCommon struct {
0000000000000000000000000000000000000000;;		f      *framework.Framework
0000000000000000000000000000000000000000;;		c      clientset.Interface
0000000000000000000000000000000000000000;;		ns     string
0000000000000000000000000000000000000000;;		name   string
0000000000000000000000000000000000000000;;		labels []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsPod       *v1.Pod
0000000000000000000000000000000000000000;;		utilPod      *v1.Pod
0000000000000000000000000000000000000000;;		utilService  *v1.Service
0000000000000000000000000000000000000000;;		dnsServerPod *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cm *v1.ConfigMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDnsTestCommon() dnsTestCommon {
0000000000000000000000000000000000000000;;		return dnsTestCommon{
0000000000000000000000000000000000000000;;			f:    framework.NewDefaultFramework("dns-config-map"),
0000000000000000000000000000000000000000;;			ns:   "kube-system",
0000000000000000000000000000000000000000;;			name: "kube-dns",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) init() {
0000000000000000000000000000000000000000;;		By("Finding a DNS pod")
0000000000000000000000000000000000000000;;		label := labels.SelectorFromSet(labels.Set(map[string]string{"k8s-app": "kube-dns"}))
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pods, err := t.f.ClientSet.Core().Pods("kube-system").List(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(len(pods.Items)).Should(BeNumerically(">=", 1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.dnsPod = &pods.Items[0]
0000000000000000000000000000000000000000;;		framework.Logf("Using DNS pod: %v", t.dnsPod.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) checkDNSRecord(name string, predicate func([]string) bool, timeout time.Duration) {
0000000000000000000000000000000000000000;;		t.checkDNSRecordFrom(name, predicate, "kube-dns", timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) checkDNSRecordFrom(name string, predicate func([]string) bool, target string, timeout time.Duration) {
0000000000000000000000000000000000000000;;		var actual []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(
0000000000000000000000000000000000000000;;			time.Duration(1)*time.Second,
0000000000000000000000000000000000000000;;			timeout,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				actual = t.runDig(name, target)
0000000000000000000000000000000000000000;;				if predicate(actual) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("dig result did not match: %#v after %v",
0000000000000000000000000000000000000000;;				actual, timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runDig queries for `dnsName`. Returns a list of responses.
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) runDig(dnsName, target string) []string {
0000000000000000000000000000000000000000;;		cmd := []string{"/usr/bin/dig", "+short"}
0000000000000000000000000000000000000000;;		switch target {
0000000000000000000000000000000000000000;;		case "kube-dns":
0000000000000000000000000000000000000000;;			cmd = append(cmd, "@"+t.dnsPod.Status.PodIP, "-p", "10053")
0000000000000000000000000000000000000000;;		case "dnsmasq":
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("invalid target: " + target))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd = append(cmd, dnsName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stdout, stderr, err := t.f.ExecWithOptions(framework.ExecOptions{
0000000000000000000000000000000000000000;;			Command:       cmd,
0000000000000000000000000000000000000000;;			Namespace:     t.f.Namespace.Name,
0000000000000000000000000000000000000000;;			PodName:       t.utilPod.Name,
0000000000000000000000000000000000000000;;			ContainerName: "util",
0000000000000000000000000000000000000000;;			CaptureStdout: true,
0000000000000000000000000000000000000000;;			CaptureStderr: true,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Running dig: %v, stdout: %q, stderr: %q, err: %v",
0000000000000000000000000000000000000000;;			cmd, stdout, stderr, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if stdout == "" {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return strings.Split(stdout, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) setConfigMap(cm *v1.ConfigMap) {
0000000000000000000000000000000000000000;;		if t.cm != nil {
0000000000000000000000000000000000000000;;			t.cm = cm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cm.ObjectMeta.Namespace = t.ns
0000000000000000000000000000000000000000;;		cm.ObjectMeta.Name = t.name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{
0000000000000000000000000000000000000000;;			FieldSelector: fields.Set{
0000000000000000000000000000000000000000;;				"metadata.namespace": t.ns,
0000000000000000000000000000000000000000;;				"metadata.name":      t.name,
0000000000000000000000000000000000000000;;			}.AsSelector().String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmList, err := t.c.Core().ConfigMaps(t.ns).List(options)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cmList.Items) == 0 {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating the ConfigMap (%s:%s) %+v", t.ns, t.name, *cm))
0000000000000000000000000000000000000000;;			_, err := t.c.Core().ConfigMaps(t.ns).Create(cm)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Updating the ConfigMap (%s:%s) to %+v", t.ns, t.name, *cm))
0000000000000000000000000000000000000000;;			_, err := t.c.Core().ConfigMaps(t.ns).Update(cm)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) deleteConfigMap() {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Deleting the ConfigMap (%s:%s)", t.ns, t.name))
0000000000000000000000000000000000000000;;		t.cm = nil
0000000000000000000000000000000000000000;;		err := t.c.Core().ConfigMaps(t.ns).Delete(t.name, nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) createUtilPod() {
0000000000000000000000000000000000000000;;		// Actual port # doesn't matter, just needs to exist.
0000000000000000000000000000000000000000;;		const servicePort = 10101
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.utilPod = &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "Pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace:    t.f.Namespace.Name,
0000000000000000000000000000000000000000;;				Labels:       map[string]string{"app": "e2e-dns-configmap"},
0000000000000000000000000000000000000000;;				GenerateName: "e2e-dns-configmap-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "util",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/dnsutils:e2e",
0000000000000000000000000000000000000000;;						Command: []string{"sleep", "10000"},
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{ContainerPort: servicePort, Protocol: "TCP"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		t.utilPod, err = t.c.Core().Pods(t.f.Namespace.Name).Create(t.utilPod)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Created pod %v", t.utilPod)
0000000000000000000000000000000000000000;;		Expect(t.f.WaitForPodRunning(t.utilPod.Name)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.utilService = &v1.Service{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "Service",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: t.f.Namespace.Name,
0000000000000000000000000000000000000000;;				Name:      "e2e-dns-configmap",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: map[string]string{"app": "e2e-dns-configmap"},
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Protocol:   "TCP",
0000000000000000000000000000000000000000;;						Port:       servicePort,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(servicePort),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.utilService, err = t.c.Core().Services(t.f.Namespace.Name).Create(t.utilService)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Created service %v", t.utilService)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) deleteUtilPod() {
0000000000000000000000000000000000000000;;		podClient := t.c.Core().Pods(t.f.Namespace.Name)
0000000000000000000000000000000000000000;;		if err := podClient.Delete(t.utilPod.Name, metav1.NewDeleteOptions(0)); err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Delete of pod %v:%v failed: %v",
0000000000000000000000000000000000000000;;				t.utilPod.Namespace, t.utilPod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) createDNSServer(aRecords map[string]string) {
0000000000000000000000000000000000000000;;		t.dnsServerPod = &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind: "Pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace:    t.f.Namespace.Name,
0000000000000000000000000000000000000000;;				GenerateName: "e2e-dns-configmap-dns-server-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "dns",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/k8s-dns-dnsmasq-amd64:1.13.0",
0000000000000000000000000000000000000000;;						Command: []string{
0000000000000000000000000000000000000000;;							"/usr/sbin/dnsmasq",
0000000000000000000000000000000000000000;;							"-u", "root",
0000000000000000000000000000000000000000;;							"-k",
0000000000000000000000000000000000000000;;							"--log-facility", "-",
0000000000000000000000000000000000000000;;							"-q",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				DNSPolicy: "Default",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, ip := range aRecords {
0000000000000000000000000000000000000000;;			t.dnsServerPod.Spec.Containers[0].Command = append(
0000000000000000000000000000000000000000;;				t.dnsServerPod.Spec.Containers[0].Command,
0000000000000000000000000000000000000000;;				fmt.Sprintf("-A/%v/%v", name, ip))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		t.dnsServerPod, err = t.c.Core().Pods(t.f.Namespace.Name).Create(t.dnsServerPod)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		framework.Logf("Created pod %v", t.dnsServerPod)
0000000000000000000000000000000000000000;;		Expect(t.f.WaitForPodRunning(t.dnsServerPod.Name)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.dnsServerPod, err = t.c.Core().Pods(t.f.Namespace.Name).Get(
0000000000000000000000000000000000000000;;			t.dnsServerPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsTestCommon) deleteDNSServerPod() {
0000000000000000000000000000000000000000;;		podClient := t.c.Core().Pods(t.f.Namespace.Name)
0000000000000000000000000000000000000000;;		if err := podClient.Delete(t.dnsServerPod.Name, metav1.NewDeleteOptions(0)); err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Delete of pod %v:%v failed: %v",
0000000000000000000000000000000000000000;;				t.utilPod.Namespace, t.dnsServerPod.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
