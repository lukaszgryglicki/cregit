0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
006911360d58f99aaf61c190fbe687e22b233700;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dnsFederationsConfigMapTest struct {
0000000000000000000000000000000000000000;;		dnsTestCommon
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fedMap  map[string]string
0000000000000000000000000000000000000000;;		isValid bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("DNS configMap federations", func() {
0000000000000000000000000000000000000000;;		t := &dnsNameserverTest{dnsTestCommon: newDnsTestCommon()}
0000000000000000000000000000000000000000;;		BeforeEach(func() { t.c = t.f.ClientSet })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be able to change federation configuration [Slow][Serial]", func() {
0000000000000000000000000000000000000000;;			t.run()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsFederationsConfigMapTest) run() {
0000000000000000000000000000000000000000;;		t.init()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer t.c.Core().ConfigMaps(t.ns).Delete(t.name, nil)
0000000000000000000000000000000000000000;;		t.createUtilPod()
0000000000000000000000000000000000000000;;		defer t.deleteUtilPod()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.validate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.labels = []string{"abc", "ghi"}
0000000000000000000000000000000000000000;;		valid1 := map[string]string{"federations": t.labels[0] + "=def"}
0000000000000000000000000000000000000000;;		valid1m := map[string]string{t.labels[0]: "def"}
0000000000000000000000000000000000000000;;		valid2 := map[string]string{"federations": t.labels[1] + "=xyz"}
0000000000000000000000000000000000000000;;		valid2m := map[string]string{t.labels[1]: "xyz"}
0000000000000000000000000000000000000000;;		invalid := map[string]string{"federations": "invalid.map=xyz"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("empty -> valid1")
0000000000000000000000000000000000000000;;		t.setConfigMap(&v1.ConfigMap{Data: valid1}, valid1m, true)
0000000000000000000000000000000000000000;;		t.validate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("valid1 -> valid2")
0000000000000000000000000000000000000000;;		t.setConfigMap(&v1.ConfigMap{Data: valid2}, valid2m, true)
0000000000000000000000000000000000000000;;		t.validate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("valid2 -> invalid")
0000000000000000000000000000000000000000;;		t.setConfigMap(&v1.ConfigMap{Data: invalid}, nil, false)
0000000000000000000000000000000000000000;;		t.validate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("invalid -> valid1")
0000000000000000000000000000000000000000;;		t.setConfigMap(&v1.ConfigMap{Data: valid1}, valid1m, true)
0000000000000000000000000000000000000000;;		t.validate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("valid1 -> deleted")
0000000000000000000000000000000000000000;;		t.deleteConfigMap()
0000000000000000000000000000000000000000;;		t.validate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("deleted -> invalid")
0000000000000000000000000000000000000000;;		t.setConfigMap(&v1.ConfigMap{Data: invalid}, nil, false)
0000000000000000000000000000000000000000;;		t.validate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsFederationsConfigMapTest) validate() {
0000000000000000000000000000000000000000;;		federations := t.fedMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(federations) == 0 {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Validating federation labels %v do not exist", t.labels))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, label := range t.labels {
0000000000000000000000000000000000000000;;				var federationDNS = fmt.Sprintf("e2e-dns-configmap.%s.%s.svc.cluster.local.",
0000000000000000000000000000000000000000;;					t.f.Namespace.Name, label)
0000000000000000000000000000000000000000;;				predicate := func(actual []string) bool {
0000000000000000000000000000000000000000;;					return len(actual) == 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.checkDNSRecord(federationDNS, predicate, wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for label := range federations {
0000000000000000000000000000000000000000;;				var federationDNS = fmt.Sprintf("%s.%s.%s.svc.cluster.local.",
0000000000000000000000000000000000000000;;					t.utilService.ObjectMeta.Name, t.f.Namespace.Name, label)
0000000000000000000000000000000000000000;;				var localDNS = fmt.Sprintf("%s.%s.svc.cluster.local.",
0000000000000000000000000000000000000000;;					t.utilService.ObjectMeta.Name, t.f.Namespace.Name)
0000000000000000000000000000000000000000;;				// Check local mapping. Checking a remote mapping requires
0000000000000000000000000000000000000000;;				// creating an arbitrary DNS record which is not possible at the
0000000000000000000000000000000000000000;;				// moment.
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Validating federation record %v", label))
0000000000000000000000000000000000000000;;				predicate := func(actual []string) bool {
0000000000000000000000000000000000000000;;					for _, v := range actual {
0000000000000000000000000000000000000000;;						if v == localDNS {
0000000000000000000000000000000000000000;;							return true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.checkDNSRecord(federationDNS, predicate, wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsFederationsConfigMapTest) setConfigMap(cm *v1.ConfigMap, fedMap map[string]string, isValid bool) {
0000000000000000000000000000000000000000;;		if isValid {
0000000000000000000000000000000000000000;;			t.fedMap = fedMap
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.isValid = isValid
0000000000000000000000000000000000000000;;		t.dnsTestCommon.setConfigMap(cm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsFederationsConfigMapTest) deleteConfigMap() {
0000000000000000000000000000000000000000;;		t.isValid = false
0000000000000000000000000000000000000000;;		t.dnsTestCommon.deleteConfigMap()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dnsNameserverTest struct {
0000000000000000000000000000000000000000;;		dnsTestCommon
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *dnsNameserverTest) run() {
0000000000000000000000000000000000000000;;		t.init()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.createUtilPod()
0000000000000000000000000000000000000000;;		defer t.deleteUtilPod()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.createDNSServer(map[string]string{
0000000000000000000000000000000000000000;;			"abc.acme.local": "1.1.1.1",
0000000000000000000000000000000000000000;;			"def.acme.local": "2.2.2.2",
0000000000000000000000000000000000000000;;			"widget.local":   "3.3.3.3",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		defer t.deleteDNSServerPod()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.setConfigMap(&v1.ConfigMap{Data: map[string]string{
0000000000000000000000000000000000000000;;			"stubDomains":         fmt.Sprintf(`{"acme.local":["%v"]}`, t.dnsServerPod.Status.PodIP),
0000000000000000000000000000000000000000;;			"upstreamNameservers": fmt.Sprintf(`["%v"]`, t.dnsServerPod.Status.PodIP),
0000000000000000000000000000000000000000;;		}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The ConfigMap update mechanism takes longer than the standard
0000000000000000000000000000000000000000;;		// wait.ForeverTestTimeout.
0000000000000000000000000000000000000000;;		moreForeverTestTimeout := 2 * 60 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.checkDNSRecordFrom(
0000000000000000000000000000000000000000;;			"abc.acme.local",
0000000000000000000000000000000000000000;;			func(actual []string) bool { return len(actual) == 1 && actual[0] == "1.1.1.1" },
0000000000000000000000000000000000000000;;			"dnsmasq",
0000000000000000000000000000000000000000;;			moreForeverTestTimeout)
0000000000000000000000000000000000000000;;		t.checkDNSRecordFrom(
0000000000000000000000000000000000000000;;			"def.acme.local",
0000000000000000000000000000000000000000;;			func(actual []string) bool { return len(actual) == 1 && actual[0] == "2.2.2.2" },
0000000000000000000000000000000000000000;;			"dnsmasq",
0000000000000000000000000000000000000000;;			moreForeverTestTimeout)
0000000000000000000000000000000000000000;;		t.checkDNSRecordFrom(
0000000000000000000000000000000000000000;;			"widget.local",
0000000000000000000000000000000000000000;;			func(actual []string) bool { return len(actual) == 1 && actual[0] == "3.3.3.3" },
0000000000000000000000000000000000000000;;			"dnsmasq",
0000000000000000000000000000000000000000;;			moreForeverTestTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.c.Core().ConfigMaps(t.ns).Delete(t.name, nil)
0000000000000000000000000000000000000000;;		// Wait for the deleted ConfigMap to take effect, otherwise the
0000000000000000000000000000000000000000;;		// configuration can bleed into other tests.
0000000000000000000000000000000000000000;;		t.checkDNSRecordFrom(
0000000000000000000000000000000000000000;;			"abc.acme.local",
0000000000000000000000000000000000000000;;			func(actual []string) bool { return len(actual) == 0 },
0000000000000000000000000000000000000000;;			"dnsmasq",
0000000000000000000000000000000000000000;;			moreForeverTestTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("DNS configMap nameserver", func() {
0000000000000000000000000000000000000000;;		t := &dnsNameserverTest{dnsTestCommon: newDnsTestCommon()}
0000000000000000000000000000000000000000;;		BeforeEach(func() { t.c = t.f.ClientSet })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should be able to change stubDomain configuration [Slow][Serial]", func() {
0000000000000000000000000000000000000000;;			t.run()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
