0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8685ca99b0c54f74f083670b84398182ec779afd;test/e2e/rescheduler.go[test/e2e/rescheduler.go][test/e2e/scheduling/rescheduler.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scheduling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/v1/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultTimeout = 3 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test requires Rescheduler to be enabled.
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Rescheduler [Serial]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("rescheduler")
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		var totalMillicores int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			nodes := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;			nodeCount := len(nodes.Items)
0000000000000000000000000000000000000000;;			Expect(nodeCount).NotTo(BeZero())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cpu := nodes.Items[0].Status.Capacity[v1.ResourceCPU]
0000000000000000000000000000000000000000;;			totalMillicores = int((&cpu).MilliValue()) * nodeCount
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should ensure that critical pod is scheduled in case there is no resources available", func() {
0000000000000000000000000000000000000000;;			By("reserving all available cpu")
0000000000000000000000000000000000000000;;			err := reserveAllCpu(f, "reserve-all-cpu", totalMillicores)
0000000000000000000000000000000000000000;;			defer framework.DeleteRCAndPods(f.ClientSet, f.InternalClientset, ns, "reserve-all-cpu")
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("creating a new instance of Dashboard and waiting for Dashboard to be scheduled")
0000000000000000000000000000000000000000;;			label := labels.SelectorFromSet(labels.Set(map[string]string{"k8s-app": "kubernetes-dashboard"}))
0000000000000000000000000000000000000000;;			listOpts := metav1.ListOptions{LabelSelector: label.String()}
0000000000000000000000000000000000000000;;			deployments, err := f.ClientSet.Extensions().Deployments(metav1.NamespaceSystem).List(listOpts)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			Expect(len(deployments.Items)).Should(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			deployment := deployments.Items[0]
0000000000000000000000000000000000000000;;			replicas := uint(*(deployment.Spec.Replicas))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = framework.ScaleDeployment(f.ClientSet, f.InternalClientset, metav1.NamespaceSystem, deployment.Name, replicas+1, true)
0000000000000000000000000000000000000000;;			defer framework.ExpectNoError(framework.ScaleDeployment(f.ClientSet, f.InternalClientset, metav1.NamespaceSystem, deployment.Name, replicas, true))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reserveAllCpu(f *framework.Framework, id string, millicores int) error {
0000000000000000000000000000000000000000;;		timeout := 5 * time.Minute
0000000000000000000000000000000000000000;;		replicas := millicores / 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reserveCpu(f, id, 1, 100)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.ScaleRC(f.ClientSet, f.InternalClientset, f.Namespace.Name, id, uint(replicas), false))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < timeout; time.Sleep(10 * time.Second) {
0000000000000000000000000000000000000000;;			pods, err := framework.GetPodsInNamespace(f.ClientSet, f.Namespace.Name, framework.ImagePullerLabels)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(pods) != replicas {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allRunningOrUnschedulable := true
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				if !podRunningOrUnschedulable(pod) {
0000000000000000000000000000000000000000;;					allRunningOrUnschedulable = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if allRunningOrUnschedulable {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Pod name %s: Gave up waiting %v for %d pods to come up", id, timeout, replicas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podRunningOrUnschedulable(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		_, cond := podutil.GetPodCondition(&pod.Status, v1.PodScheduled)
0000000000000000000000000000000000000000;;		if cond != nil && cond.Status == v1.ConditionFalse && cond.Reason == "Unschedulable" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		running, _ := testutils.PodRunningReady(pod)
0000000000000000000000000000000000000000;;		return running
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reserveCpu(f *framework.Framework, id string, replicas, millicores int) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Running RC which reserves %v millicores", millicores))
0000000000000000000000000000000000000000;;		request := int64(millicores / replicas)
0000000000000000000000000000000000000000;;		config := &testutils.RCConfig{
0000000000000000000000000000000000000000;;			Client:         f.ClientSet,
0000000000000000000000000000000000000000;;			InternalClient: f.InternalClientset,
0000000000000000000000000000000000000000;;			Name:           id,
0000000000000000000000000000000000000000;;			Namespace:      f.Namespace.Name,
0000000000000000000000000000000000000000;;			Timeout:        defaultTimeout,
0000000000000000000000000000000000000000;;			Image:          framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;			Replicas:       replicas,
0000000000000000000000000000000000000000;;			CpuRequest:     request,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.RunRC(*config))
0000000000000000000000000000000000000000;;	}
