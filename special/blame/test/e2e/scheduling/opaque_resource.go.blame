0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c6a685569f96d2ad2d79719bc2400a086a2b3b4d;test/e2e/opaque_resource.go[test/e2e/opaque_resource.go][test/e2e/scheduling/opaque_resource.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scheduling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/system"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/common"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Opaque resources [Feature:OpaqueResources]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("opaque-resource")
0000000000000000000000000000000000000000;;		opaqueResName := v1helper.OpaqueIntResourceName("foo")
0000000000000000000000000000000000000000;;		var node *v1.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			if node == nil {
0000000000000000000000000000000000000000;;				// Priming invocation; select the first non-master node.
0000000000000000000000000000000000000000;;				nodes, err := f.ClientSet.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				for _, n := range nodes.Items {
0000000000000000000000000000000000000000;;					if !system.IsMasterNode(n.Name) {
0000000000000000000000000000000000000000;;						node = &n
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if node == nil {
0000000000000000000000000000000000000000;;					framework.Failf("unable to select a non-master node")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			addOpaqueResource(f, node.Name, opaqueResName)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: The suite times out if removeOpaqueResource is called as part of
0000000000000000000000000000000000000000;;		//       an AfterEach closure. For now, it is the last statement in each
0000000000000000000000000000000000000000;;		//       It block.
0000000000000000000000000000000000000000;;		// AfterEach(func() {
0000000000000000000000000000000000000000;;		// 	removeOpaqueResource(f, node.Name, opaqueResName)
0000000000000000000000000000000000000000;;		// })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not break pods that do not consume opaque integer resources.", func() {
0000000000000000000000000000000000000000;;			defer removeOpaqueResource(f, node.Name, opaqueResName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a vanilla pod")
0000000000000000000000000000000000000000;;			requests := v1.ResourceList{v1.ResourceCPU: resource.MustParse("0.1")}
0000000000000000000000000000000000000000;;			limits := v1.ResourceList{v1.ResourceCPU: resource.MustParse("0.2")}
0000000000000000000000000000000000000000;;			pod := f.NewTestPod("without-oir", requests, limits)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Observing an event that indicates the pod was scheduled")
0000000000000000000000000000000000000000;;			action := func() error {
0000000000000000000000000000000000000000;;				_, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Here we don't check for the bound node name since it can land on
0000000000000000000000000000000000000000;;			// any one (this pod doesn't require any of the opaque resource.)
0000000000000000000000000000000000000000;;			predicate := scheduleSuccessEvent(pod.Name, "")
0000000000000000000000000000000000000000;;			success, err := common.ObserveEventAfterAction(f, predicate, action)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should schedule pods that do consume opaque integer resources.", func() {
0000000000000000000000000000000000000000;;			defer removeOpaqueResource(f, node.Name, opaqueResName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod that requires less of the opaque resource than is allocatable on a node.")
0000000000000000000000000000000000000000;;			requests := v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU: resource.MustParse("0.1"),
0000000000000000000000000000000000000000;;				opaqueResName:  resource.MustParse("1"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			limits := v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU: resource.MustParse("0.2"),
0000000000000000000000000000000000000000;;				opaqueResName:  resource.MustParse("2"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod := f.NewTestPod("min-oir", requests, limits)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Observing an event that indicates the pod was scheduled")
0000000000000000000000000000000000000000;;			action := func() error {
0000000000000000000000000000000000000000;;				_, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			predicate := scheduleSuccessEvent(pod.Name, node.Name)
0000000000000000000000000000000000000000;;			success, err := common.ObserveEventAfterAction(f, predicate, action)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not schedule pods that exceed the available amount of opaque integer resource.", func() {
0000000000000000000000000000000000000000;;			defer removeOpaqueResource(f, node.Name, opaqueResName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod that requires more of the opaque resource than is allocatable on any node")
0000000000000000000000000000000000000000;;			requests := v1.ResourceList{opaqueResName: resource.MustParse("6")}
0000000000000000000000000000000000000000;;			limits := v1.ResourceList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Observing an event that indicates the pod was not scheduled")
0000000000000000000000000000000000000000;;			action := func() error {
0000000000000000000000000000000000000000;;				_, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(f.NewTestPod("over-max-oir", requests, limits))
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			predicate := scheduleFailureEvent("over-max-oir")
0000000000000000000000000000000000000000;;			success, err := common.ObserveEventAfterAction(f, predicate, action)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should account opaque integer resources in pods with multiple containers.", func() {
0000000000000000000000000000000000000000;;			defer removeOpaqueResource(f, node.Name, opaqueResName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod with two containers that together require less of the opaque resource than is allocatable on a node")
0000000000000000000000000000000000000000;;			requests := v1.ResourceList{opaqueResName: resource.MustParse("1")}
0000000000000000000000000000000000000000;;			limits := v1.ResourceList{}
0000000000000000000000000000000000000000;;			image := framework.GetPauseImageName(f.ClientSet)
0000000000000000000000000000000000000000;;			// This pod consumes 2 "foo" resources.
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "mult-container-oir",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "pause",
0000000000000000000000000000000000000000;;							Image: image,
0000000000000000000000000000000000000000;;							Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;								Requests: requests,
0000000000000000000000000000000000000000;;								Limits:   limits,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "pause-sidecar",
0000000000000000000000000000000000000000;;							Image: image,
0000000000000000000000000000000000000000;;							Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;								Requests: requests,
0000000000000000000000000000000000000000;;								Limits:   limits,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Observing an event that indicates the pod was scheduled")
0000000000000000000000000000000000000000;;			action := func() error {
0000000000000000000000000000000000000000;;				_, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			predicate := scheduleSuccessEvent(pod.Name, node.Name)
0000000000000000000000000000000000000000;;			success, err := common.ObserveEventAfterAction(f, predicate, action)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod with two containers that together require more of the opaque resource than is allocatable on any node")
0000000000000000000000000000000000000000;;			requests = v1.ResourceList{opaqueResName: resource.MustParse("3")}
0000000000000000000000000000000000000000;;			limits = v1.ResourceList{}
0000000000000000000000000000000000000000;;			// This pod consumes 6 "foo" resources.
0000000000000000000000000000000000000000;;			pod = &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "mult-container-over-max-oir",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "pause",
0000000000000000000000000000000000000000;;							Image: image,
0000000000000000000000000000000000000000;;							Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;								Requests: requests,
0000000000000000000000000000000000000000;;								Limits:   limits,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "pause-sidecar",
0000000000000000000000000000000000000000;;							Image: image,
0000000000000000000000000000000000000000;;							Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;								Requests: requests,
0000000000000000000000000000000000000000;;								Limits:   limits,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Observing an event that indicates the pod was not scheduled")
0000000000000000000000000000000000000000;;			action = func() error {
0000000000000000000000000000000000000000;;				_, err = f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			predicate = scheduleFailureEvent(pod.Name)
0000000000000000000000000000000000000000;;			success, err = common.ObserveEventAfterAction(f, predicate, action)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should schedule pods that initially do not fit after enough opaque integer resources are freed.", func() {
0000000000000000000000000000000000000000;;			defer removeOpaqueResource(f, node.Name, opaqueResName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Creating a pod that requires less of the opaque resource than is allocatable on a node.")
0000000000000000000000000000000000000000;;			requests := v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU: resource.MustParse("0.1"),
0000000000000000000000000000000000000000;;				opaqueResName:  resource.MustParse("3"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			limits := v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceCPU: resource.MustParse("0.2"),
0000000000000000000000000000000000000000;;				opaqueResName:  resource.MustParse("3"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod1 := f.NewTestPod("oir-1", requests, limits)
0000000000000000000000000000000000000000;;			pod2 := f.NewTestPod("oir-2", requests, limits)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Observing an event that indicates one pod was scheduled")
0000000000000000000000000000000000000000;;			action := func() error {
0000000000000000000000000000000000000000;;				_, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod1)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			predicate := scheduleSuccessEvent(pod1.Name, node.Name)
0000000000000000000000000000000000000000;;			success, err := common.ObserveEventAfterAction(f, predicate, action)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Observing an event that indicates a subsequent pod was not scheduled")
0000000000000000000000000000000000000000;;			action = func() error {
0000000000000000000000000000000000000000;;				_, err := f.ClientSet.Core().Pods(f.Namespace.Name).Create(pod2)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			predicate = scheduleFailureEvent(pod2.Name)
0000000000000000000000000000000000000000;;			success, err = common.ObserveEventAfterAction(f, predicate, action)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Observing an event that indicates the second pod was scheduled after deleting the first pod")
0000000000000000000000000000000000000000;;			action = func() error {
0000000000000000000000000000000000000000;;				err := f.ClientSet.Core().Pods(f.Namespace.Name).Delete(pod1.Name, nil)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			predicate = scheduleSuccessEvent(pod2.Name, node.Name)
0000000000000000000000000000000000000000;;			success, err = common.ObserveEventAfterAction(f, predicate, action)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds the opaque resource to a node.
0000000000000000000000000000000000000000;;	func addOpaqueResource(f *framework.Framework, nodeName string, opaqueResName v1.ResourceName) {
0000000000000000000000000000000000000000;;		action := func() error {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Adding OIR to node [%s]", nodeName))
0000000000000000000000000000000000000000;;			patch := []byte(fmt.Sprintf(`[{"op": "add", "path": "/status/capacity/%s", "value": "5"}]`, escapeForJSONPatch(opaqueResName)))
0000000000000000000000000000000000000000;;			return f.ClientSet.Core().RESTClient().Patch(types.JSONPatchType).Resource("nodes").Name(nodeName).SubResource("status").Body(patch).Do().Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		predicate := func(n *v1.Node) bool {
0000000000000000000000000000000000000000;;			capacity, foundCap := n.Status.Capacity[opaqueResName]
0000000000000000000000000000000000000000;;			allocatable, foundAlloc := n.Status.Allocatable[opaqueResName]
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Node [%s] has OIR capacity: [%t] (%s), has OIR allocatable: [%t] (%s)", n.Name, foundCap, capacity.String(), foundAlloc, allocatable.String()))
0000000000000000000000000000000000000000;;			return foundCap && capacity.MilliValue() == int64(5000) &&
0000000000000000000000000000000000000000;;				foundAlloc && allocatable.MilliValue() == int64(5000)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		success, err := common.ObserveNodeUpdateAfterAction(f, nodeName, predicate, action)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes the opaque resource from a node.
0000000000000000000000000000000000000000;;	func removeOpaqueResource(f *framework.Framework, nodeName string, opaqueResName v1.ResourceName) {
0000000000000000000000000000000000000000;;		action := func() error {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Removing OIR from node [%s]", nodeName))
0000000000000000000000000000000000000000;;			patch := []byte(fmt.Sprintf(`[{"op": "remove", "path": "/status/capacity/%s"}]`, escapeForJSONPatch(opaqueResName)))
0000000000000000000000000000000000000000;;			f.ClientSet.Core().RESTClient().Patch(types.JSONPatchType).Resource("nodes").Name(nodeName).SubResource("status").Body(patch).Do()
0000000000000000000000000000000000000000;;			return nil // Ignore error -- the opaque resource may not exist.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		predicate := func(n *v1.Node) bool {
0000000000000000000000000000000000000000;;			capacity, foundCap := n.Status.Capacity[opaqueResName]
0000000000000000000000000000000000000000;;			allocatable, foundAlloc := n.Status.Allocatable[opaqueResName]
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Node [%s] has OIR capacity: [%t] (%s), has OIR allocatable: [%t] (%s)", n.Name, foundCap, capacity.String(), foundAlloc, allocatable.String()))
0000000000000000000000000000000000000000;;			return (!foundCap || capacity.IsZero()) && (!foundAlloc || allocatable.IsZero())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		success, err := common.ObserveNodeUpdateAfterAction(f, nodeName, predicate, action)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(success).To(Equal(true))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escapeForJSONPatch(resName v1.ResourceName) string {
0000000000000000000000000000000000000000;;		// Escape forward slashes in the resource name per the JSON Pointer spec.
0000000000000000000000000000000000000000;;		// See https://tools.ietf.org/html/rfc6901#section-3
0000000000000000000000000000000000000000;;		return strings.Replace(string(resName), "/", "~1", -1)
0000000000000000000000000000000000000000;;	}
