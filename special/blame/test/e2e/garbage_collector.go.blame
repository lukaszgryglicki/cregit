0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f4e034409f056353cebff6d554f9bb45cc8d0697;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		v1beta1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/metrics"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getForegroundOptions() *metav1.DeleteOptions {
0000000000000000000000000000000000000000;;		policy := metav1.DeletePropagationForeground
0000000000000000000000000000000000000000;;		return &metav1.DeleteOptions{PropagationPolicy: &policy}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOrphanOptions() *metav1.DeleteOptions {
0000000000000000000000000000000000000000;;		var trueVar = true
0000000000000000000000000000000000000000;;		return &metav1.DeleteOptions{OrphanDependents: &trueVar}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNonOrphanOptions() *metav1.DeleteOptions {
0000000000000000000000000000000000000000;;		var falseVar = false
0000000000000000000000000000000000000000;;		return &metav1.DeleteOptions{OrphanDependents: &falseVar}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var zero = int64(0)
0000000000000000000000000000000000000000;;	var deploymentLabels = map[string]string{"app": "gc-test"}
0000000000000000000000000000000000000000;;	var podTemplateSpec = v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;		ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;			Labels: deploymentLabels,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;			TerminationGracePeriodSeconds: &zero,
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Name:  "nginx",
0000000000000000000000000000000000000000;;					Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newOwnerDeployment(f *framework.Framework, deploymentName string) *v1beta1.Deployment {
0000000000000000000000000000000000000000;;		replicas := int32(2)
0000000000000000000000000000000000000000;;		return &v1beta1.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: deploymentName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{MatchLabels: deploymentLabels},
0000000000000000000000000000000000000000;;				Strategy: v1beta1.DeploymentStrategy{
0000000000000000000000000000000000000000;;					Type: v1beta1.RollingUpdateDeploymentStrategyType,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: podTemplateSpec,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSelector() map[string]string {
0000000000000000000000000000000000000000;;		return map[string]string{"app": "gc-test"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newOwnerRC(f *framework.Framework, name string, replicas int32) *v1.ReplicationController {
0000000000000000000000000000000000000000;;		return &v1.ReplicationController{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Selector: map[string]string{"app": "gc-test"},
0000000000000000000000000000000000000000;;				Template: &podTemplateSpec,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyRemainingDeploymentsReplicaSetsPods verifies if the number
0000000000000000000000000000000000000000;;	// of the remaining deployments, replica set and pods are deploymentNum,
0000000000000000000000000000000000000000;;	// rsNum and podNum. It returns error if the communication with the API
0000000000000000000000000000000000000000;;	// server fails.
0000000000000000000000000000000000000000;;	func verifyRemainingDeploymentsReplicaSetsPods(
0000000000000000000000000000000000000000;;		f *framework.Framework,
0000000000000000000000000000000000000000;;		clientSet clientset.Interface,
0000000000000000000000000000000000000000;;		deployment *v1beta1.Deployment,
0000000000000000000000000000000000000000;;		deploymentNum, rsNum, podNum int,
0000000000000000000000000000000000000000;;	) (bool, error) {
0000000000000000000000000000000000000000;;		var ret = true
0000000000000000000000000000000000000000;;		rs, err := clientSet.Extensions().ReplicaSets(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list rs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rs.Items) != rsNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("expected %d rs, got %d rs", rsNum, len(rs.Items)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deployments, err := clientSet.Extensions().Deployments(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list deployments: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(deployments.Items) != deploymentNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("expected %d Deploymentss, got %d Deployments", deploymentNum, len(deployments.Items)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pods, err := clientSet.CoreV1().Pods(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pods.Items) != podNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("expected %v Pods, got %d Pods", podNum, len(pods.Items)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newGCPod(name string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				TerminationGracePeriodSeconds: new(int64),
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "nginx",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/nginx:1.7.9",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyRemainingObjects verifies if the number of the remaining replication
0000000000000000000000000000000000000000;;	// controllers and pods are rcNum and podNum. It returns error if the
0000000000000000000000000000000000000000;;	// communication with the API server fails.
0000000000000000000000000000000000000000;;	func verifyRemainingObjects(f *framework.Framework, clientSet clientset.Interface, rcNum, podNum int) (bool, error) {
0000000000000000000000000000000000000000;;		rcClient := clientSet.Core().ReplicationControllers(f.Namespace.Name)
0000000000000000000000000000000000000000;;		pods, err := clientSet.Core().Pods(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ret = true
0000000000000000000000000000000000000000;;		if len(pods.Items) != podNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("expected %d pods, got %d pods", podNum, len(pods.Items)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rcs, err := rcClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Failed to list replication controllers: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rcs.Items) != rcNum {
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("expected %d RCs, got %d RCs", rcNum, len(rcs.Items)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gatherMetrics(f *framework.Framework) {
0000000000000000000000000000000000000000;;		By("Gathering metrics")
0000000000000000000000000000000000000000;;		var summary framework.TestDataSummary
0000000000000000000000000000000000000000;;		grabber, err := metrics.NewMetricsGrabber(f.ClientSet, false, false, true, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Failed to create MetricsGrabber. Skipping metrics gathering.")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			received, err := grabber.Grab()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("MetricsGrabber failed grab metrics. Skipping metrics gathering.")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				summary = (*framework.MetricsForE2E)(&received)
0000000000000000000000000000000000000000;;				framework.Logf(summary.PrintHumanReadable())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Garbage collector", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("gc")
0000000000000000000000000000000000000000;;		It("should delete pods created by rc when not orphaning", func() {
0000000000000000000000000000000000000000;;			clientSet := f.ClientSet
0000000000000000000000000000000000000000;;			rcClient := clientSet.Core().ReplicationControllers(f.Namespace.Name)
0000000000000000000000000000000000000000;;			podClient := clientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			rcName := "simpletest.rc"
0000000000000000000000000000000000000000;;			rc := newOwnerRC(f, rcName, 2)
0000000000000000000000000000000000000000;;			By("create the rc")
0000000000000000000000000000000000000000;;			rc, err := rcClient.Create(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// wait for rc to create some pods
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// We intentionally don't wait the number of pods to reach
0000000000000000000000000000000000000000;;				// rc.Spec.Replicas. We want to see if the garbage collector and the
0000000000000000000000000000000000000000;;				// rc manager work properly if the rc is deleted before it reaches
0000000000000000000000000000000000000000;;				// stasis.
0000000000000000000000000000000000000000;;				if len(pods.Items) > 0 {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to wait for the rc to create some pods: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("delete the rc")
0000000000000000000000000000000000000000;;			deleteOptions := getNonOrphanOptions()
0000000000000000000000000000000000000000;;			deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(rc.UID))
0000000000000000000000000000000000000000;;			if err := rcClient.Delete(rc.ObjectMeta.Name, deleteOptions); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("wait for all pods to be garbage collected")
0000000000000000000000000000000000000000;;			// wait for the RCs and Pods to reach the expected numbers.
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				return verifyRemainingObjects(f, clientSet, 0, 0)
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to wait for all pods to be deleted: %v", err)
0000000000000000000000000000000000000000;;				remainingPods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("failed to list pods post mortem: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Failf("remaining pods are: %#v", remainingPods)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gatherMetrics(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should orphan pods created by rc if delete options say so", func() {
0000000000000000000000000000000000000000;;			clientSet := f.ClientSet
0000000000000000000000000000000000000000;;			rcClient := clientSet.Core().ReplicationControllers(f.Namespace.Name)
0000000000000000000000000000000000000000;;			podClient := clientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			rcName := "simpletest.rc"
0000000000000000000000000000000000000000;;			rc := newOwnerRC(f, rcName, 100)
0000000000000000000000000000000000000000;;			By("create the rc")
0000000000000000000000000000000000000000;;			rc, err := rcClient.Create(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// wait for rc to create pods
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				rc, err := rcClient.Get(rc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to get rc: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if rc.Status.Replicas == *rc.Spec.Replicas {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to wait for the rc.Status.Replicas to reach rc.Spec.Replicas: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("delete the rc")
0000000000000000000000000000000000000000;;			deleteOptions := getOrphanOptions()
0000000000000000000000000000000000000000;;			deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(rc.UID))
0000000000000000000000000000000000000000;;			if err := rcClient.Delete(rc.ObjectMeta.Name, deleteOptions); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("wait for the rc to be deleted")
0000000000000000000000000000000000000000;;			// Orphaning the 100 pods takes 100 PATCH operations. The default qps of
0000000000000000000000000000000000000000;;			// a client is 5. If the qps is saturated, it will take 20s to orphan
0000000000000000000000000000000000000000;;			// the pods. However, apiserver takes hundreds of ms to finish one
0000000000000000000000000000000000000000;;			// PATCH, and the gc sends the patching in a single thread, so the
0000000000000000000000000000000000000000;;			// actual qps is less than 5. According to the test logs, 60s is enough
0000000000000000000000000000000000000000;;			// time.
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 60*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				rcs, err := rcClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to list rcs: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(rcs.Items) != 0 {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("wait for 30 seconds to see if the garbage collector mistakenly deletes the pods")
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := int(*(rc.Spec.Replicas)), len(pods.Items); e != a {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("expect %d pods, got %d pods", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}); err != nil && err != wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				framework.Failf("%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gatherMetrics(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should orphan pods created by rc if deleteOptions.OrphanDependents is nil", func() {
0000000000000000000000000000000000000000;;			clientSet := f.ClientSet
0000000000000000000000000000000000000000;;			rcClient := clientSet.Core().ReplicationControllers(f.Namespace.Name)
0000000000000000000000000000000000000000;;			podClient := clientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			rcName := "simpletest.rc"
0000000000000000000000000000000000000000;;			rc := newOwnerRC(f, rcName, 2)
0000000000000000000000000000000000000000;;			By("create the rc")
0000000000000000000000000000000000000000;;			rc, err := rcClient.Create(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// wait for rc to create some pods
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				rc, err := rcClient.Get(rc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to get rc: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if rc.Status.Replicas == *rc.Spec.Replicas {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to wait for the rc.Status.Replicas to reach rc.Spec.Replicas: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("delete the rc")
0000000000000000000000000000000000000000;;			deleteOptions := &metav1.DeleteOptions{}
0000000000000000000000000000000000000000;;			deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(rc.UID))
0000000000000000000000000000000000000000;;			if err := rcClient.Delete(rc.ObjectMeta.Name, deleteOptions); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("wait for 30 seconds to see if the garbage collector mistakenly deletes the pods")
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := int(*(rc.Spec.Replicas)), len(pods.Items); e != a {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("expect %d pods, got %d pods", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}); err != nil && err != wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				framework.Failf("%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gatherMetrics(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should delete RS created by deployment when not orphaning", func() {
0000000000000000000000000000000000000000;;			clientSet := f.ClientSet
0000000000000000000000000000000000000000;;			deployClient := clientSet.Extensions().Deployments(f.Namespace.Name)
0000000000000000000000000000000000000000;;			rsClient := clientSet.Extensions().ReplicaSets(f.Namespace.Name)
0000000000000000000000000000000000000000;;			deploymentName := "simpletest.deployment"
0000000000000000000000000000000000000000;;			deployment := newOwnerDeployment(f, deploymentName)
0000000000000000000000000000000000000000;;			By("create the deployment")
0000000000000000000000000000000000000000;;			createdDeployment, err := deployClient.Create(deployment)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create deployment: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// wait for deployment to create some rs
0000000000000000000000000000000000000000;;			By("Wait for the Deployment to create new ReplicaSet")
0000000000000000000000000000000000000000;;			err = wait.PollImmediate(500*time.Millisecond, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;				rsList, err := rsClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to list rs: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return len(rsList.Items) > 0, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Failed to wait for the Deployment to create some ReplicaSet: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("delete the deployment")
0000000000000000000000000000000000000000;;			deleteOptions := getNonOrphanOptions()
0000000000000000000000000000000000000000;;			deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(createdDeployment.UID))
0000000000000000000000000000000000000000;;			if err := deployClient.Delete(deployment.ObjectMeta.Name, deleteOptions); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete the deployment: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("wait for all rs to be garbage collected")
0000000000000000000000000000000000000000;;			err = wait.PollImmediate(500*time.Millisecond, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;				return verifyRemainingDeploymentsReplicaSetsPods(f, clientSet, deployment, 0, 0, 0)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Failed to wait for all rs to be garbage collected: %v", err)
0000000000000000000000000000000000000000;;				remainingRSs, err := rsClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("failed to list RSs post mortem: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Failf("remaining rs are: %#v", remainingRSs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gatherMetrics(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should orphan RS created by deployment when deleteOptions.OrphanDependents is true", func() {
0000000000000000000000000000000000000000;;			clientSet := f.ClientSet
0000000000000000000000000000000000000000;;			deployClient := clientSet.Extensions().Deployments(f.Namespace.Name)
0000000000000000000000000000000000000000;;			rsClient := clientSet.Extensions().ReplicaSets(f.Namespace.Name)
0000000000000000000000000000000000000000;;			deploymentName := "simpletest.deployment"
0000000000000000000000000000000000000000;;			deployment := newOwnerDeployment(f, deploymentName)
0000000000000000000000000000000000000000;;			By("create the deployment")
0000000000000000000000000000000000000000;;			createdDeployment, err := deployClient.Create(deployment)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create deployment: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// wait for deployment to create some rs
0000000000000000000000000000000000000000;;			By("Wait for the Deployment to create new ReplicaSet")
0000000000000000000000000000000000000000;;			err = wait.PollImmediate(500*time.Millisecond, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;				rsList, err := rsClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to list rs: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return len(rsList.Items) > 0, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Failed to wait for the Deployment to create some ReplicaSet: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("delete the deployment")
0000000000000000000000000000000000000000;;			deleteOptions := getOrphanOptions()
0000000000000000000000000000000000000000;;			deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(createdDeployment.UID))
0000000000000000000000000000000000000000;;			if err := deployClient.Delete(deployment.ObjectMeta.Name, deleteOptions); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete the deployment: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("wait for 2 Minute to see if the garbage collector mistakenly deletes the rs")
0000000000000000000000000000000000000000;;			err = wait.PollImmediate(5*time.Second, 2*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;				return verifyRemainingDeploymentsReplicaSetsPods(f, clientSet, deployment, 0, 1, 2)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Failed to wait to see if the garbage collecter mistakenly deletes the rs: %v", err)
0000000000000000000000000000000000000000;;				remainingRSs, err := rsClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("failed to list RSs post mortem: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Failf("remaining rs post mortem: %#v", remainingRSs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				remainingDSs, err := deployClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("failed to list Deployments post mortem: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Failf("remaining deployment's post mortem: %#v", remainingDSs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rs, err := clientSet.Extensions().ReplicaSets(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to list ReplicaSet %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, replicaSet := range rs.Items {
0000000000000000000000000000000000000000;;				if controller.GetControllerOf(&replicaSet.ObjectMeta) != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Found ReplicaSet with non nil ownerRef %v", replicaSet)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gatherMetrics(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("[Feature:GarbageCollector] should keep the rc around until all its pods are deleted if the deleteOptions says so", func() {
0000000000000000000000000000000000000000;;			clientSet := f.ClientSet
0000000000000000000000000000000000000000;;			rcClient := clientSet.Core().ReplicationControllers(f.Namespace.Name)
0000000000000000000000000000000000000000;;			podClient := clientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			rcName := "simpletest.rc"
0000000000000000000000000000000000000000;;			rc := newOwnerRC(f, rcName, 100)
0000000000000000000000000000000000000000;;			By("create the rc")
0000000000000000000000000000000000000000;;			rc, err := rcClient.Create(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// wait for rc to create pods
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				rc, err := rcClient.Get(rc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to get rc: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if rc.Status.Replicas == *rc.Spec.Replicas {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to wait for the rc.Status.Replicas to reach rc.Spec.Replicas: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("delete the rc")
0000000000000000000000000000000000000000;;			deleteOptions := getForegroundOptions()
0000000000000000000000000000000000000000;;			deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(rc.UID))
0000000000000000000000000000000000000000;;			if err := rcClient.Delete(rc.ObjectMeta.Name, deleteOptions); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("wait for the rc to be deleted")
0000000000000000000000000000000000000000;;			// default client QPS is 20, deleting each pod requires 2 requests, so 30s should be enough
0000000000000000000000000000000000000000;;			if err := wait.Poll(1*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				_, err := rcClient.Get(rc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					pods, _ := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;					framework.Logf("%d pods remaining", len(pods.Items))
0000000000000000000000000000000000000000;;					count := 0
0000000000000000000000000000000000000000;;					for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;						if pod.ObjectMeta.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;							count++
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					framework.Logf("%d pods has nil DeletionTimestamp", count)
0000000000000000000000000000000000000000;;					framework.Logf("")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				pods, err2 := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err2 != nil {
0000000000000000000000000000000000000000;;					framework.Failf("%v", err2)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("%d remaining pods are:", len(pods.Items))
0000000000000000000000000000000000000000;;				framework.Logf("The ObjectMeta of the remaining pods are:")
0000000000000000000000000000000000000000;;				for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;					framework.Logf("%#v", pod.ObjectMeta)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// There shouldn't be any pods
0000000000000000000000000000000000000000;;			pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pods.Items) != 0 {
0000000000000000000000000000000000000000;;				framework.Failf("expected no pods, got %#v", pods)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gatherMetrics(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: this should be an integration test
0000000000000000000000000000000000000000;;		It("[Feature:GarbageCollector] should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted", func() {
0000000000000000000000000000000000000000;;			clientSet := f.ClientSet
0000000000000000000000000000000000000000;;			rcClient := clientSet.Core().ReplicationControllers(f.Namespace.Name)
0000000000000000000000000000000000000000;;			podClient := clientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			rc1Name := "simpletest-rc-to-be-deleted"
0000000000000000000000000000000000000000;;			replicas := int32(100)
0000000000000000000000000000000000000000;;			halfReplicas := int(replicas / 2)
0000000000000000000000000000000000000000;;			rc1 := newOwnerRC(f, rc1Name, replicas)
0000000000000000000000000000000000000000;;			By("create the rc1")
0000000000000000000000000000000000000000;;			rc1, err := rcClient.Create(rc1)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rc2Name := "simpletest-rc-to-stay"
0000000000000000000000000000000000000000;;			rc2 := newOwnerRC(f, rc2Name, 0)
0000000000000000000000000000000000000000;;			rc2.Spec.Selector = nil
0000000000000000000000000000000000000000;;			rc2.Spec.Template.ObjectMeta.Labels = map[string]string{"another.key": "another.value"}
0000000000000000000000000000000000000000;;			By("create the rc2")
0000000000000000000000000000000000000000;;			rc2, err = rcClient.Create(rc2)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to create replication controller: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// wait for rc1 to be stable
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				rc1, err := rcClient.Get(rc1.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to get rc: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if rc1.Status.Replicas == *rc1.Spec.Replicas {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to wait for the rc.Status.Replicas to reach rc.Spec.Replicas: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("set half of pods created by rc %s to have rc %s as owner as well", rc1Name, rc2Name))
0000000000000000000000000000000000000000;;			pods, err := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			patch := fmt.Sprintf(`{"metadata":{"ownerReferences":[{"apiVersion":"v1","kind":"ReplicationController","name":"%s","uid":"%s"}]}}`, rc2.ObjectMeta.Name, rc2.ObjectMeta.UID)
0000000000000000000000000000000000000000;;			for i := 0; i < halfReplicas; i++ {
0000000000000000000000000000000000000000;;				pod := pods.Items[i]
0000000000000000000000000000000000000000;;				_, err := podClient.Patch(pod.Name, types.StrategicMergePatchType, []byte(patch))
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("delete the rc %s", rc1Name))
0000000000000000000000000000000000000000;;			deleteOptions := getForegroundOptions()
0000000000000000000000000000000000000000;;			deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(rc1.UID))
0000000000000000000000000000000000000000;;			if err := rcClient.Delete(rc1.ObjectMeta.Name, deleteOptions); err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete the rc: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By("wait for the rc to be deleted")
0000000000000000000000000000000000000000;;			// default client QPS is 20, deleting each pod requires 2 requests, so 30s should be enough
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				_, err := rcClient.Get(rc1.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					pods, _ := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;					framework.Logf("%d pods remaining", len(pods.Items))
0000000000000000000000000000000000000000;;					count := 0
0000000000000000000000000000000000000000;;					for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;						if pod.ObjectMeta.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;							count++
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					framework.Logf("%d pods has nil DeletionTimestamp", count)
0000000000000000000000000000000000000000;;					framework.Logf("")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				pods, err2 := podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err2 != nil {
0000000000000000000000000000000000000000;;					framework.Failf("%v", err2)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("%d remaining pods are:", len(pods.Items))
0000000000000000000000000000000000000000;;				framework.Logf("ObjectMeta of remaining pods are:")
0000000000000000000000000000000000000000;;				for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;					framework.Logf("%#v", pod.ObjectMeta)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Failf("failed to delete rc %s, err: %v", rc1Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// half of the pods should still exist,
0000000000000000000000000000000000000000;;			pods, err = podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pods.Items) != halfReplicas {
0000000000000000000000000000000000000000;;				framework.Failf("expected %d pods, got %d", halfReplicas, len(pods.Items))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range pods.Items {
0000000000000000000000000000000000000000;;				if pod.ObjectMeta.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;					framework.Failf("expected pod DeletionTimestamp to be nil, got %#v", pod.ObjectMeta)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// they should only have 1 ownerReference left
0000000000000000000000000000000000000000;;				if len(pod.ObjectMeta.OwnerReferences) != 1 {
0000000000000000000000000000000000000000;;					framework.Failf("expected pod to only have 1 owner, got %#v", pod.ObjectMeta.OwnerReferences)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gatherMetrics(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: should be an integration test
0000000000000000000000000000000000000000;;		It("[Feature:GarbageCollector] should not be blocked by dependency circle", func() {
0000000000000000000000000000000000000000;;			clientSet := f.ClientSet
0000000000000000000000000000000000000000;;			podClient := clientSet.Core().Pods(f.Namespace.Name)
0000000000000000000000000000000000000000;;			pod1 := newGCPod("pod1")
0000000000000000000000000000000000000000;;			pod1, err := podClient.Create(pod1)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			pod2 := newGCPod("pod2")
0000000000000000000000000000000000000000;;			pod2, err = podClient.Create(pod2)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			pod3 := newGCPod("pod3")
0000000000000000000000000000000000000000;;			pod3, err = podClient.Create(pod3)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			// create circular dependency
0000000000000000000000000000000000000000;;			addRefPatch := func(name string, uid types.UID) []byte {
0000000000000000000000000000000000000000;;				return []byte(fmt.Sprintf(`{"metadata":{"ownerReferences":[{"apiVersion":"v1","kind":"Pod","name":"%s","uid":"%s","controller":true,"blockOwnerDeletion":true}]}}`, name, uid))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod1, err = podClient.Patch(pod1.Name, types.StrategicMergePatchType, addRefPatch(pod3.Name, pod3.UID))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			framework.Logf("pod1.ObjectMeta.OwnerReferences=%#v", pod1.ObjectMeta.OwnerReferences)
0000000000000000000000000000000000000000;;			pod2, err = podClient.Patch(pod2.Name, types.StrategicMergePatchType, addRefPatch(pod1.Name, pod1.UID))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			framework.Logf("pod2.ObjectMeta.OwnerReferences=%#v", pod2.ObjectMeta.OwnerReferences)
0000000000000000000000000000000000000000;;			pod3, err = podClient.Patch(pod3.Name, types.StrategicMergePatchType, addRefPatch(pod2.Name, pod2.UID))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			framework.Logf("pod3.ObjectMeta.OwnerReferences=%#v", pod3.ObjectMeta.OwnerReferences)
0000000000000000000000000000000000000000;;			// delete one pod, should result in the deletion of all pods
0000000000000000000000000000000000000000;;			deleteOptions := getForegroundOptions()
0000000000000000000000000000000000000000;;			deleteOptions.Preconditions = metav1.NewUIDPreconditions(string(pod1.UID))
0000000000000000000000000000000000000000;;			err = podClient.Delete(pod1.ObjectMeta.Name, deleteOptions)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			var pods *v1.PodList
0000000000000000000000000000000000000000;;			var err2 error
0000000000000000000000000000000000000000;;			if err := wait.Poll(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;				pods, err2 = podClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err2 != nil {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Failed to list pods: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(pods.Items) == 0 {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("pods are %#v", pods.Items)
0000000000000000000000000000000000000000;;				framework.Failf("failed to wait for all pods to be deleted: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
