0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
336799e8fbbf288cf7203d989addcbe998b05fec;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package chaosmonkey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import . "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Disruption is the type to construct a chaosmonkey with; see Do for more information.
0000000000000000000000000000000000000000;;	type Disruption func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test is the type to register with a chaosmonkey.  A test will run asynchronously across the
0000000000000000000000000000000000000000;;	// chaosmonkey's Disruption.  A Test takes a Semaphore as an argument.  It should call sem.Ready()
0000000000000000000000000000000000000000;;	// once it's ready for the disruption to start and should then wait until sem.StopCh (which is a
0000000000000000000000000000000000000000;;	// <-chan struct{}) is closed, which signals that the disruption is over.  It should then clean up
0000000000000000000000000000000000000000;;	// and return.  See Do and Semaphore for more information.
0000000000000000000000000000000000000000;;	type Test func(sem *Semaphore)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface can be implemented if you prefer to define tests without dealing with a Semaphore.  You
0000000000000000000000000000000000000000;;	// may define a struct that implements Interface's three methods (Setup, Test, and Teardown) and
0000000000000000000000000000000000000000;;	// RegisterInterface.  See RegisterInterface for more information.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		Setup()
0000000000000000000000000000000000000000;;		Test(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;		Teardown()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type chaosmonkey struct {
0000000000000000000000000000000000000000;;		disruption Disruption
0000000000000000000000000000000000000000;;		tests      []Test
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates and returns a chaosmonkey, with which the caller should register Tests and call Do.
0000000000000000000000000000000000000000;;	// See Do for more information.
0000000000000000000000000000000000000000;;	func New(disruption Disruption) *chaosmonkey {
0000000000000000000000000000000000000000;;		return &chaosmonkey{
0000000000000000000000000000000000000000;;			disruption,
0000000000000000000000000000000000000000;;			[]Test{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers the given Test with the chaosmonkey, so that the test will run over the
0000000000000000000000000000000000000000;;	// Disruption.
0000000000000000000000000000000000000000;;	func (cm *chaosmonkey) Register(test Test) {
0000000000000000000000000000000000000000;;		cm.tests = append(cm.tests, test)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterInterface registers the given Interface with the chaosmonkey, so the chaosmonkey will
0000000000000000000000000000000000000000;;	// call Setup, Test, and Teardown properly.  Test can tell that the Disruption is finished when
0000000000000000000000000000000000000000;;	// stopCh is closed.
0000000000000000000000000000000000000000;;	func (cm *chaosmonkey) RegisterInterface(in Interface) {
0000000000000000000000000000000000000000;;		cm.Register(func(sem *Semaphore) {
0000000000000000000000000000000000000000;;			in.Setup()
0000000000000000000000000000000000000000;;			sem.Ready()
0000000000000000000000000000000000000000;;			in.Test(sem.StopCh)
0000000000000000000000000000000000000000;;			in.Teardown()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do performs the Disruption while testing the registered Tests.  Once the caller has registered
0000000000000000000000000000000000000000;;	// all Tests with the chaosmonkey, they call Do.  Do starts each registered test asynchronously and
0000000000000000000000000000000000000000;;	// waits for each test to signal that it is ready by calling sem.Ready().  Do will then do the
0000000000000000000000000000000000000000;;	// Disruption, and when it's complete, close sem.StopCh to signal to the registered Tests that the
0000000000000000000000000000000000000000;;	// Disruption is over, and wait for all Tests to return.
0000000000000000000000000000000000000000;;	func (cm *chaosmonkey) Do() {
0000000000000000000000000000000000000000;;		sems := []*Semaphore{}
0000000000000000000000000000000000000000;;		// All semaphores have the same StopCh.
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range cm.tests {
0000000000000000000000000000000000000000;;			test := test
0000000000000000000000000000000000000000;;			sem := newSemaphore(stopCh)
0000000000000000000000000000000000000000;;			sems = append(sems, sem)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer GinkgoRecover()
0000000000000000000000000000000000000000;;				defer sem.done()
0000000000000000000000000000000000000000;;				test(sem)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for all async tests to be ready")
0000000000000000000000000000000000000000;;		for _, sem := range sems {
0000000000000000000000000000000000000000;;			// Wait for test to be ready.  We have to wait for ready *or done* because a test
0000000000000000000000000000000000000000;;			// may panic before signaling that its ready, and we shouldn't block.  Since we
0000000000000000000000000000000000000000;;			// defered sem.done() above, if a test panics, it's marked as done.
0000000000000000000000000000000000000000;;			sem.waitForReadyOrDone()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			By("Waiting for async validations to complete")
0000000000000000000000000000000000000000;;			for _, sem := range sems {
0000000000000000000000000000000000000000;;				sem.waitForDone()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Starting disruption")
0000000000000000000000000000000000000000;;		cm.disruption()
0000000000000000000000000000000000000000;;		By("Disruption complete; stopping async validations")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Semaphore is taken by a Test and provides: Ready(), for the Test to call when it's ready for the
0000000000000000000000000000000000000000;;	// disruption to start; and StopCh, the closure of which signals to the Test that the disruption is
0000000000000000000000000000000000000000;;	// finished.
0000000000000000000000000000000000000000;;	type Semaphore struct {
0000000000000000000000000000000000000000;;		readyCh chan struct{}
0000000000000000000000000000000000000000;;		StopCh  <-chan struct{}
0000000000000000000000000000000000000000;;		doneCh  chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSemaphore(stopCh <-chan struct{}) *Semaphore {
0000000000000000000000000000000000000000;;		// We don't want to block on Ready() or done()
0000000000000000000000000000000000000000;;		return &Semaphore{
0000000000000000000000000000000000000000;;			make(chan struct{}, 1),
0000000000000000000000000000000000000000;;			stopCh,
0000000000000000000000000000000000000000;;			make(chan struct{}, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ready is called by the Test to signal that the Test is ready for the disruption to start.
0000000000000000000000000000000000000000;;	func (sem *Semaphore) Ready() {
0000000000000000000000000000000000000000;;		close(sem.readyCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// done is an internal method for Go to defer, both to wait for all tests to return, but also to
0000000000000000000000000000000000000000;;	// sense if a test panicked before calling Ready.  See waitForReadyOrDone.
0000000000000000000000000000000000000000;;	func (sem *Semaphore) done() {
0000000000000000000000000000000000000000;;		close(sem.doneCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We would like to just check if all tests are ready, but if they fail (which Ginkgo implements as
0000000000000000000000000000000000000000;;	// a panic), they may not have called Ready().  We check done as well to see if the function has
0000000000000000000000000000000000000000;;	// already returned; if it has, we don't care if it's ready, and just continue.
0000000000000000000000000000000000000000;;	func (sem *Semaphore) waitForReadyOrDone() {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-sem.readyCh:
0000000000000000000000000000000000000000;;		case <-sem.doneCh:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForDone is an internal method for Go to wait on all Tests returning.
0000000000000000000000000000000000000000;;	func (sem *Semaphore) waitForDone() {
0000000000000000000000000000000000000000;;		<-sem.doneCh
0000000000000000000000000000000000000000;;	}
