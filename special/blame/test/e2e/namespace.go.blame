0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f1d0081a71887f2d98776109de677bb96b8951d3;test/e2e/soak_namespace.go[test/e2e/soak_namespace.go][test/e2e/namespace.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extinguish(f *framework.Framework, totalNS int, maxAllowedAfterDel int, maxSeconds int) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating testing namespaces")
0000000000000000000000000000000000000000;;		wg := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(totalNS)
0000000000000000000000000000000000000000;;		for n := 0; n < totalNS; n += 1 {
0000000000000000000000000000000000000000;;			go func(n int) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				defer GinkgoRecover()
0000000000000000000000000000000000000000;;				_, err = f.CreateNamespace(fmt.Sprintf("nslifetest-%v", n), nil)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//Wait 10 seconds, then SEND delete requests for all the namespaces.
0000000000000000000000000000000000000000;;		By("Waiting 10 seconds")
0000000000000000000000000000000000000000;;		time.Sleep(time.Duration(10 * time.Second))
0000000000000000000000000000000000000000;;		deleted, err := framework.DeleteNamespaces(f.ClientSet, []string{"nslifetest"}, nil /* skipFilter */)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		Expect(len(deleted)).To(Equal(totalNS))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for namespaces to vanish")
0000000000000000000000000000000000000000;;		//Now POLL until all namespaces have been eradicated.
0000000000000000000000000000000000000000;;		framework.ExpectNoError(wait.Poll(2*time.Second, time.Duration(maxSeconds)*time.Second,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				var cnt = 0
0000000000000000000000000000000000000000;;				nsList, err := f.ClientSet.Core().Namespaces().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, item := range nsList.Items {
0000000000000000000000000000000000000000;;					if strings.Contains(item.Name, "nslifetest") {
0000000000000000000000000000000000000000;;						cnt++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cnt > maxAllowedAfterDel {
0000000000000000000000000000000000000000;;					framework.Logf("Remaining namespaces : %v", cnt)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPodInNamespace(c clientset.Interface, ns, podName string) *v1.Pod {
0000000000000000000000000000000000000000;;		var pod *v1.Pod
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(2*time.Second, 15*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			pod, err = c.Core().Pods(ns).Get(podName, metav1.GetOptions{IncludeUninitialized: true})
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensurePodsAreRemovedWhenNamespaceIsDeleted(f *framework.Framework) {
0000000000000000000000000000000000000000;;		By("Creating a test namespace")
0000000000000000000000000000000000000000;;		namespace, err := f.CreateNamespace("nsdeletetest", nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for a default service account to be provisioned in namespace")
0000000000000000000000000000000000000000;;		err = framework.WaitForDefaultServiceAccountInNamespace(f.ClientSet, namespace.Name)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a pod in the namespace")
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "test-pod",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "nginx",
0000000000000000000000000000000000000000;;						Image: framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod, err = f.ClientSet.Core().Pods(namespace.Name).Create(pod)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for the pod to have running status")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForPodRunningInNamespace(f.ClientSet, pod))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating an uninitialized pod in the namespace")
0000000000000000000000000000000000000000;;		podB := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:         "test-pod-uninitialized",
0000000000000000000000000000000000000000;;				Initializers: &metav1.Initializers{Pending: []metav1.Initializer{{Name: "test.initializer.k8s.io"}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "nginx",
0000000000000000000000000000000000000000;;						Image: framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().Pods(namespace.Name).Create(podB)
0000000000000000000000000000000000000000;;			// This error is ok, beacuse we will delete the pod before it completes initialization
0000000000000000000000000000000000000000;;			framework.Logf("error from create uninitialized namespace: %v", err)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		podB = waitForPodInNamespace(f.ClientSet, namespace.Name, podB.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Deleting the namespace")
0000000000000000000000000000000000000000;;		err = f.ClientSet.Core().Namespaces().Delete(namespace.Name, nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for the namespace to be removed.")
0000000000000000000000000000000000000000;;		maxWaitSeconds := int64(60) + *pod.Spec.TerminationGracePeriodSeconds
0000000000000000000000000000000000000000;;		framework.ExpectNoError(wait.Poll(1*time.Second, time.Duration(maxWaitSeconds)*time.Second,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				_, err = f.ClientSet.Core().Namespaces().Get(namespace.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Recreating the namespace")
0000000000000000000000000000000000000000;;		namespace, err = f.CreateNamespace("nsdeletetest", nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying there are no pods in the namespace")
0000000000000000000000000000000000000000;;		_, err = f.ClientSet.Core().Pods(namespace.Name).Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;		_, err = f.ClientSet.Core().Pods(namespace.Name).Get(podB.Name, metav1.GetOptions{IncludeUninitialized: true})
0000000000000000000000000000000000000000;;		Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureServicesAreRemovedWhenNamespaceIsDeleted(f *framework.Framework) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a test namespace")
0000000000000000000000000000000000000000;;		namespace, err := f.CreateNamespace("nsdeletetest", nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for a default service account to be provisioned in namespace")
0000000000000000000000000000000000000000;;		err = framework.WaitForDefaultServiceAccountInNamespace(f.ClientSet, namespace.Name)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a service in the namespace")
0000000000000000000000000000000000000000;;		serviceName := "test-service"
0000000000000000000000000000000000000000;;		labels := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		service := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: serviceName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: labels,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       80,
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		service, err = f.ClientSet.Core().Services(namespace.Name).Create(service)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Deleting the namespace")
0000000000000000000000000000000000000000;;		err = f.ClientSet.Core().Namespaces().Delete(namespace.Name, nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for the namespace to be removed.")
0000000000000000000000000000000000000000;;		maxWaitSeconds := int64(60)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(wait.Poll(1*time.Second, time.Duration(maxWaitSeconds)*time.Second,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				_, err = f.ClientSet.Core().Namespaces().Get(namespace.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Recreating the namespace")
0000000000000000000000000000000000000000;;		namespace, err = f.CreateNamespace("nsdeletetest", nil)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Verifying there is no service in the namespace")
0000000000000000000000000000000000000000;;		_, err = f.ClientSet.Core().Services(namespace.Name).Get(service.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test must run [Serial] due to the impact of running other parallel
0000000000000000000000000000000000000000;;	// tests can have on its performance.  Each test that follows the common
0000000000000000000000000000000000000000;;	// test framework follows this pattern:
0000000000000000000000000000000000000000;;	//   1. Create a Namespace
0000000000000000000000000000000000000000;;	//   2. Do work that generates content in that namespace
0000000000000000000000000000000000000000;;	//   3. Delete a Namespace
0000000000000000000000000000000000000000;;	// Creation of a Namespace is non-trivial since it requires waiting for a
0000000000000000000000000000000000000000;;	// ServiceAccount to be generated.
0000000000000000000000000000000000000000;;	// Deletion of a Namespace is non-trivial and performance intensive since
0000000000000000000000000000000000000000;;	// its an orchestrated process.  The controller that handles deletion must
0000000000000000000000000000000000000000;;	// query the namespace for all existing content, and then delete each piece
0000000000000000000000000000000000000000;;	// of content in turn.  As the API surface grows to add more KIND objects
0000000000000000000000000000000000000000;;	// that could exist in a Namespace, the number of calls that the namespace
0000000000000000000000000000000000000000;;	// controller must orchestrate grows since it must LIST, DELETE (1x1) each
0000000000000000000000000000000000000000;;	// KIND.
0000000000000000000000000000000000000000;;	// There is work underway to improve this, but it's
0000000000000000000000000000000000000000;;	// most likely not going to get significantly better until etcd v3.
0000000000000000000000000000000000000000;;	// Going back to this test, this test generates 100 Namespace objects, and then
0000000000000000000000000000000000000000;;	// rapidly deletes all of them.  This causes the NamespaceController to observe
0000000000000000000000000000000000000000;;	// and attempt to process a large number of deletes concurrently.  In effect,
0000000000000000000000000000000000000000;;	// it's like running 100 traditional e2e tests in parallel.  If the namespace
0000000000000000000000000000000000000000;;	// controller orchestrating deletes is slowed down deleting another test's
0000000000000000000000000000000000000000;;	// content then this test may fail.  Since the goal of this test is to soak
0000000000000000000000000000000000000000;;	// Namespace creation, and soak Namespace deletion, its not appropriate to
0000000000000000000000000000000000000000;;	// further soak the cluster with other parallel Namespace deletion activities
0000000000000000000000000000000000000000;;	// that each have a variable amount of content in the associated Namespace.
0000000000000000000000000000000000000000;;	// When run in [Serial] this test appears to delete Namespace objects at a
0000000000000000000000000000000000000000;;	// rate of approximately 1 per second.
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Namespaces [Serial]", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("namespaces")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should ensure that all pods are removed when a namespace is deleted.",
0000000000000000000000000000000000000000;;			func() { ensurePodsAreRemovedWhenNamespaceIsDeleted(f) })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should ensure that all services are removed when a namespace is deleted.",
0000000000000000000000000000000000000000;;			func() { ensureServicesAreRemovedWhenNamespaceIsDeleted(f) })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should delete fast enough (90 percent of 100 namespaces in 150 seconds)",
0000000000000000000000000000000000000000;;			func() { extinguish(f, 100, 10, 150) })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// On hold until etcd3; see #7372
0000000000000000000000000000000000000000;;		It("should always delete fast (ALL of 100 namespaces in 150 seconds) [Feature:ComprehensiveNamespaceDraining]",
0000000000000000000000000000000000000000;;			func() { extinguish(f, 100, 0, 150) })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	})
