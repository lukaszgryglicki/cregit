0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1947ee172d493da1b40d928e59794672b839ba3c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/manifest"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLoadBalancerControllers returns a list of LBCtesters.
0000000000000000000000000000000000000000;;	func getLoadBalancerControllers(client clientset.Interface) []LBCTester {
0000000000000000000000000000000000000000;;		return []LBCTester{
0000000000000000000000000000000000000000;;			&haproxyControllerTester{
0000000000000000000000000000000000000000;;				name:   "haproxy",
0000000000000000000000000000000000000000;;				cfg:    "test/e2e/testing-manifests/serviceloadbalancer/haproxyrc.yaml",
0000000000000000000000000000000000000000;;				client: client,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIngManagers returns a list of ingManagers.
0000000000000000000000000000000000000000;;	func getIngManagers(client clientset.Interface) []*ingManager {
0000000000000000000000000000000000000000;;		return []*ingManager{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "netexec",
0000000000000000000000000000000000000000;;				rcCfgPaths:  []string{"test/e2e/testing-manifests/serviceloadbalancer/netexecrc.yaml"},
0000000000000000000000000000000000000000;;				svcCfgPaths: []string{"test/e2e/testing-manifests/serviceloadbalancer/netexecsvc.yaml"},
0000000000000000000000000000000000000000;;				svcNames:    []string{},
0000000000000000000000000000000000000000;;				client:      client,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LBCTester is an interface used to test loadbalancer controllers.
0000000000000000000000000000000000000000;;	type LBCTester interface {
0000000000000000000000000000000000000000;;		// start starts the loadbalancer controller in the given namespace
0000000000000000000000000000000000000000;;		start(namespace string) error
0000000000000000000000000000000000000000;;		// lookup returns the address (ip/hostname) associated with ingressKey
0000000000000000000000000000000000000000;;		lookup(ingressKey string) string
0000000000000000000000000000000000000000;;		// stop stops the loadbalancer controller
0000000000000000000000000000000000000000;;		stop() error
0000000000000000000000000000000000000000;;		// name returns the name of the loadbalancer
0000000000000000000000000000000000000000;;		getName() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// haproxyControllerTester implements LBCTester for bare metal haproxy LBs.
0000000000000000000000000000000000000000;;	type haproxyControllerTester struct {
0000000000000000000000000000000000000000;;		client      clientset.Interface
0000000000000000000000000000000000000000;;		cfg         string
0000000000000000000000000000000000000000;;		rcName      string
0000000000000000000000000000000000000000;;		rcNamespace string
0000000000000000000000000000000000000000;;		name        string
0000000000000000000000000000000000000000;;		address     []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *haproxyControllerTester) getName() string {
0000000000000000000000000000000000000000;;		return h.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *haproxyControllerTester) start(namespace string) (err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a replication controller with the given configuration.
0000000000000000000000000000000000000000;;		framework.Logf("Parsing rc from %v", h.cfg)
0000000000000000000000000000000000000000;;		rc, err := manifest.RcFromManifest(h.cfg)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		rc.Namespace = namespace
0000000000000000000000000000000000000000;;		rc.Spec.Template.Labels["name"] = rc.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the --namespace arg.
0000000000000000000000000000000000000000;;		// TODO: Remove this when we have proper namespace support.
0000000000000000000000000000000000000000;;		for i, c := range rc.Spec.Template.Spec.Containers {
0000000000000000000000000000000000000000;;			rc.Spec.Template.Spec.Containers[i].Args = append(
0000000000000000000000000000000000000000;;				c.Args, fmt.Sprintf("--namespace=%v", namespace))
0000000000000000000000000000000000000000;;			framework.Logf("Container args %+v", rc.Spec.Template.Spec.Containers[i].Args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc, err = h.client.Core().ReplicationControllers(rc.Namespace).Create(rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = framework.WaitForControlledPodsRunning(h.client, namespace, rc.Name, api.Kind("ReplicationController")); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.rcName = rc.Name
0000000000000000000000000000000000000000;;		h.rcNamespace = rc.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the pods of the rc we just created.
0000000000000000000000000000000000000000;;		labelSelector := labels.SelectorFromSet(
0000000000000000000000000000000000000000;;			labels.Set(map[string]string{"name": h.rcName}))
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: labelSelector.String()}
0000000000000000000000000000000000000000;;		pods, err := h.client.Core().Pods(h.rcNamespace).List(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the external addresses of the nodes the pods are running on.
0000000000000000000000000000000000000000;;		for _, p := range pods.Items {
0000000000000000000000000000000000000000;;			wait.Poll(pollInterval, framework.ServiceRespondingTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				address, err := framework.GetHostExternalAddress(h.client, &p)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("%v", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				h.address = append(h.address, address)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(h.address) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("No external ips found for loadbalancer %v", h.getName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *haproxyControllerTester) stop() error {
0000000000000000000000000000000000000000;;		return h.client.Core().ReplicationControllers(h.rcNamespace).Delete(h.rcName, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *haproxyControllerTester) lookup(ingressKey string) string {
0000000000000000000000000000000000000000;;		// The address of a service is the address of the lb/servicename, currently.
0000000000000000000000000000000000000000;;		return fmt.Sprintf("http://%v/%v", h.address[0], ingressKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ingManager starts an rc and the associated service.
0000000000000000000000000000000000000000;;	type ingManager struct {
0000000000000000000000000000000000000000;;		rcCfgPaths  []string
0000000000000000000000000000000000000000;;		svcCfgPaths []string
0000000000000000000000000000000000000000;;		ingCfgPath  string
0000000000000000000000000000000000000000;;		name        string
0000000000000000000000000000000000000000;;		namespace   string
0000000000000000000000000000000000000000;;		client      clientset.Interface
0000000000000000000000000000000000000000;;		svcNames    []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ingManager) getName() string {
0000000000000000000000000000000000000000;;		return s.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ingManager) start(namespace string) (err error) {
0000000000000000000000000000000000000000;;		// Create rcs
0000000000000000000000000000000000000000;;		for _, rcPath := range s.rcCfgPaths {
0000000000000000000000000000000000000000;;			framework.Logf("Parsing rc from %v", rcPath)
0000000000000000000000000000000000000000;;			var rc *v1.ReplicationController
0000000000000000000000000000000000000000;;			rc, err = manifest.RcFromManifest(rcPath)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			rc.Namespace = namespace
0000000000000000000000000000000000000000;;			rc.Spec.Template.Labels["name"] = rc.Name
0000000000000000000000000000000000000000;;			rc, err = s.client.Core().ReplicationControllers(rc.Namespace).Create(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = framework.WaitForControlledPodsRunning(s.client, rc.Namespace, rc.Name, api.Kind("ReplicationController")); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create services.
0000000000000000000000000000000000000000;;		// Note that it's up to the caller to make sure the service actually matches
0000000000000000000000000000000000000000;;		// the pods of the rc.
0000000000000000000000000000000000000000;;		for _, svcPath := range s.svcCfgPaths {
0000000000000000000000000000000000000000;;			framework.Logf("Parsing service from %v", svcPath)
0000000000000000000000000000000000000000;;			var svc *v1.Service
0000000000000000000000000000000000000000;;			svc, err = manifest.SvcFromManifest(svcPath)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			svc.Namespace = namespace
0000000000000000000000000000000000000000;;			svc, err = s.client.Core().Services(svc.Namespace).Create(svc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: This is short term till we have an Ingress.
0000000000000000000000000000000000000000;;			s.svcNames = append(s.svcNames, svc.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.name = s.svcNames[0]
0000000000000000000000000000000000000000;;		s.namespace = namespace
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ingManager) test(path string) error {
0000000000000000000000000000000000000000;;		url := fmt.Sprintf("%v/hostName", path)
0000000000000000000000000000000000000000;;		httpClient := &http.Client{}
0000000000000000000000000000000000000000;;		return wait.Poll(pollInterval, framework.ServiceRespondingTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			body, err := framework.SimpleGET(httpClient, url, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("%v\n%v\n%v", url, body, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("ServiceLoadBalancer [Feature:ServiceLoadBalancer]", func() {
0000000000000000000000000000000000000000;;		// These variables are initialized after framework's beforeEach.
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		var client clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("servicelb")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			client = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should support simple GET on Ingress ips", func() {
0000000000000000000000000000000000000000;;			for _, t := range getLoadBalancerControllers(client) {
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Starting loadbalancer controller %v in namespace %v", t.getName(), ns))
0000000000000000000000000000000000000000;;				Expect(t.start(ns)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, s := range getIngManagers(client) {
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Starting ingress manager %v in namespace %v", s.getName(), ns))
0000000000000000000000000000000000000000;;					Expect(s.start(ns)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for _, sName := range s.svcNames {
0000000000000000000000000000000000000000;;						path := t.lookup(sName)
0000000000000000000000000000000000000000;;						framework.Logf("Testing path %v", path)
0000000000000000000000000000000000000000;;						Expect(s.test(path)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Expect(t.stop()).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
