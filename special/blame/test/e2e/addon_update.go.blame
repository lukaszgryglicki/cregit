0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
9ad7a79c8c9cca2a2f411730c6507f131234f7ba;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/ssh"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: it would probably be slightly better to build up the objects
0000000000000000000000000000000000000000;;	// in the code and then serialize to yaml.
0000000000000000000000000000000000000000;;	var reconcile_addon_controller = `
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: ReplicationController
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: addon-reconcile-test
0000000000000000000000000000000000000000;;	  namespace: %s
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: addon-reconcile-test
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	    addonmanager.kubernetes.io/mode: Reconcile
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  replicas: 2
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: addon-reconcile-test
0000000000000000000000000000000000000000;;	  template:
0000000000000000000000000000000000000000;;	    metadata:
0000000000000000000000000000000000000000;;	      labels:
0000000000000000000000000000000000000000;;	        k8s-app: addon-reconcile-test
0000000000000000000000000000000000000000;;	    spec:
0000000000000000000000000000000000000000;;	      containers:
0000000000000000000000000000000000000000;;	      - image: gcr.io/google_containers/serve_hostname:v1.4
0000000000000000000000000000000000000000;;	        name: addon-reconcile-test
0000000000000000000000000000000000000000;;	        ports:
0000000000000000000000000000000000000000;;	        - containerPort: 9376
0000000000000000000000000000000000000000;;	          protocol: TCP
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Should update "reconcile" class addon.
0000000000000000000000000000000000000000;;	var reconcile_addon_controller_updated = `
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: ReplicationController
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: addon-reconcile-test
0000000000000000000000000000000000000000;;	  namespace: %s
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: addon-reconcile-test
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	    addonmanager.kubernetes.io/mode: Reconcile
0000000000000000000000000000000000000000;;	    newLabel: addon-reconcile-test
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  replicas: 2
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: addon-reconcile-test
0000000000000000000000000000000000000000;;	  template:
0000000000000000000000000000000000000000;;	    metadata:
0000000000000000000000000000000000000000;;	      labels:
0000000000000000000000000000000000000000;;	        k8s-app: addon-reconcile-test
0000000000000000000000000000000000000000;;	    spec:
0000000000000000000000000000000000000000;;	      containers:
0000000000000000000000000000000000000000;;	      - image: gcr.io/google_containers/serve_hostname:v1.4
0000000000000000000000000000000000000000;;	        name: addon-reconcile-test
0000000000000000000000000000000000000000;;	        ports:
0000000000000000000000000000000000000000;;	        - containerPort: 9376
0000000000000000000000000000000000000000;;	          protocol: TCP
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ensure_exists_addon_service = `
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Service
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: addon-ensure-exists-test
0000000000000000000000000000000000000000;;	  namespace: %s
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: addon-ensure-exists-test
0000000000000000000000000000000000000000;;	    addonmanager.kubernetes.io/mode: EnsureExists
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  ports:
0000000000000000000000000000000000000000;;	  - port: 9376
0000000000000000000000000000000000000000;;	    protocol: TCP
0000000000000000000000000000000000000000;;	    targetPort: 9376
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: addon-ensure-exists-test
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Should create but don't update "ensure exist" class addon.
0000000000000000000000000000000000000000;;	var ensure_exists_addon_service_updated = `
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Service
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: addon-ensure-exists-test
0000000000000000000000000000000000000000;;	  namespace: %s
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: addon-ensure-exists-test
0000000000000000000000000000000000000000;;	    addonmanager.kubernetes.io/mode: EnsureExists
0000000000000000000000000000000000000000;;	    newLabel: addon-ensure-exists-test
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  ports:
0000000000000000000000000000000000000000;;	  - port: 9376
0000000000000000000000000000000000000000;;	    protocol: TCP
0000000000000000000000000000000000000000;;	    targetPort: 9376
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: addon-ensure-exists-test
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var deprecated_label_addon_service = `
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Service
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: addon-deprecated-label-test
0000000000000000000000000000000000000000;;	  namespace: %s
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: addon-deprecated-label-test
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  ports:
0000000000000000000000000000000000000000;;	  - port: 9376
0000000000000000000000000000000000000000;;	    protocol: TCP
0000000000000000000000000000000000000000;;	    targetPort: 9376
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: addon-deprecated-label-test
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Should update addon with label "kubernetes.io/cluster-service=true".
0000000000000000000000000000000000000000;;	var deprecated_label_addon_service_updated = `
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Service
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: addon-deprecated-label-test
0000000000000000000000000000000000000000;;	  namespace: %s
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: addon-deprecated-label-test
0000000000000000000000000000000000000000;;	    kubernetes.io/cluster-service: "true"
0000000000000000000000000000000000000000;;	    newLabel: addon-deprecated-label-test
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  ports:
0000000000000000000000000000000000000000;;	  - port: 9376
0000000000000000000000000000000000000000;;	    protocol: TCP
0000000000000000000000000000000000000000;;	    targetPort: 9376
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: addon-deprecated-label-test
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Should not create addon without valid label.
0000000000000000000000000000000000000000;;	var invalid_addon_controller = `
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: ReplicationController
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: invalid-addon-test
0000000000000000000000000000000000000000;;	  namespace: %s
0000000000000000000000000000000000000000;;	  labels:
0000000000000000000000000000000000000000;;	    k8s-app: invalid-addon-test
0000000000000000000000000000000000000000;;	    addonmanager.kubernetes.io/mode: NotMatch
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  replicas: 2
0000000000000000000000000000000000000000;;	  selector:
0000000000000000000000000000000000000000;;	    k8s-app: invalid-addon-test
0000000000000000000000000000000000000000;;	  template:
0000000000000000000000000000000000000000;;	    metadata:
0000000000000000000000000000000000000000;;	      labels:
0000000000000000000000000000000000000000;;	        k8s-app: invalid-addon-test
0000000000000000000000000000000000000000;;	    spec:
0000000000000000000000000000000000000000;;	      containers:
0000000000000000000000000000000000000000;;	      - image: gcr.io/google_containers/serve_hostname:v1.4
0000000000000000000000000000000000000000;;	        name: invalid-addon-test
0000000000000000000000000000000000000000;;	        ports:
0000000000000000000000000000000000000000;;	        - containerPort: 9376
0000000000000000000000000000000000000000;;	          protocol: TCP
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		addonTestPollInterval = 3 * time.Second
0000000000000000000000000000000000000000;;		addonTestPollTimeout  = 5 * time.Minute
0000000000000000000000000000000000000000;;		addonNsName           = metav1.NamespaceSystem
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stringPair struct {
0000000000000000000000000000000000000000;;		data, fileName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Addon update", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dir string
0000000000000000000000000000000000000000;;		var sshClient *ssh.Client
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("addon-update-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			// This test requires:
0000000000000000000000000000000000000000;;			// - SSH master access
0000000000000000000000000000000000000000;;			// ... so the provider check should be identical to the intersection of
0000000000000000000000000000000000000000;;			// providers that provide those capabilities.
0000000000000000000000000000000000000000;;			if !framework.ProviderIs("gce") {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			sshClient, err = getMasterSSHClient()
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to get the master SSH client.")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			if sshClient != nil {
0000000000000000000000000000000000000000;;				sshClient.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WARNING: the test is not parallel-friendly!
0000000000000000000000000000000000000000;;		It("should propagate add-on file changes [Slow]", func() {
0000000000000000000000000000000000000000;;			// This test requires:
0000000000000000000000000000000000000000;;			// - SSH
0000000000000000000000000000000000000000;;			// - master access
0000000000000000000000000000000000000000;;			// ... so the provider check should be identical to the intersection of
0000000000000000000000000000000000000000;;			// providers that provide those capabilities.
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//these tests are long, so I squeezed several cases in one scenario
0000000000000000000000000000000000000000;;			Expect(sshClient).NotTo(BeNil())
0000000000000000000000000000000000000000;;			dir = f.Namespace.Name // we use it only to give a unique string for each test execution
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			temporaryRemotePathPrefix := "addon-test-dir"
0000000000000000000000000000000000000000;;			temporaryRemotePath := temporaryRemotePathPrefix + "/" + dir                  // in home directory on kubernetes-master
0000000000000000000000000000000000000000;;			defer sshExec(sshClient, fmt.Sprintf("rm -rf %s", temporaryRemotePathPrefix)) // ignore the result in cleanup
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("mkdir -p %s", temporaryRemotePath))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rcAddonReconcile := "addon-reconcile-controller.yaml"
0000000000000000000000000000000000000000;;			rcAddonReconcileUpdated := "addon-reconcile-controller-Updated.yaml"
0000000000000000000000000000000000000000;;			rcInvalid := "invalid-addon-controller.yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			svcAddonDeprecatedLabel := "addon-deprecated-label-service.yaml"
0000000000000000000000000000000000000000;;			svcAddonDeprecatedLabelUpdated := "addon-deprecated-label-service-updated.yaml"
0000000000000000000000000000000000000000;;			svcAddonEnsureExists := "addon-ensure-exists-service.yaml"
0000000000000000000000000000000000000000;;			svcAddonEnsureExistsUpdated := "addon-ensure-exists-service-updated.yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var remoteFiles []stringPair = []stringPair{
0000000000000000000000000000000000000000;;				{fmt.Sprintf(reconcile_addon_controller, addonNsName), rcAddonReconcile},
0000000000000000000000000000000000000000;;				{fmt.Sprintf(reconcile_addon_controller_updated, addonNsName), rcAddonReconcileUpdated},
0000000000000000000000000000000000000000;;				{fmt.Sprintf(deprecated_label_addon_service, addonNsName), svcAddonDeprecatedLabel},
0000000000000000000000000000000000000000;;				{fmt.Sprintf(deprecated_label_addon_service_updated, addonNsName), svcAddonDeprecatedLabelUpdated},
0000000000000000000000000000000000000000;;				{fmt.Sprintf(ensure_exists_addon_service, addonNsName), svcAddonEnsureExists},
0000000000000000000000000000000000000000;;				{fmt.Sprintf(ensure_exists_addon_service_updated, addonNsName), svcAddonEnsureExistsUpdated},
0000000000000000000000000000000000000000;;				{fmt.Sprintf(invalid_addon_controller, addonNsName), rcInvalid},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, p := range remoteFiles {
0000000000000000000000000000000000000000;;				err := writeRemoteFile(sshClient, p.data, temporaryRemotePath, p.fileName, 0644)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred(), "Failed to write file %q at remote path %q with ssh client %+v", p.fileName, temporaryRemotePath, sshClient)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// directory on kubernetes-master
0000000000000000000000000000000000000000;;			destinationDirPrefix := "/etc/kubernetes/addons/addon-test-dir"
0000000000000000000000000000000000000000;;			destinationDir := destinationDirPrefix + "/" + dir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// cleanup from previous tests
0000000000000000000000000000000000000000;;			_, _, _, err := sshExec(sshClient, fmt.Sprintf("sudo rm -rf %s", destinationDirPrefix))
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "Failed to remove remote dir %q with ssh client %+v", destinationDirPrefix, sshClient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer sshExec(sshClient, fmt.Sprintf("sudo rm -rf %s", destinationDirPrefix)) // ignore result in cleanup
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo mkdir -p %s", destinationDir))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("copy invalid manifests to the destination dir")
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo cp %s/%s %s/%s", temporaryRemotePath, rcInvalid, destinationDir, rcInvalid))
0000000000000000000000000000000000000000;;			// we will verify at the end of the test that the objects weren't created from the invalid manifests
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("copy new manifests")
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo cp %s/%s %s/%s", temporaryRemotePath, rcAddonReconcile, destinationDir, rcAddonReconcile))
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo cp %s/%s %s/%s", temporaryRemotePath, svcAddonDeprecatedLabel, destinationDir, svcAddonDeprecatedLabel))
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo cp %s/%s %s/%s", temporaryRemotePath, svcAddonEnsureExists, destinationDir, svcAddonEnsureExists))
0000000000000000000000000000000000000000;;			// Delete the "ensure exist class" addon at the end.
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				framework.Logf("Cleaning up ensure exist class addon.")
0000000000000000000000000000000000000000;;				Expect(f.ClientSet.Core().Services(addonNsName).Delete("addon-ensure-exists-test", nil)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			waitForReplicationControllerInAddonTest(f.ClientSet, addonNsName, "addon-reconcile-test", true)
0000000000000000000000000000000000000000;;			waitForServiceInAddonTest(f.ClientSet, addonNsName, "addon-deprecated-label-test", true)
0000000000000000000000000000000000000000;;			waitForServiceInAddonTest(f.ClientSet, addonNsName, "addon-ensure-exists-test", true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Replace the manifests with new contents.
0000000000000000000000000000000000000000;;			By("update manifests")
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo cp %s/%s %s/%s", temporaryRemotePath, rcAddonReconcileUpdated, destinationDir, rcAddonReconcile))
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo cp %s/%s %s/%s", temporaryRemotePath, svcAddonDeprecatedLabelUpdated, destinationDir, svcAddonDeprecatedLabel))
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo cp %s/%s %s/%s", temporaryRemotePath, svcAddonEnsureExistsUpdated, destinationDir, svcAddonEnsureExists))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait for updated addons to have the new added label.
0000000000000000000000000000000000000000;;			reconcileSelector := labels.SelectorFromSet(labels.Set(map[string]string{"newLabel": "addon-reconcile-test"}))
0000000000000000000000000000000000000000;;			waitForReplicationControllerwithSelectorInAddonTest(f.ClientSet, addonNsName, true, reconcileSelector)
0000000000000000000000000000000000000000;;			deprecatedLabelSelector := labels.SelectorFromSet(labels.Set(map[string]string{"newLabel": "addon-deprecated-label-test"}))
0000000000000000000000000000000000000000;;			waitForServicewithSelectorInAddonTest(f.ClientSet, addonNsName, true, deprecatedLabelSelector)
0000000000000000000000000000000000000000;;			// "Ensure exist class" addon should not be updated.
0000000000000000000000000000000000000000;;			ensureExistSelector := labels.SelectorFromSet(labels.Set(map[string]string{"newLabel": "addon-ensure-exists-test"}))
0000000000000000000000000000000000000000;;			waitForServicewithSelectorInAddonTest(f.ClientSet, addonNsName, false, ensureExistSelector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("remove manifests")
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo rm %s/%s", destinationDir, rcAddonReconcile))
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo rm %s/%s", destinationDir, svcAddonDeprecatedLabel))
0000000000000000000000000000000000000000;;			sshExecAndVerify(sshClient, fmt.Sprintf("sudo rm %s/%s", destinationDir, svcAddonEnsureExists))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			waitForReplicationControllerInAddonTest(f.ClientSet, addonNsName, "addon-reconcile-test", false)
0000000000000000000000000000000000000000;;			waitForServiceInAddonTest(f.ClientSet, addonNsName, "addon-deprecated-label-test", false)
0000000000000000000000000000000000000000;;			// "Ensure exist class" addon will not be deleted when manifest is removed.
0000000000000000000000000000000000000000;;			waitForServiceInAddonTest(f.ClientSet, addonNsName, "addon-ensure-exists-test", true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verify invalid addons weren't created")
0000000000000000000000000000000000000000;;			_, err = f.ClientSet.Core().ReplicationControllers(addonNsName).Get("invalid-addon-test", metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).To(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Invalid addon manifests and the "ensure exist class" addon will be deleted by the deferred function.
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForServiceInAddonTest(c clientset.Interface, addonNamespace, name string, exist bool) {
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForService(c, addonNamespace, name, exist, addonTestPollInterval, addonTestPollTimeout))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForReplicationControllerInAddonTest(c clientset.Interface, addonNamespace, name string, exist bool) {
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForReplicationController(c, addonNamespace, name, exist, addonTestPollInterval, addonTestPollTimeout))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForServicewithSelectorInAddonTest(c clientset.Interface, addonNamespace string, exist bool, selector labels.Selector) {
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForServiceWithSelector(c, addonNamespace, selector, exist, addonTestPollInterval, addonTestPollTimeout))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForReplicationControllerwithSelectorInAddonTest(c clientset.Interface, addonNamespace string, exist bool, selector labels.Selector) {
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.WaitForReplicationControllerwithSelector(c, addonNamespace, selector, exist, addonTestPollInterval,
0000000000000000000000000000000000000000;;			addonTestPollTimeout))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO use the framework.SSH code, either adding an SCP to it or copying files
0000000000000000000000000000000000000000;;	// differently.
0000000000000000000000000000000000000000;;	func getMasterSSHClient() (*ssh.Client, error) {
0000000000000000000000000000000000000000;;		// Get a signer for the provider.
0000000000000000000000000000000000000000;;		signer, err := framework.GetSigner(framework.TestContext.Provider)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error getting signer for provider %s: '%v'", framework.TestContext.Provider, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sshUser := os.Getenv("KUBE_SSH_USER")
0000000000000000000000000000000000000000;;		if sshUser == "" {
0000000000000000000000000000000000000000;;			sshUser = os.Getenv("USER")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config := &ssh.ClientConfig{
0000000000000000000000000000000000000000;;			User: sshUser,
0000000000000000000000000000000000000000;;			Auth: []ssh.AuthMethod{ssh.PublicKeys(signer)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host := framework.GetMasterHost() + ":22"
0000000000000000000000000000000000000000;;		client, err := ssh.Dial("tcp", host, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error getting SSH client to host %s: '%v'", host, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sshExecAndVerify(client *ssh.Client, cmd string) {
0000000000000000000000000000000000000000;;		_, _, rc, err := sshExec(client, cmd)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "Failed to execute %q with ssh client %+v", cmd, client)
0000000000000000000000000000000000000000;;		Expect(rc).To(Equal(0), "error return code from executing command on the cluster: %s", cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sshExec(client *ssh.Client, cmd string) (string, string, int, error) {
0000000000000000000000000000000000000000;;		framework.Logf("Executing '%s' on %v", cmd, client.RemoteAddr())
0000000000000000000000000000000000000000;;		session, err := client.NewSession()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", 0, fmt.Errorf("error creating session to host %s: '%v'", client.RemoteAddr(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer session.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the command.
0000000000000000000000000000000000000000;;		code := 0
0000000000000000000000000000000000000000;;		var bout, berr bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		session.Stdout, session.Stderr = &bout, &berr
0000000000000000000000000000000000000000;;		err = session.Run(cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Check whether the command failed to run or didn't complete.
0000000000000000000000000000000000000000;;			if exiterr, ok := err.(*ssh.ExitError); ok {
0000000000000000000000000000000000000000;;				// If we got an ExitError and the exit code is nonzero, we'll
0000000000000000000000000000000000000000;;				// consider the SSH itself successful (just that the command run
0000000000000000000000000000000000000000;;				// errored on the host).
0000000000000000000000000000000000000000;;				if code = exiterr.ExitStatus(); code != 0 {
0000000000000000000000000000000000000000;;					err = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Some other kind of error happened (e.g. an IOError); consider the
0000000000000000000000000000000000000000;;				// SSH unsuccessful.
0000000000000000000000000000000000000000;;				err = fmt.Errorf("failed running `%s` on %s: '%v'", cmd, client.RemoteAddr(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bout.String(), berr.String(), code, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeRemoteFile(sshClient *ssh.Client, data, dir, fileName string, mode os.FileMode) error {
0000000000000000000000000000000000000000;;		framework.Logf(fmt.Sprintf("Writing remote file '%s/%s' on %v", dir, fileName, sshClient.RemoteAddr()))
0000000000000000000000000000000000000000;;		session, err := sshClient.NewSession()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error creating session to host %s: '%v'", sshClient.RemoteAddr(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer session.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileSize := len(data)
0000000000000000000000000000000000000000;;		pipe, err := session.StdinPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer pipe.Close()
0000000000000000000000000000000000000000;;		if err := session.Start(fmt.Sprintf("scp -t %s", dir)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(pipe, "C%#o %d %s\n", mode, fileSize, fileName)
0000000000000000000000000000000000000000;;		io.Copy(pipe, strings.NewReader(data))
0000000000000000000000000000000000000000;;		fmt.Fprint(pipe, "\x00")
0000000000000000000000000000000000000000;;		pipe.Close()
0000000000000000000000000000000000000000;;		return session.Wait()
0000000000000000000000000000000000000000;;	}
