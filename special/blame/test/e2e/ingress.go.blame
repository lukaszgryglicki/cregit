0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
67fe5ef3fdf0e6bd1c856a743b70eb50297cc7bc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rbacv1beta1 "k8s.io/api/rbac/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Loadbalancing: L7", func() {
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			ns               string
0000000000000000000000000000000000000000;;			jig              *framework.IngressTestJig
0000000000000000000000000000000000000000;;			conformanceTests []framework.IngressConformanceTests
0000000000000000000000000000000000000000;;			cloudConfig      framework.CloudConfig
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("ingress")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			f.BeforeEach()
0000000000000000000000000000000000000000;;			jig = framework.NewIngressTestJig(f.ClientSet)
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			cloudConfig = framework.TestContext.CloudConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// this test wants powerful permissions.  Since the namespace names are unique, we can leave this
0000000000000000000000000000000000000000;;			// lying around so we don't have to race any caches
0000000000000000000000000000000000000000;;			framework.BindClusterRole(jig.Client.Rbac(), "cluster-admin", f.Namespace.Name,
0000000000000000000000000000000000000000;;				rbacv1beta1.Subject{Kind: rbacv1beta1.ServiceAccountKind, Namespace: f.Namespace.Name, Name: "default"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := framework.WaitForAuthorizationUpdate(jig.Client.AuthorizationV1beta1(),
0000000000000000000000000000000000000000;;				serviceaccount.MakeUsername(f.Namespace.Name, "default"),
0000000000000000000000000000000000000000;;				"", "create", schema.GroupResource{Resource: "pods"}, true)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Before enabling this loadbalancer test in any other test list you must
0000000000000000000000000000000000000000;;		// make sure the associated project has enough quota. At the time of this
0000000000000000000000000000000000000000;;		// writing a GCE project is allowed 3 backend services by default. This
0000000000000000000000000000000000000000;;		// test requires at least 5.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Slow by design ~10m for each "It" block dominated by loadbalancer setup time
0000000000000000000000000000000000000000;;		// TODO: write similar tests for nginx, haproxy and AWS Ingress.
0000000000000000000000000000000000000000;;		framework.KubeDescribe("GCE [Slow] [Feature:Ingress]", func() {
0000000000000000000000000000000000000000;;			var gceController *framework.GCEIngressController
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Platform specific setup
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;				By("Initializing gce controller")
0000000000000000000000000000000000000000;;				gceController = &framework.GCEIngressController{
0000000000000000000000000000000000000000;;					Ns:     ns,
0000000000000000000000000000000000000000;;					Client: jig.Client,
0000000000000000000000000000000000000000;;					Cloud:  framework.TestContext.CloudConfig,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gceController.Init()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Platform specific cleanup
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				if CurrentGinkgoTestDescription().Failed {
0000000000000000000000000000000000000000;;					framework.DescribeIng(ns)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if jig.Ingress == nil {
0000000000000000000000000000000000000000;;					By("No ingress created, no cleanup necessary")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("Deleting ingress")
0000000000000000000000000000000000000000;;				jig.TryDeleteIngress()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Cleaning up cloud resources")
0000000000000000000000000000000000000000;;				framework.CleanupGCEIngressController(gceController)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should conform to Ingress spec", func() {
0000000000000000000000000000000000000000;;				conformanceTests = framework.CreateIngressComformanceTests(jig, ns)
0000000000000000000000000000000000000000;;				for _, t := range conformanceTests {
0000000000000000000000000000000000000000;;					By(t.EntryLog)
0000000000000000000000000000000000000000;;					t.Execute()
0000000000000000000000000000000000000000;;					By(t.ExitLog)
0000000000000000000000000000000000000000;;					jig.WaitForIngress(true)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create ingress with given static-ip", func() {
0000000000000000000000000000000000000000;;				// ip released when the rest of lb resources are deleted in CleanupGCEIngressController
0000000000000000000000000000000000000000;;				ip := gceController.CreateStaticIP(ns)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("allocated static ip %v: %v through the GCE cloud provider", ns, ip))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				jig.CreateIngress(filepath.Join(framework.IngressManifestPath, "static-ip"), ns, map[string]string{
0000000000000000000000000000000000000000;;					"kubernetes.io/ingress.global-static-ip-name": ns,
0000000000000000000000000000000000000000;;					"kubernetes.io/ingress.allow-http":            "false",
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("waiting for Ingress to come up with ip: " + ip)
0000000000000000000000000000000000000000;;				httpClient := framework.BuildInsecureClient(framework.IngressReqTimeout)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.PollURL(fmt.Sprintf("https://%v/", ip), "", framework.LoadBalancerPollTimeout, jig.PollInterval, httpClient, false))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("should reject HTTP traffic")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(framework.PollURL(fmt.Sprintf("http://%v/", ip), "", framework.LoadBalancerPollTimeout, jig.PollInterval, httpClient, true))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("should have correct firewall rule for ingress")
0000000000000000000000000000000000000000;;				fw := gceController.GetFirewallRule()
0000000000000000000000000000000000000000;;				nodeTags := []string{cloudConfig.NodeTag}
0000000000000000000000000000000000000000;;				if framework.TestContext.Provider != "gce" {
0000000000000000000000000000000000000000;;					// nodeTags would be different in GKE.
0000000000000000000000000000000000000000;;					nodeTags = framework.GetNodeTags(jig.Client, cloudConfig)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expFw := jig.ConstructFirewallForIngress(gceController, nodeTags)
0000000000000000000000000000000000000000;;				// Passed the last argument as `true` to verify the backend ports is a subset
0000000000000000000000000000000000000000;;				// of the allowed ports in firewall rule, given there may be other existing
0000000000000000000000000000000000000000;;				// ingress resources and backends we are not aware of.
0000000000000000000000000000000000000000;;				Expect(framework.VerifyFirewallRule(fw, expFw, gceController.Cloud.Network, true)).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: uncomment the restart test once we have a way to synchronize
0000000000000000000000000000000000000000;;				// and know that the controller has resumed watching. If we delete
0000000000000000000000000000000000000000;;				// the ingress before the controller is ready we will leak.
0000000000000000000000000000000000000000;;				// By("restaring glbc")
0000000000000000000000000000000000000000;;				// restarter := NewRestartConfig(
0000000000000000000000000000000000000000;;				//	 framework.GetMasterHost(), "glbc", glbcHealthzPort, restartPollInterval, restartTimeout)
0000000000000000000000000000000000000000;;				// restarter.restart()
0000000000000000000000000000000000000000;;				// By("should continue serving on provided static-ip for 30 seconds")
0000000000000000000000000000000000000000;;				// framework.ExpectNoError(jig.verifyURL(fmt.Sprintf("https://%v/", ip), "", 30, 1*time.Second, httpClient))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: Implement a multizone e2e that verifies traffic reaches each
0000000000000000000000000000000000000000;;			// zone based on pod labels.
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Time: borderline 5m, slow by design
0000000000000000000000000000000000000000;;		framework.KubeDescribe("[Slow] Nginx", func() {
0000000000000000000000000000000000000000;;			var nginxController *framework.NginxIngressController
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("gce", "gke")
0000000000000000000000000000000000000000;;				By("Initializing nginx controller")
0000000000000000000000000000000000000000;;				jig.Class = "nginx"
0000000000000000000000000000000000000000;;				nginxController = &framework.NginxIngressController{Ns: ns, Client: jig.Client}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: This test may fail on other platforms. We can simply skip it
0000000000000000000000000000000000000000;;				// but we want to allow easy testing where a user might've hand
0000000000000000000000000000000000000000;;				// configured firewalls.
0000000000000000000000000000000000000000;;				if framework.ProviderIs("gce", "gke") {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.GcloudComputeResourceCreate("firewall-rules", fmt.Sprintf("ingress-80-443-%v", ns), framework.TestContext.CloudConfig.ProjectID, "--allow", "tcp:80,tcp:443", "--network", framework.TestContext.CloudConfig.Network))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Logf("WARNING: Not running on GCE/GKE, cannot create firewall rules for :80, :443. Assuming traffic can reach the external ips of all nodes in cluster on those ports.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nginxController.Init()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				if framework.ProviderIs("gce", "gke") {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(framework.GcloudComputeResourceDelete("firewall-rules", fmt.Sprintf("ingress-80-443-%v", ns), framework.TestContext.CloudConfig.ProjectID))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if CurrentGinkgoTestDescription().Failed {
0000000000000000000000000000000000000000;;					framework.DescribeIng(ns)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if jig.Ingress == nil {
0000000000000000000000000000000000000000;;					By("No ingress created, no cleanup necessary")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("Deleting ingress")
0000000000000000000000000000000000000000;;				jig.TryDeleteIngress()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should conform to Ingress spec", func() {
0000000000000000000000000000000000000000;;				// Poll more frequently to reduce e2e completion time.
0000000000000000000000000000000000000000;;				// This test runs in presubmit.
0000000000000000000000000000000000000000;;				jig.PollInterval = 5 * time.Second
0000000000000000000000000000000000000000;;				conformanceTests = framework.CreateIngressComformanceTests(jig, ns)
0000000000000000000000000000000000000000;;				for _, t := range conformanceTests {
0000000000000000000000000000000000000000;;					By(t.EntryLog)
0000000000000000000000000000000000000000;;					t.Execute()
0000000000000000000000000000000000000000;;					By(t.ExitLog)
0000000000000000000000000000000000000000;;					jig.WaitForIngress(false)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
