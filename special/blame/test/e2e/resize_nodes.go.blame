0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
53862cfccb706257741d679fe564b86e0c95cef6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		resizeNodeReadyTimeout = 2 * time.Minute
0000000000000000000000000000000000000000;;		nodeReadinessTimeout   = 3 * time.Minute
0000000000000000000000000000000000000000;;		podNotReadyTimeout     = 1 * time.Minute
0000000000000000000000000000000000000000;;		podReadyTimeout        = 2 * time.Minute
0000000000000000000000000000000000000000;;		testPort               = 9376
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func svcByName(name string, port int) *v1.Service {
0000000000000000000000000000000000000000;;		return &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: v1.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				Selector: map[string]string{
0000000000000000000000000000000000000000;;					"name": name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;					Port:       int32(port),
0000000000000000000000000000000000000000;;					TargetPort: intstr.FromInt(port),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSVCByName(c clientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		_, err := c.Core().Services(ns).Create(svcByName(name, testPort))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRCByName creates a replication controller with a selector by name of name.
0000000000000000000000000000000000000000;;	func newRCByName(c clientset.Interface, ns, name string, replicas int32, gracePeriod *int64) (*v1.ReplicationController, error) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("creating replication controller %s", name))
0000000000000000000000000000000000000000;;		return c.Core().ReplicationControllers(ns).Create(framework.RcByNamePort(
0000000000000000000000000000000000000000;;			name, replicas, framework.ServeHostnameImage, 9376, v1.ProtocolTCP, map[string]string{}, gracePeriod))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resizeRC(c clientset.Interface, ns, name string, replicas int32) error {
0000000000000000000000000000000000000000;;		rc, err := c.Core().ReplicationControllers(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*(rc.Spec.Replicas) = replicas
0000000000000000000000000000000000000000;;		_, err = c.Core().ReplicationControllers(rc.Namespace).Update(rc)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Nodes [Disruptive]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("resize-nodes")
0000000000000000000000000000000000000000;;		var systemPodsNo int32
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;		var ns string
0000000000000000000000000000000000000000;;		ignoreLabels := framework.ImagePullerLabels
0000000000000000000000000000000000000000;;		var group string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			systemPods, err := framework.GetPodsInNamespace(c, ns, ignoreLabels)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			systemPodsNo = int32(len(systemPods))
0000000000000000000000000000000000000000;;			if strings.Index(framework.TestContext.CloudConfig.NodeInstanceGroup, ",") >= 0 {
0000000000000000000000000000000000000000;;				framework.Failf("Test dose not support cluster setup with more than one MIG: %s", framework.TestContext.CloudConfig.NodeInstanceGroup)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				group = framework.TestContext.CloudConfig.NodeInstanceGroup
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Slow issue #13323 (8 min)
0000000000000000000000000000000000000000;;		framework.KubeDescribe("Resize [Slow]", func() {
0000000000000000000000000000000000000000;;			var skipped bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				skipped = true
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("gce", "gke", "aws")
0000000000000000000000000000000000000000;;				framework.SkipUnlessNodeCountIsAtLeast(2)
0000000000000000000000000000000000000000;;				skipped = false
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				if skipped {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("restoring the original node instance group size")
0000000000000000000000000000000000000000;;				if err := framework.ResizeGroup(group, int32(framework.TestContext.CloudConfig.NumNodes)); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Couldn't restore the original node instance group size: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// In GKE, our current tunneling setup has the potential to hold on to a broken tunnel (from a
0000000000000000000000000000000000000000;;				// rebooted/deleted node) for up to 5 minutes before all tunnels are dropped and recreated.
0000000000000000000000000000000000000000;;				// Most tests make use of some proxy feature to verify functionality. So, if a reboot test runs
0000000000000000000000000000000000000000;;				// right before a test that tries to get logs, for example, we may get unlucky and try to use a
0000000000000000000000000000000000000000;;				// closed tunnel to a node that was recently rebooted. There's no good way to framework.Poll for proxies
0000000000000000000000000000000000000000;;				// being closed, so we sleep.
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// TODO(cjcullen) reduce this sleep (#19314)
0000000000000000000000000000000000000000;;				if framework.ProviderIs("gke") {
0000000000000000000000000000000000000000;;					By("waiting 5 minutes for all dead tunnels to be dropped")
0000000000000000000000000000000000000000;;					time.Sleep(5 * time.Minute)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := framework.WaitForGroupSize(group, int32(framework.TestContext.CloudConfig.NumNodes)); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Couldn't restore the original node instance group size: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := framework.WaitForClusterSize(c, framework.TestContext.CloudConfig.NumNodes, 10*time.Minute); err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Couldn't restore the original cluster size: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Many e2e tests assume that the cluster is fully healthy before they start.  Wait until
0000000000000000000000000000000000000000;;				// the cluster is restored to health.
0000000000000000000000000000000000000000;;				By("waiting for system pods to successfully restart")
0000000000000000000000000000000000000000;;				err := framework.WaitForPodsRunningReady(c, metav1.NamespaceSystem, systemPodsNo, 0, framework.PodReadyBeforeTimeout, ignoreLabels)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				By("waiting for image prepulling pods to complete")
0000000000000000000000000000000000000000;;				framework.WaitForPodsSuccess(c, metav1.NamespaceSystem, framework.ImagePullerLabels, imagePrePullingTimeout)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to delete nodes", func() {
0000000000000000000000000000000000000000;;				// Create a replication controller for a service that serves its hostname.
0000000000000000000000000000000000000000;;				// The source for the Docker container kubernetes/serve_hostname is in contrib/for-demos/serve_hostname
0000000000000000000000000000000000000000;;				name := "my-hostname-delete-node"
0000000000000000000000000000000000000000;;				replicas := int32(framework.TestContext.CloudConfig.NumNodes)
0000000000000000000000000000000000000000;;				newRCByName(c, ns, name, replicas, nil)
0000000000000000000000000000000000000000;;				err := framework.VerifyPods(c, ns, name, true, replicas)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("decreasing cluster size to %d", replicas-1))
0000000000000000000000000000000000000000;;				err = framework.ResizeGroup(group, replicas-1)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				err = framework.WaitForGroupSize(group, replicas-1)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				err = framework.WaitForClusterSize(c, int(replicas-1), 10*time.Minute)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("waiting 1 minute for the watch in the podGC to catch up, remove any pods scheduled on " +
0000000000000000000000000000000000000000;;					"the now non-existent node and the RC to recreate it")
0000000000000000000000000000000000000000;;				time.Sleep(time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("verifying whether the pods from the removed node are recreated")
0000000000000000000000000000000000000000;;				err = framework.VerifyPods(c, ns, name, true, replicas)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: Bug here - testName is not correct
0000000000000000000000000000000000000000;;			It("should be able to add nodes", func() {
0000000000000000000000000000000000000000;;				// Create a replication controller for a service that serves its hostname.
0000000000000000000000000000000000000000;;				// The source for the Docker container kubernetes/serve_hostname is in contrib/for-demos/serve_hostname
0000000000000000000000000000000000000000;;				name := "my-hostname-add-node"
0000000000000000000000000000000000000000;;				newSVCByName(c, ns, name)
0000000000000000000000000000000000000000;;				replicas := int32(framework.TestContext.CloudConfig.NumNodes)
0000000000000000000000000000000000000000;;				newRCByName(c, ns, name, replicas, nil)
0000000000000000000000000000000000000000;;				err := framework.VerifyPods(c, ns, name, true, replicas)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("increasing cluster size to %d", replicas+1))
0000000000000000000000000000000000000000;;				err = framework.ResizeGroup(group, replicas+1)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				err = framework.WaitForGroupSize(group, replicas+1)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				err = framework.WaitForClusterSize(c, int(replicas+1), 10*time.Minute)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("increasing size of the replication controller to %d and verifying all pods are running", replicas+1))
0000000000000000000000000000000000000000;;				err = resizeRC(c, ns, name, replicas+1)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				err = framework.VerifyPods(c, ns, name, true, replicas+1)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
