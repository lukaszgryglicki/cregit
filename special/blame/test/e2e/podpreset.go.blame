0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4f464f4f557a394d8000d8a173a77452fc579f35;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		settings "k8s.io/api/settings/v1alpha1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("PodPreset", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("podpreset")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var podClient *framework.PodClient
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			// only run on gce for the time being til we find an easier way to update
0000000000000000000000000000000000000000;;			// the admission controllers used on the others
0000000000000000000000000000000000000000;;			framework.SkipUnlessProviderIs("gce")
0000000000000000000000000000000000000000;;			podClient = f.PodClient()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simplest case: all pods succeed promptly
0000000000000000000000000000000000000000;;		It("should create a pod preset", func() {
0000000000000000000000000000000000000000;;			By("Creating a pod preset")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pip := &settings.PodPreset{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "hello",
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: settings.PodPresetSpec{
0000000000000000000000000000000000000000;;					Selector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:      "security",
0000000000000000000000000000000000000000;;								Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;								Values:   []string{"S2"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{{Name: "vol", VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{}}}},
0000000000000000000000000000000000000000;;					VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;						{Name: "vol", MountPath: "/foo"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{{Name: "abc", Value: "value"}, {Name: "ABC", Value: "value"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err := createPodPreset(f.ClientSet, f.Namespace.Name, pip)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			name := "pod-preset-pod"
0000000000000000000000000000000000000000;;			value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;			pod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"name":     "foo",
0000000000000000000000000000000000000000;;						"time":     value,
0000000000000000000000000000000000000000;;						"security": "S2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "nginx",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("setting up watch")
0000000000000000000000000000000000000000;;			selector := labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pod")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{
0000000000000000000000000000000000000000;;				LabelSelector:   selector.String(),
0000000000000000000000000000000000000000;;				ResourceVersion: pods.ListMeta.ResourceVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w, err := podClient.Watch(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to set up watch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;			podClient.Create(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the pod is in kubernetes")
0000000000000000000000000000000000000000;;			selector = labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err = podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pod")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying pod creation was observed")
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;				if event.Type != watch.Added {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to observe pod creation: %v", event)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(framework.PodStartTimeout):
0000000000000000000000000000000000000000;;				framework.Failf("Timeout while waiting for pod creation")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We need to wait for the pod to be running, otherwise the deletion
0000000000000000000000000000000000000000;;			// may be carried out immediately rather than gracefully.
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.WaitForPodRunning(pod.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("ensuring pod is modified")
0000000000000000000000000000000000000000;;			// save the running pod
0000000000000000000000000000000000000000;;			pod, err = podClient.Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to GET scheduled pod")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check the annotation is there
0000000000000000000000000000000000000000;;			if _, ok := pod.Annotations["podpreset.admission.kubernetes.io/podpreset-hello"]; !ok {
0000000000000000000000000000000000000000;;				framework.Failf("Annotation not found in pod annotations: \n%v\n", pod.Annotations)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify the env is the same
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(pip.Spec.Env, pod.Spec.Containers[0].Env) {
0000000000000000000000000000000000000000;;				framework.Failf("env of pod container does not match the env of the pip: expected %#v, got: %#v", pip.Spec.Env, pod.Spec.Containers[0].Env)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should not modify the pod on conflict", func() {
0000000000000000000000000000000000000000;;			By("Creating a pod preset")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pip := &settings.PodPreset{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "hello",
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: settings.PodPresetSpec{
0000000000000000000000000000000000000000;;					Selector: metav1.LabelSelector{
0000000000000000000000000000000000000000;;						MatchExpressions: []metav1.LabelSelectorRequirement{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Key:      "security",
0000000000000000000000000000000000000000;;								Operator: metav1.LabelSelectorOpIn,
0000000000000000000000000000000000000000;;								Values:   []string{"S2"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{{Name: "vol", VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{}}}},
0000000000000000000000000000000000000000;;					VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;						{Name: "vol", MountPath: "/foo"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{{Name: "abc", Value: "value"}, {Name: "ABC", Value: "value"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err := createPodPreset(f.ClientSet, f.Namespace.Name, pip)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("creating the pod")
0000000000000000000000000000000000000000;;			name := "pod-preset-pod"
0000000000000000000000000000000000000000;;			value := strconv.Itoa(time.Now().Nanosecond())
0000000000000000000000000000000000000000;;			originalPod := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      name,
0000000000000000000000000000000000000000;;					Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"name":     "foo",
0000000000000000000000000000000000000000;;						"time":     value,
0000000000000000000000000000000000000000;;						"security": "S2",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:  "nginx",
0000000000000000000000000000000000000000;;							Image: "gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;							Env:   []v1.EnvVar{{Name: "abc", Value: "value2"}, {Name: "ABC", Value: "value"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("setting up watch")
0000000000000000000000000000000000000000;;			selector := labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err := podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pod")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(0))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{
0000000000000000000000000000000000000000;;				LabelSelector:   selector.String(),
0000000000000000000000000000000000000000;;				ResourceVersion: pods.ListMeta.ResourceVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w, err := podClient.Watch(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to set up watch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("submitting the pod to kubernetes")
0000000000000000000000000000000000000000;;			podClient.Create(originalPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying the pod is in kubernetes")
0000000000000000000000000000000000000000;;			selector = labels.SelectorFromSet(labels.Set(map[string]string{"time": value}))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;			pods, err = podClient.List(options)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to query for pod")
0000000000000000000000000000000000000000;;			Expect(len(pods.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("verifying pod creation was observed")
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, _ := <-w.ResultChan():
0000000000000000000000000000000000000000;;				if event.Type != watch.Added {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to observe pod creation: %v", event)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(framework.PodStartTimeout):
0000000000000000000000000000000000000000;;				framework.Failf("Timeout while waiting for pod creation")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We need to wait for the pod to be running, otherwise the deletion
0000000000000000000000000000000000000000;;			// may be carried out immediately rather than gracefully.
0000000000000000000000000000000000000000;;			framework.ExpectNoError(f.WaitForPodRunning(originalPod.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("ensuring pod is modified")
0000000000000000000000000000000000000000;;			// save the running pod
0000000000000000000000000000000000000000;;			pod, err := podClient.Get(originalPod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), "failed to GET scheduled pod")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check the annotation is not there
0000000000000000000000000000000000000000;;			if _, ok := pod.Annotations["podpreset.admission.kubernetes.io/podpreset-hello"]; ok {
0000000000000000000000000000000000000000;;				framework.Failf("Annotation found in pod annotations and should not be: \n%v\n", pod.Annotations)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify the env is the same
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(originalPod.Spec.Containers[0].Env, pod.Spec.Containers[0].Env) {
0000000000000000000000000000000000000000;;				framework.Failf("env of pod container does not match the env of the original pod: expected %#v, got: %#v", originalPod.Spec.Containers[0].Env, pod.Spec.Containers[0].Env)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodPreset(c clientset.Interface, ns, name string) (*settings.PodPreset, error) {
0000000000000000000000000000000000000000;;		return c.Settings().PodPresets(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPodPreset(c clientset.Interface, ns string, job *settings.PodPreset) (*settings.PodPreset, error) {
0000000000000000000000000000000000000000;;		return c.Settings().PodPresets(ns).Create(job)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updatePodPreset(c clientset.Interface, ns string, job *settings.PodPreset) (*settings.PodPreset, error) {
0000000000000000000000000000000000000000;;		return c.Settings().PodPresets(ns).Update(job)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deletePodPreset(c clientset.Interface, ns, name string) error {
0000000000000000000000000000000000000000;;		return c.Settings().PodPresets(ns).Delete(name, nil)
0000000000000000000000000000000000000000;;	}
