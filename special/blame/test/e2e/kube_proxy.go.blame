0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
30902f78648c29d1ef98d3429f3e2e68aeef4b37;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/images/net/nat"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const kubeProxyE2eImage = "gcr.io/google_containers/e2e-net-amd64:1.0"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Network", func() {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			testDaemonHttpPort    = 11301
0000000000000000000000000000000000000000;;			testDaemonTcpPort     = 11302
0000000000000000000000000000000000000000;;			timeoutSeconds        = 10
0000000000000000000000000000000000000000;;			postFinTimeoutSeconds = 5
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fr := framework.NewDefaultFramework("network")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should set TCP CLOSE_WAIT timeout", func() {
0000000000000000000000000000000000000000;;			nodes := framework.GetReadySchedulableNodesOrDie(fr.ClientSet)
0000000000000000000000000000000000000000;;			ips := framework.CollectAddresses(nodes, v1.NodeInternalIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(nodes.Items) < 2 {
0000000000000000000000000000000000000000;;				framework.Skipf(
0000000000000000000000000000000000000000;;					"Test requires >= 2 Ready nodes, but there are only %v nodes",
0000000000000000000000000000000000000000;;					len(nodes.Items))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			type NodeInfo struct {
0000000000000000000000000000000000000000;;				node   *v1.Node
0000000000000000000000000000000000000000;;				name   string
0000000000000000000000000000000000000000;;				nodeIp string
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clientNodeInfo := NodeInfo{
0000000000000000000000000000000000000000;;				node:   &nodes.Items[0],
0000000000000000000000000000000000000000;;				name:   nodes.Items[0].Name,
0000000000000000000000000000000000000000;;				nodeIp: ips[0],
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serverNodeInfo := NodeInfo{
0000000000000000000000000000000000000000;;				node:   &nodes.Items[1],
0000000000000000000000000000000000000000;;				name:   nodes.Items[1].Name,
0000000000000000000000000000000000000000;;				nodeIp: ips[1],
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			zero := int64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clientPodSpec := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "e2e-net-client",
0000000000000000000000000000000000000000;;					Namespace: fr.Namespace.Name,
0000000000000000000000000000000000000000;;					Labels:    map[string]string{"app": "e2e-net-client"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					NodeName: clientNodeInfo.name,
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:            "e2e-net-client",
0000000000000000000000000000000000000000;;							Image:           kubeProxyE2eImage,
0000000000000000000000000000000000000000;;							ImagePullPolicy: "Always",
0000000000000000000000000000000000000000;;							Command: []string{
0000000000000000000000000000000000000000;;								"/net", "-serve", fmt.Sprintf("0.0.0.0:%d", testDaemonHttpPort),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					TerminationGracePeriodSeconds: &zero,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serverPodSpec := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "e2e-net-server",
0000000000000000000000000000000000000000;;					Namespace: fr.Namespace.Name,
0000000000000000000000000000000000000000;;					Labels:    map[string]string{"app": "e2e-net-server"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					NodeName: serverNodeInfo.name,
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:            "e2e-net-server",
0000000000000000000000000000000000000000;;							Image:           kubeProxyE2eImage,
0000000000000000000000000000000000000000;;							ImagePullPolicy: "Always",
0000000000000000000000000000000000000000;;							Command: []string{
0000000000000000000000000000000000000000;;								"/net",
0000000000000000000000000000000000000000;;								"-runner", "nat-closewait-server",
0000000000000000000000000000000000000000;;								"-options",
0000000000000000000000000000000000000000;;								fmt.Sprintf(`{"LocalAddr":"0.0.0.0:%v", "PostFindTimeoutSeconds":%v}`,
0000000000000000000000000000000000000000;;									testDaemonTcpPort,
0000000000000000000000000000000000000000;;									postFinTimeoutSeconds),
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:          "tcp",
0000000000000000000000000000000000000000;;									ContainerPort: testDaemonTcpPort,
0000000000000000000000000000000000000000;;									HostPort:      testDaemonTcpPort,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					TerminationGracePeriodSeconds: &zero,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf(
0000000000000000000000000000000000000000;;				"Launching a server daemon on node %v (node ip: %v, image: %v)",
0000000000000000000000000000000000000000;;				serverNodeInfo.name,
0000000000000000000000000000000000000000;;				serverNodeInfo.nodeIp,
0000000000000000000000000000000000000000;;				kubeProxyE2eImage))
0000000000000000000000000000000000000000;;			fr.PodClient().CreateSync(serverPodSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf(
0000000000000000000000000000000000000000;;				"Launching a client daemon on node %v (node ip: %v, image: %v)",
0000000000000000000000000000000000000000;;				clientNodeInfo.name,
0000000000000000000000000000000000000000;;				clientNodeInfo.nodeIp,
0000000000000000000000000000000000000000;;				kubeProxyE2eImage))
0000000000000000000000000000000000000000;;			fr.PodClient().CreateSync(clientPodSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Make client connect")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			options := nat.CloseWaitClientOptions{
0000000000000000000000000000000000000000;;				RemoteAddr: fmt.Sprintf("%v:%v",
0000000000000000000000000000000000000000;;					serverNodeInfo.nodeIp, testDaemonTcpPort),
0000000000000000000000000000000000000000;;				TimeoutSeconds:        timeoutSeconds,
0000000000000000000000000000000000000000;;				PostFinTimeoutSeconds: 0,
0000000000000000000000000000000000000000;;				LeakConnection:        true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			jsonBytes, err := json.Marshal(options)
0000000000000000000000000000000000000000;;			cmd := fmt.Sprintf(
0000000000000000000000000000000000000000;;				`curl -X POST http://localhost:%v/run/nat-closewait-client -d `+
0000000000000000000000000000000000000000;;					`'%v' 2>/dev/null`,
0000000000000000000000000000000000000000;;				testDaemonHttpPort,
0000000000000000000000000000000000000000;;				string(jsonBytes))
0000000000000000000000000000000000000000;;			framework.RunHostCmdOrDie(fr.Namespace.Name, "e2e-net-client", cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			<-time.After(time.Duration(1) * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Checking /proc/net/nf_conntrack for the timeout")
0000000000000000000000000000000000000000;;			// If test flakes occur here, then this check should be performed
0000000000000000000000000000000000000000;;			// in a loop as there may be a race with the client connecting.
0000000000000000000000000000000000000000;;			framework.IssueSSHCommandWithResult(
0000000000000000000000000000000000000000;;				fmt.Sprintf("sudo cat /proc/net/ip_conntrack | grep 'dport=%v'",
0000000000000000000000000000000000000000;;					testDaemonTcpPort),
0000000000000000000000000000000000000000;;				framework.TestContext.Provider,
0000000000000000000000000000000000000000;;				clientNodeInfo.node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Timeout in seconds is available as the third column from
0000000000000000000000000000000000000000;;			// /proc/net/ip_conntrack.
0000000000000000000000000000000000000000;;			result, err := framework.IssueSSHCommandWithResult(
0000000000000000000000000000000000000000;;				fmt.Sprintf(
0000000000000000000000000000000000000000;;					"sudo cat /proc/net/ip_conntrack "+
0000000000000000000000000000000000000000;;						"| grep 'CLOSE_WAIT.*dst=%v.*dport=%v' "+
0000000000000000000000000000000000000000;;						"| tail -n 1"+
0000000000000000000000000000000000000000;;						"| awk '{print $3}' ",
0000000000000000000000000000000000000000;;					serverNodeInfo.nodeIp,
0000000000000000000000000000000000000000;;					testDaemonTcpPort),
0000000000000000000000000000000000000000;;				framework.TestContext.Provider,
0000000000000000000000000000000000000000;;				clientNodeInfo.node)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			timeoutSeconds, err := strconv.Atoi(strings.TrimSpace(result.Stdout))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// These must be synchronized from the default values set in
0000000000000000000000000000000000000000;;			// pkg/apis/../defaults.go ConntrackTCPCloseWaitTimeout. The
0000000000000000000000000000000000000000;;			// current defaults are hidden in the initialization code.
0000000000000000000000000000000000000000;;			const epsilonSeconds = 60
0000000000000000000000000000000000000000;;			const expectedTimeoutSeconds = 60 * 60
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.Logf("conntrack entry timeout was: %v, expected: %v",
0000000000000000000000000000000000000000;;				timeoutSeconds, expectedTimeoutSeconds)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Expect(math.Abs(float64(timeoutSeconds - expectedTimeoutSeconds))).Should(
0000000000000000000000000000000000000000;;				BeNumerically("<", (epsilonSeconds)))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
