0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Script that creates a Kubemark cluster for any given cloud provider.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	TMP_ROOT="$(dirname "${BASH_SOURCE}")/../.."
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(readlink -e ${TMP_ROOT} 2> /dev/null || perl -MCwd -e 'print Cwd::abs_path shift' ${TMP_ROOT})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/test/kubemark/skeleton/util.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/test/kubemark/cloud-provider-config.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/test/kubemark/${CLOUD_PROVIDER}/util.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/kubemark/${CLOUD_PROVIDER}/config-default.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/kubemark/util.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# hack/lib/init.sh will ovewrite ETCD_VERSION if this is unset
0000000000000000000000000000000000000000;;	# what what is default in hack/lib/etcd.sh
0000000000000000000000000000000000000000;;	# To avoid it, if it is empty, we set it to 'avoid-overwrite' and
0000000000000000000000000000000000000000;;	# clean it after that.
0000000000000000000000000000000000000000;;	if [ -z "${ETCD_VERSION:-}" ]; then
0000000000000000000000000000000000000000;;	  ETCD_VERSION="avoid-overwrite"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/init.sh"
0000000000000000000000000000000000000000;;	if [ "${ETCD_VERSION:-}" == "avoid-overwrite" ]; then
0000000000000000000000000000000000000000;;	  ETCD_VERSION=""
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBECTL="${KUBE_ROOT}/cluster/kubectl.sh"
0000000000000000000000000000000000000000;;	KUBEMARK_DIRECTORY="${KUBE_ROOT}/test/kubemark"
0000000000000000000000000000000000000000;;	RESOURCE_DIRECTORY="${KUBEMARK_DIRECTORY}/resources"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Write all environment variables that we need to pass to the kubemark master,
0000000000000000000000000000000000000000;;	# locally to the file ${RESOURCE_DIRECTORY}/kubemark-master-env.sh.
0000000000000000000000000000000000000000;;	function create-master-environment-file {
0000000000000000000000000000000000000000;;	  cat > "${RESOURCE_DIRECTORY}/kubemark-master-env.sh" <<EOF
0000000000000000000000000000000000000000;;	# Generic variables.
0000000000000000000000000000000000000000;;	INSTANCE_PREFIX="${INSTANCE_PREFIX:-}"
0000000000000000000000000000000000000000;;	SERVICE_CLUSTER_IP_RANGE="${SERVICE_CLUSTER_IP_RANGE:-}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Etcd related variables.
0000000000000000000000000000000000000000;;	ETCD_IMAGE="${ETCD_IMAGE:-3.0.17}"
0000000000000000000000000000000000000000;;	ETCD_VERSION="${ETCD_VERSION:-}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Controller-manager related variables.
0000000000000000000000000000000000000000;;	CONTROLLER_MANAGER_TEST_ARGS="${CONTROLLER_MANAGER_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;	ALLOCATE_NODE_CIDRS="${ALLOCATE_NODE_CIDRS:-}"
0000000000000000000000000000000000000000;;	CLUSTER_IP_RANGE="${CLUSTER_IP_RANGE:-}"
0000000000000000000000000000000000000000;;	TERMINATED_POD_GC_THRESHOLD="${TERMINATED_POD_GC_THRESHOLD:-}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Scheduler related variables.
0000000000000000000000000000000000000000;;	SCHEDULER_TEST_ARGS="${SCHEDULER_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Apiserver related variables.
0000000000000000000000000000000000000000;;	APISERVER_TEST_ARGS="${APISERVER_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;	STORAGE_BACKEND="${STORAGE_BACKEND:-}"
0000000000000000000000000000000000000000;;	NUM_NODES="${NUM_NODES:-}"
0000000000000000000000000000000000000000;;	CUSTOM_ADMISSION_PLUGINS="${CUSTOM_ADMISSION_PLUGINS:-}"
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  echo "Created the environment file for master."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generate certs/keys for CA, master, kubelet and kubecfg, and tokens for kubelet
0000000000000000000000000000000000000000;;	# and kubeproxy.
0000000000000000000000000000000000000000;;	function generate-pki-config {
0000000000000000000000000000000000000000;;	  kube::util::ensure-temp-dir
0000000000000000000000000000000000000000;;	  gen-kube-bearertoken
0000000000000000000000000000000000000000;;	  gen-kube-basicauth
0000000000000000000000000000000000000000;;	  create-certs ${MASTER_IP}
0000000000000000000000000000000000000000;;	  KUBELET_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  KUBE_PROXY_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  NODE_PROBLEM_DETECTOR_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  HEAPSTER_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;	  echo "Generated PKI authentication data for kubemark."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait for the master to be reachable for executing commands on it. We do this by
0000000000000000000000000000000000000000;;	# trying to run the bash noop(:) on the master, with 10 retries.
0000000000000000000000000000000000000000;;	function wait-for-master-reachability {
0000000000000000000000000000000000000000;;	  execute-cmd-on-master-with-retries ":" 10
0000000000000000000000000000000000000000;;	  echo "Checked master reachability for remote command execution."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Write all the relevant certs/keys/tokens to the master.
0000000000000000000000000000000000000000;;	function write-pki-config-to-master {
0000000000000000000000000000000000000000;;	  PKI_SETUP_CMD="sudo mkdir /home/kubernetes/k8s_auth_data -p && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo ${CA_CERT_BASE64} | base64 --decode > /home/kubernetes/k8s_auth_data/ca.crt\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo ${MASTER_CERT_BASE64} | base64 --decode > /home/kubernetes/k8s_auth_data/server.cert\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo ${MASTER_KEY_BASE64} | base64 --decode > /home/kubernetes/k8s_auth_data/server.key\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo ${KUBECFG_CERT_BASE64} | base64 --decode > /home/kubernetes/k8s_auth_data/kubecfg.crt\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo ${KUBECFG_KEY_BASE64} | base64 --decode > /home/kubernetes/k8s_auth_data/kubecfg.key\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo \"${KUBE_BEARER_TOKEN},admin,admin\" > /home/kubernetes/k8s_auth_data/known_tokens.csv\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo \"${KUBELET_TOKEN},system:node:node-name,uid:kubelet,system:nodes\" >> /home/kubernetes/k8s_auth_data/known_tokens.csv\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo \"${KUBE_PROXY_TOKEN},system:kube-proxy,uid:kube_proxy\" >> /home/kubernetes/k8s_auth_data/known_tokens.csv\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo \"${HEAPSTER_TOKEN},system:heapster,uid:heapster\" >> /home/kubernetes/k8s_auth_data/known_tokens.csv\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo \"${NODE_PROBLEM_DETECTOR_TOKEN},system:node-problem-detector,uid:system:node-problem-detector\" >> /home/kubernetes/k8s_auth_data/known_tokens.csv\" && \
0000000000000000000000000000000000000000;;	    sudo bash -c \"echo ${KUBE_PASSWORD},admin,admin > /home/kubernetes/k8s_auth_data/basic_auth.csv\""
0000000000000000000000000000000000000000;;	  execute-cmd-on-master-with-retries "${PKI_SETUP_CMD}" 3
0000000000000000000000000000000000000000;;	  echo "Wrote PKI certs, keys, tokens and admin password to master."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Write kubeconfig to ${RESOURCE_DIRECTORY}/kubeconfig.kubemark in order to
0000000000000000000000000000000000000000;;	# use kubectl locally.
0000000000000000000000000000000000000000;;	function write-local-kubeconfig {
0000000000000000000000000000000000000000;;	  LOCAL_KUBECONFIG="${RESOURCE_DIRECTORY}/kubeconfig.kubemark"
0000000000000000000000000000000000000000;;	  cat > "${LOCAL_KUBECONFIG}" << EOF
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Config
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: kubecfg
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate-data: "${KUBECFG_CERT_BASE64}"
0000000000000000000000000000000000000000;;	    client-key-data: "${KUBECFG_KEY_BASE64}"
0000000000000000000000000000000000000000;;	    username: admin
0000000000000000000000000000000000000000;;	    password: admin
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- name: kubemark
0000000000000000000000000000000000000000;;	  cluster:
0000000000000000000000000000000000000000;;	    certificate-authority-data: "${CA_CERT_BASE64}"
0000000000000000000000000000000000000000;;	    server: https://${MASTER_IP}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- context:
0000000000000000000000000000000000000000;;	    cluster: kubemark
0000000000000000000000000000000000000000;;	    user: kubecfg
0000000000000000000000000000000000000000;;	  name: kubemark-context
0000000000000000000000000000000000000000;;	current-context: kubemark-context
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  echo "Kubeconfig file for kubemark master written to ${LOCAL_KUBECONFIG}."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copy all the necessary resource files (scripts/configs/manifests) to the master.
0000000000000000000000000000000000000000;;	function copy-resource-files-to-master {
0000000000000000000000000000000000000000;;	  copy-files \
0000000000000000000000000000000000000000;;	    "${SERVER_BINARY_TAR}" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/kubemark-master-env.sh" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/start-kubemark-master.sh" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/kubeconfig.kubemark" \
0000000000000000000000000000000000000000;;	    "${KUBEMARK_DIRECTORY}/configure-kubectl.sh" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/manifests/etcd.yaml" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/manifests/etcd-events.yaml" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/manifests/kube-apiserver.yaml" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/manifests/kube-scheduler.yaml" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/manifests/kube-controller-manager.yaml" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/manifests/kube-addon-manager.yaml" \
0000000000000000000000000000000000000000;;	    "${RESOURCE_DIRECTORY}/manifests/addons/kubemark-rbac-bindings" \
0000000000000000000000000000000000000000;;	    "kubernetes@${MASTER_NAME}":/home/kubernetes/
0000000000000000000000000000000000000000;;	  echo "Copied server binary, master startup scripts, configs and resource manifests to master."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Make startup scripts executable and run start-kubemark-master.sh.
0000000000000000000000000000000000000000;;	function start-master-components {
0000000000000000000000000000000000000000;;	  echo ""
0000000000000000000000000000000000000000;;	  MASTER_STARTUP_CMD="sudo bash /home/kubernetes/start-kubemark-master.sh"
0000000000000000000000000000000000000000;;	  execute-cmd-on-master-with-retries "${MASTER_STARTUP_CMD}"
0000000000000000000000000000000000000000;;	  echo "The master has started and is now live."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Finds the right kubemark binary for 'linux/amd64' platform and uses it to
0000000000000000000000000000000000000000;;	# create a docker image for hollow-node and upload it to the appropriate
0000000000000000000000000000000000000000;;	# docker container registry for the cloud provider.
0000000000000000000000000000000000000000;;	function create-and-upload-hollow-node-image {
0000000000000000000000000000000000000000;;	  MAKE_DIR="${KUBE_ROOT}/cluster/images/kubemark"
0000000000000000000000000000000000000000;;	  KUBEMARK_BIN="$(kube::util::find-binary-for-platform kubemark linux/amd64)"
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBEMARK_BIN}" ]]; then
0000000000000000000000000000000000000000;;	    echo 'Cannot find cmd/kubemark binary'
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  
0000000000000000000000000000000000000000;;	  echo "Copying kubemark binary to ${MAKE_DIR}"
0000000000000000000000000000000000000000;;	  cp "${KUBEMARK_BIN}" "${MAKE_DIR}"
0000000000000000000000000000000000000000;;	  CURR_DIR=`pwd`
0000000000000000000000000000000000000000;;	  cd "${MAKE_DIR}"
0000000000000000000000000000000000000000;;	  RETRIES=3
0000000000000000000000000000000000000000;;	  for attempt in $(seq 1 ${RETRIES}); do
0000000000000000000000000000000000000000;;	    if ! REGISTRY="${CONTAINER_REGISTRY}" PROJECT="${PROJECT}" make "${KUBEMARK_IMAGE_MAKE_TARGET}"; then
0000000000000000000000000000000000000000;;	      if [[ $((attempt)) -eq "${RETRIES}" ]]; then
0000000000000000000000000000000000000000;;	        echo "${color_red}Make failed. Exiting.${color_norm}"
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      echo -e "${color_yellow}Make attempt $(($attempt)) failed. Retrying.${color_norm}" >& 2
0000000000000000000000000000000000000000;;	      sleep $(($attempt * 5))
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  rm kubemark
0000000000000000000000000000000000000000;;	  cd $CURR_DIR
0000000000000000000000000000000000000000;;	  echo "Created and uploaded the kubemark hollow-node image to docker registry."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Generate secret and configMap for the hollow-node pods to work, prepare
0000000000000000000000000000000000000000;;	# manifests of the hollow-node and heapster replication controllers from
0000000000000000000000000000000000000000;;	# templates, and finally create these resources through kubectl.
0000000000000000000000000000000000000000;;	function create-kube-hollow-node-resources {
0000000000000000000000000000000000000000;;	  # Create kubeconfig for Kubelet.
0000000000000000000000000000000000000000;;	  KUBELET_KUBECONFIG_CONTENTS=$(echo "apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Config
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: kubelet
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate-data: "${KUBELET_CERT_BASE64}"
0000000000000000000000000000000000000000;;	    client-key-data: "${KUBELET_KEY_BASE64}"
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- name: kubemark
0000000000000000000000000000000000000000;;	  cluster:
0000000000000000000000000000000000000000;;	    certificate-authority-data: "${CA_CERT_BASE64}"
0000000000000000000000000000000000000000;;	    server: https://${MASTER_IP}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- context:
0000000000000000000000000000000000000000;;	    cluster: kubemark
0000000000000000000000000000000000000000;;	    user: kubelet
0000000000000000000000000000000000000000;;	  name: kubemark-context
0000000000000000000000000000000000000000;;	current-context: kubemark-context")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create kubeconfig for Kubeproxy.
0000000000000000000000000000000000000000;;	  KUBEPROXY_KUBECONFIG_CONTENTS=$(echo "apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Config
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: kube-proxy
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    token: ${KUBE_PROXY_TOKEN}
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- name: kubemark
0000000000000000000000000000000000000000;;	  cluster:
0000000000000000000000000000000000000000;;	    insecure-skip-tls-verify: true
0000000000000000000000000000000000000000;;	    server: https://${MASTER_IP}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- context:
0000000000000000000000000000000000000000;;	    cluster: kubemark
0000000000000000000000000000000000000000;;	    user: kube-proxy
0000000000000000000000000000000000000000;;	  name: kubemark-context
0000000000000000000000000000000000000000;;	current-context: kubemark-context")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create kubeconfig for Heapster.
0000000000000000000000000000000000000000;;	  HEAPSTER_KUBECONFIG_CONTENTS=$(echo "apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Config
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: heapster
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    token: ${HEAPSTER_TOKEN}
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- name: kubemark
0000000000000000000000000000000000000000;;	  cluster:
0000000000000000000000000000000000000000;;	    insecure-skip-tls-verify: true
0000000000000000000000000000000000000000;;	    server: https://${MASTER_IP}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- context:
0000000000000000000000000000000000000000;;	    cluster: kubemark
0000000000000000000000000000000000000000;;	    user: heapster
0000000000000000000000000000000000000000;;	  name: kubemark-context
0000000000000000000000000000000000000000;;	current-context: kubemark-context")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create kubeconfig for NodeProblemDetector.
0000000000000000000000000000000000000000;;	  NPD_KUBECONFIG_CONTENTS=$(echo "apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Config
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: node-problem-detector
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    token: ${NODE_PROBLEM_DETECTOR_TOKEN}
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- name: kubemark
0000000000000000000000000000000000000000;;	  cluster:
0000000000000000000000000000000000000000;;	    insecure-skip-tls-verify: true
0000000000000000000000000000000000000000;;	    server: https://${MASTER_IP}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- context:
0000000000000000000000000000000000000000;;	    cluster: kubemark
0000000000000000000000000000000000000000;;	    user: node-problem-detector
0000000000000000000000000000000000000000;;	  name: kubemark-context
0000000000000000000000000000000000000000;;	current-context: kubemark-context")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create kubemark namespace.
0000000000000000000000000000000000000000;;	  "${KUBECTL}" create -f "${RESOURCE_DIRECTORY}/kubemark-ns.json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create configmap for configuring hollow- kubelet, proxy and npd.
0000000000000000000000000000000000000000;;	  "${KUBECTL}" create configmap "node-configmap" --namespace="kubemark" \
0000000000000000000000000000000000000000;;	    --from-literal=content.type="${TEST_CLUSTER_API_CONTENT_TYPE}" \
0000000000000000000000000000000000000000;;	    --from-file=kernel.monitor="${RESOURCE_DIRECTORY}/kernel-monitor.json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create secret for passing kubeconfigs to kubelet, kubeproxy and npd.
0000000000000000000000000000000000000000;;	  "${KUBECTL}" create secret generic "kubeconfig" --type=Opaque --namespace="kubemark" \
0000000000000000000000000000000000000000;;	    --from-literal=kubelet.kubeconfig="${KUBELET_KUBECONFIG_CONTENTS}" \
0000000000000000000000000000000000000000;;	    --from-literal=kubeproxy.kubeconfig="${KUBEPROXY_KUBECONFIG_CONTENTS}" \
0000000000000000000000000000000000000000;;	    --from-literal=heapster.kubeconfig="${HEAPSTER_KUBECONFIG_CONTENTS}" \
0000000000000000000000000000000000000000;;	    --from-literal=npd.kubeconfig="${NPD_KUBECONFIG_CONTENTS}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create addon pods.
0000000000000000000000000000000000000000;;	  mkdir -p "${RESOURCE_DIRECTORY}/addons"
0000000000000000000000000000000000000000;;	  sed "s/{{MASTER_IP}}/${MASTER_IP}/g" "${RESOURCE_DIRECTORY}/heapster_template.json" > "${RESOURCE_DIRECTORY}/addons/heapster.json"
0000000000000000000000000000000000000000;;	  metrics_mem_per_node=4
0000000000000000000000000000000000000000;;	  metrics_mem=$((200 + ${metrics_mem_per_node}*${NUM_NODES:-10}))
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{METRICS_MEM}}/${metrics_mem}/g" "${RESOURCE_DIRECTORY}/addons/heapster.json"
0000000000000000000000000000000000000000;;	  metrics_cpu_per_node_numerator=${NUM_NODES:-10}
0000000000000000000000000000000000000000;;	  metrics_cpu_per_node_denominator=2
0000000000000000000000000000000000000000;;	  metrics_cpu=$((80 + metrics_cpu_per_node_numerator / metrics_cpu_per_node_denominator))
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{METRICS_CPU}}/${metrics_cpu}/g" "${RESOURCE_DIRECTORY}/addons/heapster.json"
0000000000000000000000000000000000000000;;	  eventer_mem_per_node=500
0000000000000000000000000000000000000000;;	  eventer_mem=$((200 * 1024 + ${eventer_mem_per_node}*${NUM_NODES:-10}))
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{EVENTER_MEM}}/${eventer_mem}/g" "${RESOURCE_DIRECTORY}/addons/heapster.json"
0000000000000000000000000000000000000000;;	  "${KUBECTL}" create -f "${RESOURCE_DIRECTORY}/addons" --namespace="kubemark"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create the replication controller for hollow-nodes.
0000000000000000000000000000000000000000;;	  sed "s/{{numreplicas}}/${NUM_NODES:-10}/g" "${RESOURCE_DIRECTORY}/hollow-node_template.yaml" > "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  proxy_cpu=20
0000000000000000000000000000000000000000;;	  if [ "${NUM_NODES:-10}" -gt 1000 ]; then
0000000000000000000000000000000000000000;;	    proxy_cpu=50
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  proxy_mem_per_node=100
0000000000000000000000000000000000000000;;	  proxy_mem=$((100 * 1024 + ${proxy_mem_per_node}*${NUM_NODES:-10}))
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{HOLLOW_PROXY_CPU}}/${proxy_cpu}/g" "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{HOLLOW_PROXY_MEM}}/${proxy_mem}/g" "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{registry}}/${CONTAINER_REGISTRY}/g" "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{project}}/${PROJECT}/g" "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{master_ip}}/${MASTER_IP}/g" "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{kubelet_verbosity_level}}/${KUBELET_TEST_LOG_LEVEL}/g" "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{kubeproxy_verbosity_level}}/${KUBEPROXY_TEST_LOG_LEVEL}/g" "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  sed -i'' -e "s/{{use_real_proxier}}/${USE_REAL_PROXIER}/g" "${RESOURCE_DIRECTORY}/hollow-node.yaml"
0000000000000000000000000000000000000000;;	  "${KUBECTL}" create -f "${RESOURCE_DIRECTORY}/hollow-node.yaml" --namespace="kubemark"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Created secrets, configMaps, replication-controllers required for hollow-nodes."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait until all hollow-nodes are running or there is a timeout.
0000000000000000000000000000000000000000;;	function wait-for-hollow-nodes-to-run-or-timeout {
0000000000000000000000000000000000000000;;	  echo -n "Waiting for all hollow-nodes to become Running"
0000000000000000000000000000000000000000;;	  start=$(date +%s)
0000000000000000000000000000000000000000;;	  nodes=$("${KUBECTL}" --kubeconfig="${LOCAL_KUBECONFIG}" get node 2> /dev/null) || true
0000000000000000000000000000000000000000;;	  ready=$(($(echo "${nodes}" | grep -v "NotReady" | wc -l) - 1))
0000000000000000000000000000000000000000;;	  
0000000000000000000000000000000000000000;;	  until [[ "${ready}" -ge "${NUM_NODES}" ]]; do
0000000000000000000000000000000000000000;;	    echo -n "."
0000000000000000000000000000000000000000;;	    sleep 1
0000000000000000000000000000000000000000;;	    now=$(date +%s)
0000000000000000000000000000000000000000;;	    # Fail it if it already took more than 30 minutes.
0000000000000000000000000000000000000000;;	    if [ $((now - start)) -gt 1800 ]; then
0000000000000000000000000000000000000000;;	      echo ""
0000000000000000000000000000000000000000;;	      echo -e "${color_red} Timeout waiting for all hollow-nodes to become Running. ${color_norm}"
0000000000000000000000000000000000000000;;	      # Try listing nodes again - if it fails it means that API server is not responding
0000000000000000000000000000000000000000;;	      if "${KUBECTL}" --kubeconfig="${LOCAL_KUBECONFIG}" get node &> /dev/null; then
0000000000000000000000000000000000000000;;	        echo "Found only ${ready} ready hollow-nodes while waiting for ${NUM_NODES}."
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	        echo "Got error while trying to list hollow-nodes. Probably API server is down."
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      pods=$("${KUBECTL}" get pods --namespace=kubemark) || true
0000000000000000000000000000000000000000;;	      running=$(($(echo "${pods}" | grep "Running" | wc -l)))
0000000000000000000000000000000000000000;;	      echo "${running} hollow-nodes are reported as 'Running'"
0000000000000000000000000000000000000000;;	      not_running=$(($(echo "${pods}" | grep -v "Running" | wc -l) - 1))
0000000000000000000000000000000000000000;;	      echo "${not_running} hollow-nodes are reported as NOT 'Running'"
0000000000000000000000000000000000000000;;	      echo $(echo "${pods}" | grep -v "Running")
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    nodes=$("${KUBECTL}" --kubeconfig="${LOCAL_KUBECONFIG}" get node 2> /dev/null) || true
0000000000000000000000000000000000000000;;	    ready=$(($(echo "${nodes}" | grep -v "NotReady" | wc -l) - 1))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  echo -e "${color_green} Done!${color_norm}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	############################### Main Function ########################################
0000000000000000000000000000000000000000;;	detect-project &> /dev/null
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Setup for master.
0000000000000000000000000000000000000000;;	echo -e "${color_yellow}STARTING SETUP FOR MASTER${color_norm}"
0000000000000000000000000000000000000000;;	find-release-tars
0000000000000000000000000000000000000000;;	create-master-environment-file
0000000000000000000000000000000000000000;;	create-master-instance-with-resources
0000000000000000000000000000000000000000;;	generate-pki-config
0000000000000000000000000000000000000000;;	wait-for-master-reachability
0000000000000000000000000000000000000000;;	write-pki-config-to-master
0000000000000000000000000000000000000000;;	write-local-kubeconfig
0000000000000000000000000000000000000000;;	copy-resource-files-to-master
0000000000000000000000000000000000000000;;	start-master-components
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Setup for hollow-nodes.
0000000000000000000000000000000000000000;;	echo ""
0000000000000000000000000000000000000000;;	echo -e "${color_yellow}STARTING SETUP FOR HOLLOW-NODES${color_norm}"
0000000000000000000000000000000000000000;;	create-and-upload-hollow-node-image
0000000000000000000000000000000000000000;;	create-kube-hollow-node-resources
0000000000000000000000000000000000000000;;	wait-for-hollow-nodes-to-run-or-timeout
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo ""
0000000000000000000000000000000000000000;;	echo "Master IP: ${MASTER_IP}"
0000000000000000000000000000000000000000;;	echo "Password to kubemark master: ${KUBE_PASSWORD}"
0000000000000000000000000000000000000000;;	echo "Kubeconfig for kubemark master is written in ${LOCAL_KUBECONFIG}"
