0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Script that starts kubelet on kubemark-master as a supervisord process
0000000000000000000000000000000000000000;;	# and then runs the master components as pods using kubelet.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Define key path variables.
0000000000000000000000000000000000000000;;	KUBE_ROOT="/home/kubernetes"
0000000000000000000000000000000000000000;;	KUBE_BINDIR="${KUBE_ROOT}/kubernetes/server/bin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function config-ip-firewall {
0000000000000000000000000000000000000000;;	  echo "Configuring IP firewall rules"
0000000000000000000000000000000000000000;;	  # The GCI image has host firewall which drop most inbound/forwarded packets.
0000000000000000000000000000000000000000;;	  # We need to add rules to accept all TCP/UDP/ICMP packets.
0000000000000000000000000000000000000000;;	  if iptables -L INPUT | grep "Chain INPUT (policy DROP)" > /dev/null; then
0000000000000000000000000000000000000000;;	    echo "Add rules to accept all inbound TCP/UDP/ICMP packets"
0000000000000000000000000000000000000000;;	    iptables -A INPUT -w -p TCP -j ACCEPT
0000000000000000000000000000000000000000;;	    iptables -A INPUT -w -p UDP -j ACCEPT
0000000000000000000000000000000000000000;;	    iptables -A INPUT -w -p ICMP -j ACCEPT
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if iptables -L FORWARD | grep "Chain FORWARD (policy DROP)" > /dev/null; then
0000000000000000000000000000000000000000;;	    echo "Add rules to accept all forwarded TCP/UDP/ICMP packets"
0000000000000000000000000000000000000000;;	    iptables -A FORWARD -w -p TCP -j ACCEPT
0000000000000000000000000000000000000000;;	    iptables -A FORWARD -w -p UDP -j ACCEPT
0000000000000000000000000000000000000000;;	    iptables -A FORWARD -w -p ICMP -j ACCEPT
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-dirs {
0000000000000000000000000000000000000000;;		echo "Creating required directories"
0000000000000000000000000000000000000000;;		mkdir -p /var/lib/kubelet
0000000000000000000000000000000000000000;;		mkdir -p /etc/kubernetes/manifests
0000000000000000000000000000000000000000;;		mkdir -p /etc/kubernetes/addons
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Setup working directory for kubelet.
0000000000000000000000000000000000000000;;	function setup-kubelet-dir {
0000000000000000000000000000000000000000;;		echo "Making /var/lib/kubelet executable for kubelet"
0000000000000000000000000000000000000000;;		mount -B /var/lib/kubelet /var/lib/kubelet/
0000000000000000000000000000000000000000;;		mount -B -o remount,exec,suid,dev /var/lib/kubelet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Remove any default etcd config dirs/files.
0000000000000000000000000000000000000000;;	function delete-default-etcd-configs {
0000000000000000000000000000000000000000;;		if [[ -d /etc/etcd ]]; then
0000000000000000000000000000000000000000;;			rm -rf /etc/etcd
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		if [[ -e /etc/default/etcd ]]; then
0000000000000000000000000000000000000000;;			rm -f /etc/default/etcd
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		if [[ -e /etc/systemd/system/etcd.service ]]; then
0000000000000000000000000000000000000000;;			rm -f /etc/systemd/system/etcd.service
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		if [[ -e /etc/init.d/etcd ]]; then
0000000000000000000000000000000000000000;;			rm -f /etc/init.d/etcd
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Compute etcd related variables.
0000000000000000000000000000000000000000;;	function compute-etcd-variables {
0000000000000000000000000000000000000000;;		ETCD_IMAGE="${ETCD_IMAGE:-}"
0000000000000000000000000000000000000000;;		ETCD_QUOTA_BYTES=""
0000000000000000000000000000000000000000;;		if [ "${ETCD_VERSION:0:2}" == "3." ]; then
0000000000000000000000000000000000000000;;			# TODO: Set larger quota to see if that helps with
0000000000000000000000000000000000000000;;			# 'mvcc: database space exceeded' errors. If so, pipe
0000000000000000000000000000000000000000;;			# though our setup scripts.
0000000000000000000000000000000000000000;;			ETCD_QUOTA_BYTES=" --quota-backend-bytes=4294967296 "
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Formats the given device ($1) if needed and mounts it at given mount point
0000000000000000000000000000000000000000;;	# ($2).
0000000000000000000000000000000000000000;;	function safe-format-and-mount() {
0000000000000000000000000000000000000000;;		device=$1
0000000000000000000000000000000000000000;;		mountpoint=$2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# Format only if the disk is not already formatted.
0000000000000000000000000000000000000000;;		if ! tune2fs -l "${device}" ; then
0000000000000000000000000000000000000000;;			echo "Formatting '${device}'"
0000000000000000000000000000000000000000;;			mkfs.ext4 -F "${device}"
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		echo "Mounting '${device}' at '${mountpoint}'"
0000000000000000000000000000000000000000;;		mount -o discard,defaults "${device}" "${mountpoint}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Finds a PD device with name '$1' attached to the master.
0000000000000000000000000000000000000000;;	function find-attached-pd() {
0000000000000000000000000000000000000000;;		local -r pd_name=$1
0000000000000000000000000000000000000000;;		if [[ ! -e /dev/disk/by-id/${pd_name} ]]; then
0000000000000000000000000000000000000000;;			echo ""
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		device_info=$(ls -l /dev/disk/by-id/${pd_name})
0000000000000000000000000000000000000000;;		relative_path=${device_info##* }
0000000000000000000000000000000000000000;;		echo "/dev/disk/by-id/${relative_path}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Mounts a persistent disk (formatting if needed) to store the persistent data
0000000000000000000000000000000000000000;;	# on the master. safe-format-and-mount only formats an unformatted disk, and
0000000000000000000000000000000000000000;;	# mkdir -p will leave a directory be if it already exists.
0000000000000000000000000000000000000000;;	function mount-pd() {
0000000000000000000000000000000000000000;;		local -r pd_name=$1
0000000000000000000000000000000000000000;;		local -r mount_point=$2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if [[ -z "${find-attached-pd ${pd_name}}" ]]; then
0000000000000000000000000000000000000000;;			echo "Can't find ${pd_name}. Skipping mount."
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		local -r pd_path="/dev/disk/by-id/${pd_name}"
0000000000000000000000000000000000000000;;		echo "Mounting PD '${pd_path}' at '${mount_point}'"
0000000000000000000000000000000000000000;;		# Format and mount the disk, create directories on it for all of the master's
0000000000000000000000000000000000000000;;		# persistent data, and link them to where they're used.
0000000000000000000000000000000000000000;;		mkdir -p "${mount_point}"
0000000000000000000000000000000000000000;;		safe-format-and-mount "${pd_path}" "${mount_point}"
0000000000000000000000000000000000000000;;		echo "Mounted PD '${pd_path}' at '${mount_point}'"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# NOTE: These locations on the PD store persistent data, so to maintain
0000000000000000000000000000000000000000;;		# upgradeability, these locations should not change.  If they do, take care
0000000000000000000000000000000000000000;;		# to maintain a migration path from these locations to whatever new
0000000000000000000000000000000000000000;;		# locations.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create kubeconfig for controller-manager's service account authentication.
0000000000000000000000000000000000000000;;	function create-kubecontrollermanager-kubeconfig {
0000000000000000000000000000000000000000;;		echo "Creating kube-controller-manager kubeconfig file"
0000000000000000000000000000000000000000;;		mkdir -p "${KUBE_ROOT}/k8s_auth_data/kube-controller-manager"
0000000000000000000000000000000000000000;;		cat <<EOF >"${KUBE_ROOT}/k8s_auth_data/kube-controller-manager/kubeconfig"
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Config
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: kube-controller-manager
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    token: ${KUBE_CONTROLLER_MANAGER_TOKEN}
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- name: local
0000000000000000000000000000000000000000;;	  cluster:
0000000000000000000000000000000000000000;;	    insecure-skip-tls-verify: true
0000000000000000000000000000000000000000;;	    server: https://localhost:443
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- context:
0000000000000000000000000000000000000000;;	    cluster: local
0000000000000000000000000000000000000000;;	    user: kube-controller-manager
0000000000000000000000000000000000000000;;	  name: service-account-context
0000000000000000000000000000000000000000;;	current-context: service-account-context
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create-kubescheduler-kubeconfig {
0000000000000000000000000000000000000000;;	  echo "Creating kube-scheduler kubeconfig file"
0000000000000000000000000000000000000000;;	  mkdir -p "${KUBE_ROOT}/k8s_auth_data/kube-scheduler"
0000000000000000000000000000000000000000;;	  cat <<EOF >"${KUBE_ROOT}/k8s_auth_data/kube-scheduler/kubeconfig"
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Config
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: kube-scheduler
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    token: ${KUBE_SCHEDULER_TOKEN}
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- name: local
0000000000000000000000000000000000000000;;	  cluster:
0000000000000000000000000000000000000000;;	    insecure-skip-tls-verify: true
0000000000000000000000000000000000000000;;	    server: https://localhost:443
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- context:
0000000000000000000000000000000000000000;;	    cluster: local
0000000000000000000000000000000000000000;;	    user: kube-scheduler
0000000000000000000000000000000000000000;;	  name: kube-scheduler
0000000000000000000000000000000000000000;;	current-context: kube-scheduler
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function assemble-docker-flags {
0000000000000000000000000000000000000000;;		echo "Assemble docker command line flags"
0000000000000000000000000000000000000000;;		local docker_opts="-p /var/run/docker.pid --iptables=false --ip-masq=false"
0000000000000000000000000000000000000000;;		docker_opts+=" --log-level=debug"  # Since it's a test cluster
0000000000000000000000000000000000000000;;		# TODO(shyamjvs): Incorporate network plugin options, etc later.
0000000000000000000000000000000000000000;;		echo "DOCKER_OPTS=\"${docker_opts}\"" > /etc/default/docker
0000000000000000000000000000000000000000;;		echo "DOCKER_NOFILE=65536" >> /etc/default/docker  # For setting ulimit -n
0000000000000000000000000000000000000000;;		systemctl restart docker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A helper function for loading a docker image. It keeps trying up to 5 times.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1: Full path of the docker image
0000000000000000000000000000000000000000;;	function try-load-docker-image {
0000000000000000000000000000000000000000;;		local -r img=$1
0000000000000000000000000000000000000000;;		echo "Try to load docker image file ${img}"
0000000000000000000000000000000000000000;;		# Temporarily turn off errexit, because we don't want to exit on first failure.
0000000000000000000000000000000000000000;;		set +e
0000000000000000000000000000000000000000;;		local -r max_attempts=5
0000000000000000000000000000000000000000;;		local -i attempt_num=1
0000000000000000000000000000000000000000;;		until timeout 30 docker load -i "${img}"; do
0000000000000000000000000000000000000000;;			if [[ "${attempt_num}" == "${max_attempts}" ]]; then
0000000000000000000000000000000000000000;;				echo "Fail to load docker image file ${img} after ${max_attempts} retries. Exit!!"
0000000000000000000000000000000000000000;;				exit 1
0000000000000000000000000000000000000000;;			else
0000000000000000000000000000000000000000;;				attempt_num=$((attempt_num+1))
0000000000000000000000000000000000000000;;				sleep 5
0000000000000000000000000000000000000000;;			fi
0000000000000000000000000000000000000000;;		done
0000000000000000000000000000000000000000;;		# Re-enable errexit.
0000000000000000000000000000000000000000;;		set -e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Loads kube-system docker images. It is better to do it before starting kubelet,
0000000000000000000000000000000000000000;;	# as kubelet will restart docker daemon, which may interfere with loading images.
0000000000000000000000000000000000000000;;	function load-docker-images {
0000000000000000000000000000000000000000;;		echo "Start loading kube-system docker images"
0000000000000000000000000000000000000000;;		local -r img_dir="${KUBE_BINDIR}"
0000000000000000000000000000000000000000;;		try-load-docker-image "${img_dir}/kube-apiserver.tar"
0000000000000000000000000000000000000000;;		try-load-docker-image "${img_dir}/kube-controller-manager.tar"
0000000000000000000000000000000000000000;;		try-load-docker-image "${img_dir}/kube-scheduler.tar"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Computes command line arguments to be passed to kubelet.
0000000000000000000000000000000000000000;;	function compute-kubelet-params {
0000000000000000000000000000000000000000;;		local params="${KUBELET_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;		params+=" --allow-privileged=true"
0000000000000000000000000000000000000000;;		params+=" --cgroup-root=/"
0000000000000000000000000000000000000000;;		params+=" --cloud-provider=gce"
0000000000000000000000000000000000000000;;		params+=" --pod-manifest-path=/etc/kubernetes/manifests"
0000000000000000000000000000000000000000;;		if [[ -n "${KUBELET_PORT:-}" ]]; then
0000000000000000000000000000000000000000;;			params+=" --port=${KUBELET_PORT}"
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		params+=" --enable-debugging-handlers=false"
0000000000000000000000000000000000000000;;		params+=" --hairpin-mode=none"
0000000000000000000000000000000000000000;;		echo "${params}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Creates the systemd config file for kubelet.service.
0000000000000000000000000000000000000000;;	function create-kubelet-conf() {
0000000000000000000000000000000000000000;;		local -r kubelet_bin="$1"
0000000000000000000000000000000000000000;;		local -r kubelet_env_file="/etc/default/kubelet"
0000000000000000000000000000000000000000;;		local -r flags=$(compute-kubelet-params)
0000000000000000000000000000000000000000;;		echo "KUBELET_OPTS=\"${flags}\"" > "${kubelet_env_file}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# Write the systemd service file for kubelet.
0000000000000000000000000000000000000000;;		cat <<EOF >/etc/systemd/system/kubelet.service
0000000000000000000000000000000000000000;;	[Unit]
0000000000000000000000000000000000000000;;	Description=Kubermark kubelet
0000000000000000000000000000000000000000;;	Requires=network-online.target
0000000000000000000000000000000000000000;;	After=network-online.target
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Service]
0000000000000000000000000000000000000000;;	Restart=always
0000000000000000000000000000000000000000;;	RestartSec=10
0000000000000000000000000000000000000000;;	EnvironmentFile=${kubelet_env_file}
0000000000000000000000000000000000000000;;	ExecStart=${kubelet_bin} \$KUBELET_OPTS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Install]
0000000000000000000000000000000000000000;;	WantedBy=multi-user.target
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This function assembles the kubelet systemd service file and starts it using
0000000000000000000000000000000000000000;;	# systemctl, on the kubemark master.
0000000000000000000000000000000000000000;;	function start-kubelet {
0000000000000000000000000000000000000000;;		# Create systemd config.
0000000000000000000000000000000000000000;;		local -r kubelet_bin="/usr/bin/kubelet"
0000000000000000000000000000000000000000;;		create-kubelet-conf "${kubelet_bin}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# Flush iptables nat table
0000000000000000000000000000000000000000;;	  	iptables -t nat -F || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# Start the kubelet service.
0000000000000000000000000000000000000000;;		systemctl start kubelet.service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create the log file and set its properties.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1 is the file to create.
0000000000000000000000000000000000000000;;	function prepare-log-file {
0000000000000000000000000000000000000000;;		touch $1
0000000000000000000000000000000000000000;;		chmod 644 $1
0000000000000000000000000000000000000000;;		chown root:root $1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A helper function for copying addon manifests and set dir/files
0000000000000000000000000000000000000000;;	# permissions.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1: addon category under /etc/kubernetes
0000000000000000000000000000000000000000;;	# $2: manifest source dir
0000000000000000000000000000000000000000;;	function setup-addon-manifests {
0000000000000000000000000000000000000000;;	  local -r src_dir="${KUBE_ROOT}/$2"
0000000000000000000000000000000000000000;;	  local -r dst_dir="/etc/kubernetes/$1/$2"
0000000000000000000000000000000000000000;;	  if [[ ! -d "${dst_dir}" ]]; then
0000000000000000000000000000000000000000;;	    mkdir -p "${dst_dir}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  local files=$(find "${src_dir}" -maxdepth 1 -name "*.yaml")
0000000000000000000000000000000000000000;;	  if [[ -n "${files}" ]]; then
0000000000000000000000000000000000000000;;	    cp "${src_dir}/"*.yaml "${dst_dir}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  chown -R root:root "${dst_dir}"
0000000000000000000000000000000000000000;;	  chmod 755 "${dst_dir}"
0000000000000000000000000000000000000000;;	  chmod 644 "${dst_dir}"/*
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Computes command line arguments to be passed to etcd.
0000000000000000000000000000000000000000;;	function compute-etcd-params {
0000000000000000000000000000000000000000;;		local params="${ETCD_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;		params+=" --listen-peer-urls=http://127.0.0.1:2380"
0000000000000000000000000000000000000000;;		params+=" --advertise-client-urls=http://127.0.0.1:2379"
0000000000000000000000000000000000000000;;		params+=" --listen-client-urls=http://0.0.0.0:2379"
0000000000000000000000000000000000000000;;		params+=" --data-dir=/var/etcd/data"
0000000000000000000000000000000000000000;;		params+=" ${ETCD_QUOTA_BYTES}"
0000000000000000000000000000000000000000;;		echo "${params}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Computes command line arguments to be passed to etcd-events.
0000000000000000000000000000000000000000;;	function compute-etcd-events-params {
0000000000000000000000000000000000000000;;		local params="${ETCD_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;		params+=" --listen-peer-urls=http://127.0.0.1:2381"
0000000000000000000000000000000000000000;;		params+=" --advertise-client-urls=http://127.0.0.1:4002"
0000000000000000000000000000000000000000;;		params+=" --listen-client-urls=http://0.0.0.0:4002"
0000000000000000000000000000000000000000;;		params+=" --data-dir=/var/etcd/data-events"
0000000000000000000000000000000000000000;;		params+=" ${ETCD_QUOTA_BYTES}"
0000000000000000000000000000000000000000;;		echo "${params}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Computes command line arguments to be passed to apiserver.
0000000000000000000000000000000000000000;;	function compute-kube-apiserver-params {
0000000000000000000000000000000000000000;;		local params="${APISERVER_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;		params+=" --insecure-bind-address=0.0.0.0"
0000000000000000000000000000000000000000;;		if [[ -z "${ETCD_SERVERS:-}" ]]; then
0000000000000000000000000000000000000000;;			params+=" --etcd-servers=http://127.0.0.1:2379"
0000000000000000000000000000000000000000;;			params+=" --etcd-servers-overrides=/events#${EVENT_STORE_URL}"
0000000000000000000000000000000000000000;;		else
0000000000000000000000000000000000000000;;			params+=" --etcd-servers=${ETCD_SERVERS}"
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		params+=" --tls-cert-file=/etc/srv/kubernetes/server.cert"
0000000000000000000000000000000000000000;;		params+=" --tls-private-key-file=/etc/srv/kubernetes/server.key"
0000000000000000000000000000000000000000;;		params+=" --client-ca-file=/etc/srv/kubernetes/ca.crt"
0000000000000000000000000000000000000000;;		params+=" --token-auth-file=/etc/srv/kubernetes/known_tokens.csv"
0000000000000000000000000000000000000000;;		params+=" --secure-port=443"
0000000000000000000000000000000000000000;;		params+=" --basic-auth-file=/etc/srv/kubernetes/basic_auth.csv"
0000000000000000000000000000000000000000;;		params+=" --target-ram-mb=$((${NUM_NODES} * 60))"
0000000000000000000000000000000000000000;;		params+=" --storage-backend=${STORAGE_BACKEND}"
0000000000000000000000000000000000000000;;		params+=" --service-cluster-ip-range=${SERVICE_CLUSTER_IP_RANGE}"
0000000000000000000000000000000000000000;;		params+=" --admission-control=${CUSTOM_ADMISSION_PLUGINS}"
0000000000000000000000000000000000000000;;		params+=" --authorization-mode=Node,RBAC"
0000000000000000000000000000000000000000;;		echo "${params}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Computes command line arguments to be passed to controller-manager.
0000000000000000000000000000000000000000;;	function compute-kube-controller-manager-params {
0000000000000000000000000000000000000000;;		local params="${CONTROLLER_MANAGER_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;		params+=" --use-service-account-credentials"
0000000000000000000000000000000000000000;;		params+=" --kubeconfig=/etc/srv/kubernetes/kube-controller-manager/kubeconfig"
0000000000000000000000000000000000000000;;		params+=" --service-account-private-key-file=/etc/srv/kubernetes/server.key"
0000000000000000000000000000000000000000;;		params+=" --root-ca-file=/etc/srv/kubernetes/ca.crt"
0000000000000000000000000000000000000000;;		params+=" --allocate-node-cidrs=${ALLOCATE_NODE_CIDRS}"
0000000000000000000000000000000000000000;;		params+=" --cluster-cidr=${CLUSTER_IP_RANGE}"
0000000000000000000000000000000000000000;;		params+=" --service-cluster-ip-range=${SERVICE_CLUSTER_IP_RANGE}"
0000000000000000000000000000000000000000;;		params+=" --terminated-pod-gc-threshold=${TERMINATED_POD_GC_THRESHOLD}"
0000000000000000000000000000000000000000;;		echo "${params}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Computes command line arguments to be passed to scheduler.
0000000000000000000000000000000000000000;;	function compute-kube-scheduler-params {
0000000000000000000000000000000000000000;;		local params="${SCHEDULER_TEST_ARGS:-}"
0000000000000000000000000000000000000000;;		params+=" --kubeconfig=/etc/srv/kubernetes/kube-scheduler/kubeconfig"
0000000000000000000000000000000000000000;;		echo "${params}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Computes command line arguments to be passed to addon-manager.
0000000000000000000000000000000000000000;;	function compute-kube-addon-manager-params {
0000000000000000000000000000000000000000;;		echo ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Start a kubernetes master component '$1' which can be any of the following:
0000000000000000000000000000000000000000;;	# 1. etcd
0000000000000000000000000000000000000000;;	# 2. etcd-events
0000000000000000000000000000000000000000;;	# 3. kube-apiserver
0000000000000000000000000000000000000000;;	# 4. kube-controller-manager
0000000000000000000000000000000000000000;;	# 5. kube-scheduler
0000000000000000000000000000000000000000;;	# 6. kube-addon-manager
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# It prepares the log file, loads the docker tag, calculates variables, sets them
0000000000000000000000000000000000000000;;	# in the manifest file, and then copies the manifest file to /etc/kubernetes/manifests.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Assumed vars:
0000000000000000000000000000000000000000;;	#   DOCKER_REGISTRY
0000000000000000000000000000000000000000;;	function start-kubemaster-component() {
0000000000000000000000000000000000000000;;		echo "Start master component $1"
0000000000000000000000000000000000000000;;		local -r component=$1
0000000000000000000000000000000000000000;;		prepare-log-file /var/log/"${component}".log
0000000000000000000000000000000000000000;;		local -r src_file="${KUBE_ROOT}/${component}.yaml"
0000000000000000000000000000000000000000;;		local -r params=$(compute-${component}-params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# Evaluate variables.
0000000000000000000000000000000000000000;;		sed -i -e "s@{{params}}@${params}@g" "${src_file}"
0000000000000000000000000000000000000000;;		sed -i -e "s@{{kube_docker_registry}}@${DOCKER_REGISTRY}@g" "${src_file}"
0000000000000000000000000000000000000000;;		sed -i -e "s@{{instance_prefix}}@${INSTANCE_PREFIX}@g" "${src_file}"
0000000000000000000000000000000000000000;;		if [ "${component:0:4}" == "etcd" ]; then
0000000000000000000000000000000000000000;;			sed -i -e "s@{{etcd_image}}@${ETCD_IMAGE}@g" "${src_file}"
0000000000000000000000000000000000000000;;		elif [ "${component}" == "kube-addon-manager" ]; then
0000000000000000000000000000000000000000;;			setup-addon-manifests "addons" "kubemark-rbac-bindings"
0000000000000000000000000000000000000000;;		else
0000000000000000000000000000000000000000;;			local -r component_docker_tag=$(cat ${KUBE_BINDIR}/${component}.docker_tag)
0000000000000000000000000000000000000000;;			sed -i -e "s@{{${component}_docker_tag}}@${component_docker_tag}@g" "${src_file}"
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		cp "${src_file}" /etc/kubernetes/manifests
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	############################### Main Function ########################################
0000000000000000000000000000000000000000;;	echo "Start to configure master instance for kubemark"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Extract files from the server tar and setup master env variables.
0000000000000000000000000000000000000000;;	cd "${KUBE_ROOT}"
0000000000000000000000000000000000000000;;	if [[ ! -d "${KUBE_ROOT}/kubernetes" ]]; then
0000000000000000000000000000000000000000;;		tar xzf kubernetes-server-linux-amd64.tar.gz
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/kubemark-master-env.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Setup IP firewall rules, required directory structure and etcd config.
0000000000000000000000000000000000000000;;	config-ip-firewall
0000000000000000000000000000000000000000;;	create-dirs
0000000000000000000000000000000000000000;;	setup-kubelet-dir
0000000000000000000000000000000000000000;;	delete-default-etcd-configs
0000000000000000000000000000000000000000;;	compute-etcd-variables
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Setup authentication tokens and kubeconfigs for kube-controller-manager and kube-scheduler,
0000000000000000000000000000000000000000;;	# only if their kubeconfigs don't already exist as this script could be running on reboot.
0000000000000000000000000000000000000000;;	if [[ ! -f "${KUBE_ROOT}/k8s_auth_data/kube-controller-manager/kubeconfig" ]]; then
0000000000000000000000000000000000000000;;		KUBE_CONTROLLER_MANAGER_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;		echo "${KUBE_CONTROLLER_MANAGER_TOKEN},system:kube-controller-manager,uid:system:kube-controller-manager" >> "${KUBE_ROOT}/k8s_auth_data/known_tokens.csv"
0000000000000000000000000000000000000000;;		create-kubecontrollermanager-kubeconfig
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	if [[ ! -f "${KUBE_ROOT}/k8s_auth_data/kube-scheduler/kubeconfig" ]]; then
0000000000000000000000000000000000000000;;		KUBE_SCHEDULER_TOKEN=$(dd if=/dev/urandom bs=128 count=1 2>/dev/null | base64 | tr -d "=+/" | dd bs=32 count=1 2>/dev/null)
0000000000000000000000000000000000000000;;		echo "${KUBE_SCHEDULER_TOKEN},system:kube-scheduler,uid:system:kube-scheduler" >> "${KUBE_ROOT}/k8s_auth_data/known_tokens.csv"
0000000000000000000000000000000000000000;;		create-kubescheduler-kubeconfig
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Mount master PD for etcd and create symbolic links to it.
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;		main_etcd_mount_point="/mnt/disks/master-pd"
0000000000000000000000000000000000000000;;		mount-pd "google-master-pd" "${main_etcd_mount_point}"
0000000000000000000000000000000000000000;;		# Contains all the data stored in etcd.
0000000000000000000000000000000000000000;;		mkdir -m 700 -p "${main_etcd_mount_point}/var/etcd"
0000000000000000000000000000000000000000;;		ln -s -f "${main_etcd_mount_point}/var/etcd" /var/etcd
0000000000000000000000000000000000000000;;		mkdir -p /etc/srv
0000000000000000000000000000000000000000;;		# Setup the dynamically generated apiserver auth certs and keys to pd.
0000000000000000000000000000000000000000;;		mkdir -p "${main_etcd_mount_point}/srv/kubernetes"
0000000000000000000000000000000000000000;;		ln -s -f "${main_etcd_mount_point}/srv/kubernetes" /etc/srv/kubernetes
0000000000000000000000000000000000000000;;		# Copy the files to the PD only if they don't exist (so we do it only the first time).
0000000000000000000000000000000000000000;;		if [[ "$(ls -A ${main_etcd_mount_point}/srv/kubernetes/)" == "" ]]; then
0000000000000000000000000000000000000000;;			cp -r "${KUBE_ROOT}"/k8s_auth_data/* "${main_etcd_mount_point}/srv/kubernetes/"
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;		# Directory for kube-apiserver to store SSH key (if necessary).
0000000000000000000000000000000000000000;;		mkdir -p "${main_etcd_mount_point}/srv/sshproxy"
0000000000000000000000000000000000000000;;		ln -s -f "${main_etcd_mount_point}/srv/sshproxy" /etc/srv/sshproxy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Mount master PD for event-etcd (if required) and create symbolic links to it.
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;		EVENT_STORE_IP="${EVENT_STORE_IP:-127.0.0.1}"
0000000000000000000000000000000000000000;;		EVENT_STORE_URL="${EVENT_STORE_URL:-http://${EVENT_STORE_IP}:4002}"
0000000000000000000000000000000000000000;;		EVENT_PD="${EVENT_PD:-false}"
0000000000000000000000000000000000000000;;		if [ "${EVENT_PD:-false}" == "true" ]; then
0000000000000000000000000000000000000000;;			event_etcd_mount_point="/mnt/disks/master-event-pd"
0000000000000000000000000000000000000000;;			mount-pd "google-master-event-pd" "${event_etcd_mount_point}"
0000000000000000000000000000000000000000;;			# Contains all the data stored in event etcd.
0000000000000000000000000000000000000000;;			mkdir -m 700 -p "${event_etcd_mount_point}/var/etcd/events"
0000000000000000000000000000000000000000;;			ln -s -f "${event_etcd_mount_point}/var/etcd/events" /var/etcd/events
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Setup docker flags and load images of the master components.
0000000000000000000000000000000000000000;;	assemble-docker-flags
0000000000000000000000000000000000000000;;	DOCKER_REGISTRY="gcr.io/google_containers"
0000000000000000000000000000000000000000;;	load-docker-images
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Start kubelet as a supervisord process and master components as pods.
0000000000000000000000000000000000000000;;	start-kubelet
0000000000000000000000000000000000000000;;	start-kubemaster-component "etcd"
0000000000000000000000000000000000000000;;	if [ "${EVENT_STORE_IP:-}" == "127.0.0.1" ]; then
0000000000000000000000000000000000000000;;		start-kubemaster-component "etcd-events"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	start-kubemaster-component "kube-apiserver"
0000000000000000000000000000000000000000;;	start-kubemaster-component "kube-controller-manager"
0000000000000000000000000000000000000000;;	start-kubemaster-component "kube-scheduler"
0000000000000000000000000000000000000000;;	start-kubemaster-component "kube-addon-manager"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Wait till apiserver is working fine or timeout.
0000000000000000000000000000000000000000;;	echo -n "Waiting for apiserver to be healthy"
0000000000000000000000000000000000000000;;	start=$(date +%s)
0000000000000000000000000000000000000000;;	until [ "$(curl 127.0.0.1:8080/healthz 2> /dev/null)" == "ok" ]; do
0000000000000000000000000000000000000000;;		echo -n "."
0000000000000000000000000000000000000000;;		sleep 1
0000000000000000000000000000000000000000;;		now=$(date +%s)
0000000000000000000000000000000000000000;;		if [ $((now - start)) -gt 300 ]; then
0000000000000000000000000000000000000000;;			echo "Timeout!"
0000000000000000000000000000000000000000;;			exit 1
0000000000000000000000000000000000000000;;		fi
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "Done for the configuration for kubermark master"
