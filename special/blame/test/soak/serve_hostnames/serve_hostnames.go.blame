0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
83c266748202246c620af618530efd6a0fd22dc8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	This soak tests places a specified number of pods on each node and then
0000000000000000000000000000000000000000;;	repeatedly sends queries to a service running on these pods via
0000000000000000000000000000000000000000;;	a serivce
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		e2e "k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		queriesAverage = flag.Int("queries", 100, "Number of hostname queries to make in each iteration per pod on average")
0000000000000000000000000000000000000000;;		podsPerNode    = flag.Int("pods_per_node", 1, "Number of serve_hostname pods per node")
0000000000000000000000000000000000000000;;		upTo           = flag.Int("up_to", 1, "Number of iterations or -1 for no limit")
0000000000000000000000000000000000000000;;		maxPar         = flag.Int("max_par", 500, "Maximum number of queries in flight")
0000000000000000000000000000000000000000;;		gke            = flag.String("gke_context", "", "Target GKE cluster with context gke_{project}_{zone}_{cluster-name}")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		deleteTimeout          = 2 * time.Minute
0000000000000000000000000000000000000000;;		endpointTimeout        = 5 * time.Minute
0000000000000000000000000000000000000000;;		nodeListTimeout        = 2 * time.Minute
0000000000000000000000000000000000000000;;		podCreateTimeout       = 2 * time.Minute
0000000000000000000000000000000000000000;;		podStartTimeout        = 30 * time.Minute
0000000000000000000000000000000000000000;;		serviceCreateTimeout   = 2 * time.Minute
0000000000000000000000000000000000000000;;		namespaceDeleteTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting serve_hostnames soak test with queries=%d and podsPerNode=%d upTo=%d",
0000000000000000000000000000000000000000;;			*queriesAverage, *podsPerNode, *upTo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var spec string
0000000000000000000000000000000000000000;;		if *gke != "" {
0000000000000000000000000000000000000000;;			spec = filepath.Join(os.Getenv("HOME"), ".config", "gcloud", "kubernetes", "kubeconfig")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			spec = filepath.Join(os.Getenv("HOME"), ".kube", "config")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		settings, err := clientcmd.LoadFromFile(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Error loading configuration: %v", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *gke != "" {
0000000000000000000000000000000000000000;;			settings.CurrentContext = *gke
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config, err := clientcmd.NewDefaultClientConfig(*settings, &clientcmd.ConfigOverrides{}).ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to construct config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := clientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to make client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var nodes *v1.NodeList
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < nodeListTimeout; time.Sleep(2 * time.Second) {
0000000000000000000000000000000000000000;;			nodes, err = client.Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to list nodes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Giving up trying to list nodes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(nodes.Items) == 0 {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to find any nodes.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Found %d nodes on this cluster:", len(nodes.Items))
0000000000000000000000000000000000000000;;		for i, node := range nodes.Items {
0000000000000000000000000000000000000000;;			glog.Infof("%d: %s", i, node.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queries := *queriesAverage * len(nodes.Items) * *podsPerNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the namespace
0000000000000000000000000000000000000000;;		got, err := client.Namespaces().Create(&v1.Namespace{ObjectMeta: metav1.ObjectMeta{GenerateName: "serve-hostnames-"}})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to create namespace: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ns := got.Name
0000000000000000000000000000000000000000;;		defer func(ns string) {
0000000000000000000000000000000000000000;;			if err := client.Core().Namespaces().Delete(ns, nil); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to delete namespace ns: %e", ns, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// wait until the namespace disappears
0000000000000000000000000000000000000000;;				for i := 0; i < int(namespaceDeleteTimeout/time.Second); i++ {
0000000000000000000000000000000000000000;;					if _, err := client.Namespaces().Get(ns, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;						if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					time.Sleep(time.Second)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}(ns)
0000000000000000000000000000000000000000;;		glog.Infof("Created namespace %s", ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a service for these pods.
0000000000000000000000000000000000000000;;		glog.Infof("Creating service %s/serve-hostnames", ns)
0000000000000000000000000000000000000000;;		// Make several attempts to create a service.
0000000000000000000000000000000000000000;;		var svc *v1.Service
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < serviceCreateTimeout; time.Sleep(2 * time.Second) {
0000000000000000000000000000000000000000;;			t := time.Now()
0000000000000000000000000000000000000000;;			svc, err = client.Services(ns).Create(&v1.Service{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: "serve-hostnames",
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"name": "serve-hostname",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;					Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;						Protocol:   "TCP",
0000000000000000000000000000000000000000;;						Port:       9376,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(9376),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;					Selector: map[string]string{
0000000000000000000000000000000000000000;;						"name": "serve-hostname",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Service create %s/server-hostnames took %v", ns, time.Since(t))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Warningf("After %v failed to create service %s/serve-hostnames: %v", time.Since(start), ns, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to create service %s/%s: %v", ns, svc.Name, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Clean up service
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.Infof("Cleaning up service %s/serve-hostnames", ns)
0000000000000000000000000000000000000000;;			// Make several attempts to delete the service.
0000000000000000000000000000000000000000;;			for start := time.Now(); time.Since(start) < deleteTimeout; time.Sleep(1 * time.Second) {
0000000000000000000000000000000000000000;;				if err := client.Services(ns).Delete(svc.Name, nil); err == nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Warningf("After %v unable to delete service %s/%s: %v", time.Since(start), ns, svc.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Put serve-hostname pods on each node.
0000000000000000000000000000000000000000;;		podNames := []string{}
0000000000000000000000000000000000000000;;		for i, node := range nodes.Items {
0000000000000000000000000000000000000000;;			for j := 0; j < *podsPerNode; j++ {
0000000000000000000000000000000000000000;;				podName := fmt.Sprintf("serve-hostname-%d-%d", i, j)
0000000000000000000000000000000000000000;;				podNames = append(podNames, podName)
0000000000000000000000000000000000000000;;				// Make several attempts
0000000000000000000000000000000000000000;;				for start := time.Now(); time.Since(start) < podCreateTimeout; time.Sleep(2 * time.Second) {
0000000000000000000000000000000000000000;;					glog.Infof("Creating pod %s/%s on node %s", ns, podName, node.Name)
0000000000000000000000000000000000000000;;					t := time.Now()
0000000000000000000000000000000000000000;;					_, err = client.Pods(ns).Create(&v1.Pod{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name: podName,
0000000000000000000000000000000000000000;;							Labels: map[string]string{
0000000000000000000000000000000000000000;;								"name": "serve-hostname",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							Containers: []v1.Container{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name:  "serve-hostname",
0000000000000000000000000000000000000000;;									Image: e2e.ServeHostnameImage,
0000000000000000000000000000000000000000;;									Ports: []v1.ContainerPort{{ContainerPort: 9376}},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							NodeName: node.Name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Pod create %s/%s request took %v", ns, podName, time.Since(t))
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.Warningf("After %s failed to create pod %s/%s: %v", time.Since(start), ns, podName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Failed to create pod %s/%s: %v", ns, podName, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Clean up the pods
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.Info("Cleaning up pods")
0000000000000000000000000000000000000000;;			// Make several attempts to delete the pods.
0000000000000000000000000000000000000000;;			for _, podName := range podNames {
0000000000000000000000000000000000000000;;				for start := time.Now(); time.Since(start) < deleteTimeout; time.Sleep(1 * time.Second) {
0000000000000000000000000000000000000000;;					if err = client.Pods(ns).Delete(podName, nil); err == nil {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.Warningf("After %v failed to delete pod %s/%s: %v", time.Since(start), ns, podName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Info("Waiting for the serve-hostname pods to be ready")
0000000000000000000000000000000000000000;;		for _, podName := range podNames {
0000000000000000000000000000000000000000;;			var pod *v1.Pod
0000000000000000000000000000000000000000;;			for start := time.Now(); time.Since(start) < podStartTimeout; time.Sleep(5 * time.Second) {
0000000000000000000000000000000000000000;;				pod, err = client.Pods(ns).Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Get pod %s/%s failed, ignoring for %v: %v", ns, podName, err, podStartTimeout)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.Status.Phase == v1.PodRunning {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod.Status.Phase != v1.PodRunning {
0000000000000000000000000000000000000000;;				glog.Warningf("Gave up waiting on pod %s/%s to be running (saw %v)", ns, podName, pod.Status.Phase)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("%s/%s is running", ns, podName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rclient, err := restclient.RESTClientFor(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to build restclient: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxyRequest, errProxy := e2e.GetServicesProxyRequest(client, rclient.Get())
0000000000000000000000000000000000000000;;		if errProxy != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Get services proxy request failed: %v", errProxy)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the endpoints to propagate.
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < endpointTimeout; time.Sleep(10 * time.Second) {
0000000000000000000000000000000000000000;;			hostname, err := proxyRequest.
0000000000000000000000000000000000000000;;				Namespace(ns).
0000000000000000000000000000000000000000;;				Name("serve-hostnames").
0000000000000000000000000000000000000000;;				DoRaw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Infof("After %v while making a proxy call got error %v", time.Since(start), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var r metav1.Status
0000000000000000000000000000000000000000;;			if err := runtime.DecodeInto(api.Codecs.UniversalDecoder(), hostname, &r); err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.Status == metav1.StatusFailure {
0000000000000000000000000000000000000000;;				glog.Infof("After %v got status %v", time.Since(start), string(hostname))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Repeatedly make requests.
0000000000000000000000000000000000000000;;		for iteration := 0; iteration != *upTo; iteration++ {
0000000000000000000000000000000000000000;;			responseChan := make(chan string, queries)
0000000000000000000000000000000000000000;;			// Use a channel of size *maxPar to throttle the number
0000000000000000000000000000000000000000;;			// of in-flight requests to avoid overloading the service.
0000000000000000000000000000000000000000;;			inFlight := make(chan struct{}, *maxPar)
0000000000000000000000000000000000000000;;			start := time.Now()
0000000000000000000000000000000000000000;;			for q := 0; q < queries; q++ {
0000000000000000000000000000000000000000;;				go func(i int, query int) {
0000000000000000000000000000000000000000;;					inFlight <- struct{}{}
0000000000000000000000000000000000000000;;					t := time.Now()
0000000000000000000000000000000000000000;;					hostname, err := proxyRequest.
0000000000000000000000000000000000000000;;						Namespace(ns).
0000000000000000000000000000000000000000;;						Name("serve-hostnames").
0000000000000000000000000000000000000000;;						DoRaw()
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Proxy call in namespace %s took %v", ns, time.Since(t))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Warningf("Call failed during iteration %d query %d : %v", i, query, err)
0000000000000000000000000000000000000000;;						// If the query failed return a string which starts with a character
0000000000000000000000000000000000000000;;						// that can't be part of a hostname.
0000000000000000000000000000000000000000;;						responseChan <- fmt.Sprintf("!failed in iteration %d to issue query %d: %v", i, query, err)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						responseChan <- string(hostname)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					<-inFlight
0000000000000000000000000000000000000000;;				}(iteration, q)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			responses := make(map[string]int, *podsPerNode*len(nodes.Items))
0000000000000000000000000000000000000000;;			missing := 0
0000000000000000000000000000000000000000;;			for q := 0; q < queries; q++ {
0000000000000000000000000000000000000000;;				r := <-responseChan
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Got response from %s", r)
0000000000000000000000000000000000000000;;				responses[r]++
0000000000000000000000000000000000000000;;				// If the returned hostname starts with '!' then it indicates
0000000000000000000000000000000000000000;;				// an error response.
0000000000000000000000000000000000000000;;				if len(r) > 0 && r[0] == '!' {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("Got response %s", r)
0000000000000000000000000000000000000000;;					missing++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if missing > 0 {
0000000000000000000000000000000000000000;;				glog.Warningf("Missing %d responses out of %d", missing, queries)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Report any nodes that did not respond.
0000000000000000000000000000000000000000;;			for n, node := range nodes.Items {
0000000000000000000000000000000000000000;;				for i := 0; i < *podsPerNode; i++ {
0000000000000000000000000000000000000000;;					name := fmt.Sprintf("serve-hostname-%d-%d", n, i)
0000000000000000000000000000000000000000;;					if _, ok := responses[name]; !ok {
0000000000000000000000000000000000000000;;						glog.Warningf("No response from pod %s on node %s at iteration %d", name, node.Name, iteration)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Iteration %d took %v for %d queries (%.2f QPS) with %d missing",
0000000000000000000000000000000000000000;;				iteration, time.Since(start), queries-missing, float64(queries-missing)/time.Since(start).Seconds(), missing)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
