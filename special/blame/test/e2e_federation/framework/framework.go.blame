0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d69e9f3b52ad8a48c8fbcf3c11e270a0b7bc8e9a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		yaml "gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Framework extends e2e Framework and adds federation specific fields
0000000000000000000000000000000000000000;;	type Framework struct {
0000000000000000000000000000000000000000;;		*framework.Framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To make sure that this framework cleans up after itself, no matter what,
0000000000000000000000000000000000000000;;		// we install a Cleanup action before each test and clear it after.  If we
0000000000000000000000000000000000000000;;		// should abort, the AfterSuite hook should run all Cleanup actions.
0000000000000000000000000000000000000000;;		cleanupHandle framework.CleanupActionHandle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FederationConfig *restclient.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FederationClientset *federation_clientset.Clientset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FederationNamespace *v1.Namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefaultFederatedFramework(baseName string) *Framework {
0000000000000000000000000000000000000000;;		f := &Framework{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register the federation cleanup before initializing the default
0000000000000000000000000000000000000000;;		// e2e framework to ensure it gets called before the default
0000000000000000000000000000000000000000;;		// framework's cleanup.
0000000000000000000000000000000000000000;;		AfterEach(f.FederationAfterEach)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Framework = framework.NewDefaultFramework(baseName)
0000000000000000000000000000000000000000;;		f.Framework.SkipNamespaceCreation = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register the federation setup after initializing the default
0000000000000000000000000000000000000000;;		// e2e framework to ensure it gets called after the default
0000000000000000000000000000000000000000;;		// framework's setup.
0000000000000000000000000000000000000000;;		BeforeEach(f.FederationBeforeEach)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederationBeforeEach checks for federation apiserver is ready and makes a namespace.
0000000000000000000000000000000000000000;;	func (f *Framework) FederationBeforeEach() {
0000000000000000000000000000000000000000;;		// The fact that we need this feels like a bug in ginkgo.
0000000000000000000000000000000000000000;;		// https://github.com/onsi/ginkgo/issues/222
0000000000000000000000000000000000000000;;		f.cleanupHandle = framework.AddCleanupAction(f.FederationAfterEach)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.FederationConfig == nil {
0000000000000000000000000000000000000000;;			By("Reading the federation configuration")
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			f.FederationConfig, err = LoadFederatedConfig(&clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.FederationClientset == nil {
0000000000000000000000000000000000000000;;			By("Creating a release 1.5 federation Clientset")
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			f.FederationClientset, err = LoadFederationClientset(f.FederationConfig)
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By("Waiting for federation-apiserver to be ready")
0000000000000000000000000000000000000000;;		err := WaitForFederationApiserverReady(f.FederationClientset)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		By("federation-apiserver is ready")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Creating a federation namespace")
0000000000000000000000000000000000000000;;		ns, err := f.createFederationNamespace(f.BaseName)
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		f.FederationNamespace = ns
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Created federation namespace %s", ns.Name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) deleteFederationNs() {
0000000000000000000000000000000000000000;;		ns := f.FederationNamespace
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Destroying federation namespace %q for this suite.", ns.Name))
0000000000000000000000000000000000000000;;		timeout := 5 * time.Minute
0000000000000000000000000000000000000000;;		if f.NamespaceDeletionTimeout != 0 {
0000000000000000000000000000000000000000;;			timeout = f.NamespaceDeletionTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset := f.FederationClientset
0000000000000000000000000000000000000000;;		// First delete the namespace from federation apiserver.
0000000000000000000000000000000000000000;;		// Also delete the corresponding namespaces from underlying clusters.
0000000000000000000000000000000000000000;;		orphanDependents := false
0000000000000000000000000000000000000000;;		if err := clientset.Core().Namespaces().Delete(ns.Name, &metav1.DeleteOptions{OrphanDependents: &orphanDependents}); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error while deleting federation namespace %s: %s", ns.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Verify that it got deleted.
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(5*time.Second, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			if _, err := clientset.Core().Namespaces().Get(ns.Name, metav1.GetOptions{}); err != nil {
0000000000000000000000000000000000000000;;				if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("Error while waiting for namespace to be terminated: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				framework.Failf("Couldn't delete ns %q: %s", ns.Name, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Logf("Namespace %v was already deleted", ns.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederationAfterEach deletes the namespace, after reading its events.
0000000000000000000000000000000000000000;;	func (f *Framework) FederationAfterEach() {
0000000000000000000000000000000000000000;;		framework.RemoveCleanupAction(f.cleanupHandle)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeleteNamespace at the very end in defer, to avoid any
0000000000000000000000000000000000000000;;		// expectation failures preventing deleting the namespace.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// Whether to delete namespace is determined by 3 factors: delete-namespace flag, delete-namespace-on-failure flag and the test result
0000000000000000000000000000000000000000;;			// if delete-namespace set to false, namespace will always be preserved.
0000000000000000000000000000000000000000;;			// if delete-namespace is true and delete-namespace-on-failure is false, namespace will be preserved if test failed.
0000000000000000000000000000000000000000;;			if framework.TestContext.DeleteNamespace && (framework.TestContext.DeleteNamespaceOnFailure || !CurrentGinkgoTestDescription().Failed) {
0000000000000000000000000000000000000000;;				// Delete the federation namespace.
0000000000000000000000000000000000000000;;				f.deleteFederationNs()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Paranoia-- prevent reuse!
0000000000000000000000000000000000000000;;			f.FederationNamespace = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if f.FederationClientset == nil {
0000000000000000000000000000000000000000;;				framework.Logf("Warning: framework is marked federated, but has no federation 1.5 clientset")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Print events if the test failed.
0000000000000000000000000000000000000000;;		if CurrentGinkgoTestDescription().Failed && framework.TestContext.DumpLogsOnFailure {
0000000000000000000000000000000000000000;;			// Dump federation events in federation namespace.
0000000000000000000000000000000000000000;;			framework.DumpEventsInNamespace(func(opts metav1.ListOptions, ns string) (*v1.EventList, error) {
0000000000000000000000000000000000000000;;				return f.FederationClientset.Core().Events(ns).List(opts)
0000000000000000000000000000000000000000;;			}, f.FederationNamespace.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) createFederationNamespace(baseName string) (*v1.Namespace, error) {
0000000000000000000000000000000000000000;;		clientset := f.FederationClientset
0000000000000000000000000000000000000000;;		namespaceObj := &v1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: fmt.Sprintf("e2e-tests-%v-", baseName),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Be robust about making the namespace creation call.
0000000000000000000000000000000000000000;;		var got *v1.Namespace
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(framework.Poll, framework.SingleCallTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			got, err = clientset.Core().Namespaces().Create(namespaceObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Unexpected error while creating namespace: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return got, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type E2EContext struct {
0000000000000000000000000000000000000000;;		// Raw context name,
0000000000000000000000000000000000000000;;		RawName string `yaml:"rawName"`
0000000000000000000000000000000000000000;;		// A valid dns subdomain which can be used as the name of kubernetes resources.
0000000000000000000000000000000000000000;;		Name    string                 `yaml:"name"`
0000000000000000000000000000000000000000;;		Cluster *framework.KubeCluster `yaml:"cluster"`
0000000000000000000000000000000000000000;;		User    *framework.KubeUser    `yaml:"user"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) GetUnderlyingFederatedContexts() []E2EContext {
0000000000000000000000000000000000000000;;		kubeconfig := framework.KubeConfig{}
0000000000000000000000000000000000000000;;		configBytes, err := ioutil.ReadFile(framework.TestContext.KubeConfig)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		err = yaml.Unmarshal(configBytes, &kubeconfig)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e2eContexts := []E2EContext{}
0000000000000000000000000000000000000000;;		for _, context := range kubeconfig.Contexts {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(context.Name, "federation") && context.Name != framework.TestContext.FederatedKubeContext {
0000000000000000000000000000000000000000;;				user := kubeconfig.FindUser(context.Context.User)
0000000000000000000000000000000000000000;;				if user == nil {
0000000000000000000000000000000000000000;;					framework.Failf("Could not find user for context %+v", context)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cluster := kubeconfig.FindCluster(context.Context.Cluster)
0000000000000000000000000000000000000000;;				if cluster == nil {
0000000000000000000000000000000000000000;;					framework.Failf("Could not find cluster for context %+v", context)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				dnsSubdomainName, err := GetValidDNSSubdomainName(context.Name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Could not convert context name %s to a valid dns subdomain name, error: %s", context.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e2eContexts = append(e2eContexts, E2EContext{
0000000000000000000000000000000000000000;;					RawName: context.Name,
0000000000000000000000000000000000000000;;					Name:    dnsSubdomainName,
0000000000000000000000000000000000000000;;					Cluster: cluster,
0000000000000000000000000000000000000000;;					User:    user,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e2eContexts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) GetRegisteredClusters() ClusterSlice {
0000000000000000000000000000000000000000;;		if framework.TestContext.FederationConfigFromCluster {
0000000000000000000000000000000000000000;;			return registeredClustersFromSecrets(f)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return registeredClustersFromConfig(f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framework) GetClusterClients() []kubeclientset.Interface {
0000000000000000000000000000000000000000;;		clusters := f.GetRegisteredClusters()
0000000000000000000000000000000000000000;;		var clusterClients []kubeclientset.Interface
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			clusterClients = append(clusterClients, c.Clientset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clusterClients
0000000000000000000000000000000000000000;;	}
