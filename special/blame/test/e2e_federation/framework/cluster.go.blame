0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
44e1d7539c385ea4d5a515b49f5cb3bde1f7e154;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const federatedClustersWaitTimeout = 1 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterSlice is a slice of clusters
0000000000000000000000000000000000000000;;	type ClusterSlice []*Cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cluster keeps track of the name and client of a cluster in the federation
0000000000000000000000000000000000000000;;	type Cluster struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		*kubeclientset.Clientset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// registeredClustersFromConfig configures clientsets for registered clusters from the e2e kubeconfig
0000000000000000000000000000000000000000;;	func registeredClustersFromConfig(f *Framework) ClusterSlice {
0000000000000000000000000000000000000000;;		contexts := f.GetUnderlyingFederatedContexts()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Obtaining a list of all the clusters")
0000000000000000000000000000000000000000;;		clusterList := waitForAllRegisteredClusters(f, len(contexts))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framework.Logf("Checking that %d clusters are Ready", len(contexts))
0000000000000000000000000000000000000000;;		for _, context := range contexts {
0000000000000000000000000000000000000000;;			ClusterIsReadyOrFail(f, context.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("%d clusters are Ready", len(contexts))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusters := ClusterSlice{}
0000000000000000000000000000000000000000;;		for i, c := range clusterList.Items {
0000000000000000000000000000000000000000;;			framework.Logf("Creating a clientset for the cluster %s", c.Name)
0000000000000000000000000000000000000000;;			Expect(framework.TestContext.KubeConfig).ToNot(Equal(""), "KubeConfig must be specified to load clusters' client config")
0000000000000000000000000000000000000000;;			config := restConfigFromContext(c, i)
0000000000000000000000000000000000000000;;			clusters = append(clusters, &Cluster{
0000000000000000000000000000000000000000;;				Name:      c.Name,
0000000000000000000000000000000000000000;;				Clientset: clientsetFromConfig(f, config, c.Spec.ServerAddressByClientCIDRs[0].ServerAddress),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNamespaceInFederatedClusters(clusters, f.FederationNamespace.Name)
0000000000000000000000000000000000000000;;		return clusters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForAllRegisteredClusters waits for all clusters defined in e2e context to be created
0000000000000000000000000000000000000000;;	// return ClusterList until the listed cluster items equals clusterCount
0000000000000000000000000000000000000000;;	func waitForAllRegisteredClusters(f *Framework, clusterCount int) *federationapi.ClusterList {
0000000000000000000000000000000000000000;;		var clusterList *federationapi.ClusterList
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(framework.Poll, federatedClustersWaitTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			clusterList, err = f.FederationClientset.Federation().Clusters().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("%d clusters registered, waiting for %d", len(clusterList.Items), clusterCount)
0000000000000000000000000000000000000000;;			if len(clusterList.Items) == clusterCount {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to list registered clusters: %+v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clusterList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restConfigFromContext(c federationapi.Cluster, i int) *restclient.Config {
0000000000000000000000000000000000000000;;		kubecfg, err := clientcmd.LoadFromFile(framework.TestContext.KubeConfig)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "error loading KubeConfig: %v", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ccfg := clientcmd.NewNonInteractiveClientConfig(*kubecfg, c.Name, &clientcmd.ConfigOverrides{}, clientcmd.NewDefaultClientConfigLoadingRules())
0000000000000000000000000000000000000000;;		cfg, err := ccfg.ClientConfig()
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Error creating client config in cluster #%d (%q)", i, c.Name)
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func clientsetFromConfig(f *Framework, cfg *restclient.Config, host string) *kubeclientset.Clientset {
0000000000000000000000000000000000000000;;		cfg.Host = host
0000000000000000000000000000000000000000;;		cfg.QPS = f.Framework.Options.ClientQPS
0000000000000000000000000000000000000000;;		cfg.Burst = f.Framework.Options.ClientBurst
0000000000000000000000000000000000000000;;		return kubeclientset.NewForConfigOrDie(restclient.AddUserAgent(cfg, "federation-e2e"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForNamespaceInFederatedClusters waits for the federated namespace to be created in federated clusters
0000000000000000000000000000000000000000;;	func waitForNamespaceInFederatedClusters(clusters ClusterSlice, nsName string) {
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			name := c.Name
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Waiting for namespace %q to be created in cluster %q", nsName, name))
0000000000000000000000000000000000000000;;			err := wait.PollImmediate(framework.Poll, FederatedDefaultTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				_, err := c.Clientset.Core().Namespaces().Get(nsName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				} else if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("An error occurred waiting for namespace %q to be created in cluster %q: %v", nsName, name, err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Namespace %q exists in cluster %q", nsName, name))
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Failed to verify federated namespace %q creation in cluster %q", nsName, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterIsReadyOrFail checks whether the named cluster is ready
0000000000000000000000000000000000000000;;	func ClusterIsReadyOrFail(f *Framework, clusterName string) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Checking readiness of cluster %q", clusterName))
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(framework.Poll, FederatedDefaultTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			c, err := f.FederationClientset.Federation().Clusters().Get(clusterName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, condition := range c.Status.Conditions {
0000000000000000000000000000000000000000;;				if condition.Type == federationapi.ClusterReady && condition.Status == v1.ConditionTrue {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, fmt.Sprintf("Unexpected error in verifying if cluster %q is ready: %+v", clusterName, err))
0000000000000000000000000000000000000000;;		framework.Logf("Cluster %s is Ready", clusterName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cache the cluster config to avoid having to retrieve it for each test
0000000000000000000000000000000000000000;;	type clusterConfig struct {
0000000000000000000000000000000000000000;;		name   string
0000000000000000000000000000000000000000;;		host   string
0000000000000000000000000000000000000000;;		config []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cachedClusterConfigs []*clusterConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// registeredClustersFromSecrets configures clientsets for cluster access from secrets in the host cluster
0000000000000000000000000000000000000000;;	func registeredClustersFromSecrets(f *Framework) ClusterSlice {
0000000000000000000000000000000000000000;;		if cachedClusterConfigs == nil {
0000000000000000000000000000000000000000;;			cachedClusterConfigs = clusterConfigFromSecrets(f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusters := ClusterSlice{}
0000000000000000000000000000000000000000;;		for _, clusterConf := range cachedClusterConfigs {
0000000000000000000000000000000000000000;;			restConfig := restConfigForCluster(clusterConf)
0000000000000000000000000000000000000000;;			clientset := clientsetFromConfig(f, restConfig, clusterConf.host)
0000000000000000000000000000000000000000;;			clusters = append(clusters, &Cluster{
0000000000000000000000000000000000000000;;				Name:      clusterConf.name,
0000000000000000000000000000000000000000;;				Clientset: clientset,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForNamespaceInFederatedClusters(clusters, f.FederationNamespace.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clusters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clusterConfigFromSecrets retrieves cluster configuration from
0000000000000000000000000000000000000000;;	// secrets in the host cluster
0000000000000000000000000000000000000000;;	func clusterConfigFromSecrets(f *Framework) []*clusterConfig {
0000000000000000000000000000000000000000;;		By("Obtaining a list of registered clusters")
0000000000000000000000000000000000000000;;		clusterList, err := f.FederationClientset.Federation().Clusters().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, fmt.Sprintf("Error retrieving list of federated clusters: %+v", err))
0000000000000000000000000000000000000000;;		if len(clusterList.Items) == 0 {
0000000000000000000000000000000000000000;;			framework.Failf("No registered clusters found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterConfigs := []*clusterConfig{}
0000000000000000000000000000000000000000;;		for _, c := range clusterList.Items {
0000000000000000000000000000000000000000;;			ClusterIsReadyOrFail(f, c.Name)
0000000000000000000000000000000000000000;;			config := clusterConfigFromSecret(f, c.Name, c.Spec.SecretRef.Name)
0000000000000000000000000000000000000000;;			clusterConfigs = append(clusterConfigs, &clusterConfig{
0000000000000000000000000000000000000000;;				name:   c.Name,
0000000000000000000000000000000000000000;;				host:   c.Spec.ServerAddressByClientCIDRs[0].ServerAddress,
0000000000000000000000000000000000000000;;				config: config,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clusterConfigs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clusterConfigFromSecret retrieves configuration for a accessing a
0000000000000000000000000000000000000000;;	// cluster from a secret in the host cluster
0000000000000000000000000000000000000000;;	func clusterConfigFromSecret(f *Framework, clusterName string, secretName string) []byte {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Loading configuration for cluster %q", clusterName))
0000000000000000000000000000000000000000;;		namespace := framework.FederationSystemNamespace()
0000000000000000000000000000000000000000;;		secret, err := f.Framework.ClientSet.Core().Secrets(namespace).Get(secretName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, fmt.Sprintf("Error loading config secret \"%s/%s\" for cluster %q: %+v", namespace, secretName, clusterName, err))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, ok := secret.Data[util.KubeconfigSecretDataKey]
0000000000000000000000000000000000000000;;		if !ok || len(config) == 0 {
0000000000000000000000000000000000000000;;			framework.Failf("Secret \"%s/%s\" for cluster %q has no value for key %q", namespace, secretName, clusterName, util.KubeconfigSecretDataKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// restConfigForCluster creates a rest client config for the given cluster config
0000000000000000000000000000000000000000;;	func restConfigForCluster(clusterConf *clusterConfig) *restclient.Config {
0000000000000000000000000000000000000000;;		cfg, err := clientcmd.Load(clusterConf.config)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, fmt.Sprintf("Error loading configuration for cluster %q: %+v", clusterConf.name, err))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restConfig, err := clientcmd.NewDefaultClientConfig(*cfg, &clientcmd.ConfigOverrides{}).ClientConfig()
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, fmt.Sprintf("Error creating client for cluster %q: %+v", clusterConf.name, err))
0000000000000000000000000000000000000000;;		return restConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetZoneFromClusterName(clusterName string) string {
0000000000000000000000000000000000000000;;		// Ref: https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-util.sh#L55
0000000000000000000000000000000000000000;;		prefix := "federation-e2e-" + framework.TestContext.Provider + "-"
0000000000000000000000000000000000000000;;		return strings.TrimPrefix(clusterName, prefix)
0000000000000000000000000000000000000000;;	}
