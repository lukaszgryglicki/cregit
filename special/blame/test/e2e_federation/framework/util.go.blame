0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d69e9f3b52ad8a48c8fbcf3c11e270a0b7bc8e9a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		validationutil "k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const FederatedDefaultTestTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detects whether the federation namespace exists in the underlying cluster
0000000000000000000000000000000000000000;;	func SkipUnlessFederated(c clientset.Interface) {
0000000000000000000000000000000000000000;;		federationNS := framework.FederationSystemNamespace()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := c.Core().Namespaces().Get(federationNS, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				framework.Skipf("Could not find federation namespace %s: skipping federated test", federationNS)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Failf("Unexpected error getting namespace: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForFederationApiserverReady waits for the federation apiserver to be ready.
0000000000000000000000000000000000000000;;	// It tests the readiness by sending a GET request and expecting a non error response.
0000000000000000000000000000000000000000;;	func WaitForFederationApiserverReady(c *federation_clientset.Clientset) error {
0000000000000000000000000000000000000000;;		return wait.PollImmediate(time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := c.Federation().Clusters().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadFederationClientset(config *restclient.Config) (*federation_clientset.Clientset, error) {
0000000000000000000000000000000000000000;;		c, err := federation_clientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating federation clientset: %v", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadFederatedConfig(overrides *clientcmd.ConfigOverrides) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		c, err := framework.RestclientConfig(framework.TestContext.FederatedKubeContext)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating federation client config: %v", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg, err := clientcmd.NewDefaultClientConfig(*c, &clientcmd.ConfigOverrides{}).ClientConfig()
0000000000000000000000000000000000000000;;		if cfg != nil {
0000000000000000000000000000000000000000;;			//TODO(colhom): this is only here because https://github.com/kubernetes/kubernetes/issues/25422
0000000000000000000000000000000000000000;;			cfg.NegotiatedSerializer = api.Codecs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return cfg, fmt.Errorf("error creating federation default client config: %v", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetValidDNSSubdomainName massages the given name to be a valid dns subdomain name.
0000000000000000000000000000000000000000;;	// Most resources (such as secrets, clusters) require the names to be valid dns subdomain.
0000000000000000000000000000000000000000;;	// This is a generic function (not specific to federation). Should be moved to a more generic location if others want to use it.
0000000000000000000000000000000000000000;;	func GetValidDNSSubdomainName(name string) (string, error) {
0000000000000000000000000000000000000000;;		// "_" are not allowed. Replace them by "-".
0000000000000000000000000000000000000000;;		name = regexp.MustCompile("_").ReplaceAllLiteralString(name, "-")
0000000000000000000000000000000000000000;;		maxLength := validationutil.DNS1123SubdomainMaxLength
0000000000000000000000000000000000000000;;		if len(name) > maxLength {
0000000000000000000000000000000000000000;;			name = name[0 : maxLength-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Verify that name now passes the validation.
0000000000000000000000000000000000000000;;		if errors := validation.NameIsDNSSubdomain(name, false); len(errors) != 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("errors in converting name to a valid DNS subdomain %s", errors)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FederationControlPlaneUpgrade(version string) error {
0000000000000000000000000000000000000000;;		version = "v" + version
0000000000000000000000000000000000000000;;		_, _, err := framework.RunCmd(path.Join(framework.TestContext.RepoRoot, "federation/cluster/upgrade.sh"), version)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckFederationVersion(c federation_clientset.Interface, want string) error {
0000000000000000000000000000000000000000;;		framework.Logf("Checking federation version")
0000000000000000000000000000000000000000;;		v, err := c.Discovery().ServerVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("CheckFederationVersion() couldn't get the master version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We do prefix trimming and then matching because:
0000000000000000000000000000000000000000;;		// want looks like:  0.19.3-815-g50e67d4
0000000000000000000000000000000000000000;;		// got  looks like: v0.19.3-815-g50e67d4034e858-dirty
0000000000000000000000000000000000000000;;		got := strings.TrimPrefix(v.GitVersion, "v")
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(got, want) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("federation had apiserver version %s which does not start with %s",
0000000000000000000000000000000000000000;;				got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("Federation is at version %s", want)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MasterUpgrade(context, version string) error {
0000000000000000000000000000000000000000;;		switch framework.TestContext.Provider {
0000000000000000000000000000000000000000;;		case "gce":
0000000000000000000000000000000000000000;;			return masterUpgradeGCE(context, version)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("MasterUpgrade() is not implemented for provider %s", framework.TestContext.Provider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func masterUpgradeGCE(context, rawVersion string) error {
0000000000000000000000000000000000000000;;		version := "v" + rawVersion
0000000000000000000000000000000000000000;;		// TODO: this breaks if we want to upgrade 2 clusters in same zone. use alternate methods in future to get zone of a cluster
0000000000000000000000000000000000000000;;		zone := strings.TrimPrefix(context, "federation-e2e-"+framework.TestContext.Provider+"-")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		env := append(os.Environ(), "KUBE_CONTEXT="+context, "ZONE="+zone)
0000000000000000000000000000000000000000;;		_, _, err := framework.RunCmdEnv(env, path.Join(framework.TestContext.RepoRoot, "cluster/gce/upgrade.sh"), "-M", version)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
