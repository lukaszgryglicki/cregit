0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
77ae44795d94ce26866d7578e372c1a639fd59c5;test/e2e/federation-replicaset.go[test/e2e/federation-replicaset.go][test/e2e_federation/replicaset.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		fedutil "k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		fedframework "k8s.io/kubernetes/test/e2e_federation/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		federatedtypes "k8s.io/kubernetes/federation/pkg/federatedtypes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FederationReplicaSetPrefix = "federation-replicaset-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create/delete replicaset api objects
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Federated ReplicaSet [Feature:Federation]", func() {
0000000000000000000000000000000000000000;;		f := fedframework.NewDefaultFederatedFramework("federation-replicaset")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Describe("ReplicaSet objects [NoCluster]", func() {
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Delete all replicasets.
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				deleteAllReplicaSetsOrFail(f.FederationClientset, nsName)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be created and deleted successfully", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				rs := createReplicaSetOrFail(f.FederationClientset, newReplicaSet(nsName, FederationReplicaSetPrefix, 5, nil))
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creation of replicaset %q in namespace %q succeeded.  Deleting replicaset.", rs.Name, nsName))
0000000000000000000000000000000000000000;;				// Cleanup
0000000000000000000000000000000000000000;;				err := f.FederationClientset.Extensions().ReplicaSets(nsName).Delete(rs.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err, "Error deleting replicaset %q in namespace %q", rs.Name, rs.Namespace)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Deletion of replicaset %q in namespace %q succeeded.", rs.Name, nsName))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// e2e cases for federated replicaset controller
0000000000000000000000000000000000000000;;		Describe("Features", func() {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				clusters fedframework.ClusterSlice
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				clusters = f.GetRegisteredClusters()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// e2e cases for federated replicaset controller
0000000000000000000000000000000000000000;;			Describe("Preferences", func() {
0000000000000000000000000000000000000000;;				var (
0000000000000000000000000000000000000000;;					rs *v1beta1.ReplicaSet
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				AfterEach(func() {
0000000000000000000000000000000000000000;;					// Delete all replicasets.
0000000000000000000000000000000000000000;;					nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;					if rs != nil {
0000000000000000000000000000000000000000;;						orphanDependents := false
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("Deleting replicaset \"%s/%s\"", nsName, rs.Name))
0000000000000000000000000000000000000000;;						deleteReplicaSetOrFail(f.FederationClientset, nsName, rs.Name, &orphanDependents)
0000000000000000000000000000000000000000;;						rs = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should create replicasets with weight preference", func() {
0000000000000000000000000000000000000000;;					pref, replicas, expect := generateFedRSPrefsWithWeight(clusters)
0000000000000000000000000000000000000000;;					rs = createAndUpdateFedRSWithPref(f.FederationClientset, f.FederationNamespace.Name, clusters, pref, replicas, expect)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should create replicasets with min replicas preference", func() {
0000000000000000000000000000000000000000;;					pref, replicas, expect := generateFedRSPrefsWithMin(clusters)
0000000000000000000000000000000000000000;;					rs = createAndUpdateFedRSWithPref(f.FederationClientset, f.FederationNamespace.Name, clusters, pref, replicas, expect)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should create replicasets with max replicas preference", func() {
0000000000000000000000000000000000000000;;					pref, replicas, expect := generateFedRSPrefsWithMax(clusters)
0000000000000000000000000000000000000000;;					rs = createAndUpdateFedRSWithPref(f.FederationClientset, f.FederationNamespace.Name, clusters, pref, replicas, expect)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// test for rebalancing
0000000000000000000000000000000000000000;;				PIt("should create replicasets and rebalance them", func() {
0000000000000000000000000000000000000000;;					nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;					pref1, pref2, replicas, expect1, expect2 := generateFedRSPrefsForRebalancing(clusters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("Testing replicaset rebalancing")
0000000000000000000000000000000000000000;;					framework.Logf("Replicas: %d", replicas)
0000000000000000000000000000000000000000;;					framework.Logf("Preference 1: %#v", pref1)
0000000000000000000000000000000000000000;;					framework.Logf("Preference 2: %#v", pref2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rs = newReplicaSet(nsName, FederationReplicaSetPrefix, replicas, pref1)
0000000000000000000000000000000000000000;;					rs = createReplicaSetOrFail(f.FederationClientset, rs)
0000000000000000000000000000000000000000;;					waitForReplicaSetOrFail(f.FederationClientset, nsName, rs.Name, clusters, expect1)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Successfully created and synced replicaset \"%s/%s\" (%v/%v) to clusters", nsName, rs.Name, rs.Status.Replicas, *rs.Spec.Replicas))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rs = newReplicaSetWithName(nsName, rs.Name, replicas, pref2)
0000000000000000000000000000000000000000;;					updateReplicaSetOrFail(f.FederationClientset, rs)
0000000000000000000000000000000000000000;;					waitForReplicaSetOrFail(f.FederationClientset, nsName, rs.Name, clusters, expect1)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Successfully updated and synced replicaset \"%s/%s\" (%v/%v) to clusters", nsName, rs.Name, rs.Status.Replicas, *rs.Spec.Replicas))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					pref2 = updateFedRSPrefsRebalance(pref2, true)
0000000000000000000000000000000000000000;;					rs = newReplicaSetWithName(nsName, rs.Name, replicas, pref2)
0000000000000000000000000000000000000000;;					updateReplicaSetOrFail(f.FederationClientset, rs)
0000000000000000000000000000000000000000;;					waitForReplicaSetOrFail(f.FederationClientset, nsName, rs.Name, clusters, expect2)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Successfully updated and synced replicaset \"%s/%s\" (%v/%v) to clusters", nsName, rs.Name, rs.Status.Replicas, *rs.Spec.Replicas))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAndWaitForReplicasetOrFail(clientset *fedclientset.Clientset, nsName string, clusters fedframework.ClusterSlice) *v1beta1.ReplicaSet {
0000000000000000000000000000000000000000;;		rs := createReplicaSetOrFail(clientset, newReplicaSet(nsName, FederationReplicaSetPrefix, 5, nil))
0000000000000000000000000000000000000000;;		// Check subclusters if the replicaSet was created there.
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting for replica sets %s to be created in all underlying clusters", rs.Name))
0000000000000000000000000000000000000000;;		err := wait.Poll(5*time.Second, 2*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			for _, cluster := range clusters {
0000000000000000000000000000000000000000;;				_, err := cluster.Extensions().ReplicaSets(nsName).Get(rs.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Not all replica sets created")
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAndUpdateFedRSWithPref(clientset *fedclientset.Clientset, nsName string, clusters fedframework.ClusterSlice, pref *federation.ReplicaAllocationPreferences, replicas int32, expect map[string]int32) *v1beta1.ReplicaSet {
0000000000000000000000000000000000000000;;		framework.Logf("Replicas: %d, Preference: %#v", replicas, pref)
0000000000000000000000000000000000000000;;		rs := newReplicaSet(nsName, FederationReplicaSetPrefix, replicas, pref)
0000000000000000000000000000000000000000;;		rs = createReplicaSetOrFail(clientset, rs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForReplicaSetOrFail(clientset, nsName, rs.Name, clusters, expect)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully created and synced replicaset \"%s/%s\" (%v/%v) to clusters", nsName, rs.Name, rs.Status.Replicas, *rs.Spec.Replicas))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs = newReplicaSetWithName(nsName, rs.Name, 0, pref)
0000000000000000000000000000000000000000;;		updateReplicaSetOrFail(clientset, rs)
0000000000000000000000000000000000000000;;		waitForReplicaSetOrFail(clientset, nsName, rs.Name, clusters, nil)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully updated and synced replicaset \"%s/%s\" (%v/%v) to clusters", nsName, rs.Name, rs.Status.Replicas, *rs.Spec.Replicas))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs = newReplicaSetWithName(nsName, rs.Name, replicas, pref)
0000000000000000000000000000000000000000;;		updateReplicaSetOrFail(clientset, rs)
0000000000000000000000000000000000000000;;		waitForReplicaSetOrFail(clientset, nsName, rs.Name, clusters, expect)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully updated and synced replicaset \"%s/%s\" (%v/%v) to clusters", nsName, rs.Name, rs.Status.Replicas, *rs.Spec.Replicas))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteAllReplicaSetsOrFail deletes all replicasets in the given namespace name.
0000000000000000000000000000000000000000;;	func deleteAllReplicaSetsOrFail(clientset *fedclientset.Clientset, nsName string) {
0000000000000000000000000000000000000000;;		replicasetList, err := clientset.Extensions().ReplicaSets(nsName).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;		orphanDependents := false
0000000000000000000000000000000000000000;;		for _, replicaset := range replicasetList.Items {
0000000000000000000000000000000000000000;;			deleteReplicaSetOrFail(clientset, nsName, replicaset.Name, &orphanDependents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateFedRSPrefsWithWeight(clusters fedframework.ClusterSlice) (pref *federation.ReplicaAllocationPreferences, replicas int32, expect map[string]int32) {
0000000000000000000000000000000000000000;;		By("Generating replicaset preferences with weights")
0000000000000000000000000000000000000000;;		clusterNames := extractClusterNames(clusters)
0000000000000000000000000000000000000000;;		pref = &federation.ReplicaAllocationPreferences{
0000000000000000000000000000000000000000;;			Clusters: map[string]federation.ClusterPreferences{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		replicas = 0
0000000000000000000000000000000000000000;;		expect = map[string]int32{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, clusterName := range clusterNames {
0000000000000000000000000000000000000000;;			if i != 0 { // do not set weight for cluster[0] thus it should have no replicas scheduled
0000000000000000000000000000000000000000;;				pref.Clusters[clusterName] = federation.ClusterPreferences{
0000000000000000000000000000000000000000;;					Weight: int64(i),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				replicas += int32(i)
0000000000000000000000000000000000000000;;				expect[clusterName] = int32(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateFedRSPrefsWithMin(clusters fedframework.ClusterSlice) (pref *federation.ReplicaAllocationPreferences, replicas int32, expect map[string]int32) {
0000000000000000000000000000000000000000;;		By("Generating replicaset preferences with min replicas")
0000000000000000000000000000000000000000;;		clusterNames := extractClusterNames(clusters)
0000000000000000000000000000000000000000;;		pref = &federation.ReplicaAllocationPreferences{
0000000000000000000000000000000000000000;;			Clusters: map[string]federation.ClusterPreferences{
0000000000000000000000000000000000000000;;				clusterNames[0]: {Weight: 100},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		replicas = 0
0000000000000000000000000000000000000000;;		expect = map[string]int32{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, clusterName := range clusterNames {
0000000000000000000000000000000000000000;;			if i != 0 { // do not set weight and minReplicas for cluster[0] thus it should have no replicas scheduled
0000000000000000000000000000000000000000;;				pref.Clusters[clusterName] = federation.ClusterPreferences{
0000000000000000000000000000000000000000;;					Weight:      int64(1),
0000000000000000000000000000000000000000;;					MinReplicas: int64(i + 2),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				replicas += int32(i + 2)
0000000000000000000000000000000000000000;;				expect[clusterName] = int32(i + 2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// the extra replica goes to cluster[0] which has the highest weight
0000000000000000000000000000000000000000;;		replicas += 1
0000000000000000000000000000000000000000;;		expect[clusterNames[0]] = 1
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateFedRSPrefsWithMax(clusters fedframework.ClusterSlice) (pref *federation.ReplicaAllocationPreferences, replicas int32, expect map[string]int32) {
0000000000000000000000000000000000000000;;		By("Generating replicaset preferences with max replicas")
0000000000000000000000000000000000000000;;		clusterNames := extractClusterNames(clusters)
0000000000000000000000000000000000000000;;		pref = &federation.ReplicaAllocationPreferences{
0000000000000000000000000000000000000000;;			Clusters: map[string]federation.ClusterPreferences{
0000000000000000000000000000000000000000;;				clusterNames[0]: {Weight: 1},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		replicas = 0
0000000000000000000000000000000000000000;;		expect = map[string]int32{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, clusterName := range clusterNames {
0000000000000000000000000000000000000000;;			if i != 0 { // do not set maxReplicas for cluster[0] thus replicas exceeds the total maxReplicas turned to cluster[0]
0000000000000000000000000000000000000000;;				maxReplicas := int64(i)
0000000000000000000000000000000000000000;;				pref.Clusters[clusterName] = federation.ClusterPreferences{
0000000000000000000000000000000000000000;;					Weight:      int64(100),
0000000000000000000000000000000000000000;;					MaxReplicas: &maxReplicas,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				replicas += int32(i)
0000000000000000000000000000000000000000;;				expect[clusterName] = int32(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// extra replicas go to cluster[0] although it has the lowest weight as others hit the MaxReplicas
0000000000000000000000000000000000000000;;		replicas += 5
0000000000000000000000000000000000000000;;		expect[clusterNames[0]] = 5
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateFedRSPrefsRebalance(pref *federation.ReplicaAllocationPreferences, rebalance bool) *federation.ReplicaAllocationPreferences {
0000000000000000000000000000000000000000;;		pref.Rebalance = rebalance
0000000000000000000000000000000000000000;;		return pref
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateFedRSPrefsForRebalancing(clusters fedframework.ClusterSlice) (pref1, pref2 *federation.ReplicaAllocationPreferences, replicas int32, expect1, expect2 map[string]int32) {
0000000000000000000000000000000000000000;;		By("Generating replicaset for rebalancing")
0000000000000000000000000000000000000000;;		clusterNames := extractClusterNames(clusters)
0000000000000000000000000000000000000000;;		replicas = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pref1 = &federation.ReplicaAllocationPreferences{
0000000000000000000000000000000000000000;;			Clusters: map[string]federation.ClusterPreferences{
0000000000000000000000000000000000000000;;				clusterNames[0]: {Weight: 1},
0000000000000000000000000000000000000000;;				clusterNames[1]: {Weight: 2},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expect1 = map[string]int32{
0000000000000000000000000000000000000000;;			clusterNames[0]: 1,
0000000000000000000000000000000000000000;;			clusterNames[1]: 2,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pref2 = &federation.ReplicaAllocationPreferences{
0000000000000000000000000000000000000000;;			Clusters: map[string]federation.ClusterPreferences{
0000000000000000000000000000000000000000;;				clusterNames[0]: {Weight: 2},
0000000000000000000000000000000000000000;;				clusterNames[1]: {Weight: 1},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expect2 = map[string]int32{
0000000000000000000000000000000000000000;;			clusterNames[0]: 2,
0000000000000000000000000000000000000000;;			clusterNames[1]: 1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForReplicaSetOrFail(c *fedclientset.Clientset, namespace string, replicaSetName string, clusters fedframework.ClusterSlice, expect map[string]int32) {
0000000000000000000000000000000000000000;;		err := waitForReplicaSet(c, namespace, replicaSetName, clusters, expect)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Failed to verify replica set \"%s/%s\", err: %v", namespace, replicaSetName, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForReplicaSet(c *fedclientset.Clientset, namespace string, replicaSetName string, clusters fedframework.ClusterSlice, expect map[string]int32) error {
0000000000000000000000000000000000000000;;		framework.Logf("waitForReplicaSet: %s/%s; clusters: %v; expect: %v", namespace, replicaSetName, clusters, expect)
0000000000000000000000000000000000000000;;		err := wait.Poll(10*time.Second, fedframework.FederatedDefaultTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			frs, err := c.ReplicaSets(namespace).Get(replicaSetName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			specReplicas, statusReplicas := int32(0), int32(0)
0000000000000000000000000000000000000000;;			for _, cluster := range clusters {
0000000000000000000000000000000000000000;;				rs, err := cluster.ReplicaSets(namespace).Get(replicaSetName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					framework.Logf("Failed getting replicaset: \"%s/%s/%s\", err: %v", cluster.Name, namespace, replicaSetName, err)
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					if expect != nil && expect[cluster.Name] > 0 {
0000000000000000000000000000000000000000;;						framework.Logf("Replicaset \"%s/%s/%s\" with replica count %d does not exist", cluster.Name, namespace, replicaSetName, expect[cluster.Name])
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if !equivalentReplicaSet(frs, rs) {
0000000000000000000000000000000000000000;;						framework.Logf("Replicaset meta or spec does not match for cluster %q:\n    federation: %v\n    cluster: %v", cluster.Name, frs, rs)
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if expect != nil && *rs.Spec.Replicas < expect[cluster.Name] {
0000000000000000000000000000000000000000;;						framework.Logf("Replicas do not match for \"%s/%s/%s\": expected: >= %v, actual: %v", cluster.Name, namespace, replicaSetName, expect[cluster.Name], *rs.Spec.Replicas)
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					specReplicas += *rs.Spec.Replicas
0000000000000000000000000000000000000000;;					statusReplicas += rs.Status.Replicas
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if *frs.Spec.Replicas == 0 && frs.Status.Replicas != 0 {
0000000000000000000000000000000000000000;;				framework.Logf("ReplicaSet \"%s/%s\" with zero replicas should match the status as no overflow happens: expected: 0, actual: %v", namespace, replicaSetName, frs.Status.Replicas)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if statusReplicas == frs.Status.Replicas && specReplicas >= *frs.Spec.Replicas {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Replicas do not match, federation replicas: %v/%v, cluster replicas: %v/%v", frs.Status.Replicas, *frs.Spec.Replicas, statusReplicas, specReplicas)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equivalentReplicaSet(fedReplicaSet, localReplicaSet *v1beta1.ReplicaSet) bool {
0000000000000000000000000000000000000000;;		localReplicaSetSpec := localReplicaSet.Spec
0000000000000000000000000000000000000000;;		localReplicaSetSpec.Replicas = fedReplicaSet.Spec.Replicas
0000000000000000000000000000000000000000;;		return fedutil.ObjectMetaEquivalent(fedReplicaSet.ObjectMeta, localReplicaSet.ObjectMeta) &&
0000000000000000000000000000000000000000;;			reflect.DeepEqual(fedReplicaSet.Spec, localReplicaSetSpec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createReplicaSetOrFail(clientset *fedclientset.Clientset, replicaset *v1beta1.ReplicaSet) *v1beta1.ReplicaSet {
0000000000000000000000000000000000000000;;		namespace := replicaset.Namespace
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 {
0000000000000000000000000000000000000000;;			Fail(fmt.Sprintf("Internal error: invalid parameters passed to createReplicaSetOrFail: clientset: %v, namespace: %v", clientset, namespace))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating federation replicaset %q in namespace %q", replicaset.Name, namespace))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newRS, err := clientset.Extensions().ReplicaSets(namespace).Create(replicaset)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Creating replicaset %q in namespace %q", replicaset.Name, namespace)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully created federation replicaset %q in namespace %q", newRS.Name, namespace))
0000000000000000000000000000000000000000;;		return newRS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteReplicaSetOrFail(clientset *fedclientset.Clientset, nsName string, replicaSetName string, orphanDependents *bool) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Deleting replica set %q in namespace %q", replicaSetName, nsName))
0000000000000000000000000000000000000000;;		err := clientset.Extensions().ReplicaSets(nsName).Delete(replicaSetName, &metav1.DeleteOptions{OrphanDependents: orphanDependents})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Error deleting replica set %q in namespace %q", replicaSetName, nsName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForReplicaSetToBeDeletedOrFail(clientset, nsName, replicaSetName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateReplicaSetOrFail(clientset *fedclientset.Clientset, replicaset *v1beta1.ReplicaSet) *v1beta1.ReplicaSet {
0000000000000000000000000000000000000000;;		namespace := replicaset.Namespace
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 {
0000000000000000000000000000000000000000;;			Fail(fmt.Sprintf("Internal error: invalid parameters passed to updateReplicaSetOrFail: clientset: %v, namespace: %v", clientset, namespace))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Updating federation replicaset %q in namespace %q", replicaset.Name, namespace))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newRS, err := clientset.ReplicaSets(namespace).Update(replicaset)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Updating replicaset %q in namespace %q", replicaset.Name, namespace)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully updated federation replicaset %q in namespace %q", replicaset.Name, namespace))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newRS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicaSetObj(namespace string, replicas int32, pref *federation.ReplicaAllocationPreferences) *v1beta1.ReplicaSet {
0000000000000000000000000000000000000000;;		// When the tests are run in parallel, replicasets from different tests can
0000000000000000000000000000000000000000;;		// collide with each other. Prevent that by creating a unique label and
0000000000000000000000000000000000000000;;		// label selector for each created replica set.
0000000000000000000000000000000000000000;;		uuidString := string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		rsLabel := fmt.Sprintf("myrs-%s", uuidString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs := &v1beta1.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;					MatchLabels: map[string]string{"name": rsLabel},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{"name": rsLabel},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "nginx",
0000000000000000000000000000000000000000;;								Image: "nginx",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pref != nil {
0000000000000000000000000000000000000000;;			prefBytes, _ := json.Marshal(pref)
0000000000000000000000000000000000000000;;			prefString := string(prefBytes)
0000000000000000000000000000000000000000;;			rs.Annotations[federatedtypes.FedReplicaSetPreferencesAnnotation] = prefString
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicaSet(namespace string, prefix string, replicas int32, pref *federation.ReplicaAllocationPreferences) *v1beta1.ReplicaSet {
0000000000000000000000000000000000000000;;		rs := newReplicaSetObj(namespace, replicas, pref)
0000000000000000000000000000000000000000;;		rs.GenerateName = prefix
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicaSetWithName(namespace string, name string, replicas int32, pref *federation.ReplicaAllocationPreferences) *v1beta1.ReplicaSet {
0000000000000000000000000000000000000000;;		rs := newReplicaSetObj(namespace, replicas, pref)
0000000000000000000000000000000000000000;;		rs.Name = name
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractClusterNames(clusters fedframework.ClusterSlice) []string {
0000000000000000000000000000000000000000;;		clusterNames := make([]string, 0, len(clusters))
0000000000000000000000000000000000000000;;		for _, cluster := range clusters {
0000000000000000000000000000000000000000;;			clusterNames = append(clusterNames, cluster.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clusterNames
0000000000000000000000000000000000000000;;	}
