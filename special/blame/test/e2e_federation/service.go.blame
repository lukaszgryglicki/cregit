0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f45fdf1beface4a3ec767087833dbee60617b81d;test/e2e/federated-service.go[test/e2e/federated-service.go][test/e2e_federation/service.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		fedframework "k8s.io/kubernetes/test/e2e_federation/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FederatedServiceName    = "federated-service"
0000000000000000000000000000000000000000;;		FederatedServicePodName = "federated-service-test-pod"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var FederatedServiceLabels = map[string]string{
0000000000000000000000000000000000000000;;		"foo": "bar",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Federated Services [Feature:Federation]", func() {
0000000000000000000000000000000000000000;;		f := fedframework.NewDefaultFederatedFramework("federated-service")
0000000000000000000000000000000000000000;;		var clusters fedframework.ClusterSlice
0000000000000000000000000000000000000000;;		var federationName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var _ = Describe("Without Clusters [NoCluster]", func() {
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				// Placeholder
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should succeed when a service is created", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				service := createServiceOrFail(f.FederationClientset, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creation of service %q in namespace %q succeeded.  Deleting service.", service.Name, nsName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Cleanup
0000000000000000000000000000000000000000;;				err := f.FederationClientset.Services(nsName).Delete(service.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err, "Error deleting service %q in namespace %q", service.Name, service.Namespace)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Deletion of service %q in namespace %q succeeded.", service.Name, nsName))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var _ = Describe("with clusters", func() {
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: Federation API server should be able to answer this.
0000000000000000000000000000000000000000;;				if federationName = os.Getenv("FEDERATION_NAME"); federationName == "" {
0000000000000000000000000000000000000000;;					federationName = DefaultFederationName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				clusters = f.GetRegisteredClusters()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Describe("Federated Service", func() {
0000000000000000000000000000000000000000;;				var (
0000000000000000000000000000000000000000;;					service *v1.Service
0000000000000000000000000000000000000000;;					nsName  string
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				BeforeEach(func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;					nsName = f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				AfterEach(func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if service != nil {
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("Deleting service shards and their provider resources in underlying clusters for service %q in namespace %q", service.Name, nsName))
0000000000000000000000000000000000000000;;						cleanupServiceShardsAndProviderResources(nsName, service, clusters)
0000000000000000000000000000000000000000;;						service = nil
0000000000000000000000000000000000000000;;						nsName = ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should create and update matching services in underlying clusters", func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;					service = createServiceOrFail(f.FederationClientset, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;					defer func() { // Cleanup
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("Deleting service %q in namespace %q", service.Name, nsName))
0000000000000000000000000000000000000000;;						err := f.FederationClientset.Services(nsName).Delete(service.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;						framework.ExpectNoError(err, "Error deleting service %q in namespace %q", service.Name, nsName)
0000000000000000000000000000000000000000;;					}()
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Wait for service shards to be created in all clusters for service \"%s/%s\"", nsName, service.Name))
0000000000000000000000000000000000000000;;					waitForServiceShardsOrFail(nsName, service, clusters)
0000000000000000000000000000000000000000;;					framework.Logf("Successfully created and synced service \"%s/%s\" to all clusters", nsName, service.Name)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Update federated service \"%s/%s\"", nsName, service.Name))
0000000000000000000000000000000000000000;;					service = updateServiceOrFail(f.FederationClientset, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;					waitForServiceShardsOrFail(nsName, service, clusters)
0000000000000000000000000000000000000000;;					framework.Logf("Successfully updated and synced service \"%s/%s\" to clusters", nsName, service.Name)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should be deleted from underlying clusters when OrphanDependents is false", func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;					orphanDependents := false
0000000000000000000000000000000000000000;;					verifyCascadingDeletionForService(f.FederationClientset, clusters, &orphanDependents, nsName)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Verified that services were deleted from underlying clusters"))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should not be deleted from underlying clusters when OrphanDependents is true", func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;					orphanDependents := true
0000000000000000000000000000000000000000;;					verifyCascadingDeletionForService(f.FederationClientset, clusters, &orphanDependents, nsName)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Verified that services were not deleted from underlying clusters"))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should not be deleted from underlying clusters when OrphanDependents is nil", func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;					verifyCascadingDeletionForService(f.FederationClientset, clusters, nil, nsName)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Verified that services were not deleted from underlying clusters"))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should recreate service shard in underlying clusters when service shard is deleted", func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;					service = createServiceOrFail(f.FederationClientset, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;					defer func() {
0000000000000000000000000000000000000000;;						// Cleanup
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("Deleting service %q in namespace %q", service.Name, nsName))
0000000000000000000000000000000000000000;;						err := f.FederationClientset.Services(nsName).Delete(service.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;						framework.ExpectNoError(err, "Error deleting service %q in namespace %q", service.Name, nsName)
0000000000000000000000000000000000000000;;					}()
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Wait for service shards to be created in all clusters for service \"%s/%s\"", nsName, service.Name))
0000000000000000000000000000000000000000;;					waitForServiceShardsOrFail(nsName, service, clusters)
0000000000000000000000000000000000000000;;					framework.Logf("Successfully created and synced service \"%s/%s\" to all clusters", nsName, service.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Deleting a service shard in one underlying cluster"))
0000000000000000000000000000000000000000;;					primaryClusterName := clusters[0].Name
0000000000000000000000000000000000000000;;					err := deleteServiceShard(clusters[0], nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, fmt.Sprintf("while deleting service shard %q in cluster %q", FederatedServiceName, primaryClusterName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					waitForServiceShardsOrFail(nsName, service, clusters)
0000000000000000000000000000000000000000;;					framework.Logf("Successfully recreated service shard \"%s/%s\" in %q cluster", nsName, service.Name, primaryClusterName)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var _ = Describe("DNS", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var (
0000000000000000000000000000000000000000;;					service      *v1.Service
0000000000000000000000000000000000000000;;					serviceShard *v1.Service
0000000000000000000000000000000000000000;;					backendPods  BackendPodMap
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				BeforeEach(func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					backendPods = createBackendPodsOrFail(clusters, nsName, FederatedServicePodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					service = createLBServiceOrFail(f.FederationClientset, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;					obj, err := api.Scheme.DeepCopy(service)
0000000000000000000000000000000000000000;;					// Cloning shouldn't fail. On the off-chance it does, we
0000000000000000000000000000000000000000;;					// should shallow copy service to serviceShard before
0000000000000000000000000000000000000000;;					// failing. If we don't do this we will never really
0000000000000000000000000000000000000000;;					// get a chance to clean up the underlying services
0000000000000000000000000000000000000000;;					// when the cloner fails for reasons not in our
0000000000000000000000000000000000000000;;					// control. For example, cloner bug. That will cause
0000000000000000000000000000000000000000;;					// the resources to leak, which in turn causes the
0000000000000000000000000000000000000000;;					// test project to run out of quota and the entire
0000000000000000000000000000000000000000;;					// suite starts failing. So we must try as hard as
0000000000000000000000000000000000000000;;					// possible to cleanup the underlying services. So
0000000000000000000000000000000000000000;;					// if DeepCopy fails, we are going to try with shallow
0000000000000000000000000000000000000000;;					// copy as a last resort.
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						serviceCopy := *service
0000000000000000000000000000000000000000;;						serviceShard = &serviceCopy
0000000000000000000000000000000000000000;;						framework.ExpectNoError(err, fmt.Sprintf("Error in deep copying service %q", service.Name))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var ok bool
0000000000000000000000000000000000000000;;					serviceShard, ok = obj.(*v1.Service)
0000000000000000000000000000000000000000;;					// Same argument as above about using shallow copy
0000000000000000000000000000000000000000;;					// as a last resort.
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						serviceCopy := *service
0000000000000000000000000000000000000000;;						serviceShard = &serviceCopy
0000000000000000000000000000000000000000;;						framework.ExpectNoError(err, fmt.Sprintf("Unexpected service object copied %T", obj))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					waitForServiceShardsOrFail(nsName, serviceShard, clusters)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				AfterEach(func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;					deleteBackendPodsOrFail(clusters, backendPods)
0000000000000000000000000000000000000000;;					backendPods = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if service != nil {
0000000000000000000000000000000000000000;;						deleteServiceOrFail(f.FederationClientset, nsName, service.Name, nil)
0000000000000000000000000000000000000000;;						service = nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						By("No service to delete.  Service is nil")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if serviceShard != nil {
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("Deleting service shards and their provider resources in underlying clusters for service %q in namespace %q", serviceShard.Name, nsName))
0000000000000000000000000000000000000000;;						cleanupServiceShardsAndProviderResources(nsName, serviceShard, clusters)
0000000000000000000000000000000000000000;;						serviceShard = nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						By("No service shards to delete. `serviceShard` is nil")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should be able to discover a federated service", func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;					svcDNSNames := []string{
0000000000000000000000000000000000000000;;						FederatedServiceName,
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s.%s", FederatedServiceName, nsName),
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s.%s.svc.cluster.local.", FederatedServiceName, nsName),
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s.%s.%s", FederatedServiceName, nsName, federationName),
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s.%s.%s.svc.cluster.local.", FederatedServiceName, nsName, federationName),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// TODO(mml): This could be much faster.  We can launch all the test
0000000000000000000000000000000000000000;;					// pods, perhaps in the BeforeEach, and then just poll until we get
0000000000000000000000000000000000000000;;					// successes/failures from them all.
0000000000000000000000000000000000000000;;					for i, DNSName := range svcDNSNames {
0000000000000000000000000000000000000000;;						discoverService(f, DNSName, true, "federated-service-e2e-discovery-pod-"+strconv.Itoa(i))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					By("Verified that DNS rules are working as expected")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("Deleting the service to verify that DNS rules still work")
0000000000000000000000000000000000000000;;					err := f.FederationClientset.Services(nsName).Delete(FederatedServiceName, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, "Error deleting service %q in namespace %q", service.Name, service.Namespace)
0000000000000000000000000000000000000000;;					// Service is deleted, unset the test block-global service variable.
0000000000000000000000000000000000000000;;					service = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for i, DNSName := range svcDNSNames {
0000000000000000000000000000000000000000;;						discoverService(f, DNSName, true, "federated-service-e2e-discovery-pod-"+strconv.Itoa(i))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					By("Verified that deleting the service does not affect DNS records")
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Context("non-local federated service", func() {
0000000000000000000000000000000000000000;;					BeforeEach(func() {
0000000000000000000000000000000000000000;;						fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Delete the backend pod from the shard which is local to the discovery pod.
0000000000000000000000000000000000000000;;						primaryCluster := clusters[0]
0000000000000000000000000000000000000000;;						backendPod := backendPods[primaryCluster.Name]
0000000000000000000000000000000000000000;;						deleteOneBackendPodOrFail(primaryCluster, backendPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					PIt("should be able to discover a non-local federated service", func() {
0000000000000000000000000000000000000000;;						fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;						svcDNSNames := []string{
0000000000000000000000000000000000000000;;							fmt.Sprintf("%s.%s.%s", FederatedServiceName, nsName, federationName),
0000000000000000000000000000000000000000;;							fmt.Sprintf("%s.%s.%s.svc.cluster.local.", FederatedServiceName, nsName, federationName),
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for i, name := range svcDNSNames {
0000000000000000000000000000000000000000;;							discoverService(f, name, true, "federated-service-e2e-discovery-pod-"+strconv.Itoa(i))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// TODO(mml): This currently takes 9 minutes.  Consider reducing the
0000000000000000000000000000000000000000;;					// TTL and/or running the pods in parallel.
0000000000000000000000000000000000000000;;					Context("[Slow] missing local service", func() {
0000000000000000000000000000000000000000;;						It("should never find DNS entries for a missing local service", func() {
0000000000000000000000000000000000000000;;							fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;							localSvcDNSNames := []string{
0000000000000000000000000000000000000000;;								FederatedServiceName,
0000000000000000000000000000000000000000;;								fmt.Sprintf("%s.%s", FederatedServiceName, nsName),
0000000000000000000000000000000000000000;;								fmt.Sprintf("%s.%s.svc.cluster.local.", FederatedServiceName, nsName),
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							for i, name := range localSvcDNSNames {
0000000000000000000000000000000000000000;;								discoverService(f, name, false, "federated-service-e2e-discovery-pod-"+strconv.Itoa(i))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyCascadingDeletionForService verifies that services are deleted from
0000000000000000000000000000000000000000;;	// underlying clusters when orphan dependents is false and they are not
0000000000000000000000000000000000000000;;	// deleted when orphan dependents is true.
0000000000000000000000000000000000000000;;	func verifyCascadingDeletionForService(clientset *fedclientset.Clientset, clusters fedframework.ClusterSlice, orphanDependents *bool, nsName string) {
0000000000000000000000000000000000000000;;		service := createServiceOrFail(clientset, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;		serviceName := service.Name
0000000000000000000000000000000000000000;;		// Check subclusters if the service was created there.
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting for service %s to be created in all underlying clusters", serviceName))
0000000000000000000000000000000000000000;;		err := wait.Poll(5*time.Second, 2*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			for _, cluster := range clusters {
0000000000000000000000000000000000000000;;				_, err := cluster.Core().Services(nsName).Get(serviceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Not all services created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Deleting service %s", serviceName))
0000000000000000000000000000000000000000;;		deleteServiceOrFail(clientset, nsName, serviceName, orphanDependents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Verifying services %s in underlying clusters", serviceName))
0000000000000000000000000000000000000000;;		errMessages := []string{}
0000000000000000000000000000000000000000;;		// service should be present in underlying clusters unless orphanDependents is false.
0000000000000000000000000000000000000000;;		shouldExist := orphanDependents == nil || *orphanDependents == true
0000000000000000000000000000000000000000;;		for _, cluster := range clusters {
0000000000000000000000000000000000000000;;			clusterName := cluster.Name
0000000000000000000000000000000000000000;;			_, err := cluster.Core().Services(nsName).Get(serviceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if shouldExist && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				errMessages = append(errMessages, fmt.Sprintf("unexpected NotFound error for service %s in cluster %s, expected service to exist", serviceName, clusterName))
0000000000000000000000000000000000000000;;			} else if !shouldExist && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				errMessages = append(errMessages, fmt.Sprintf("expected NotFound error for service %s in cluster %s, got error: %v", serviceName, clusterName, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errMessages) != 0 {
0000000000000000000000000000000000000000;;			framework.Failf("%s", strings.Join(errMessages, "; "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateServiceOrFail(clientset *fedclientset.Clientset, namespace, name string) *v1.Service {
0000000000000000000000000000000000000000;;		service, err := clientset.Services(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Getting service %q in namespace %q", name, namespace)
0000000000000000000000000000000000000000;;		service.Spec.Selector["name"] = "update-demo"
0000000000000000000000000000000000000000;;		newService, err := clientset.Services(namespace).Update(service)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully updated federated service %q in namespace %q", name, namespace))
0000000000000000000000000000000000000000;;		return newService
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteServiceShard(c *fedframework.Cluster, namespace, service string) error {
0000000000000000000000000000000000000000;;		err := c.Clientset.Services(namespace).Delete(service, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			framework.Logf("Failed to delete service %q in namespace %q, in cluster %q", service, namespace, c.Name)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Service %q in namespace %q in cluster %q deleted", service, namespace, c.Name))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// equivalent returns true if the two services are equivalent.  Fields which are expected to differ between
0000000000000000000000000000000000000000;;	// federated services and the underlying cluster services (e.g. ClusterIP, NodePort) are ignored.
0000000000000000000000000000000000000000;;	func equivalent(federationService, clusterService v1.Service) bool {
0000000000000000000000000000000000000000;;		clusterService.Spec.ClusterIP = federationService.Spec.ClusterIP
0000000000000000000000000000000000000000;;		for i := range clusterService.Spec.Ports {
0000000000000000000000000000000000000000;;			clusterService.Spec.Ports[i].NodePort = federationService.Spec.Ports[i].NodePort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if federationService.Name != clusterService.Name || federationService.Namespace != clusterService.Namespace {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(federationService.Labels, clusterService.Labels) && (len(federationService.Labels) != 0 || len(clusterService.Labels) != 0) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(federationService.Spec, clusterService.Spec) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
