0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7795d0f22a3420af9e7c5c58bad6bd408db17333;test/e2e/federated-ingress.go[test/e2e/federated-ingress.go][test/e2e_federation/ingress.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		fedframework "k8s.io/kubernetes/test/e2e_federation/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MaxRetriesOnFederatedApiserver = 3
0000000000000000000000000000000000000000;;		FederatedIngressTimeout        = 15 * time.Minute
0000000000000000000000000000000000000000;;		FederatedIngressDeleteTimeout  = 2 * time.Minute
0000000000000000000000000000000000000000;;		FederatedIngressName           = "federated-ingress"
0000000000000000000000000000000000000000;;		FederatedIngressServiceName    = "federated-ingress-service"
0000000000000000000000000000000000000000;;		FederatedIngressTLSSecretName  = "federated-ingress-tls-secret"
0000000000000000000000000000000000000000;;		FederatedIngressServicePodName = "federated-ingress-service-test-pod"
0000000000000000000000000000000000000000;;		FederatedIngressHost           = "test-f8n.k8s.io."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FederatedSecretTimeout = 60 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLS Certificate and Key for the ingress resource
0000000000000000000000000000000000000000;;		// Generated using:
0000000000000000000000000000000000000000;;		// $ openssl req -nodes -x509 -newkey rsa:2048 -keyout fedingtestkey.pem -out fedingtestcrt.pem -days 2485
0000000000000000000000000000000000000000;;		// 2485 days is an arbitrary large number chosen below int32 seconds.
0000000000000000000000000000000000000000;;		FederatedIngressTLSCrt = `-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIIDaTCCAlGgAwIBAgIJANwsCbwxm9pyMA0GCSqGSIb3DQEBCwUAMEoxCzAJBgNV
0000000000000000000000000000000000000000;;	BAYTAlVTMRMwEQYDVQQIDApTb21lLVN0YXRlMQswCQYDVQQKDAJOQTEZMBcGA1UE
0000000000000000000000000000000000000000;;	AwwQdGVzdC1mOG4uazhzLmlvLjAgFw0xNjEyMTYwNjA1NDRaGA8yMDg1MDEwMzA2
0000000000000000000000000000000000000000;;	MDU0NFowSjELMAkGA1UEBhMCVVMxEzARBgNVBAgMClNvbWUtU3RhdGUxCzAJBgNV
0000000000000000000000000000000000000000;;	BAoMAk5BMRkwFwYDVQQDDBB0ZXN0LWY4bi5rOHMuaW8uMIIBIjANBgkqhkiG9w0B
0000000000000000000000000000000000000000;;	AQEFAAOCAQ8AMIIBCgKCAQEAmsHYnLhqSeO1Q6SEjaiPiLUQV8tyGfttwNQiOT5u
0000000000000000000000000000000000000000;;	ULz6ZWYA40m/1hhla9KH9sJZ515Iq+jTtiVH0rUjryT96SjxitLCAZlxVwQ63B50
0000000000000000000000000000000000000000;;	aZF2T2OPSzvrmN+J6VGcRIq0N8fUeyp2WTIEdWlpQ7DTmDNArQqFSIvJndkLow3d
0000000000000000000000000000000000000000;;	hec7O+PErnvZQQC9zqa23rGndDzlgDJ4HJGAQNm3uYVh5WHv+wziP67T/82bEGgO
0000000000000000000000000000000000000000;;	A6EdDPWzpYxzAA1wsqz9lX5jitlbKdI56698fPR2KRelySf7OXVvZCS4/ED1lF4k
0000000000000000000000000000000000000000;;	b7fQgtBhAWe1BkuAMUl7vdRjMps7nkxmBSuxBkVQ7sb5AwIDAQABo1AwTjAdBgNV
0000000000000000000000000000000000000000;;	HQ4EFgQUjf53O/W/iE2mxuJkNjZGUfjJ9RUwHwYDVR0jBBgwFoAUjf53O/W/iE2m
0000000000000000000000000000000000000000;;	xuJkNjZGUfjJ9RUwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEABE7B
0000000000000000000000000000000000000000;;	bAiORDBA3qE5lh6JCs/lEfz93E/gOhD9oDnm9SRND4kjy7qeGxk4Wzsd/Vr+R2mi
0000000000000000000000000000000000000000;;	EZ40d4MA/mCCPnYsNQoEXMFc8IvwAbzkhh2gqTNgG0/Ks0A1mIPQNpvUcSetS4IV
0000000000000000000000000000000000000000;;	732DvB3nSnFtlzf6afw+V1Vf5ydRNuM/c9GEOOHSz+rs+9M364d+wNaFD64M72ol
0000000000000000000000000000000000000000;;	iDMAdtcrhOqkQi0lUING904jlJcyYM5oVNCCtme4F8nkIX9bxP/9Ea6VhDGPeJiX
0000000000000000000000000000000000000000;;	tVwZuudkoEbrFlEYbyLrbVeVa9oTf4Jn66iz49/+th+bUtEoTt9gk9Cul5TFgfzx
0000000000000000000000000000000000000000;;	EscdahceC7afheq6zg==
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FederatedIngressTLSKey = `-----BEGIN PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCawdicuGpJ47VD
0000000000000000000000000000000000000000;;	pISNqI+ItRBXy3IZ+23A1CI5Pm5QvPplZgDjSb/WGGVr0of2wlnnXkir6NO2JUfS
0000000000000000000000000000000000000000;;	tSOvJP3pKPGK0sIBmXFXBDrcHnRpkXZPY49LO+uY34npUZxEirQ3x9R7KnZZMgR1
0000000000000000000000000000000000000000;;	aWlDsNOYM0CtCoVIi8md2QujDd2F5zs748Sue9lBAL3Oprbesad0POWAMngckYBA
0000000000000000000000000000000000000000;;	2be5hWHlYe/7DOI/rtP/zZsQaA4DoR0M9bOljHMADXCyrP2VfmOK2Vsp0jnrr3x8
0000000000000000000000000000000000000000;;	9HYpF6XJJ/s5dW9kJLj8QPWUXiRvt9CC0GEBZ7UGS4AxSXu91GMymzueTGYFK7EG
0000000000000000000000000000000000000000;;	RVDuxvkDAgMBAAECggEAYrXGPqB6W0r88XpceibL9rzXAcjorJ3s8ZPdiHnDz4fa
0000000000000000000000000000000000000000;;	hxa69j6yOBMzjcSpqMFqquM+ozhM4d+BomqbqjmEI1ZUSuIHkRGYc5JlIMXkJvn7
0000000000000000000000000000000000000000;;	ZsPwQGKl8cqTotjFPgrizLmPVEhPWLFImsNzuxNsw6XdWQJe5VkUbrRkccqEQ8Wt
0000000000000000000000000000000000000000;;	xwq/SlRercIMnRVLOOESq8EyjOY4yDgOdIifq9K9xiI8W6nMiPs0X5AcIJoTMbCe
0000000000000000000000000000000000000000;;	cX0zUqW317awDWWP8u2GswwDDm4qPeWnXOrDkDx8Eo0dWJbmxw9su0XrM6KMvEMe
0000000000000000000000000000000000000000;;	2a/Fy/enr5Cc6/jgsh3gO5sa8dJ1Cu+wexcoEbez8QKBgQDMXlXJu/C7djke94s3
0000000000000000000000000000000000000000;;	vGxati7AGO95bBQHW+cPuN4l0rfPZ8YuUAWD4csW4BOlUPAOukreD/SKdanigR3N
0000000000000000000000000000000000000000;;	FqVPeI8rXd5kzy8/lPIOGuSkkVEpKsAJ7prFbSUVKjVPYQk2dsOEeR0r7pr2FxC9
0000000000000000000000000000000000000000;;	SBhVS/LgmPYh++iny9D0aU23hQKBgQDB2t55OE+00vgoauUc10LEY+J6tiwXuNm7
0000000000000000000000000000000000000000;;	43JtrH5ET4N+TJ2BOUl5f88TY/3QuTu6vYwlxjyn+LFuWQNhShX6lFMjt5zqPTdw
0000000000000000000000000000000000000000;;	ZPDA+9B6a45cV3YjXjRsYidpWj0D2lJgy0DbucC4f3eIhNGyFUbAQB9npKDzOeUh
0000000000000000000000000000000000000000;;	7Z+p/Grg5wKBgGUnVCLzySWgUImJUPkXZDJJ9j3SmcVpv0gdLvLTN/FUqPIZlTgb
0000000000000000000000000000000000000000;;	F3+9ZL4/zrmGpCtF/gSHtSxLLPkVm2CFkvEQ5Rw76/XNrr8zw9NDcGQcISXVKRRB
0000000000000000000000000000000000000000;;	a43IhhBBwf02NE8m3YNWRyAVi9G+fOSTKKgfXWnZjAoqG2/iK9ytum/ZAoGAYlP8
0000000000000000000000000000000000000000;;	KIxxkYy5Jvchg4GEck0f4ZJpxxaSCoWR0yN9YHTcg8Gk2pkONbyocnNzmN17+HqQ
0000000000000000000000000000000000000000;;	jdCBj8nLZedsmXqUr2dwzFskEoQ+jJoGrDyOQKoxqZELcWElQhx/VSbacAvbYRF3
0000000000000000000000000000000000000000;;	snwDzxGItgx4uNWl73oW8+FDalvhZ1Y6eGR6ad0CgYEAtlNa92Fbvd3r9O2mdyWe
0000000000000000000000000000000000000000;;	D2SXNMi45+wsNafX2sdkyb+qNN6qZXC9ylUl9h0zdky88JNgtAOgxIaRIdEZajnD
0000000000000000000000000000000000000000;;	/Zq17sTNtgpm53x16gOAgD8M+/wmBZxA+/IKfFCubuV77MbQoPfcjT5wBMRnFQnY
0000000000000000000000000000000000000000;;	Ks7c+dzaRlgDKZ6v/L/8iZU=
0000000000000000000000000000000000000000;;	-----END PRIVATE KEY-----`
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// timeout on a single http request.
0000000000000000000000000000000000000000;;		reqTimeout = 10 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Federated ingresses [Feature:Federation]", func() {
0000000000000000000000000000000000000000;;		f := fedframework.NewDefaultFederatedFramework("federated-ingress")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create/delete ingress api objects
0000000000000000000000000000000000000000;;		// Validate federation apiserver, does not rely on underlying clusters or federation ingress controller.
0000000000000000000000000000000000000000;;		Describe("Federated Ingresses [NoCluster]", func() {
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				// Delete all ingresses.
0000000000000000000000000000000000000000;;				deleteAllIngressesOrFail(f.FederationClientset, nsName)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be created and deleted successfully", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("gce", "gke") // TODO: Federated ingress is not yet supported on non-GCP platforms.
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				ingress := createIngressOrFail(f.FederationClientset, nsName, FederatedIngressServiceName, FederatedIngressTLSSecretName)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creation of ingress %q in namespace %q succeeded.  Deleting ingress.", ingress.Name, nsName))
0000000000000000000000000000000000000000;;				// Cleanup
0000000000000000000000000000000000000000;;				err := f.FederationClientset.Extensions().Ingresses(nsName).Delete(ingress.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err, "Error deleting ingress %q in namespace %q", ingress.Name, ingress.Namespace)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Deletion of ingress %q in namespace %q succeeded.", ingress.Name, nsName))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// e2e cases for federation ingress controller
0000000000000000000000000000000000000000;;		var _ = Describe("Federated Ingresses [Slow]", func() {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				clusters           fedframework.ClusterSlice
0000000000000000000000000000000000000000;;				federationName, ns string
0000000000000000000000000000000000000000;;				jig                *federationTestJig
0000000000000000000000000000000000000000;;				service            *v1.Service
0000000000000000000000000000000000000000;;				secret             *v1.Secret
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// register clusters in federation apiserver
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				framework.SkipUnlessProviderIs("gce", "gke") // TODO: Federated ingress is not yet supported on non-GCP platforms.
0000000000000000000000000000000000000000;;				if federationName = os.Getenv("FEDERATION_NAME"); federationName == "" {
0000000000000000000000000000000000000000;;					federationName = DefaultFederationName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				jig = newFederationTestJig(f.FederationClientset)
0000000000000000000000000000000000000000;;				clusters = f.GetRegisteredClusters()
0000000000000000000000000000000000000000;;				ns = f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				// create backend service
0000000000000000000000000000000000000000;;				service = createLBServiceOrFail(f.FederationClientset, ns, FederatedIngressServiceName)
0000000000000000000000000000000000000000;;				// create the TLS secret
0000000000000000000000000000000000000000;;				secret = createTLSSecretOrFail(f.FederationClientset, ns, FederatedIngressTLSSecretName)
0000000000000000000000000000000000000000;;				// wait for services objects sync
0000000000000000000000000000000000000000;;				waitForServiceShardsOrFail(ns, service, clusters)
0000000000000000000000000000000000000000;;				// wait for TLS secret sync
0000000000000000000000000000000000000000;;				waitForSecretShardsOrFail(ns, secret, clusters)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				// Delete all ingresses.
0000000000000000000000000000000000000000;;				deleteAllIngressesOrFail(f.FederationClientset, ns)
0000000000000000000000000000000000000000;;				if secret != nil {
0000000000000000000000000000000000000000;;					By("Deleting secret")
0000000000000000000000000000000000000000;;					orphanDependents := false
0000000000000000000000000000000000000000;;					deleteSecretOrFail(f.FederationClientset, ns, secret.Name, &orphanDependents)
0000000000000000000000000000000000000000;;					secret = nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					By("No secret to delete. Secret is nil")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if service != nil {
0000000000000000000000000000000000000000;;					By("Deleting service")
0000000000000000000000000000000000000000;;					deleteServiceOrFail(f.FederationClientset, ns, service.Name, nil)
0000000000000000000000000000000000000000;;					By("Cleanup service shards and provider resources")
0000000000000000000000000000000000000000;;					cleanupServiceShardsAndProviderResources(ns, service, clusters)
0000000000000000000000000000000000000000;;					service = nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					By("No service to delete. Service is nil")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should create and update matching ingresses in underlying clusters", func() {
0000000000000000000000000000000000000000;;				ingress := createIngressOrFail(f.FederationClientset, ns, FederatedIngressServiceName, FederatedIngressTLSSecretName)
0000000000000000000000000000000000000000;;				// wait for ingress shards being created
0000000000000000000000000000000000000000;;				waitForIngressShardsOrFail(ns, ingress, clusters)
0000000000000000000000000000000000000000;;				ingress = updateIngressOrFail(f.FederationClientset, ns)
0000000000000000000000000000000000000000;;				waitForIngressShardsUpdatedOrFail(ns, ingress, clusters)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be deleted from underlying clusters when OrphanDependents is false", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				orphanDependents := false
0000000000000000000000000000000000000000;;				verifyCascadingDeletionForIngress(f.FederationClientset, clusters, &orphanDependents, ns)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Verified that ingresses were deleted from underlying clusters"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should not be deleted from underlying clusters when OrphanDependents is true", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				orphanDependents := true
0000000000000000000000000000000000000000;;				verifyCascadingDeletionForIngress(f.FederationClientset, clusters, &orphanDependents, ns)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Verified that ingresses were not deleted from underlying clusters"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should not be deleted from underlying clusters when OrphanDependents is nil", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				verifyCascadingDeletionForIngress(f.FederationClientset, clusters, nil, ns)
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Verified that ingresses were not deleted from underlying clusters"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var _ = Describe("Ingress connectivity and DNS", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var backendPods BackendPodMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				BeforeEach(func() {
0000000000000000000000000000000000000000;;					fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;					// create backend pod
0000000000000000000000000000000000000000;;					backendPods = createBackendPodsOrFail(clusters, ns, FederatedIngressServicePodName)
0000000000000000000000000000000000000000;;					// create ingress object
0000000000000000000000000000000000000000;;					jig.ing = createIngressOrFail(f.FederationClientset, ns, service.Name, FederatedIngressTLSSecretName)
0000000000000000000000000000000000000000;;					// wait for ingress objects sync
0000000000000000000000000000000000000000;;					waitForIngressShardsOrFail(ns, jig.ing, clusters)
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Ingress created as %v", jig.ing.Name))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				AfterEach(func() {
0000000000000000000000000000000000000000;;					deleteBackendPodsOrFail(clusters, backendPods)
0000000000000000000000000000000000000000;;					backendPods = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if jig.ing != nil {
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("Deleting ingress %v on all clusters", jig.ing.Name))
0000000000000000000000000000000000000000;;						orphanDependents := false
0000000000000000000000000000000000000000;;						deleteIngressOrFail(f.FederationClientset, ns, jig.ing.Name, &orphanDependents)
0000000000000000000000000000000000000000;;						jig.ing = nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						By("No ingress to delete. Ingress is nil")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				PIt("should be able to discover a federated ingress service via DNS", func() {
0000000000000000000000000000000000000000;;					// we are about the ingress name
0000000000000000000000000000000000000000;;					svcDNSNames := []string{
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s.%s", FederatedIngressServiceName, ns),
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s.%s.svc.cluster.local.", FederatedIngressServiceName, ns),
0000000000000000000000000000000000000000;;						// TODO these two entries are not set yet
0000000000000000000000000000000000000000;;						//fmt.Sprintf("%s.%s.%s", FederatedIngressServiceName, ns, federationName),
0000000000000000000000000000000000000000;;						//fmt.Sprintf("%s.%s.%s.svc.cluster.local.", FederatedIngressServiceName, ns, federationName),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// check dns records in underlying cluster
0000000000000000000000000000000000000000;;					for i, DNSName := range svcDNSNames {
0000000000000000000000000000000000000000;;						discoverService(f, DNSName, true, "federated-ingress-e2e-discovery-pod-"+strconv.Itoa(i))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// TODO check dns record in global dns server
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				PIt("should be able to connect to a federated ingress via its load balancer", func() {
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Waiting for Federated Ingress on %v", jig.ing.Name))
0000000000000000000000000000000000000000;;					// check the traffic on federation ingress
0000000000000000000000000000000000000000;;					jig.waitForFederatedIngress()
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes all Ingresses in the given namespace name.
0000000000000000000000000000000000000000;;	func deleteAllIngressesOrFail(clientset *fedclientset.Clientset, nsName string) {
0000000000000000000000000000000000000000;;		orphanDependents := false
0000000000000000000000000000000000000000;;		err := clientset.Extensions().Ingresses(nsName).DeleteCollection(&metav1.DeleteOptions{OrphanDependents: &orphanDependents}, metav1.ListOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("Error in deleting ingresses in namespace: %s", nsName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// equivalent returns true if the two ingress spec are equivalent.
0000000000000000000000000000000000000000;;	func equivalentIngress(federatedIngress, clusterIngress v1beta1.Ingress) bool {
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(clusterIngress.Spec, federatedIngress.Spec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyCascadingDeletionForIngress verifies that ingresses are deleted from
0000000000000000000000000000000000000000;;	// underlying clusters when orphan dependents is false and they are not deleted
0000000000000000000000000000000000000000;;	// when orphan dependents is true.
0000000000000000000000000000000000000000;;	func verifyCascadingDeletionForIngress(clientset *fedclientset.Clientset, clusters fedframework.ClusterSlice, orphanDependents *bool, nsName string) {
0000000000000000000000000000000000000000;;		ingress := createIngressOrFail(clientset, nsName, FederatedIngressServiceName, FederatedIngressTLSSecretName)
0000000000000000000000000000000000000000;;		ingressName := ingress.Name
0000000000000000000000000000000000000000;;		// Check subclusters if the ingress was created there.
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting for ingress %s to be created in all underlying clusters", ingressName))
0000000000000000000000000000000000000000;;		waitForIngressShardsOrFail(nsName, ingress, clusters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Deleting ingress %s", ingressName))
0000000000000000000000000000000000000000;;		deleteIngressOrFail(clientset, nsName, ingressName, orphanDependents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Verifying ingresses %s in underlying clusters", ingressName))
0000000000000000000000000000000000000000;;		errMessages := []string{}
0000000000000000000000000000000000000000;;		// ingress should be present in underlying clusters unless orphanDependents is false.
0000000000000000000000000000000000000000;;		shouldExist := orphanDependents == nil || *orphanDependents == true
0000000000000000000000000000000000000000;;		for _, cluster := range clusters {
0000000000000000000000000000000000000000;;			clusterName := cluster.Name
0000000000000000000000000000000000000000;;			_, err := cluster.Extensions().Ingresses(nsName).Get(ingressName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if shouldExist && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				errMessages = append(errMessages, fmt.Sprintf("unexpected NotFound error for ingress %s in cluster %s, expected ingress to exist", ingressName, clusterName))
0000000000000000000000000000000000000000;;			} else if !shouldExist && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				errMessages = append(errMessages, fmt.Sprintf("expected NotFound error for ingress %s in cluster %s, got error: %v", ingressName, clusterName, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errMessages) != 0 {
0000000000000000000000000000000000000000;;			framework.Failf("%s", strings.Join(errMessages, "; "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForIngressOrFail waits until a ingress is either present or absent in the cluster specified by clientset.
0000000000000000000000000000000000000000;;	// If the condition is not met within timout, it fails the calling test.
0000000000000000000000000000000000000000;;	func waitForIngressOrFail(clientset *kubeclientset.Clientset, namespace string, ingress *v1beta1.Ingress, present bool, timeout time.Duration) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Fetching a federated ingress shard of ingress %q in namespace %q from cluster", ingress.Name, namespace))
0000000000000000000000000000000000000000;;		var clusterIngress *v1beta1.Ingress
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(framework.Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			clusterIngress, err = clientset.Ingresses(namespace).Get(ingress.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if (!present) && errors.IsNotFound(err) { // We want it gone, and it's gone.
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Success: shard of federated ingress %q in namespace %q in cluster is absent", ingress.Name, namespace))
0000000000000000000000000000000000000000;;				return true, nil // Success
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if present && err == nil { // We want it present, and the Get succeeded, so we're all good.
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Success: shard of federated ingress %q in namespace %q in cluster is present", ingress.Name, namespace))
0000000000000000000000000000000000000000;;				return true, nil // Success
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Ingress %q in namespace %q in cluster.  Found: %v, waiting for Found: %v, trying again in %s (err=%v)", ingress.Name, namespace, clusterIngress != nil && err == nil, present, framework.Poll, err))
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Failed to verify ingress %q in namespace %q in cluster: Present=%v", ingress.Name, namespace, present)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if present && clusterIngress != nil {
0000000000000000000000000000000000000000;;			Expect(equivalentIngress(*clusterIngress, *ingress))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForIngressShardsOrFail waits for the ingress to appear in all clusters
0000000000000000000000000000000000000000;;	func waitForIngressShardsOrFail(namespace string, ingress *v1beta1.Ingress, clusters fedframework.ClusterSlice) {
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for ingress %q in %d clusters", ingress.Name, len(clusters))
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			waitForIngressOrFail(c.Clientset, namespace, ingress, true, FederatedIngressTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForIngressShardsUpdatedOrFail waits for the ingress to be updated in all clusters
0000000000000000000000000000000000000000;;	func waitForIngressShardsUpdatedOrFail(namespace string, ingress *v1beta1.Ingress, clusters fedframework.ClusterSlice) {
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for ingress %q in %d clusters", ingress.Name, len(clusters))
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			waitForIngressUpdateOrFail(c.Clientset, namespace, ingress, FederatedIngressTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForIngressUpdateOrFail waits until a ingress is updated in the specified cluster with same spec of federated ingress.
0000000000000000000000000000000000000000;;	// If the condition is not met within timeout, it fails the calling test.
0000000000000000000000000000000000000000;;	func waitForIngressUpdateOrFail(clientset *kubeclientset.Clientset, namespace string, ingress *v1beta1.Ingress, timeout time.Duration) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Fetching a federated ingress shard of ingress %q in namespace %q from cluster", ingress.Name, namespace))
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(framework.Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			clusterIngress, err := clientset.Ingresses(namespace).Get(ingress.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err == nil { // We want it present, and the Get succeeded, so we're all good.
0000000000000000000000000000000000000000;;				if equivalentIngress(*clusterIngress, *ingress) {
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Success: shard of federated ingress %q in namespace %q in cluster is updated", ingress.Name, namespace))
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Ingress %q in namespace %q in cluster, waiting for service being updated, trying again in %s (err=%v)", ingress.Name, namespace, framework.Poll, err))
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Ingress %q in namespace %q in cluster, waiting for service being updated, trying again in %s (err=%v)", ingress.Name, namespace, framework.Poll, err))
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Failed to verify ingress %q in namespace %q in cluster", ingress.Name, namespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForIngressShardsGoneOrFail waits for the ingress to disappear in all clusters
0000000000000000000000000000000000000000;;	func waitForIngressShardsGoneOrFail(namespace string, ingress *v1beta1.Ingress, clusters fedframework.ClusterSlice) {
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for ingress %q in %d clusters", ingress.Name, len(clusters))
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			waitForIngressOrFail(c.Clientset, namespace, ingress, false, FederatedIngressTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteIngressOrFail(clientset *fedclientset.Clientset, namespace string, ingressName string, orphanDependents *bool) {
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 || len(ingressName) == 0 {
0000000000000000000000000000000000000000;;			Fail(fmt.Sprintf("Internal error: invalid parameters passed to deleteIngressOrFail: clientset: %v, namespace: %v, ingress: %v", clientset, namespace, ingressName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := clientset.Ingresses(namespace).Delete(ingressName, &metav1.DeleteOptions{OrphanDependents: orphanDependents})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Error deleting ingress %q from namespace %q", ingressName, namespace)
0000000000000000000000000000000000000000;;		// Wait for the ingress to be deleted.
0000000000000000000000000000000000000000;;		err = wait.Poll(framework.Poll, FederatedIngressDeleteTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := clientset.Extensions().Ingresses(namespace).Get(ingressName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error in deleting ingress %s: %v", ingressName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: quinton: This is largely a cut 'n paste of the above.  Yuck! Refactor as soon as we have a common interface implmented by both fedclientset.Clientset and kubeclientset.Clientset
0000000000000000000000000000000000000000;;	func deleteClusterIngressOrFail(clusterName string, clientset *kubeclientset.Clientset, namespace string, ingressName string) {
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 || len(ingressName) == 0 {
0000000000000000000000000000000000000000;;			Fail(fmt.Sprintf("Internal error: invalid parameters passed to deleteClusterIngressOrFail: cluster: %q, clientset: %v, namespace: %v, ingress: %v", clusterName, clientset, namespace, ingressName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := clientset.Ingresses(namespace).Delete(ingressName, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Error deleting cluster ingress %q/%q from cluster %q", namespace, ingressName, clusterName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createIngressOrFail(clientset *fedclientset.Clientset, namespace, serviceName, secretName string) *v1beta1.Ingress {
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 {
0000000000000000000000000000000000000000;;			Fail(fmt.Sprintf("Internal error: invalid parameters passed to createIngressOrFail: clientset: %v, namespace: %v", clientset, namespace))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating federated ingress %q in namespace %q", FederatedIngressName, namespace))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ingress := &v1beta1.Ingress{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: FederatedIngressName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.IngressSpec{
0000000000000000000000000000000000000000;;				Backend: &v1beta1.IngressBackend{
0000000000000000000000000000000000000000;;					ServiceName: serviceName,
0000000000000000000000000000000000000000;;					ServicePort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				TLS: []v1beta1.IngressTLS{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						SecretName: secretName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newIng, err := clientset.Extensions().Ingresses(namespace).Create(ingress)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Creating ingress %q in namespace %q", ingress.Name, namespace)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully created federated ingress %q in namespace %q", FederatedIngressName, namespace))
0000000000000000000000000000000000000000;;		return newIng
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateIngressOrFail(clientset *fedclientset.Clientset, namespace string) (newIng *v1beta1.Ingress) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 {
0000000000000000000000000000000000000000;;			Fail(fmt.Sprintf("Internal error: invalid parameters passed to createIngressOrFail: clientset: %v, namespace: %v", clientset, namespace))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ingress := &v1beta1.Ingress{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: FederatedIngressName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.IngressSpec{
0000000000000000000000000000000000000000;;				Backend: &v1beta1.IngressBackend{
0000000000000000000000000000000000000000;;					ServiceName: "updated-testingress-service",
0000000000000000000000000000000000000000;;					ServicePort: intstr.FromInt(80),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = waitForFederatedIngressExists(clientset, namespace, FederatedIngressName, FederatedIngressTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("failed to get ingress %q: %v", FederatedIngressName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < MaxRetriesOnFederatedApiserver; i++ {
0000000000000000000000000000000000000000;;			newIng, err = clientset.Extensions().Ingresses(namespace).Update(ingress)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				framework.DescribeIng(namespace)
0000000000000000000000000000000000000000;;				return newIng
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsConflict(err) && !errors.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;				framework.Failf("failed to update ingress %q: %v", FederatedIngressName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Failf("too many retries updating ingress %q", FederatedIngressName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *federationTestJig) waitForFederatedIngress() {
0000000000000000000000000000000000000000;;		// Wait for the loadbalancer IP.
0000000000000000000000000000000000000000;;		address, err := waitForFederatedIngressAddress(j.client, j.ing.Namespace, j.ing.Name, framework.LoadBalancerPollTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Ingress failed to acquire an IP address within %v", framework.LoadBalancerPollTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		j.address = address
0000000000000000000000000000000000000000;;		framework.Logf("Found address %v for ingress %v", j.address, j.ing.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := &http.Client{
0000000000000000000000000000000000000000;;			// This is mostly `http.DefaultTransport` except for the
0000000000000000000000000000000000000000;;			// `TLSClientConfig`.
0000000000000000000000000000000000000000;;			Transport: utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;				TLSClientConfig: &tls.Config{
0000000000000000000000000000000000000000;;					InsecureSkipVerify: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			Timeout: reqTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that simple GET works.
0000000000000000000000000000000000000000;;		route := fmt.Sprintf("https://%v", address)
0000000000000000000000000000000000000000;;		framework.Logf("Testing route %v with simple GET", route)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(framework.PollURL(route, FederatedIngressHost, framework.LoadBalancerPollTimeout, framework.LoadBalancerPollInterval, client, false))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTLSSecretOrFail(clientset *fedclientset.Clientset, namespace, secretName string) *v1.Secret {
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 {
0000000000000000000000000000000000000000;;			framework.Logf("Internal error: invalid parameters passed to createTLSSecretOrFail: clientset: %v, namespace: %v", clientset, namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secret := &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: secretName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: v1.SecretTypeOpaque,
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"tls.crt": []byte(FederatedIngressTLSCrt),
0000000000000000000000000000000000000000;;				"tls.key": []byte(FederatedIngressTLSKey),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating federated secret %q in namespace %q", secretName, namespace))
0000000000000000000000000000000000000000;;		newSecret, err := clientset.Core().Secrets(namespace).Create(secret)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "creating secret %q in namespace %q", secret.Name, namespace)
0000000000000000000000000000000000000000;;		return newSecret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type federationTestJig struct {
0000000000000000000000000000000000000000;;		// TODO add TLS check later
0000000000000000000000000000000000000000;;		rootCAs map[string][]byte
0000000000000000000000000000000000000000;;		address string
0000000000000000000000000000000000000000;;		ing     *v1beta1.Ingress
0000000000000000000000000000000000000000;;		client  *fedclientset.Clientset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFederationTestJig(c *fedclientset.Clientset) *federationTestJig {
0000000000000000000000000000000000000000;;		return &federationTestJig{client: c, rootCAs: map[string][]byte{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForFederatedIngressAddress waits for the Ingress to acquire an address.
0000000000000000000000000000000000000000;;	func waitForFederatedIngressAddress(c *fedclientset.Clientset, ns, ingName string, timeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		var address string
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(10*time.Second, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			ipOrNameList, err := getFederatedIngressAddress(c, ns, ingName)
0000000000000000000000000000000000000000;;			if err != nil || len(ipOrNameList) == 0 {
0000000000000000000000000000000000000000;;				framework.Logf("Waiting for Ingress %v to acquire IP, error %v", ingName, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			address = ipOrNameList[0]
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return address, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForFederatedIngressExists waits for the Ingress object exists.
0000000000000000000000000000000000000000;;	func waitForFederatedIngressExists(c *fedclientset.Clientset, ns, ingName string, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(10*time.Second, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := c.Extensions().Ingresses(ns).Get(ingName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Waiting for Ingress %v, error %v", ingName, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getFederatedIngressAddress returns the ips/hostnames associated with the Ingress.
0000000000000000000000000000000000000000;;	func getFederatedIngressAddress(client *fedclientset.Clientset, ns, name string) ([]string, error) {
0000000000000000000000000000000000000000;;		ing, err := client.Extensions().Ingresses(ns).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addresses := []string{}
0000000000000000000000000000000000000000;;		for _, a := range ing.Status.LoadBalancer.Ingress {
0000000000000000000000000000000000000000;;			if a.IP != "" {
0000000000000000000000000000000000000000;;				addresses = append(addresses, a.IP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a.Hostname != "" {
0000000000000000000000000000000000000000;;				addresses = append(addresses, a.Hostname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addresses, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForSecretShardsOrFail(nsName string, secret *v1.Secret, clusters fedframework.ClusterSlice) {
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for secret %q in %d clusters", secret.Name, len(clusters))
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			waitForSecretOrFail(c.Clientset, nsName, secret, true, FederatedSecretTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForSecretOrFail(clientset *kubeclientset.Clientset, nsName string, secret *v1.Secret, present bool, timeout time.Duration) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Fetching a federated secret shard of secret %q in namespace %q from cluster", secret.Name, nsName))
0000000000000000000000000000000000000000;;		var clusterSecret *v1.Secret
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(framework.Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			clusterSecret, err = clientset.Core().Secrets(nsName).Get(secret.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if (!present) && errors.IsNotFound(err) { // We want it gone, and it's gone.
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Success: shard of federated secret %q in namespace %q in cluster is absent", secret.Name, nsName))
0000000000000000000000000000000000000000;;				return true, nil // Success
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if present && err == nil { // We want it present, and the Get succeeded, so we're all good.
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Success: shard of federated secret %q in namespace %q in cluster is present", secret.Name, nsName))
0000000000000000000000000000000000000000;;				return true, nil // Success
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Secret %q in namespace %q in cluster.  Found: %v, waiting for Found: %v, trying again in %s (err=%v)", secret.Name, nsName, clusterSecret != nil && err == nil, present, framework.Poll, err))
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Failed to verify secret %q in namespace %q in cluster: Present=%v", secret.Name, nsName, present)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if present && clusterSecret != nil {
0000000000000000000000000000000000000000;;			Expect(util.SecretEquivalent(*clusterSecret, *secret))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteSecretOrFail(clientset *fedclientset.Clientset, nsName string, secretName string, orphanDependents *bool) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Deleting secret %q in namespace %q", secretName, nsName))
0000000000000000000000000000000000000000;;		err := clientset.Core().Secrets(nsName).Delete(secretName, &metav1.DeleteOptions{OrphanDependents: orphanDependents})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Error deleting secret %q in namespace %q", secretName, nsName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the secret to be deleted.
0000000000000000000000000000000000000000;;		err = wait.Poll(5*time.Second, wait.ForeverTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := clientset.Core().Secrets(nsName).Get(secretName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error in deleting secret %s: %v", secretName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
