0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4bf04519e4b972f6a55224a8a10d9b30e183a221;test/e2e/federation-apiserver.go[test/e2e/federation-apiserver.go][test/e2e_federation/apiserver.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		fedframework "k8s.io/kubernetes/test/e2e_federation/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create/delete cluster api objects
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Federation apiserver [Feature:Federation]", func() {
0000000000000000000000000000000000000000;;		f := fedframework.NewDefaultFederatedFramework("federation-cluster")
0000000000000000000000000000000000000000;;		testClusterPrefix := "test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Describe("Cluster objects [Serial]", func() {
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Delete registered clusters.
0000000000000000000000000000000000000000;;				// This is if a test failed, it should not affect other tests.
0000000000000000000000000000000000000000;;				clusterList, err := f.FederationClientset.Federation().Clusters().List(metav1.ListOptions{LabelSelector: "prefix=" + testClusterPrefix})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				for _, cluster := range clusterList.Items {
0000000000000000000000000000000000000000;;					err := f.FederationClientset.Federation().Clusters().Delete(cluster.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be created and deleted successfully", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				contexts := f.GetUnderlyingFederatedContexts()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creating %d cluster objects", len(contexts)))
0000000000000000000000000000000000000000;;				for _, context := range contexts {
0000000000000000000000000000000000000000;;					createClusterObjectOrFail(f, &context, testClusterPrefix)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Checking that %d clusters are ready", len(contexts)))
0000000000000000000000000000000000000000;;				for _, context := range contexts {
0000000000000000000000000000000000000000;;					fedframework.ClusterIsReadyOrFail(f, context.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("%d clusters are Ready", len(contexts))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Verify that deletion works.
0000000000000000000000000000000000000000;;				framework.Logf("Deleting %d clusters", len(contexts))
0000000000000000000000000000000000000000;;				for _, context := range contexts {
0000000000000000000000000000000000000000;;					clusterName := testClusterPrefix + context.Name
0000000000000000000000000000000000000000;;					framework.Logf("Deleting cluster object: %s (%s, secret: %s)", clusterName, context.Cluster.Cluster.Server, context.Name)
0000000000000000000000000000000000000000;;					err := f.FederationClientset.Federation().Clusters().Delete(clusterName, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, fmt.Sprintf("unexpected error in deleting cluster %s: %+v", clusterName, err))
0000000000000000000000000000000000000000;;					framework.Logf("Successfully deleted cluster object: %s (%s, secret: %s)", clusterName, context.Cluster.Cluster.Server, context.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// There should not be any remaining cluster.
0000000000000000000000000000000000000000;;				framework.Logf("Verifying that zero test clusters remain")
0000000000000000000000000000000000000000;;				clusterList, err := f.FederationClientset.Federation().Clusters().List(metav1.ListOptions{LabelSelector: "prefix=" + testClusterPrefix})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				if len(clusterList.Items) != 0 {
0000000000000000000000000000000000000000;;					framework.Failf("there should not have been any remaining clusters. Found: %+v", clusterList)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.Logf("Verified that zero clusters remain")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Describe("Admission control [NoCluster]", func() {
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should not be able to create resources if namespace does not exist", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Creating a service in a non-existing namespace should fail.
0000000000000000000000000000000000000000;;				svcNamespace := "federation-admission-test-ns"
0000000000000000000000000000000000000000;;				svcName := "myns"
0000000000000000000000000000000000000000;;				clientset := f.FederationClientset
0000000000000000000000000000000000000000;;				framework.Logf("Trying to create service %s in namespace %s, expect to get error", svcName, svcNamespace)
0000000000000000000000000000000000000000;;				if _, err := clientset.Core().Services(svcNamespace).Create(newService(svcName, svcNamespace)); err == nil {
0000000000000000000000000000000000000000;;					framework.Failf("Expected to get an error while creating a service in a non-existing namespace")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Note: We have other tests that verify that we can create resources in existing namespaces, so we dont test it again here.
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newService(name, namespace string) *v1.Service {
0000000000000000000000000000000000000000;;		return &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Port: 80,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
