0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
e26a0a8c6a0236b3358e8f0d1b3b25e6b5e6cdbc;test/e2e/federation-authn.go[test/e2e/federation-authn.go][test/e2e_federation/authn.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		fedframework "k8s.io/kubernetes/test/e2e_federation/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: These tests should be integration tests rather than e2e tests, when the
0000000000000000000000000000000000000000;;	// integration test harness is ready.
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("[Feature:Federation]", func() {
0000000000000000000000000000000000000000;;		f := fedframework.NewDefaultFederatedFramework("federation-apiserver-authn")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var _ = Describe("Federation API server authentication [NoCluster]", func() {
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should accept cluster resources when the client has certificate authentication credentials", func() {
0000000000000000000000000000000000000000;;				fcs, err := federationClientSetWithCert()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				svc := createServiceOrFail(fcs, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;				deleteServiceOrFail(f.FederationClientset, nsName, svc.Name, nil)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should accept cluster resources when the client has HTTP Basic authentication credentials", func() {
0000000000000000000000000000000000000000;;				fcs, err := federationClientSetWithBasicAuth(true /* valid */)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				svc, err := createService(fcs, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				deleteServiceOrFail(fcs, nsName, svc.Name, nil)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should accept cluster resources when the client has token authentication credentials", func() {
0000000000000000000000000000000000000000;;				fcs, err := federationClientSetWithToken(true /* valid */)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				svc, err := createService(fcs, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				deleteServiceOrFail(fcs, nsName, svc.Name, nil)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should not accept cluster resources when the client has no authentication credentials", func() {
0000000000000000000000000000000000000000;;				fcs, err := unauthenticatedFederationClientSet()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				_, err = createService(fcs, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;				Expect(errors.IsUnauthorized(err)).To(BeTrue())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: Add a test for invalid certificate credentials. The certificate is validated for
0000000000000000000000000000000000000000;;			// correct format, so it cannot contain random noise.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should not accept cluster resources when the client has invalid HTTP Basic authentication credentials", func() {
0000000000000000000000000000000000000000;;				fcs, err := federationClientSetWithBasicAuth(false /* invalid */)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				_, err = createService(fcs, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;				Expect(errors.IsUnauthorized(err)).To(BeTrue())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should not accept cluster resources when the client has invalid token authentication credentials", func() {
0000000000000000000000000000000000000000;;				fcs, err := federationClientSetWithToken(false /* invalid */)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;				_, err = createService(fcs, nsName, FederatedServiceName)
0000000000000000000000000000000000000000;;				Expect(errors.IsUnauthorized(err)).To(BeTrue())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unauthenticatedFederationClientSet returns a Federation Clientset configured with
0000000000000000000000000000000000000000;;	// no authentication credentials.
0000000000000000000000000000000000000000;;	func unauthenticatedFederationClientSet() (*federation_clientset.Clientset, error) {
0000000000000000000000000000000000000000;;		config, err := fedframework.LoadFederatedConfig(&clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.Insecure = true
0000000000000000000000000000000000000000;;		config.CAData = []byte{}
0000000000000000000000000000000000000000;;		config.CertData = []byte{}
0000000000000000000000000000000000000000;;		config.KeyData = []byte{}
0000000000000000000000000000000000000000;;		config.BearerToken = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := federation_clientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating federation clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// federationClientSetWithCert returns a Federation Clientset configured with
0000000000000000000000000000000000000000;;	// certificate authentication credentials.
0000000000000000000000000000000000000000;;	func federationClientSetWithCert() (*federation_clientset.Clientset, error) {
0000000000000000000000000000000000000000;;		config, err := fedframework.LoadFederatedConfig(&clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.BearerToken = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := federation_clientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating federation clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// federationClientSetWithBasicAuth returns a Federation Clientset configured with
0000000000000000000000000000000000000000;;	// HTTP Basic authentication credentials.
0000000000000000000000000000000000000000;;	func federationClientSetWithBasicAuth(valid bool) (*federation_clientset.Clientset, error) {
0000000000000000000000000000000000000000;;		config, err := fedframework.LoadFederatedConfig(&clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.Insecure = true
0000000000000000000000000000000000000000;;		config.CAData = []byte{}
0000000000000000000000000000000000000000;;		config.CertData = []byte{}
0000000000000000000000000000000000000000;;		config.KeyData = []byte{}
0000000000000000000000000000000000000000;;		config.BearerToken = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !valid {
0000000000000000000000000000000000000000;;			config.Username = ""
0000000000000000000000000000000000000000;;			config.Password = ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// This is a hacky approach to getting the basic auth credentials, but since
0000000000000000000000000000000000000000;;			// the token and the username/password cannot live in the same AuthInfo object,
0000000000000000000000000000000000000000;;			// and because we do not want to store basic auth credentials with token and
0000000000000000000000000000000000000000;;			// certificate credentials for security reasons, we must dig it out by hand.
0000000000000000000000000000000000000000;;			c, err := framework.RestclientConfig(framework.TestContext.FederatedKubeContext)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if authInfo, ok := c.AuthInfos[fmt.Sprintf("%s-basic-auth", framework.TestContext.FederatedKubeContext)]; ok {
0000000000000000000000000000000000000000;;				config.Username = authInfo.Username
0000000000000000000000000000000000000000;;				config.Password = authInfo.Password
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := federation_clientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating federation clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// federationClientSetWithToken returns a Federation Clientset configured with
0000000000000000000000000000000000000000;;	// token authentication credentials.
0000000000000000000000000000000000000000;;	func federationClientSetWithToken(valid bool) (*federation_clientset.Clientset, error) {
0000000000000000000000000000000000000000;;		config, err := fedframework.LoadFederatedConfig(&clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.Insecure = true
0000000000000000000000000000000000000000;;		config.CAData = []byte{}
0000000000000000000000000000000000000000;;		config.CertData = []byte{}
0000000000000000000000000000000000000000;;		config.KeyData = []byte{}
0000000000000000000000000000000000000000;;		config.Username = ""
0000000000000000000000000000000000000000;;		config.Password = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !valid {
0000000000000000000000000000000000000000;;			config.BearerToken = "invalid"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := federation_clientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating federation clientset: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
