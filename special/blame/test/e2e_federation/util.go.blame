0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bd1e42e8eb2a60f7b10b68fb82ed7d570a74848b;test/e2e/federation-util.go[test/e2e/federation-util.go][test/e2e_federation/util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/rand"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/common"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		fedframework "k8s.io/kubernetes/test/e2e_federation/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		DefaultFederationName = "e2e-federation"
0000000000000000000000000000000000000000;;		// We use this to decide how long to wait for our DNS probes to succeed.
0000000000000000000000000000000000000000;;		DNSTTL = 180 * time.Second // TODO: make k8s.io/kubernetes/federation/pkg/federation-controller/service.minDnsTtl exported, and import it here.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// [30000, 32767] is the allowed default service nodeport range and our
0000000000000000000000000000000000000000;;		// tests just use the defaults.
0000000000000000000000000000000000000000;;		FederatedSvcNodePortFirst = 30000
0000000000000000000000000000000000000000;;		FederatedSvcNodePortLast  = 32767
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var FederationSuite common.Suite
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createClusterObjectOrFail(f *fedframework.Framework, context *fedframework.E2EContext, clusterNamePrefix string) {
0000000000000000000000000000000000000000;;		clusterName := clusterNamePrefix + context.Name
0000000000000000000000000000000000000000;;		framework.Logf("Creating cluster object: %s (%s, secret: %s)", clusterName, context.Cluster.Cluster.Server, context.Name)
0000000000000000000000000000000000000000;;		cluster := federationapi.Cluster{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: clusterName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: federationapi.ClusterSpec{
0000000000000000000000000000000000000000;;				ServerAddressByClientCIDRs: []federationapi.ServerAddressByClientCIDR{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ClientCIDR:    "0.0.0.0/0",
0000000000000000000000000000000000000000;;						ServerAddress: context.Cluster.Cluster.Server,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;					// Note: Name must correlate with federation build script secret name,
0000000000000000000000000000000000000000;;					//       which currently matches the cluster name.
0000000000000000000000000000000000000000;;					//       See federation/cluster/common.sh:132
0000000000000000000000000000000000000000;;					Name: context.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if clusterNamePrefix != "" {
0000000000000000000000000000000000000000;;			cluster.Labels = map[string]string{"prefix": clusterNamePrefix}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := f.FederationClientset.Federation().Clusters().Create(&cluster)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, fmt.Sprintf("creating cluster: %+v", err))
0000000000000000000000000000000000000000;;		framework.Logf("Successfully created cluster object: %s (%s, secret: %s)", clusterName, context.Cluster.Cluster.Server, context.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForServiceOrFail waits until a service is either present or absent in the cluster specified by clientset.
0000000000000000000000000000000000000000;;	// If the condition is not met within timout, it fails the calling test.
0000000000000000000000000000000000000000;;	func waitForServiceOrFail(clientset *kubeclientset.Clientset, namespace string, service *v1.Service, present bool, timeout time.Duration) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Fetching a federated service shard of service %q in namespace %q from cluster", service.Name, namespace))
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(framework.Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			clusterService, err := clientset.Services(namespace).Get(service.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if (!present) && errors.IsNotFound(err) { // We want it gone, and it's gone.
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Success: shard of federated service %q in namespace %q in cluster is absent", service.Name, namespace))
0000000000000000000000000000000000000000;;				return true, nil // Success
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if present && err == nil { // We want it present, and the Get succeeded, so we're all good.
0000000000000000000000000000000000000000;;				if equivalent(*clusterService, *service) {
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Success: shard of federated service %q in namespace %q in cluster is present", service.Name, namespace))
0000000000000000000000000000000000000000;;					return true, nil // Success
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Service %q in namespace %q in cluster.  Found: %v, waiting for Found: %v, trying again in %s (err=%v)", service.Name, namespace, clusterService != nil && err == nil, present, framework.Poll, err))
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Failed to verify service %q in namespace %q in cluster: Present=%v", service.Name, namespace, present)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForServiceShardsOrFail waits for the service to appear in all clusters
0000000000000000000000000000000000000000;;	func waitForServiceShardsOrFail(namespace string, service *v1.Service, clusters fedframework.ClusterSlice) {
0000000000000000000000000000000000000000;;		framework.Logf("Waiting for service %q in %d clusters", service.Name, len(clusters))
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			waitForServiceOrFail(c.Clientset, namespace, service, true, fedframework.FederatedDefaultTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createService(clientset *fedclientset.Clientset, namespace, name string) (*v1.Service, error) {
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Internal error: invalid parameters passed to createService: clientset: %v, namespace: %v", clientset, namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating federated service %q in namespace %q", name, namespace))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: FederatedServiceLabels,
0000000000000000000000000000000000000000;;				Type:     v1.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       "http",
0000000000000000000000000000000000000000;;						Protocol:   v1.ProtocolTCP,
0000000000000000000000000000000000000000;;						Port:       80,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(8080),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SessionAffinity: v1.ServiceAffinityNone,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Trying to create service %q in namespace %q", service.Name, namespace))
0000000000000000000000000000000000000000;;		return clientset.Services(namespace).Create(service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createLBService(clientset *fedclientset.Clientset, namespace, name string) (*v1.Service, error) {
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Internal error: invalid parameters passed to createService: clientset: %v, namespace: %v", clientset, namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating federated service (type: load balancer) %q in namespace %q", name, namespace))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tests can be run in parallel, so we need a different nodePort for
0000000000000000000000000000000000000000;;		// each test.
0000000000000000000000000000000000000000;;		// We add 1 to FederatedSvcNodePortLast because IntnRange's range end
0000000000000000000000000000000000000000;;		// is not inclusive.
0000000000000000000000000000000000000000;;		nodePort := int32(rand.IntnRange(FederatedSvcNodePortFirst, FederatedSvcNodePortLast+1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Selector: FederatedServiceLabels,
0000000000000000000000000000000000000000;;				Type:     v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       "http",
0000000000000000000000000000000000000000;;						Protocol:   v1.ProtocolTCP,
0000000000000000000000000000000000000000;;						Port:       80,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromInt(8080),
0000000000000000000000000000000000000000;;						NodePort:   nodePort,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SessionAffinity: v1.ServiceAffinityNone,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Trying to create service %q in namespace %q", service.Name, namespace))
0000000000000000000000000000000000000000;;		return clientset.Services(namespace).Create(service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createServiceOrFail(clientset *fedclientset.Clientset, namespace, name string) *v1.Service {
0000000000000000000000000000000000000000;;		service, err := createService(clientset, namespace, name)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Creating service %q in namespace %q", service.Name, namespace)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully created federated service %q in namespace %q", name, namespace))
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createLBServiceOrFail(clientset *fedclientset.Clientset, namespace, name string) *v1.Service {
0000000000000000000000000000000000000000;;		service, err := createLBService(clientset, namespace, name)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Creating service %q in namespace %q", service.Name, namespace)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully created federated service (type: load balancer) %q in namespace %q", name, namespace))
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteServiceOrFail(clientset *fedclientset.Clientset, namespace string, serviceName string, orphanDependents *bool) {
0000000000000000000000000000000000000000;;		if clientset == nil || len(namespace) == 0 || len(serviceName) == 0 {
0000000000000000000000000000000000000000;;			Fail(fmt.Sprintf("Internal error: invalid parameters passed to deleteServiceOrFail: clientset: %v, namespace: %v, service: %v", clientset, namespace, serviceName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.Logf("Deleting service %q in namespace %v", serviceName, namespace)
0000000000000000000000000000000000000000;;		err := clientset.Services(namespace).Delete(serviceName, &metav1.DeleteOptions{OrphanDependents: orphanDependents})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Error deleting service %q from namespace %q", serviceName, namespace)
0000000000000000000000000000000000000000;;		// Wait for the service to be deleted.
0000000000000000000000000000000000000000;;		err = wait.Poll(5*time.Second, fedframework.FederatedDefaultTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := clientset.Core().Services(namespace).Get(serviceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.DescribeSvc(namespace)
0000000000000000000000000000000000000000;;			framework.Failf("Error in deleting service %s: %v", serviceName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cleanupServiceShardsAndProviderResources(namespace string, service *v1.Service, clusters fedframework.ClusterSlice) {
0000000000000000000000000000000000000000;;		framework.Logf("Deleting service %q in %d clusters", service.Name, len(clusters))
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			name := c.Name
0000000000000000000000000000000000000000;;			var cSvc *v1.Service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := wait.PollImmediate(framework.Poll, fedframework.FederatedDefaultTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				cSvc, err = c.Clientset.Services(namespace).Get(service.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					// Get failed with an error, try again.
0000000000000000000000000000000000000000;;					framework.Logf("Failed to find service %q in namespace %q, in cluster %q: %v. Trying again in %s", service.Name, namespace, name, err, framework.Poll)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				} else if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					cSvc = nil
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Service %q in namespace %q in cluster %q not found", service.Name, namespace, name))
0000000000000000000000000000000000000000;;					return true, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Service %q in namespace %q in cluster %q found", service.Name, namespace, name))
0000000000000000000000000000000000000000;;				return true, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil || cSvc == nil {
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Failed to find service %q in namespace %q, in cluster %q in %s", service.Name, namespace, name, fedframework.FederatedDefaultTestTimeout))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cSvc.Spec.Type == v1.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;				// In federation tests, e2e zone names are used to derive federation member cluster names
0000000000000000000000000000000000000000;;				zone := fedframework.GetZoneFromClusterName(name)
0000000000000000000000000000000000000000;;				serviceLBName := cloudprovider.GetLoadBalancerName(cSvc)
0000000000000000000000000000000000000000;;				framework.Logf("cleaning cloud provider resource for service %q in namespace %q, in cluster %q", service.Name, namespace, name)
0000000000000000000000000000000000000000;;				framework.CleanupServiceResources(c.Clientset, serviceLBName, zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = cleanupServiceShard(c.Clientset, name, namespace, cSvc, fedframework.FederatedDefaultTestTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Failed to delete service %q in namespace %q, in cluster %q: %v", service.Name, namespace, name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cleanupServiceShard(clientset *kubeclientset.Clientset, clusterName, namespace string, service *v1.Service, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(framework.Poll, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			err := clientset.Services(namespace).Delete(service.Name, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;			if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// Deletion failed with an error, try again.
0000000000000000000000000000000000000000;;				framework.Logf("Failed to delete service %q in namespace %q, in cluster %q", service.Name, namespace, clusterName)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Service %q in namespace %q in cluster %q deleted", service.Name, namespace, clusterName))
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podExitCodeDetector(f *fedframework.Framework, name, namespace string, code int32) func() error {
0000000000000000000000000000000000000000;;		// If we ever get any container logs, stash them here.
0000000000000000000000000000000000000000;;		logs := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logerr := func(err error) error {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if logs == "" {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s (%v)", logs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			pod, err := f.ClientSet.Core().Pods(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return logerr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pod.Status.ContainerStatuses) < 1 {
0000000000000000000000000000000000000000;;				return logerr(fmt.Errorf("no container statuses"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Best effort attempt to grab pod logs for debugging
0000000000000000000000000000000000000000;;			logs, err = framework.GetPodLogs(f.ClientSet, namespace, name, pod.Spec.Containers[0].Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Cannot fetch pod logs: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status := pod.Status.ContainerStatuses[0]
0000000000000000000000000000000000000000;;			if status.State.Terminated == nil {
0000000000000000000000000000000000000000;;				return logerr(fmt.Errorf("container is not in terminated state"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if status.State.Terminated.ExitCode == code {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return logerr(fmt.Errorf("exited %d", status.State.Terminated.ExitCode))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func discoverService(f *fedframework.Framework, name string, exists bool, podName string) {
0000000000000000000000000000000000000000;;		command := []string{"sh", "-c", fmt.Sprintf("until nslookup '%s'; do sleep 10; done", name)}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Looking up %q", name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "federated-service-discovery-container",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Command: command,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsName := f.FederationNamespace.Name
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating pod %q in namespace %q", pod.Name, nsName))
0000000000000000000000000000000000000000;;		_, err := f.ClientSet.Core().Pods(nsName).Create(pod)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Trying to create pod to run %q", command)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Successfully created pod %q in namespace %q", pod.Name, nsName))
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Deleting pod %q from namespace %q", podName, nsName))
0000000000000000000000000000000000000000;;			err := f.ClientSet.Core().Pods(nsName).Delete(podName, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Deleting pod %q from namespace %q", podName, nsName)
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Deleted pod %q from namespace %q", podName, nsName))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			// TODO(mml): Eventually check the IP address is correct, too.
0000000000000000000000000000000000000000;;			Eventually(podExitCodeDetector(f, podName, nsName, 0), 3*DNSTTL, time.Second*2).
0000000000000000000000000000000000000000;;				Should(BeNil(), "%q should exit 0, but it never did", command)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			Eventually(podExitCodeDetector(f, podName, nsName, 0), 3*DNSTTL, time.Second*2).
0000000000000000000000000000000000000000;;				ShouldNot(BeNil(), "%q should eventually not exit 0, but it always did", command)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BackendPodMap maps a cluster name to a backend pod created in that cluster
0000000000000000000000000000000000000000;;	type BackendPodMap map[string]*v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createBackendPodsOrFail creates one pod in each cluster, and returns the created pods.  If creation of any pod fails,
0000000000000000000000000000000000000000;;	// the test fails (possibly with a partially created set of pods). No retries are attempted.
0000000000000000000000000000000000000000;;	func createBackendPodsOrFail(clusters fedframework.ClusterSlice, namespace string, name string) BackendPodMap {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				// Namespace: namespace,
0000000000000000000000000000000000000000;;				Labels: FederatedServiceLabels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  name,
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/echoserver:1.6",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podMap := make(BackendPodMap)
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			name := c.Name
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Creating pod %q in namespace %q in cluster %q", pod.Name, namespace, name))
0000000000000000000000000000000000000000;;			createdPod, err := c.Clientset.Core().Pods(namespace).Create(pod)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Creating pod %q in namespace %q in cluster %q", name, namespace, name)
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Successfully created pod %q in namespace %q in cluster %q: %v", pod.Name, namespace, name, *createdPod))
0000000000000000000000000000000000000000;;			podMap[name] = createdPod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return podMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteOneBackendPodOrFail deletes exactly one backend pod which must not be nil
0000000000000000000000000000000000000000;;	// The test fails if there are any errors.
0000000000000000000000000000000000000000;;	func deleteOneBackendPodOrFail(c *fedframework.Cluster, pod *v1.Pod) {
0000000000000000000000000000000000000000;;		Expect(pod).ToNot(BeNil())
0000000000000000000000000000000000000000;;		err := c.Clientset.Core().Pods(pod.Namespace).Delete(pod.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		msgFmt := fmt.Sprintf("Deleting Pod %q in namespace %q in cluster %q %%v", pod.Name, pod.Namespace, c.Name)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			framework.Logf(msgFmt, "does not exist. No need to delete it.")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, msgFmt, "")
0000000000000000000000000000000000000000;;		framework.Logf(msgFmt, "was deleted")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteBackendPodsOrFail deletes one pod from each cluster that has one.
0000000000000000000000000000000000000000;;	// If deletion of any pod fails, the test fails (possibly with a partially deleted set of pods). No retries are attempted.
0000000000000000000000000000000000000000;;	func deleteBackendPodsOrFail(clusters fedframework.ClusterSlice, backendPods BackendPodMap) {
0000000000000000000000000000000000000000;;		if backendPods == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range clusters {
0000000000000000000000000000000000000000;;			if pod, ok := backendPods[c.Name]; ok {
0000000000000000000000000000000000000000;;				deleteOneBackendPodOrFail(c, pod)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("No backend pod to delete for cluster %q", c.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForReplicatSetToBeDeletedOrFail waits for the named ReplicaSet in namespace to be deleted.
0000000000000000000000000000000000000000;;	// If the deletion fails, the enclosing test fails.
0000000000000000000000000000000000000000;;	func waitForReplicaSetToBeDeletedOrFail(clientset *fedclientset.Clientset, namespace string, replicaSet string) {
0000000000000000000000000000000000000000;;		err := wait.Poll(5*time.Second, fedframework.FederatedDefaultTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := clientset.Extensions().ReplicaSets(namespace).Get(replicaSet, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Error in deleting replica set %s: %v", replicaSet, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
