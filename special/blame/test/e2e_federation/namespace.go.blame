0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9e2ad63b09ae1086353cefe4576f08d62f4ed536;test/e2e/federated-namespace.go[test/e2e/federated-namespace.go][test/e2e_federation/namespace.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		fedframework "k8s.io/kubernetes/test/e2e_federation/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		eventNamePrefix      = "e2e-namespace-test-event-"
0000000000000000000000000000000000000000;;		namespacePrefix      = "e2e-namespace-test-"
0000000000000000000000000000000000000000;;		replicaSetNamePrefix = "e2e-namespace-test-rs-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create/delete ingress api objects
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Federation namespace [Feature:Federation]", func() {
0000000000000000000000000000000000000000;;		f := fedframework.NewDefaultFederatedFramework("federation-namespace")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Describe("Namespace objects", func() {
0000000000000000000000000000000000000000;;			var clusters fedframework.ClusterSlice
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var nsName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				clusters = f.GetRegisteredClusters()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;				deleteNamespace(nil, nsName,
0000000000000000000000000000000000000000;;					f.FederationClientset.Core().Namespaces().Get,
0000000000000000000000000000000000000000;;					f.FederationClientset.Core().Namespaces().Delete)
0000000000000000000000000000000000000000;;				for _, cluster := range clusters {
0000000000000000000000000000000000000000;;					deleteNamespace(nil, nsName,
0000000000000000000000000000000000000000;;						cluster.Core().Namespaces().Get,
0000000000000000000000000000000000000000;;						cluster.Core().Namespaces().Delete)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// See https://github.com/kubernetes/kubernetes/issues/38225
0000000000000000000000000000000000000000;;			It("deletes replicasets in the namespace when the namespace is deleted", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName = createNamespace(f.FederationClientset.Core().Namespaces())
0000000000000000000000000000000000000000;;				rsName := k8s_api_v1.SimpleNameGenerator.GenerateName(replicaSetNamePrefix)
0000000000000000000000000000000000000000;;				replicaCount := int32(2)
0000000000000000000000000000000000000000;;				rs := &v1beta1.ReplicaSet{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      rsName,
0000000000000000000000000000000000000000;;						Namespace: nsName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1beta1.ReplicaSetSpec{
0000000000000000000000000000000000000000;;						Replicas: &replicaCount,
0000000000000000000000000000000000000000;;						Selector: &metav1.LabelSelector{
0000000000000000000000000000000000000000;;							MatchLabels: map[string]string{"name": "myrs"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{"name": "myrs"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:  "nginx",
0000000000000000000000000000000000000000;;										Image: "nginx",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creating replicaset %s in namespace %s", rsName, nsName))
0000000000000000000000000000000000000000;;				_, err := f.FederationClientset.Extensions().ReplicaSets(nsName).Create(rs)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to create replicaset %v in namespace %s, err: %s", rs, nsName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Deleting namespace %s", nsName))
0000000000000000000000000000000000000000;;				deleteNamespace(nil, nsName,
0000000000000000000000000000000000000000;;					f.FederationClientset.Core().Namespaces().Get,
0000000000000000000000000000000000000000;;					f.FederationClientset.Core().Namespaces().Delete)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Verify that replicaset %s was deleted as well", rsName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				waitForReplicaSetToBeDeletedOrFail(f.FederationClientset, nsName, rsName)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("all resources in the namespace should be deleted when namespace is deleted", func() {
0000000000000000000000000000000000000000;;				fedframework.SkipUnlessFederated(f.ClientSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nsName = createNamespace(f.FederationClientset.Core().Namespaces())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create resources in the namespace.
0000000000000000000000000000000000000000;;				event := v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      k8s_api_v1.SimpleNameGenerator.GenerateName(eventNamePrefix),
0000000000000000000000000000000000000000;;						Namespace: nsName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:      "Pod",
0000000000000000000000000000000000000000;;						Namespace: nsName,
0000000000000000000000000000000000000000;;						Name:      "sample-pod",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Creating event %s in namespace %s", event.Name, nsName))
0000000000000000000000000000000000000000;;				_, err := f.FederationClientset.Core().Events(nsName).Create(&event)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Failf("Failed to create event %v in namespace %s, err: %s", event, nsName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Deleting namespace %s", nsName))
0000000000000000000000000000000000000000;;				deleteNamespace(nil, nsName,
0000000000000000000000000000000000000000;;					f.FederationClientset.Core().Namespaces().Get,
0000000000000000000000000000000000000000;;					f.FederationClientset.Core().Namespaces().Delete)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Verify that event %s was deleted as well", event.Name))
0000000000000000000000000000000000000000;;				latestEvent, err := f.FederationClientset.Core().Events(nsName).Get(event.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					framework.Failf("Event %s should have been deleted. Found: %v", event.Name, latestEvent)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("Verified that deletion succeeded"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyNsCascadingDeletion verifies that namespaces are deleted from
0000000000000000000000000000000000000000;;	// underlying clusters when orphan dependents is false and they are not
0000000000000000000000000000000000000000;;	// deleted when orphan dependents is true.
0000000000000000000000000000000000000000;;	func verifyNsCascadingDeletion(nsClient clientset.NamespaceInterface, clusters fedframework.ClusterSlice, orphanDependents *bool) string {
0000000000000000000000000000000000000000;;		nsName := createNamespace(nsClient)
0000000000000000000000000000000000000000;;		// Check subclusters if the namespace was created there.
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Waiting for namespace %s to be created in all underlying clusters", nsName))
0000000000000000000000000000000000000000;;		err := wait.Poll(5*time.Second, 2*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			for _, cluster := range clusters {
0000000000000000000000000000000000000000;;				_, err := cluster.Core().Namespaces().Get(nsName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Not all namespaces created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Deleting namespace %s", nsName))
0000000000000000000000000000000000000000;;		deleteNamespace(orphanDependents, nsName, nsClient.Get, nsClient.Delete)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Verifying namespaces %s in underlying clusters", nsName))
0000000000000000000000000000000000000000;;		errMessages := []string{}
0000000000000000000000000000000000000000;;		// namespace should be present in underlying clusters unless orphanDependents is false.
0000000000000000000000000000000000000000;;		shouldExist := orphanDependents == nil || *orphanDependents == true
0000000000000000000000000000000000000000;;		for _, cluster := range clusters {
0000000000000000000000000000000000000000;;			clusterName := cluster.Name
0000000000000000000000000000000000000000;;			_, err := cluster.Core().Namespaces().Get(nsName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if shouldExist && errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				errMessages = append(errMessages, fmt.Sprintf("unexpected NotFound error for namespace %s in cluster %s, expected namespace to exist", nsName, clusterName))
0000000000000000000000000000000000000000;;			} else if !shouldExist && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				errMessages = append(errMessages, fmt.Sprintf("expected NotFound error for namespace %s in cluster %s, got error: %v", nsName, clusterName, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errMessages) != 0 {
0000000000000000000000000000000000000000;;			framework.Failf("%s", strings.Join(errMessages, "; "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nsName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createNamespace(nsClient clientset.NamespaceInterface) string {
0000000000000000000000000000000000000000;;		ns := v1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: k8s_api_v1.SimpleNameGenerator.GenerateName(namespacePrefix),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating namespace %s", ns.Name))
0000000000000000000000000000000000000000;;		_, err := nsClient.Create(&ns)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "Failed to create namespace %s", ns.Name)
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Created namespace %s", ns.Name))
0000000000000000000000000000000000000000;;		return ns.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteNamespace(orphanDependents *bool, namespace string, getter func(name string, options metav1.GetOptions) (*v1.Namespace, error), deleter func(string, *metav1.DeleteOptions) error) {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Deleting namespace: %s", namespace))
0000000000000000000000000000000000000000;;		err := deleter(namespace, &metav1.DeleteOptions{OrphanDependents: orphanDependents})
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to set %s for deletion: %v", namespace, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitForNamespaceDeletion(namespace, getter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForNamespaceDeletion(namespace string, getter func(name string, options metav1.GetOptions) (*v1.Namespace, error)) {
0000000000000000000000000000000000000000;;		err := wait.Poll(5*time.Second, 2*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := getter(namespace, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Namespaces not deleted: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
