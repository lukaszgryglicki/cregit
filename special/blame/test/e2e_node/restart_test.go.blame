0000000000000000000000000000000000000000;;	// +build linux
a9a4336859778a9c0c728790d753f5ab8e085697;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		testutils "k8s.io/kubernetes/test/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForPods waits for timeout duration, for pod_count.
0000000000000000000000000000000000000000;;	// If the timeout is hit, it returns the list of currently running pods.
0000000000000000000000000000000000000000;;	func waitForPods(f *framework.Framework, pod_count int, timeout time.Duration) (runningPods []*v1.Pod) {
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < timeout; time.Sleep(10 * time.Second) {
0000000000000000000000000000000000000000;;			podList, err := f.PodClient().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Failed to list pods on node: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runningPods = []*v1.Pod{}
0000000000000000000000000000000000000000;;			for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;				if r, err := testutils.PodRunningReady(&pod); err != nil || !r {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				runningPods = append(runningPods, &pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Running pod count %d", len(runningPods))
0000000000000000000000000000000000000000;;			if len(runningPods) >= pod_count {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return runningPods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Restart [Serial] [Slow] [Disruptive]", func() {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			// Saturate the node. It's not necessary that all these pods enter
0000000000000000000000000000000000000000;;			// Running/Ready, because we don't know the number of cores in the
0000000000000000000000000000000000000000;;			// test node or default limits applied (if any). It's is essential
0000000000000000000000000000000000000000;;			// that no containers end up in terminated. 100 was chosen because
0000000000000000000000000000000000000000;;			// it's the max pods per node.
0000000000000000000000000000000000000000;;			podCount            = 100
0000000000000000000000000000000000000000;;			podCreationInterval = 100 * time.Millisecond
0000000000000000000000000000000000000000;;			recoverTimeout      = 5 * time.Minute
0000000000000000000000000000000000000000;;			startTimeout        = 3 * time.Minute
0000000000000000000000000000000000000000;;			// restartCount is chosen so even with minPods we exhaust the default
0000000000000000000000000000000000000000;;			// allocation of a /24.
0000000000000000000000000000000000000000;;			minPods      = 50
0000000000000000000000000000000000000000;;			restartCount = 6
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("restart-test")
0000000000000000000000000000000000000000;;		Context("Docker Daemon", func() {
0000000000000000000000000000000000000000;;			Context("Network", func() {
0000000000000000000000000000000000000000;;				It("should recover from ip leak", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					pods := newTestPods(podCount, false, framework.GetPauseImageNameForHostArch(), "restart-docker-test")
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Trying to create %d pods on node", len(pods)))
0000000000000000000000000000000000000000;;					createBatchPodWithRateControl(f, pods, podCreationInterval)
0000000000000000000000000000000000000000;;					defer deletePodsSync(f, pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Give the node some time to stabilize, assume pods that enter RunningReady within
0000000000000000000000000000000000000000;;					// startTimeout fit on the node and the node is now saturated.
0000000000000000000000000000000000000000;;					runningPods := waitForPods(f, podCount, startTimeout)
0000000000000000000000000000000000000000;;					if len(runningPods) < minPods {
0000000000000000000000000000000000000000;;						framework.Failf("Failed to start %d pods, cannot test that restarting docker doesn't leak IPs", minPods)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for i := 0; i < restartCount; i += 1 {
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("Restarting Docker Daemon iteration %d", i))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// TODO: Find a uniform way to deal with systemctl/initctl/service operations. #34494
0000000000000000000000000000000000000000;;						if stdout, err := exec.Command("sudo", "systemctl", "restart", "docker").CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;							framework.Logf("Failed to trigger docker restart with systemd/systemctl: %v, stdout: %q", err, string(stdout))
0000000000000000000000000000000000000000;;							if stdout, err = exec.Command("sudo", "service", "docker", "restart").CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;								framework.Failf("Failed to trigger docker restart with upstart/service: %v, stdout: %q", err, string(stdout))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						time.Sleep(20 * time.Second)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("Checking currently Running/Ready pods")
0000000000000000000000000000000000000000;;					postRestartRunningPods := waitForPods(f, len(runningPods), recoverTimeout)
0000000000000000000000000000000000000000;;					if len(postRestartRunningPods) == 0 {
0000000000000000000000000000000000000000;;						framework.Failf("Failed to start *any* pods after docker restart, this might indicate an IP leak")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					By("Confirm no containers have terminated")
0000000000000000000000000000000000000000;;					for _, pod := range postRestartRunningPods {
0000000000000000000000000000000000000000;;						if c := testutils.TerminatedContainers(pod); len(c) != 0 {
0000000000000000000000000000000000000000;;							framework.Failf("Pod %q has failed containers %+v after docker restart, this might indicate an IP leak", pod.Name, c)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Docker restart test passed with %d pods", len(postRestartRunningPods)))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
