0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
cb7e0146fb2ea1e5e51762e0031530117051407d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		kubeapi "k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		kubelettypes "k8s.io/kubernetes/pkg/kubelet/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		criticalPodName   = "critical-pod"
0000000000000000000000000000000000000000;;		guaranteedPodName = "guaranteed"
0000000000000000000000000000000000000000;;		burstablePodName  = "burstable"
0000000000000000000000000000000000000000;;		bestEffortPodName = "best-effort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("CriticalPod [Serial] [Disruptive]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("critical-pod-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("when we need to admit a critical pod", func() {
0000000000000000000000000000000000000000;;			tempSetCurrentKubeletConfig(f, func(initialConfig *componentconfig.KubeletConfiguration) {
0000000000000000000000000000000000000000;;				initialConfig.FeatureGates += ", ExperimentalCriticalPodAnnotation=true"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be able to create and delete a critical pod", func() {
0000000000000000000000000000000000000000;;				configEnabled, err := isKubeletConfigEnabled(f)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				if !configEnabled {
0000000000000000000000000000000000000000;;					framework.Skipf("unable to run test without dynamic kubelet config enabled.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Define test pods
0000000000000000000000000000000000000000;;				nonCriticalGuaranteed := getTestPod(false, guaranteedPodName, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;						"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;						"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;						"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				nonCriticalBurstable := getTestPod(false, burstablePodName, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						"cpu":    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;						"memory": resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				nonCriticalBestEffort := getTestPod(false, bestEffortPodName, v1.ResourceRequirements{})
0000000000000000000000000000000000000000;;				criticalPod := getTestPod(true, criticalPodName, v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					// request the entire resource capacity of the node, so that
0000000000000000000000000000000000000000;;					// admitting this pod requires the other pod to be preempted
0000000000000000000000000000000000000000;;					Requests: getNodeCPUAndMemoryCapacity(f),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create pods, starting with non-critical so that the critical preempts the other pods.
0000000000000000000000000000000000000000;;				f.PodClient().CreateBatch([]*v1.Pod{nonCriticalBestEffort, nonCriticalBurstable, nonCriticalGuaranteed})
0000000000000000000000000000000000000000;;				f.PodClientNS(kubeapi.NamespaceSystem).CreateSyncInNamespace(criticalPod, kubeapi.NamespaceSystem)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check that non-critical pods other than the besteffort have been evicted
0000000000000000000000000000000000000000;;				updatedPodList, err := f.ClientSet.Core().Pods(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				for _, p := range updatedPodList.Items {
0000000000000000000000000000000000000000;;					if p.Name == nonCriticalBestEffort.Name {
0000000000000000000000000000000000000000;;						Expect(p.Status.Phase).NotTo(Equal(v1.PodFailed), fmt.Sprintf("pod: %v should be preempted", p.Name))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						Expect(p.Status.Phase).To(Equal(v1.PodFailed), fmt.Sprintf("pod: %v should not be preempted", p.Name))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				// Delete Pods
0000000000000000000000000000000000000000;;				f.PodClient().DeleteSync(guaranteedPodName, &metav1.DeleteOptions{}, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;				f.PodClient().DeleteSync(burstablePodName, &metav1.DeleteOptions{}, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;				f.PodClient().DeleteSync(bestEffortPodName, &metav1.DeleteOptions{}, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;				f.PodClientNS(kubeapi.NamespaceSystem).DeleteSyncInNamespace(criticalPodName, kubeapi.NamespaceSystem, &metav1.DeleteOptions{}, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;				// Log Events
0000000000000000000000000000000000000000;;				logPodEvents(f)
0000000000000000000000000000000000000000;;				logNodeEvents(f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNodeCPUAndMemoryCapacity(f *framework.Framework) v1.ResourceList {
0000000000000000000000000000000000000000;;		nodeList, err := f.ClientSet.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		// Assuming that there is only one node, because this is a node e2e test.
0000000000000000000000000000000000000000;;		Expect(len(nodeList.Items)).To(Equal(1))
0000000000000000000000000000000000000000;;		capacity := nodeList.Items[0].Status.Allocatable
0000000000000000000000000000000000000000;;		return v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceCPU:    capacity[v1.ResourceCPU],
0000000000000000000000000000000000000000;;			v1.ResourceMemory: capacity[v1.ResourceMemory],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestPod(critical bool, name string, resources v1.ResourceRequirements) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: name},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:      "container",
0000000000000000000000000000000000000000;;						Image:     framework.GetPauseImageNameForHostArch(),
0000000000000000000000000000000000000000;;						Resources: resources,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if critical {
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Namespace = kubeapi.NamespaceSystem
0000000000000000000000000000000000000000;;			pod.ObjectMeta.Annotations = map[string]string{
0000000000000000000000000000000000000000;;				kubelettypes.CriticalPodAnnotationKey: "",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			Expect(kubelettypes.IsCriticalPod(pod)).To(BeTrue(), "pod should be a critical pod")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			Expect(kubelettypes.IsCriticalPod(pod)).To(BeFalse(), "pod should not be a critical pod")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
