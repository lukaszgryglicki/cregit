0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
02278153215f37a78825873d3c7e139c2b3357fc;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/api/v1/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Eviction Policy is described here:
0000000000000000000000000000000000000000;;	// https://github.com/kubernetes/kubernetes/blob/master/docs/proposals/kubelet-eviction.md
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("LocalStorageAllocatableEviction [Slow] [Serial] [Disruptive] [Flaky]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("localstorageallocatable-eviction-test")
0000000000000000000000000000000000000000;;		evictionTestTimeout := 15 * time.Minute
0000000000000000000000000000000000000000;;		testCondition := "Evict pod due to local storage allocatable violation"
0000000000000000000000000000000000000000;;		conditionType := v1.NodeDiskPressure
0000000000000000000000000000000000000000;;		var podTestSpecs []podTestSpec
0000000000000000000000000000000000000000;;		//podTestSpecsS := make([]podTestSpec, 5)
0000000000000000000000000000000000000000;;		var diskReserve uint64
0000000000000000000000000000000000000000;;		Context(fmt.Sprintf("when we run containers that should cause %s", testCondition), func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				diskAvail, err := getDiskUsage()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				diskReserve = uint64(0.8 * diskAvail / 1000000) // Reserve 0.8 * disk Capacity for kube-reserved scratch storage
0000000000000000000000000000000000000000;;				maxDisk := 10000000                             // Set dd command to read and write up to 10MB at a time
0000000000000000000000000000000000000000;;				count := uint64(0.8 * diskAvail / float64(maxDisk))
0000000000000000000000000000000000000000;;				command := fmt.Sprintf("dd if=/dev/urandom of=dummy bs=%d count=%d; sleep 0.5; while true; do sleep 5; done", maxDisk, count)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podTestSpecs = []podTestSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						evictionPriority: 1, // This pod should be evicted before the innocent pod
0000000000000000000000000000000000000000;;						pod: &v1.Pod{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{Name: "container-disk-hog-pod"},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;										Name:    "container-disk-hog-pod",
0000000000000000000000000000000000000000;;										Command: []string{"sh", "-c", command},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						evictionPriority: 0, // This pod should never be evicted
0000000000000000000000000000000000000000;;						pod: &v1.Pod{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{Name: "idle-pod"},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;										Name:  "idle-pod",
0000000000000000000000000000000000000000;;										Command: []string{"sh", "-c",
0000000000000000000000000000000000000000;;											fmt.Sprintf("while true; do sleep 5; done")},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set up --kube-reserved for scratch storage
0000000000000000000000000000000000000000;;			tempSetCurrentKubeletConfig(f, func(initialConfig *componentconfig.KubeletConfiguration) {
0000000000000000000000000000000000000000;;				framework.Logf("Set up --kube-reserved for local storage reserved %dMi", diskReserve)
0000000000000000000000000000000000000000;;				initialConfig.KubeReserved = componentconfig.ConfigurationMap(map[string]string{"storage": fmt.Sprintf("%dMi", diskReserve)})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Place the remainder of the test within a context so that the kubelet config is set before and after the test.
0000000000000000000000000000000000000000;;			Context("With kubeconfig updated", func() {
0000000000000000000000000000000000000000;;				runLocalStorageEvictionTest(f, conditionType, testCondition, &podTestSpecs, evictionTestTimeout, hasDiskPressure)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns TRUE if the node has disk pressure, FALSE otherwise
0000000000000000000000000000000000000000;;	func hasDiskPressure(f *framework.Framework, conditionType v1.NodeConditionType, testCondition string) (bool, error) {
0000000000000000000000000000000000000000;;		localNodeStatus := getLocalNode(f).Status
0000000000000000000000000000000000000000;;		_, pressure := nodeutil.GetNodeCondition(&localNodeStatus, conditionType)
0000000000000000000000000000000000000000;;		Expect(pressure).NotTo(BeNil())
0000000000000000000000000000000000000000;;		hasPressure := pressure.Status == v1.ConditionTrue
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("checking if pod has %s: %v", testCondition, hasPressure))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Additional Logging relating to disk
0000000000000000000000000000000000000000;;		summary, err := getNodeSummary()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if summary.Node.Runtime != nil && summary.Node.Runtime.ImageFs != nil && summary.Node.Runtime.ImageFs.UsedBytes != nil {
0000000000000000000000000000000000000000;;			framework.Logf("imageFsInfo.UsedBytes: %d", *summary.Node.Runtime.ImageFs.UsedBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if summary.Node.Fs != nil && summary.Node.Fs.UsedBytes != nil {
0000000000000000000000000000000000000000;;			framework.Logf("rootFsInfo.UsedBytes: %d", *summary.Node.Fs.UsedBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range summary.Pods {
0000000000000000000000000000000000000000;;			framework.Logf("Pod: %s", pod.PodRef.Name)
0000000000000000000000000000000000000000;;			for _, container := range pod.Containers {
0000000000000000000000000000000000000000;;				if container.Rootfs != nil && container.Rootfs.UsedBytes != nil {
0000000000000000000000000000000000000000;;					framework.Logf("--- summary Container: %s UsedBytes: %d", container.Name, *container.Rootfs.UsedBytes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, volume := range pod.VolumeStats {
0000000000000000000000000000000000000000;;				if volume.FsStats.UsedBytes != nil {
0000000000000000000000000000000000000000;;					framework.Logf("--- summary Volume: %s UsedBytes: %d", volume.Name, *volume.FsStats.UsedBytes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hasPressure, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pass podTestSpecsP as references so that it could be set up in the first BeforeEach clause
0000000000000000000000000000000000000000;;	func runLocalStorageEvictionTest(f *framework.Framework, conditionType v1.NodeConditionType, testCondition string, podTestSpecsP *[]podTestSpec, evictionTestTimeout time.Duration,
0000000000000000000000000000000000000000;;		hasPressureCondition func(*framework.Framework, v1.NodeConditionType, string) (bool, error)) {
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("seting up pods to be used by tests")
0000000000000000000000000000000000000000;;			for _, spec := range *podTestSpecsP {
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("creating pod with container: %s", spec.pod.Name))
0000000000000000000000000000000000000000;;				f.PodClient().CreateSync(spec.pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It(fmt.Sprintf("should eventually see %s, and then evict all of the correct pods", testCondition), func() {
0000000000000000000000000000000000000000;;			Expect(podTestSpecsP).NotTo(BeNil())
0000000000000000000000000000000000000000;;			podTestSpecs := *podTestSpecsP
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(func() error {
0000000000000000000000000000000000000000;;				hasPressure, err := hasPressureCondition(f, conditionType, testCondition)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if hasPressure {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("Condition: %s not encountered", testCondition)
0000000000000000000000000000000000000000;;			}, evictionTestTimeout, evictionPollInterval).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Eventually(func() error {
0000000000000000000000000000000000000000;;				// Gather current information
0000000000000000000000000000000000000000;;				updatedPodList, err := f.ClientSet.Core().Pods(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				updatedPods := updatedPodList.Items
0000000000000000000000000000000000000000;;				for _, p := range updatedPods {
0000000000000000000000000000000000000000;;					framework.Logf("fetching pod %s; phase= %v", p.Name, p.Status.Phase)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = hasPressureCondition(f, conditionType, testCondition)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("checking eviction ordering and ensuring important pods dont fail")
0000000000000000000000000000000000000000;;				done := true
0000000000000000000000000000000000000000;;				for _, priorityPodSpec := range podTestSpecs {
0000000000000000000000000000000000000000;;					var priorityPod v1.Pod
0000000000000000000000000000000000000000;;					for _, p := range updatedPods {
0000000000000000000000000000000000000000;;						if p.Name == priorityPodSpec.pod.Name {
0000000000000000000000000000000000000000;;							priorityPod = p
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					Expect(priorityPod).NotTo(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check eviction ordering.
0000000000000000000000000000000000000000;;					// Note: it is alright for a priority 1 and priority 2 pod (for example) to fail in the same round
0000000000000000000000000000000000000000;;					for _, lowPriorityPodSpec := range podTestSpecs {
0000000000000000000000000000000000000000;;						var lowPriorityPod v1.Pod
0000000000000000000000000000000000000000;;						for _, p := range updatedPods {
0000000000000000000000000000000000000000;;							if p.Name == lowPriorityPodSpec.pod.Name {
0000000000000000000000000000000000000000;;								lowPriorityPod = p
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						Expect(lowPriorityPod).NotTo(BeNil())
0000000000000000000000000000000000000000;;						if priorityPodSpec.evictionPriority < lowPriorityPodSpec.evictionPriority && lowPriorityPod.Status.Phase == v1.PodRunning {
0000000000000000000000000000000000000000;;							Expect(priorityPod.Status.Phase).NotTo(Equal(v1.PodFailed),
0000000000000000000000000000000000000000;;								fmt.Sprintf("%s pod failed before %s pod", priorityPodSpec.pod.Name, lowPriorityPodSpec.pod.Name))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// EvictionPriority 0 pods should not fail
0000000000000000000000000000000000000000;;					if priorityPodSpec.evictionPriority == 0 {
0000000000000000000000000000000000000000;;						Expect(priorityPod.Status.Phase).NotTo(Equal(v1.PodFailed),
0000000000000000000000000000000000000000;;							fmt.Sprintf("%s pod failed (and shouldn't have failed)", priorityPod.Name))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// If a pod that is not evictionPriority 0 has not been evicted, we are not done
0000000000000000000000000000000000000000;;					if priorityPodSpec.evictionPriority != 0 && priorityPod.Status.Phase != v1.PodFailed {
0000000000000000000000000000000000000000;;						done = false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if done {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("pods that caused %s have not been evicted.", testCondition)
0000000000000000000000000000000000000000;;			}, evictionTestTimeout, evictionPollInterval).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We observe pressure from the API server.  The eviction manager observes pressure from the kubelet internal stats.
0000000000000000000000000000000000000000;;			// This means the eviction manager will observe pressure before we will, creating a delay between when the eviction manager
0000000000000000000000000000000000000000;;			// evicts a pod, and when we observe the pressure by querrying the API server.  Add a delay here to account for this delay
0000000000000000000000000000000000000000;;			By("making sure pressure from test has surfaced before continuing")
0000000000000000000000000000000000000000;;			time.Sleep(pressureDelay)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("making sure conditions eventually return to normal")
0000000000000000000000000000000000000000;;			Eventually(func() error {
0000000000000000000000000000000000000000;;				hasPressure, err := hasPressureCondition(f, conditionType, testCondition)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if hasPressure {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Conditions havent returned to normal, we still have %s", testCondition)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}, evictionTestTimeout, evictionPollInterval).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("making sure conditions do not return, and that pods that shouldnt fail dont fail")
0000000000000000000000000000000000000000;;			Consistently(func() error {
0000000000000000000000000000000000000000;;				hasPressure, err := hasPressureCondition(f, conditionType, testCondition)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Race conditions sometimes occur when checking pressure condition due to #38710 (Docker bug)
0000000000000000000000000000000000000000;;					// Do not fail the test when this occurs, since this is expected to happen occasionally.
0000000000000000000000000000000000000000;;					framework.Logf("Failed to check pressure condition. Error: %v", err)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if hasPressure {
0000000000000000000000000000000000000000;;					return fmt.Errorf("%s dissappeared and then reappeared", testCondition)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Gather current information
0000000000000000000000000000000000000000;;				updatedPodList, _ := f.ClientSet.Core().Pods(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;				for _, priorityPodSpec := range podTestSpecs {
0000000000000000000000000000000000000000;;					// EvictionPriority 0 pods should not fail
0000000000000000000000000000000000000000;;					if priorityPodSpec.evictionPriority == 0 {
0000000000000000000000000000000000000000;;						for _, p := range updatedPodList.Items {
0000000000000000000000000000000000000000;;							if p.Name == priorityPodSpec.pod.Name && p.Status.Phase == v1.PodFailed {
0000000000000000000000000000000000000000;;								return fmt.Errorf("%s pod failed (delayed) and shouldn't have failed", p.Name)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}, postTestConditionMonitoringPeriod, evictionPollInterval).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("making sure we can start a new pod after the test")
0000000000000000000000000000000000000000;;			podName := "test-admit-pod"
0000000000000000000000000000000000000000;;			f.PodClient().CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: podName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Image: framework.GetPauseImageNameForHostArch(),
0000000000000000000000000000000000000000;;							Name:  podName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			By("deleting pods")
0000000000000000000000000000000000000000;;			for _, spec := range *podTestSpecsP {
0000000000000000000000000000000000000000;;				By(fmt.Sprintf("deleting pod: %s", spec.pod.Name))
0000000000000000000000000000000000000000;;				f.PodClient().DeleteSync(spec.pod.Name, &metav1.DeleteOptions{}, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if CurrentGinkgoTestDescription().Failed {
0000000000000000000000000000000000000000;;				if framework.TestContext.DumpLogsOnFailure {
0000000000000000000000000000000000000000;;					logPodEvents(f)
0000000000000000000000000000000000000000;;					logNodeEvents(f)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("sleeping to allow for cleanup of test")
0000000000000000000000000000000000000000;;				time.Sleep(postTestConditionMonitoringPeriod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDiskUsage() (float64, error) {
0000000000000000000000000000000000000000;;		summary, err := getNodeSummary()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if nodeFs := summary.Node.Fs; nodeFs != nil {
0000000000000000000000000000000000000000;;			return float64(*nodeFs.AvailableBytes), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("fail to get nodefs available bytes")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
