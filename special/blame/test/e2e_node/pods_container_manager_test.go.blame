0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ebab011aa12692ff89235eb02d4c0483234610c9;test/e2e_node/cgroup_manager_test.go[test/e2e_node/cgroup_manager_test.go][test/e2e_node/pods_container_manager_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourceList returns a ResourceList with the
0000000000000000000000000000000000000000;;	// specified cpu and memory resource values
0000000000000000000000000000000000000000;;	func getResourceList(cpu, memory string) v1.ResourceList {
0000000000000000000000000000000000000000;;		res := v1.ResourceList{}
0000000000000000000000000000000000000000;;		if cpu != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceCPU] = resource.MustParse(cpu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memory != "" {
0000000000000000000000000000000000000000;;			res[v1.ResourceMemory] = resource.MustParse(memory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourceRequirements returns a ResourceRequirements object
0000000000000000000000000000000000000000;;	func getResourceRequirements(requests, limits v1.ResourceList) v1.ResourceRequirements {
0000000000000000000000000000000000000000;;		res := v1.ResourceRequirements{}
0000000000000000000000000000000000000000;;		res.Requests = requests
0000000000000000000000000000000000000000;;		res.Limits = limits
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Kubelet internal cgroup name for node allocatable cgroup.
0000000000000000000000000000000000000000;;		defaultNodeAllocatableCgroup = "kubepods"
0000000000000000000000000000000000000000;;		// Kubelet internal cgroup name for burstable tier
0000000000000000000000000000000000000000;;		burstableCgroup = "burstable"
0000000000000000000000000000000000000000;;		// Kubelet internal cgroup name for burstable tier
0000000000000000000000000000000000000000;;		bestEffortCgroup = "burstable"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makePodToVerifyCgroups returns a pod that verifies the existence of the specified cgroups.
0000000000000000000000000000000000000000;;	func makePodToVerifyCgroups(cgroupNames []cm.CgroupName) *v1.Pod {
0000000000000000000000000000000000000000;;		// convert the names to their literal cgroupfs forms...
0000000000000000000000000000000000000000;;		cgroupFsNames := []string{}
0000000000000000000000000000000000000000;;		for _, cgroupName := range cgroupNames {
0000000000000000000000000000000000000000;;			// Add top level cgroup used to enforce node allocatable.
0000000000000000000000000000000000000000;;			cgroupName = cm.CgroupName(path.Join(defaultNodeAllocatableCgroup, string(cgroupName)))
0000000000000000000000000000000000000000;;			if framework.TestContext.KubeletConfig.CgroupDriver == "systemd" {
0000000000000000000000000000000000000000;;				cgroupFsNames = append(cgroupFsNames, cm.ConvertCgroupNameToSystemd(cgroupName, true))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cgroupFsNames = append(cgroupFsNames, string(cgroupName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("expecting %v cgroups to be found", cgroupFsNames)
0000000000000000000000000000000000000000;;		// build the pod command to either verify cgroups exist
0000000000000000000000000000000000000000;;		command := ""
0000000000000000000000000000000000000000;;		for _, cgroupFsName := range cgroupFsNames {
0000000000000000000000000000000000000000;;			localCommand := "if [ ! -d /tmp/memory/" + cgroupFsName + " ] || [ ! -d /tmp/cpu/" + cgroupFsName + " ]; then exit 1; fi; "
0000000000000000000000000000000000000000;;			command += localCommand
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Name:    "container" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;						Command: []string{"sh", "-c", command},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "sysfscgroup",
0000000000000000000000000000000000000000;;								MountPath: "/tmp",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "sysfscgroup",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							HostPath: &v1.HostPathVolumeSource{Path: "/sys/fs/cgroup"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makePodToVerifyCgroupRemoved verfies the specified cgroup does not exist.
0000000000000000000000000000000000000000;;	func makePodToVerifyCgroupRemoved(cgroupName cm.CgroupName) *v1.Pod {
0000000000000000000000000000000000000000;;		cgroupFsName := string(cgroupName)
0000000000000000000000000000000000000000;;		if framework.TestContext.KubeletConfig.CgroupDriver == "systemd" {
0000000000000000000000000000000000000000;;			cgroupFsName = cm.ConvertCgroupNameToSystemd(cm.CgroupName(cgroupName), true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pod" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Name:    "container" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;						Command: []string{"sh", "-c", "for i in `seq 1 10`; do if [ ! -d /tmp/memory/" + cgroupFsName + " ] && [ ! -d /tmp/cpu/" + cgroupFsName + " ]; then exit 0; else sleep 10; fi; done; exit 1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "sysfscgroup",
0000000000000000000000000000000000000000;;								MountPath: "/tmp",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "sysfscgroup",
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							HostPath: &v1.HostPathVolumeSource{Path: "/sys/fs/cgroup"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Kubelet Cgroup Manager", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("kubelet-cgroup-manager")
0000000000000000000000000000000000000000;;		Describe("QOS containers", func() {
0000000000000000000000000000000000000000;;			Context("On enabling QOS cgroup hierarchy", func() {
0000000000000000000000000000000000000000;;				It("Top level QoS containers should have been created", func() {
0000000000000000000000000000000000000000;;					if !framework.TestContext.KubeletConfig.CgroupsPerQOS {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					cgroupsToVerify := []cm.CgroupName{cm.CgroupName(burstableCgroup), cm.CgroupName(bestEffortCgroup)}
0000000000000000000000000000000000000000;;					pod := makePodToVerifyCgroups(cgroupsToVerify)
0000000000000000000000000000000000000000;;					f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;					err := framework.WaitForPodSuccessInNamespace(f.ClientSet, pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;					Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Describe("Pod containers", func() {
0000000000000000000000000000000000000000;;			Context("On scheduling a Guaranteed Pod", func() {
0000000000000000000000000000000000000000;;				It("Pod containers should have been created under the cgroup-root", func() {
0000000000000000000000000000000000000000;;					if !framework.TestContext.KubeletConfig.CgroupsPerQOS {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var (
0000000000000000000000000000000000000000;;						guaranteedPod *v1.Pod
0000000000000000000000000000000000000000;;						podUID        string
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;					By("Creating a Guaranteed pod in Namespace", func() {
0000000000000000000000000000000000000000;;						guaranteedPod = f.PodClient().Create(&v1.Pod{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:      "pod" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;								Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Image:     framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;										Name:      "container" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;										Resources: getResourceRequirements(getResourceList("100m", "100Mi"), getResourceList("100m", "100Mi")),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;						podUID = string(guaranteedPod.UID)
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					By("Checking if the pod cgroup was created", func() {
0000000000000000000000000000000000000000;;						cgroupsToVerify := []cm.CgroupName{cm.CgroupName("pod" + podUID)}
0000000000000000000000000000000000000000;;						pod := makePodToVerifyCgroups(cgroupsToVerify)
0000000000000000000000000000000000000000;;						f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;						err := framework.WaitForPodSuccessInNamespace(f.ClientSet, pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					By("Checking if the pod cgroup was deleted", func() {
0000000000000000000000000000000000000000;;						gp := int64(1)
0000000000000000000000000000000000000000;;						Expect(f.PodClient().Delete(guaranteedPod.Name, &metav1.DeleteOptions{GracePeriodSeconds: &gp})).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;						pod := makePodToVerifyCgroupRemoved(cm.CgroupName("pod" + podUID))
0000000000000000000000000000000000000000;;						f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;						err := framework.WaitForPodSuccessInNamespace(f.ClientSet, pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Context("On scheduling a BestEffort Pod", func() {
0000000000000000000000000000000000000000;;				It("Pod containers should have been created under the BestEffort cgroup", func() {
0000000000000000000000000000000000000000;;					if !framework.TestContext.KubeletConfig.CgroupsPerQOS {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var (
0000000000000000000000000000000000000000;;						podUID        string
0000000000000000000000000000000000000000;;						bestEffortPod *v1.Pod
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;					By("Creating a BestEffort pod in Namespace", func() {
0000000000000000000000000000000000000000;;						bestEffortPod = f.PodClient().Create(&v1.Pod{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:      "pod" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;								Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Image:     framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;										Name:      "container" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;										Resources: getResourceRequirements(getResourceList("", ""), getResourceList("", "")),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;						podUID = string(bestEffortPod.UID)
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					By("Checking if the pod cgroup was created", func() {
0000000000000000000000000000000000000000;;						cgroupsToVerify := []cm.CgroupName{cm.CgroupName("besteffort/pod" + podUID)}
0000000000000000000000000000000000000000;;						pod := makePodToVerifyCgroups(cgroupsToVerify)
0000000000000000000000000000000000000000;;						f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;						err := framework.WaitForPodSuccessInNamespace(f.ClientSet, pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					By("Checking if the pod cgroup was deleted", func() {
0000000000000000000000000000000000000000;;						gp := int64(1)
0000000000000000000000000000000000000000;;						Expect(f.PodClient().Delete(bestEffortPod.Name, &metav1.DeleteOptions{GracePeriodSeconds: &gp})).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;						pod := makePodToVerifyCgroupRemoved(cm.CgroupName("besteffort/pod" + podUID))
0000000000000000000000000000000000000000;;						f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;						err := framework.WaitForPodSuccessInNamespace(f.ClientSet, pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Context("On scheduling a Burstable Pod", func() {
0000000000000000000000000000000000000000;;				It("Pod containers should have been created under the Burstable cgroup", func() {
0000000000000000000000000000000000000000;;					if !framework.TestContext.KubeletConfig.CgroupsPerQOS {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var (
0000000000000000000000000000000000000000;;						podUID       string
0000000000000000000000000000000000000000;;						burstablePod *v1.Pod
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;					By("Creating a Burstable pod in Namespace", func() {
0000000000000000000000000000000000000000;;						burstablePod = f.PodClient().Create(&v1.Pod{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:      "pod" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;								Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Image:     framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;										Name:      "container" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;										Resources: getResourceRequirements(getResourceList("100m", "100Mi"), getResourceList("200m", "200Mi")),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;						podUID = string(burstablePod.UID)
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					By("Checking if the pod cgroup was created", func() {
0000000000000000000000000000000000000000;;						cgroupsToVerify := []cm.CgroupName{cm.CgroupName("burstable/pod" + podUID)}
0000000000000000000000000000000000000000;;						pod := makePodToVerifyCgroups(cgroupsToVerify)
0000000000000000000000000000000000000000;;						f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;						err := framework.WaitForPodSuccessInNamespace(f.ClientSet, pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					By("Checking if the pod cgroup was deleted", func() {
0000000000000000000000000000000000000000;;						gp := int64(1)
0000000000000000000000000000000000000000;;						Expect(f.PodClient().Delete(burstablePod.Name, &metav1.DeleteOptions{GracePeriodSeconds: &gp})).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;						pod := makePodToVerifyCgroupRemoved(cm.CgroupName("burstable/pod" + podUID))
0000000000000000000000000000000000000000;;						f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;						err := framework.WaitForPodSuccessInNamespace(f.ClientSet, pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
