0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
b935414c0472deec7268803628a043f97ffbf7a9;test/e2e_node/container_list.go[test/e2e_node/container_list.go][test/e2e_node/image_list.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"os/user"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		internalapi "k8s.io/kubernetes/pkg/kubelet/apis/cri"
0000000000000000000000000000000000000000;;		runtimeapi "k8s.io/kubernetes/pkg/kubelet/apis/cri/v1alpha1/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/remote"
0000000000000000000000000000000000000000;;		commontest "k8s.io/kubernetes/test/e2e/common"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Number of attempts to pull an image.
0000000000000000000000000000000000000000;;		maxImagePullRetries = 5
0000000000000000000000000000000000000000;;		// Sleep duration between image pull retry attempts.
0000000000000000000000000000000000000000;;		imagePullRetryDelay = time.Second
0000000000000000000000000000000000000000;;		// connection timeout for gRPC image service connection
0000000000000000000000000000000000000000;;		imageServiceConnectionTimeout = 15 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeImageWhiteList is a list of images used in node e2e test. These images will be prepulled
0000000000000000000000000000000000000000;;	// before test running so that the image pulling won't fail in actual test.
0000000000000000000000000000000000000000;;	var NodeImageWhiteList = sets.NewString(
0000000000000000000000000000000000000000;;		"google/cadvisor:latest",
0000000000000000000000000000000000000000;;		"gcr.io/google-containers/stress:v1",
0000000000000000000000000000000000000000;;		"gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;		"gcr.io/google_containers/busybox@sha256:4bdd623e848417d96127e16037743f0cd8b528c026e9175e22a84f639eca58ff",
0000000000000000000000000000000000000000;;		"gcr.io/google_containers/node-problem-detector:v0.4.1",
0000000000000000000000000000000000000000;;		"gcr.io/google_containers/nginx-slim:0.7",
0000000000000000000000000000000000000000;;		"gcr.io/google_containers/serve_hostname:v1.4",
0000000000000000000000000000000000000000;;		"gcr.io/google_containers/netexec:1.7",
0000000000000000000000000000000000000000;;		framework.GetPauseImageNameForHostArch(),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Union NodeImageWhiteList and CommonImageWhiteList into the framework image white list.
0000000000000000000000000000000000000000;;		framework.ImageWhiteList = NodeImageWhiteList.Union(commontest.CommonImageWhiteList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// puller represents a generic image puller
0000000000000000000000000000000000000000;;	type puller interface {
0000000000000000000000000000000000000000;;		// Pull pulls an image by name
0000000000000000000000000000000000000000;;		Pull(image string) ([]byte, error)
0000000000000000000000000000000000000000;;		// Name returns the name of the specific puller implementation
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dockerPuller struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dp *dockerPuller) Name() string {
0000000000000000000000000000000000000000;;		return "docker"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dp *dockerPuller) Pull(image string) ([]byte, error) {
0000000000000000000000000000000000000000;;		// TODO(random-liu): Use docker client to get rid of docker binary dependency.
0000000000000000000000000000000000000000;;		return exec.Command("docker", "pull", image).CombinedOutput()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type remotePuller struct {
0000000000000000000000000000000000000000;;		imageService internalapi.ImageManagerService
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rp *remotePuller) Name() string {
0000000000000000000000000000000000000000;;		return "CRI"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rp *remotePuller) Pull(image string) ([]byte, error) {
0000000000000000000000000000000000000000;;		// TODO(runcom): should we check if the image is already pulled with ImageStatus?
0000000000000000000000000000000000000000;;		_, err := rp.imageService.PullImage(&runtimeapi.ImageSpec{Image: image}, nil)
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPuller() (puller, error) {
0000000000000000000000000000000000000000;;		runtime := framework.TestContext.ContainerRuntime
0000000000000000000000000000000000000000;;		switch runtime {
0000000000000000000000000000000000000000;;		case "docker":
0000000000000000000000000000000000000000;;			return &dockerPuller{}, nil
0000000000000000000000000000000000000000;;		case "remote":
0000000000000000000000000000000000000000;;			endpoint := framework.TestContext.ContainerRuntimeEndpoint
0000000000000000000000000000000000000000;;			if framework.TestContext.ImageServiceEndpoint != "" {
0000000000000000000000000000000000000000;;				//ImageServiceEndpoint is the same as ContainerRuntimeEndpoint if not
0000000000000000000000000000000000000000;;				//explicitly specified
0000000000000000000000000000000000000000;;				//https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet.go#L517
0000000000000000000000000000000000000000;;				endpoint = framework.TestContext.ImageServiceEndpoint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if endpoint == "" {
0000000000000000000000000000000000000000;;				return nil, errors.New("can't prepull images, no remote endpoint provided")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			is, err := remote.NewRemoteImageService(endpoint, imageServiceConnectionTimeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &remotePuller{
0000000000000000000000000000000000000000;;				imageService: is,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("can't prepull images, unknown container runtime %q", runtime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pre-fetch all images tests depend on so that we don't fail in an actual test.
0000000000000000000000000000000000000000;;	func PrePullAllImages() error {
0000000000000000000000000000000000000000;;		puller, err := getPuller()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usr, err := user.Current()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		images := framework.ImageWhiteList.List()
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Pre-pulling images with %s %+v", puller.Name(), images)
0000000000000000000000000000000000000000;;		for _, image := range images {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				err    error
0000000000000000000000000000000000000000;;				output []byte
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			for i := 0; i < maxImagePullRetries; i++ {
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					time.Sleep(imagePullRetryDelay)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if output, err = puller.Pull(image); err == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to pull %s as user %q, retrying in %s (%d of %d): %v",
0000000000000000000000000000000000000000;;					image, usr.Username, imagePullRetryDelay.String(), i+1, maxImagePullRetries, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Could not pre-pull image %s %v output: %s", image, err, output)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
