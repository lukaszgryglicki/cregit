0000000000000000000000000000000000000000;;	// +build linux
8ef87e7ab2e10de9c58688025c4d61cb7dcb97a0;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDesiredConfiguration(initialConfig *componentconfig.KubeletConfiguration) {
0000000000000000000000000000000000000000;;		initialConfig.EnforceNodeAllocatable = []string{"pods", "kube-reserved", "system-reserved"}
0000000000000000000000000000000000000000;;		initialConfig.SystemReserved = componentconfig.ConfigurationMap{
0000000000000000000000000000000000000000;;			"cpu":    "100m",
0000000000000000000000000000000000000000;;			"memory": "100Mi",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		initialConfig.KubeReserved = componentconfig.ConfigurationMap{
0000000000000000000000000000000000000000;;			"cpu":    "100m",
0000000000000000000000000000000000000000;;			"memory": "100Mi",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		initialConfig.EvictionHard = "memory.available<100Mi"
0000000000000000000000000000000000000000;;		// Necessary for allocatable cgroup creation.
0000000000000000000000000000000000000000;;		initialConfig.CgroupsPerQOS = true
0000000000000000000000000000000000000000;;		initialConfig.KubeReservedCgroup = kubeReservedCgroup
0000000000000000000000000000000000000000;;		initialConfig.SystemReservedCgroup = systemReservedCgroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Node Container Manager [Serial]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("node-container-manager")
0000000000000000000000000000000000000000;;		Describe("Validate Node Allocatable", func() {
0000000000000000000000000000000000000000;;			It("set's up the node and runs the test", func() {
0000000000000000000000000000000000000000;;				framework.ExpectNoError(runTest(f))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectFileValToEqual(filePath string, expectedValue, delta int64) error {
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile(filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to read file %q", filePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual, err := strconv.ParseInt(strings.TrimSpace(string(out)), 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to parse output %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure that values are within a delta range to work arounding rounding errors.
0000000000000000000000000000000000000000;;		if (actual < (expectedValue - delta)) || (actual > (expectedValue + delta)) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected value at %q to be between %d and %d. Got %d", filePath, (expectedValue - delta), (expectedValue + delta), actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAllocatableLimits(cpu, memory string, capacity v1.ResourceList) (*resource.Quantity, *resource.Quantity) {
0000000000000000000000000000000000000000;;		var allocatableCPU, allocatableMemory *resource.Quantity
0000000000000000000000000000000000000000;;		// Total cpu reservation is 200m.
0000000000000000000000000000000000000000;;		for k, v := range capacity {
0000000000000000000000000000000000000000;;			if k == v1.ResourceCPU {
0000000000000000000000000000000000000000;;				allocatableCPU = v.Copy()
0000000000000000000000000000000000000000;;				allocatableCPU.Sub(resource.MustParse(cpu))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k == v1.ResourceMemory {
0000000000000000000000000000000000000000;;				allocatableMemory = v.Copy()
0000000000000000000000000000000000000000;;				allocatableMemory.Sub(resource.MustParse(memory))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allocatableCPU, allocatableMemory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		kubeReservedCgroup   = "/kube_reserved"
0000000000000000000000000000000000000000;;		systemReservedCgroup = "/system_reserved"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createIfNotExists(cm cm.CgroupManager, cgroupConfig *cm.CgroupConfig) error {
0000000000000000000000000000000000000000;;		if !cm.Exists(cgroupConfig.Name) {
0000000000000000000000000000000000000000;;			if err := cm.Create(cgroupConfig); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTemporaryCgroupsForReservation(cgroupManager cm.CgroupManager) error {
0000000000000000000000000000000000000000;;		// Create kube reserved cgroup
0000000000000000000000000000000000000000;;		cgroupConfig := &cm.CgroupConfig{
0000000000000000000000000000000000000000;;			Name: cm.CgroupName(kubeReservedCgroup),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := createIfNotExists(cgroupManager, cgroupConfig); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create system reserved cgroup
0000000000000000000000000000000000000000;;		cgroupConfig.Name = cm.CgroupName(systemReservedCgroup)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return createIfNotExists(cgroupManager, cgroupConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func destroyTemporaryCgroupsForReservation(cgroupManager cm.CgroupManager) error {
0000000000000000000000000000000000000000;;		// Create kube reserved cgroup
0000000000000000000000000000000000000000;;		cgroupConfig := &cm.CgroupConfig{
0000000000000000000000000000000000000000;;			Name: cm.CgroupName(kubeReservedCgroup),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cgroupManager.Destroy(cgroupConfig); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cgroupConfig.Name = cm.CgroupName(systemReservedCgroup)
0000000000000000000000000000000000000000;;		return cgroupManager.Destroy(cgroupConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runTest(f *framework.Framework) error {
0000000000000000000000000000000000000000;;		var oldCfg *componentconfig.KubeletConfiguration
0000000000000000000000000000000000000000;;		subsystems, err := cm.GetCgroupSubsystems()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get current kubelet configuration
0000000000000000000000000000000000000000;;		oldCfg, err = getCurrentKubeletConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a cgroup manager object for manipulating cgroups.
0000000000000000000000000000000000000000;;		cgroupManager := cm.NewCgroupManager(subsystems, oldCfg.CgroupDriver)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer destroyTemporaryCgroupsForReservation(cgroupManager)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if oldCfg != nil {
0000000000000000000000000000000000000000;;				framework.ExpectNoError(setKubeletConfiguration(f, oldCfg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err := createTemporaryCgroupsForReservation(cgroupManager); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clone, err := api.Scheme.DeepCopy(oldCfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newCfg := clone.(*componentconfig.KubeletConfiguration)
0000000000000000000000000000000000000000;;		// Change existing kubelet configuration
0000000000000000000000000000000000000000;;		setDesiredConfiguration(newCfg)
0000000000000000000000000000000000000000;;		// Set the new kubelet configuration.
0000000000000000000000000000000000000000;;		err = setKubeletConfiguration(f, newCfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set new config and current config.
0000000000000000000000000000000000000000;;		currentConfig := newCfg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedNAPodCgroup := path.Join(currentConfig.CgroupRoot, "kubepods")
0000000000000000000000000000000000000000;;		if !cgroupManager.Exists(cm.CgroupName(expectedNAPodCgroup)) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected Node Allocatable Cgroup Does not exist")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Update cgroupManager to expose a Status interface to get current Cgroup Settings.
0000000000000000000000000000000000000000;;		nodeList, err := f.ClientSet.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(nodeList.Items) != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unexpected number of node objects for node e2e. Expects only one node: %+v", nodeList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node := nodeList.Items[0]
0000000000000000000000000000000000000000;;		capacity := node.Status.Capacity
0000000000000000000000000000000000000000;;		allocatableCPU, allocatableMemory := getAllocatableLimits("200m", "200Mi", capacity)
0000000000000000000000000000000000000000;;		// Total Memory reservation is 200Mi excluding eviction thresholds.
0000000000000000000000000000000000000000;;		// Expect CPU shares on node allocatable cgroup to equal allocatable.
0000000000000000000000000000000000000000;;		if err := expectFileValToEqual(filepath.Join(subsystems.MountPoints["cpu"], "kubepods", "cpu.shares"), cm.MilliCPUToShares(allocatableCPU.MilliValue()), 10); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Expect Memory limit on node allocatable cgroup to equal allocatable.
0000000000000000000000000000000000000000;;		if err := expectFileValToEqual(filepath.Join(subsystems.MountPoints["memory"], "kubepods", "memory.limit_in_bytes"), allocatableMemory.Value(), 0); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that Allocatable reported to scheduler includes eviction thresholds.
0000000000000000000000000000000000000000;;		schedulerAllocatable := node.Status.Allocatable
0000000000000000000000000000000000000000;;		// Memory allocatable should take into account eviction thresholds.
0000000000000000000000000000000000000000;;		allocatableCPU, allocatableMemory = getAllocatableLimits("200m", "300Mi", capacity)
0000000000000000000000000000000000000000;;		// Expect allocatable to include all resources in capacity.
0000000000000000000000000000000000000000;;		if len(schedulerAllocatable) != len(capacity) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected all resources in capacity to be found in allocatable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// CPU based evictions are not supported.
0000000000000000000000000000000000000000;;		if allocatableCPU.Cmp(schedulerAllocatable["cpu"]) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unexpected cpu allocatable value exposed by the node. Expected: %v, got: %v, capacity: %v", allocatableCPU, schedulerAllocatable["cpu"], capacity["cpu"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if allocatableMemory.Cmp(schedulerAllocatable["memory"]) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unexpected cpu allocatable value exposed by the node. Expected: %v, got: %v, capacity: %v", allocatableCPU, schedulerAllocatable["cpu"], capacity["memory"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !cgroupManager.Exists(cm.CgroupName(kubeReservedCgroup)) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected kube reserved cgroup Does not exist")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Expect CPU shares on kube reserved cgroup to equal it's reservation which is `100m`.
0000000000000000000000000000000000000000;;		kubeReservedCPU := resource.MustParse(currentConfig.KubeReserved["cpu"])
0000000000000000000000000000000000000000;;		if err := expectFileValToEqual(filepath.Join(subsystems.MountPoints["cpu"], kubeReservedCgroup, "cpu.shares"), cm.MilliCPUToShares(kubeReservedCPU.MilliValue()), 10); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Expect Memory limit kube reserved cgroup to equal configured value `100Mi`.
0000000000000000000000000000000000000000;;		kubeReservedMemory := resource.MustParse(currentConfig.KubeReserved["memory"])
0000000000000000000000000000000000000000;;		if err := expectFileValToEqual(filepath.Join(subsystems.MountPoints["memory"], kubeReservedCgroup, "memory.limit_in_bytes"), kubeReservedMemory.Value(), 0); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cgroupManager.Exists(cm.CgroupName(systemReservedCgroup)) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected system reserved cgroup Does not exist")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Expect CPU shares on system reserved cgroup to equal it's reservation which is `100m`.
0000000000000000000000000000000000000000;;		systemReservedCPU := resource.MustParse(currentConfig.SystemReserved["cpu"])
0000000000000000000000000000000000000000;;		if err := expectFileValToEqual(filepath.Join(subsystems.MountPoints["cpu"], systemReservedCgroup, "cpu.shares"), cm.MilliCPUToShares(systemReservedCPU.MilliValue()), 10); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Expect Memory limit on node allocatable cgroup to equal allocatable.
0000000000000000000000000000000000000000;;		systemReservedMemory := resource.MustParse(currentConfig.SystemReserved["memory"])
0000000000000000000000000000000000000000;;		if err := expectFileValToEqual(filepath.Join(subsystems.MountPoints["memory"], systemReservedCgroup, "memory.limit_in_bytes"), systemReservedMemory.Value(), 0); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
