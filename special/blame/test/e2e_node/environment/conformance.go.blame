0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
dd955972ddfdf8afbef1f6427ded1deb132cc058;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build the binary with `go build conformance.go`, then run the conformance binary on a node candidate.  If compiled
0000000000000000000000000000000000000000;;	// on a non-linux machine, must be cross compiled for the host.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cadvisor"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const success = "\033[0;32mSUCESS\033[0m"
0000000000000000000000000000000000000000;;	const failed = "\033[0;31mFAILED\033[0m"
0000000000000000000000000000000000000000;;	const notConfigured = "\033[0;34mNOT CONFIGURED\033[0m"
0000000000000000000000000000000000000000;;	const skipped = "\033[0;34mSKIPPED\033[0m"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var checkFlag = flag.String(
0000000000000000000000000000000000000000;;		"check", "all", "what to check for conformance.  One or more of all,container-runtime,daemons,dns,firewall,kernel")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Set this to false to undo util/logs.go settings it to true.  Prevents cadvisor log spam.
0000000000000000000000000000000000000000;;		// Remove this once util/logs.go stops setting the flag to true.
0000000000000000000000000000000000000000;;		flag.Set("logtostderr", "false")
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Should we write an e2e test for this?
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		o := strings.Split(*checkFlag, ",")
0000000000000000000000000000000000000000;;		errs := check(o...)
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			os.Exit(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// check returns errors found while checking the provided components.  Will prevent errors to stdout.
0000000000000000000000000000000000000000;;	func check(options ...string) []error {
0000000000000000000000000000000000000000;;		errs := []error{}
0000000000000000000000000000000000000000;;		for _, c := range options {
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case "all":
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, kernel())
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, containerRuntime())
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, daemons())
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, firewall())
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, dns())
0000000000000000000000000000000000000000;;			case "containerruntime":
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, containerRuntime())
0000000000000000000000000000000000000000;;			case "daemons":
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, daemons())
0000000000000000000000000000000000000000;;			case "dns":
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, dns())
0000000000000000000000000000000000000000;;			case "firewall":
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, firewall())
0000000000000000000000000000000000000000;;			case "kernel":
0000000000000000000000000000000000000000;;				errs = appendNotNil(errs, kernel())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fmt.Printf("Unrecognized option %s", c)
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("Unrecognized option %s", c))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const dockerVersionRegex = `1\.[7-9]\.[0-9]+`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containerRuntime checks that a suitable container runtime is installed and recognized by cadvisor: docker 1.7-1.9
0000000000000000000000000000000000000000;;	func containerRuntime() error {
0000000000000000000000000000000000000000;;		dockerRegex, err := regexp.Compile(dockerVersionRegex)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This should never happen and can only be fixed by changing the code
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup cadvisor to check the container environment
0000000000000000000000000000000000000000;;		c, err := cadvisor.New("", 0 /*don't start the http server*/, "docker", "/var/lib/kubelet")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return printError("Container Runtime Check: %s Could not start cadvisor %v", failed, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vi, err := c.VersionInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return printError("Container Runtime Check: %s Could not get VersionInfo %v", failed, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := vi.DockerVersion
0000000000000000000000000000000000000000;;		if !dockerRegex.Match([]byte(d)) {
0000000000000000000000000000000000000000;;			return printError(
0000000000000000000000000000000000000000;;				"Container Runtime Check: %s Docker version %s does not matching %s.  You may need to run as root or the "+
0000000000000000000000000000000000000000;;					"user the kubelet will run under.", failed, d, dockerVersionRegex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return printSuccess("Container Runtime Check: %s", success)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const kubeletClusterDnsRegexStr = `\/kubelet.*--cluster-dns=(\S+) `
0000000000000000000000000000000000000000;;	const kubeletClusterDomainRegexStr = `\/kubelet.*--cluster-domain=(\S+)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dns checks that cluster dns has been properly configured and can resolve the kubernetes.default service
0000000000000000000000000000000000000000;;	func dns() error {
0000000000000000000000000000000000000000;;		dnsRegex, err := regexp.Compile(kubeletClusterDnsRegexStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This should never happen and can only be fixed by changing the code
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		domainRegex, err := regexp.Compile(kubeletClusterDomainRegexStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This should never happen and can only be fixed by changing the code
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h, err := net.LookupHost("kubernetes.default")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return printSuccess("Dns Check (Optional): %s", success)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(h) > 0 {
0000000000000000000000000000000000000000;;			return printSuccess("Dns Check (Optional): %s", success)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubecmd, err := exec.Command("ps", "aux").CombinedOutput()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// look for the dns flag and parse the value
0000000000000000000000000000000000000000;;		dns := dnsRegex.FindStringSubmatch(string(kubecmd))
0000000000000000000000000000000000000000;;		if len(dns) < 2 {
0000000000000000000000000000000000000000;;			return printSuccess(
0000000000000000000000000000000000000000;;				"Dns Check (Optional): %s No hosts resolve to kubernetes.default.  kubelet will need to set "+
0000000000000000000000000000000000000000;;					"--cluster-dns and --cluster-domain when run", notConfigured)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// look for the domain flag and parse the value
0000000000000000000000000000000000000000;;		domain := domainRegex.FindStringSubmatch(string(kubecmd))
0000000000000000000000000000000000000000;;		if len(domain) < 2 {
0000000000000000000000000000000000000000;;			return printSuccess(
0000000000000000000000000000000000000000;;				"Dns Check (Optional): %s No hosts resolve to kubernetes.default.  kubelet will need to set "+
0000000000000000000000000000000000000000;;					"--cluster-dns and --cluster-domain when run", notConfigured)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do a lookup with the flags the kubelet is running with
0000000000000000000000000000000000000000;;		nsArgs := []string{"-q=a", fmt.Sprintf("kubernetes.default.%s", domain[1]), dns[1]}
0000000000000000000000000000000000000000;;		if err = exec.Command("nslookup", nsArgs...).Run(); err != nil {
0000000000000000000000000000000000000000;;			// Mark this as failed since there was a clear intention to set it up, but it is done so improperly
0000000000000000000000000000000000000000;;			return printError(
0000000000000000000000000000000000000000;;				"Dns Check (Optional): %s No hosts resolve to kubernetes.default  kubelet found, but cannot resolve "+
0000000000000000000000000000000000000000;;					"kubernetes.default using nslookup %s error: %v", failed, strings.Join(nsArgs, " "), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Can resolve kubernetes.default using the kubelete dns and domain values
0000000000000000000000000000000000000000;;		return printSuccess("Dns Check (Optional): %s", success)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const cmdlineCGroupMemory = `cgroup_enable=memory`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kernel checks that the kernel has been configured correctly to support the required cgroup features
0000000000000000000000000000000000000000;;	func kernel() error {
0000000000000000000000000000000000000000;;		cmdline, err := ioutil.ReadFile("/proc/cmdline")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return printError("Kernel Command Line Check %s: Could not check /proc/cmdline", failed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(string(cmdline), cmdlineCGroupMemory) {
0000000000000000000000000000000000000000;;			return printError("Kernel Command Line Check %s: cgroup_enable=memory not enabled in /proc/cmdline", failed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return printSuccess("Kernel Command Line %s", success)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const iptablesInputRegexStr = `Chain INPUT \(policy DROP\)`
0000000000000000000000000000000000000000;;	const iptablesForwardRegexStr = `Chain FORWARD \(policy DROP\)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// firewall checks that iptables does not have common firewall rules setup that would disrupt traffic
0000000000000000000000000000000000000000;;	func firewall() error {
0000000000000000000000000000000000000000;;		out, err := exec.Command("iptables", "-L", "INPUT").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return printSuccess("Firewall IPTables Check %s: Could not run iptables", skipped)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inputRegex, err := regexp.Compile(iptablesInputRegexStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This should never happen and can only be fixed by changing the code
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if inputRegex.Match(out) {
0000000000000000000000000000000000000000;;			return printError("Firewall IPTables Check %s: Found INPUT rule matching %s", failed, iptablesInputRegexStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check GCE forward rules
0000000000000000000000000000000000000000;;		out, err = exec.Command("iptables", "-L", "FORWARD").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return printSuccess("Firewall IPTables Check %s: Could not run iptables", skipped)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		forwardRegex, err := regexp.Compile(iptablesForwardRegexStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This should never happen and can only be fixed by changing the code
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forwardRegex.Match(out) {
0000000000000000000000000000000000000000;;			return printError("Firewall IPTables Check %s: Found FORWARD rule matching %s", failed, iptablesInputRegexStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return printSuccess("Firewall IPTables Check %s", success)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// daemons checks that the required node programs are running: kubelet, kube-proxy, and docker
0000000000000000000000000000000000000000;;	func daemons() error {
0000000000000000000000000000000000000000;;		if exec.Command("pgrep", "-f", "kubelet").Run() != nil {
0000000000000000000000000000000000000000;;			return printError("Daemon Check %s: kubelet process not found", failed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exec.Command("pgrep", "-f", "kube-proxy").Run() != nil {
0000000000000000000000000000000000000000;;			return printError("Daemon Check %s: kube-proxy process not found", failed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return printSuccess("Daemon Check %s", success)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printError provides its arguments to print a format string to the console (newline terminated) and returns an
0000000000000000000000000000000000000000;;	// error with the same string
0000000000000000000000000000000000000000;;	func printError(s string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		es := fmt.Sprintf(s, args...)
0000000000000000000000000000000000000000;;		fmt.Println(es)
0000000000000000000000000000000000000000;;		return errors.New(es)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printSuccess provides its arguments to print a format string to the console (newline terminated) and returns nil
0000000000000000000000000000000000000000;;	func printSuccess(s string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		fmt.Println(fmt.Sprintf(s, args...))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendNotNil appends err to errs iff err is not nil
0000000000000000000000000000000000000000;;	func appendNotNil(errs []error, err error) []error {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return append(errs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
