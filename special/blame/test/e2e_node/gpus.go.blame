0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f7ca95b4b17811be84855f7e211ddb6c6254db70;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const acceleratorsFeatureGate = "Accelerators=true"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getGPUsAvailable(f *framework.Framework) int64 {
0000000000000000000000000000000000000000;;		nodeList, err := f.ClientSet.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "getting node list")
0000000000000000000000000000000000000000;;		var gpusAvailable int64
0000000000000000000000000000000000000000;;		for _, node := range nodeList.Items {
0000000000000000000000000000000000000000;;			gpusAvailable += node.Status.Capacity.NvidiaGPU().Value()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gpusAvailable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gpusExistOnAllNodes(f *framework.Framework) bool {
0000000000000000000000000000000000000000;;		nodeList, err := f.ClientSet.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err, "getting node list")
0000000000000000000000000000000000000000;;		for _, node := range nodeList.Items {
0000000000000000000000000000000000000000;;			if node.Name == "kubernetes-master" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if node.Status.Capacity.NvidiaGPU().Value() == 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkIfNvidiaGPUsExistOnNode() bool {
0000000000000000000000000000000000000000;;		// Cannot use `lspci` because it is not installed on all distros by default.
0000000000000000000000000000000000000000;;		err := exec.Command("/bin/sh", "-c", "find /sys/devices/pci* -type f | grep vendor | xargs cat | grep 0x10de").Run()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("check for nvidia GPUs failed. Got Error: %v", err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serial because the test updates kubelet configuration.
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("GPU [Serial]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("gpu-test")
0000000000000000000000000000000000000000;;		Context("attempt to use GPUs if available", func() {
0000000000000000000000000000000000000000;;			It("setup the node and create pods to test gpus", func() {
0000000000000000000000000000000000000000;;				By("ensuring that Nvidia GPUs exist on the node")
0000000000000000000000000000000000000000;;				if !checkIfNvidiaGPUsExistOnNode() {
0000000000000000000000000000000000000000;;					Skip("Nvidia GPUs do not exist on the node. Skipping test.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("ensuring that dynamic kubelet configuration is enabled")
0000000000000000000000000000000000000000;;				enabled, err := isKubeletConfigEnabled(f)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				if !enabled {
0000000000000000000000000000000000000000;;					Skip("Dynamic Kubelet configuration is not enabled. Skipping test.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("enabling support for GPUs")
0000000000000000000000000000000000000000;;				var oldCfg *componentconfig.KubeletConfiguration
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if oldCfg != nil {
0000000000000000000000000000000000000000;;						framework.ExpectNoError(setKubeletConfiguration(f, oldCfg))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				oldCfg, err = getCurrentKubeletConfig()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				clone, err := api.Scheme.DeepCopy(oldCfg)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				newCfg := clone.(*componentconfig.KubeletConfiguration)
0000000000000000000000000000000000000000;;				if newCfg.FeatureGates != "" {
0000000000000000000000000000000000000000;;					newCfg.FeatureGates = fmt.Sprintf("%s,%s", acceleratorsFeatureGate, newCfg.FeatureGates)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					newCfg.FeatureGates = acceleratorsFeatureGate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				framework.ExpectNoError(setKubeletConfiguration(f, newCfg))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Waiting for GPUs to become available on the local node")
0000000000000000000000000000000000000000;;				Eventually(gpusExistOnAllNodes(f), 10*time.Minute, time.Second).Should(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating a pod that will consume all GPUs")
0000000000000000000000000000000000000000;;				podSuccess := makePod(getGPUsAvailable(f), "gpus-success")
0000000000000000000000000000000000000000;;				podSuccess = f.PodClient().CreateSync(podSuccess)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Checking the containers in the pod had restarted at-least twice successfully thereby ensuring GPUs are reused")
0000000000000000000000000000000000000000;;				const minContainerRestartCount = 2
0000000000000000000000000000000000000000;;				Eventually(func() bool {
0000000000000000000000000000000000000000;;					p, err := f.ClientSet.Core().Pods(f.Namespace.Name).Get(podSuccess.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						framework.Logf("failed to get pod status: %v", err)
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if p.Status.ContainerStatuses[0].RestartCount < minContainerRestartCount {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}, time.Minute, time.Second).Should(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Checking if the pod outputted Success to its logs")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(f.PodClient().MatchContainerOutput(podSuccess.Name, podSuccess.Name, "Success"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating a new pod requesting a GPU and noticing that it is rejected by the Kubelet")
0000000000000000000000000000000000000000;;				podFailure := makePod(1, "gpu-failure")
0000000000000000000000000000000000000000;;				framework.WaitForPodCondition(f.ClientSet, f.Namespace.Name, podFailure.Name, "pod rejected", framework.PodStartTimeout, func(pod *v1.Pod) (bool, error) {
0000000000000000000000000000000000000000;;					if pod.Status.Phase == v1.PodFailed {
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("stopping the original Pod with GPUs")
0000000000000000000000000000000000000000;;				gp := int64(0)
0000000000000000000000000000000000000000;;				deleteOptions := metav1.DeleteOptions{
0000000000000000000000000000000000000000;;					GracePeriodSeconds: &gp,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f.PodClient().DeleteSync(podSuccess.Name, &deleteOptions, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("attempting to start the failed pod again")
0000000000000000000000000000000000000000;;				f.PodClient().DeleteSync(podFailure.Name, &deleteOptions, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;				podFailure = f.PodClient().CreateSync(podFailure)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Checking if the pod outputted Success to its logs")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(f.PodClient().MatchContainerOutput(podFailure.Name, podFailure.Name, "Success"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makePod(gpus int64, name string) *v1.Pod {
0000000000000000000000000000000000000000;;		resources := v1.ResourceRequirements{
0000000000000000000000000000000000000000;;			Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;				v1.ResourceNvidiaGPU: *resource.NewQuantity(gpus, resource.DecimalSI),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gpuverificationCmd := fmt.Sprintf("if [[ %d -ne $(ls /dev/ | egrep '^nvidia[0-9]+$' | wc -l) ]]; then exit 1; else echo Success; fi", gpus)
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Image:     "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						Name:      name,
0000000000000000000000000000000000000000;;						Command:   []string{"sh", "-c", gpuverificationCmd},
0000000000000000000000000000000000000000;;						Resources: resources,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
