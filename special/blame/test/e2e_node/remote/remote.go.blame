0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
48687e92e477ac7584e2167428d5336e6db56d7e;test/e2e_node/e2e_remote.go[test/e2e_node/e2e_remote.go][test/e2e_node/remote/remote.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var testTimeoutSeconds = flag.Duration("test-timeout", 45*time.Minute, "How long (in golang duration format) to wait for ginkgo tests to complete.")
0000000000000000000000000000000000000000;;	var resultsDir = flag.String("results-dir", "/tmp/", "Directory to scp test results to.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const archiveName = "e2e_node_test.tar.gz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateTestArchive(suite TestSuite) (string, error) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Building archive...")
0000000000000000000000000000000000000000;;		tardir, err := ioutil.TempDir("", "node-e2e-archive")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to create temporary directory %v.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tardir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call the suite function to setup the test package.
0000000000000000000000000000000000000000;;		err = suite.SetupTestPackage(tardir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to setup test package %q: %v", tardir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build the tar
0000000000000000000000000000000000000000;;		out, err := exec.Command("tar", "-zcvf", archiveName, "-C", tardir, ".").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to build tar %v.  Output:\n%s", err, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dir, err := os.Getwd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get working directory %v.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Join(dir, archiveName), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the command output, whether the exit was ok, and any errors
0000000000000000000000000000000000000000;;	// TODO(random-liu): junitFilePrefix is not prefix actually, the file name is junit-junitFilePrefix.xml. Change the variable name.
0000000000000000000000000000000000000000;;	func RunRemote(suite TestSuite, archive string, host string, cleanup bool, imageDesc, junitFilePrefix, testArgs, ginkgoArgs string) (string, bool, error) {
0000000000000000000000000000000000000000;;		// Create the temp staging directory
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Staging test binaries on %q", host)
0000000000000000000000000000000000000000;;		workspace := fmt.Sprintf("/tmp/node-e2e-%s", getTimestamp())
0000000000000000000000000000000000000000;;		// Do not sudo here, so that we can use scp to copy test archive to the directdory.
0000000000000000000000000000000000000000;;		if output, err := SSHNoSudo(host, "mkdir", workspace); err != nil {
0000000000000000000000000000000000000000;;			// Exit failure with the error
0000000000000000000000000000000000000000;;			return "", false, fmt.Errorf("failed to create workspace directory %q on host %q: %v output: %q", workspace, host, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cleanup {
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				output, err := SSH(host, "rm", "-rf", workspace)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to cleanup workspace %q on host %q: %v.  Output:\n%s", workspace, host, err, output)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy the archive to the staging directory
0000000000000000000000000000000000000000;;		if output, err := runSSHCommand("scp", archive, fmt.Sprintf("%s:%s/", GetHostnameOrIp(host), workspace)); err != nil {
0000000000000000000000000000000000000000;;			// Exit failure with the error
0000000000000000000000000000000000000000;;			return "", false, fmt.Errorf("failed to copy test archive: %v, output: %q", err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extract the archive
0000000000000000000000000000000000000000;;		cmd := getSSHCommand(" && ",
0000000000000000000000000000000000000000;;			fmt.Sprintf("cd %s", workspace),
0000000000000000000000000000000000000000;;			fmt.Sprintf("tar -xzvf ./%s", archiveName),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Extracting tar on %q", host)
0000000000000000000000000000000000000000;;		// Do not use sudo here, because `sudo tar -x` will recover the file ownership inside the tar ball, but
0000000000000000000000000000000000000000;;		// we want the extracted files to be owned by the current user.
0000000000000000000000000000000000000000;;		if output, err := SSHNoSudo(host, "sh", "-c", cmd); err != nil {
0000000000000000000000000000000000000000;;			// Exit failure with the error
0000000000000000000000000000000000000000;;			return "", false, fmt.Errorf("failed to extract test archive: %v, output: %q", err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the test result directory.
0000000000000000000000000000000000000000;;		resultDir := filepath.Join(workspace, "results")
0000000000000000000000000000000000000000;;		if output, err := SSHNoSudo(host, "mkdir", resultDir); err != nil {
0000000000000000000000000000000000000000;;			// Exit failure with the error
0000000000000000000000000000000000000000;;			return "", false, fmt.Errorf("failed to create test result directory %q on host %q: %v output: %q", resultDir, host, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Running test on %q", host)
0000000000000000000000000000000000000000;;		output, err := suite.RunTest(host, workspace, resultDir, imageDesc, junitFilePrefix, testArgs, ginkgoArgs, *testTimeoutSeconds)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aggErrs := []error{}
0000000000000000000000000000000000000000;;		// Do not log the output here, let the caller deal with the test output.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			aggErrs = append(aggErrs, err)
0000000000000000000000000000000000000000;;			collectSystemLog(host, workspace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Copying test artifacts from %q", host)
0000000000000000000000000000000000000000;;		scpErr := getTestArtifacts(host, workspace)
0000000000000000000000000000000000000000;;		if scpErr != nil {
0000000000000000000000000000000000000000;;			aggErrs = append(aggErrs, scpErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output, len(aggErrs) == 0, utilerrors.NewAggregate(aggErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timestampFormat is the timestamp format used in the node e2e directory name.
0000000000000000000000000000000000000000;;	const timestampFormat = "20060102T150405"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTimestamp() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(time.Now().Format(timestampFormat))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestArtifacts(host, testDir string) error {
0000000000000000000000000000000000000000;;		logPath := filepath.Join(*resultsDir, host)
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(logPath, 0755); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create log directory %q: %v", logPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Copy logs to artifacts/hostname
0000000000000000000000000000000000000000;;		_, err := runSSHCommand("scp", "-r", fmt.Sprintf("%s:%s/results/*.log", GetHostnameOrIp(host), testDir), logPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Copy json files (if any) to artifacts.
0000000000000000000000000000000000000000;;		if _, err = SSH(host, "ls", fmt.Sprintf("%s/results/*.json", testDir)); err == nil {
0000000000000000000000000000000000000000;;			_, err = runSSHCommand("scp", "-r", fmt.Sprintf("%s:%s/results/*.json", GetHostnameOrIp(host), testDir), *resultsDir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Copy junit to the top of artifacts
0000000000000000000000000000000000000000;;		_, err = runSSHCommand("scp", fmt.Sprintf("%s:%s/results/junit*", GetHostnameOrIp(host), testDir), *resultsDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// collectSystemLog is a temporary hack to collect system log when encountered on
0000000000000000000000000000000000000000;;	// unexpected error.
0000000000000000000000000000000000000000;;	func collectSystemLog(host, workspace string) {
0000000000000000000000000000000000000000;;		// Encountered an unexpected error. The remote test harness may not
0000000000000000000000000000000000000000;;		// have finished retrieved and stored all the logs in this case. Try
0000000000000000000000000000000000000000;;		// to get some logs for debugging purposes.
0000000000000000000000000000000000000000;;		// TODO: This is a best-effort, temporary hack that only works for
0000000000000000000000000000000000000000;;		// journald nodes. We should have a more robust way to collect logs.
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			logName  = "system.log"
0000000000000000000000000000000000000000;;			logPath  = fmt.Sprintf("/tmp/%s-%s", getTimestamp(), logName)
0000000000000000000000000000000000000000;;			destPath = fmt.Sprintf("%s/%s-%s", *resultsDir, host, logName)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Test failed unexpectedly. Attempting to retreiving system logs (only works for nodes with journald)")
0000000000000000000000000000000000000000;;		// Try getting the system logs from journald and store it to a file.
0000000000000000000000000000000000000000;;		// Don't reuse the original test directory on the remote host because
0000000000000000000000000000000000000000;;		// it could've be been removed if the node was rebooted.
0000000000000000000000000000000000000000;;		if output, err := SSH(host, "sh", "-c", fmt.Sprintf("'journalctl --system --all > %s'", logPath)); err == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Got the system logs from journald; copying it back...")
0000000000000000000000000000000000000000;;			if output, err := runSSHCommand("scp", fmt.Sprintf("%s:%s", GetHostnameOrIp(host), logPath), destPath); err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Failed to copy the log: err: %v, output: %q", err, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to run journactl (normal if it doesn't exist on the node): %v, output: %q", err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteLog is a temporary function to make it possible to write log
0000000000000000000000000000000000000000;;	// in the runner. This is used to collect serial console log.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Use the log-dump script in cluster e2e.
0000000000000000000000000000000000000000;;	func WriteLog(host, filename, content string) error {
0000000000000000000000000000000000000000;;		logPath := filepath.Join(*resultsDir, host)
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(logPath, 0755); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create log directory %q: %v", logPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := os.Create(filepath.Join(logPath, filename))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		_, err = f.WriteString(content)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
