0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f1c3e351c2d32e3b2b0ef616be1104a50a42fe8e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// utils.go contains functions used across test suites.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cniRelease       = "0799f5732f2a11b329d9e3d51b9c8f2e3759f2ff"
0000000000000000000000000000000000000000;;		cniDirectory     = "cni" // The CNI tarball creates the "bin" directory under "cni".
0000000000000000000000000000000000000000;;		cniConfDirectory = "cni/net.d"
0000000000000000000000000000000000000000;;		cniURL           = "https://storage.googleapis.com/kubernetes-release/network-plugins/cni-" + cniRelease + ".tar.gz"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const cniConfig = `{
0000000000000000000000000000000000000000;;	  "name": "mynet",
0000000000000000000000000000000000000000;;	  "type": "bridge",
0000000000000000000000000000000000000000;;	  "bridge": "mynet0",
0000000000000000000000000000000000000000;;	  "isDefaultGateway": true,
0000000000000000000000000000000000000000;;	  "forceAddress": false,
0000000000000000000000000000000000000000;;	  "ipMasq": true,
0000000000000000000000000000000000000000;;	  "hairpinMode": true,
0000000000000000000000000000000000000000;;	  "ipam": {
0000000000000000000000000000000000000000;;	    "type": "host-local",
0000000000000000000000000000000000000000;;	    "subnet": "10.10.0.0/16"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Install the cni plugin and add basic bridge configuration to the
0000000000000000000000000000000000000000;;	// configuration directory.
0000000000000000000000000000000000000000;;	func setupCNI(host, workspace string) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Install CNI on %q", host)
0000000000000000000000000000000000000000;;		cniPath := filepath.Join(workspace, cniDirectory)
0000000000000000000000000000000000000000;;		cmd := getSSHCommand(" ; ",
0000000000000000000000000000000000000000;;			fmt.Sprintf("mkdir -p %s", cniPath),
0000000000000000000000000000000000000000;;			fmt.Sprintf("wget -O - %s | tar -xz -C %s", cniURL, cniPath),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if output, err := SSH(host, "sh", "-c", cmd); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to install cni plugin on %q: %v output: %q", host, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The added CNI network config is not needed for kubenet. It is only
0000000000000000000000000000000000000000;;		// used when testing the CNI network plugin, but is added in both cases
0000000000000000000000000000000000000000;;		// for consistency and simplicity.
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Adding CNI configuration on %q", host)
0000000000000000000000000000000000000000;;		cniConfigPath := filepath.Join(workspace, cniConfDirectory)
0000000000000000000000000000000000000000;;		cmd = getSSHCommand(" ; ",
0000000000000000000000000000000000000000;;			fmt.Sprintf("mkdir -p %s", cniConfigPath),
0000000000000000000000000000000000000000;;			fmt.Sprintf("echo %s > %s", quote(cniConfig), filepath.Join(cniConfigPath, "mynet.conf")),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if output, err := SSH(host, "sh", "-c", cmd); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to write cni configuration on %q: %v output: %q", host, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configureFirewall configures iptable firewall rules.
0000000000000000000000000000000000000000;;	func configureFirewall(host string) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Configure iptables firewall rules on %q", host)
0000000000000000000000000000000000000000;;		// TODO: consider calling bootstrap script to configure host based on OS
0000000000000000000000000000000000000000;;		output, err := SSH(host, "iptables", "-L", "INPUT")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get iptables INPUT on %q: %v output: %q", host, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(output, "Chain INPUT (policy DROP)") {
0000000000000000000000000000000000000000;;			cmd := getSSHCommand("&&",
0000000000000000000000000000000000000000;;				"(iptables -C INPUT -w -p TCP -j ACCEPT || iptables -A INPUT -w -p TCP -j ACCEPT)",
0000000000000000000000000000000000000000;;				"(iptables -C INPUT -w -p UDP -j ACCEPT || iptables -A INPUT -w -p UDP -j ACCEPT)",
0000000000000000000000000000000000000000;;				"(iptables -C INPUT -w -p ICMP -j ACCEPT || iptables -A INPUT -w -p ICMP -j ACCEPT)")
0000000000000000000000000000000000000000;;			output, err := SSH(host, "sh", "-c", cmd)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to configured firewall on %q: %v output: %v", host, err, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output, err = SSH(host, "iptables", "-L", "FORWARD")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get iptables FORWARD on %q: %v output: %q", host, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(output, "Chain FORWARD (policy DROP)") {
0000000000000000000000000000000000000000;;			cmd := getSSHCommand("&&",
0000000000000000000000000000000000000000;;				"(iptables -C FORWARD -w -p TCP -j ACCEPT || iptables -A FORWARD -w -p TCP -j ACCEPT)",
0000000000000000000000000000000000000000;;				"(iptables -C FORWARD -w -p UDP -j ACCEPT || iptables -A FORWARD -w -p UDP -j ACCEPT)",
0000000000000000000000000000000000000000;;				"(iptables -C FORWARD -w -p ICMP -j ACCEPT || iptables -A FORWARD -w -p ICMP -j ACCEPT)")
0000000000000000000000000000000000000000;;			output, err = SSH(host, "sh", "-c", cmd)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to configured firewall on %q: %v output: %v", host, err, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanupNodeProcesses kills all running node processes may conflict with the test.
0000000000000000000000000000000000000000;;	func cleanupNodeProcesses(host string) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Killing any existing node processes on %q", host)
0000000000000000000000000000000000000000;;		cmd := getSSHCommand(" ; ",
0000000000000000000000000000000000000000;;			"pkill kubelet",
0000000000000000000000000000000000000000;;			"pkill kube-apiserver",
0000000000000000000000000000000000000000;;			"pkill etcd",
0000000000000000000000000000000000000000;;			"pkill e2e_node.test",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// No need to log an error if pkill fails since pkill will fail if the commands are not running.
0000000000000000000000000000000000000000;;		// If we are unable to stop existing running k8s processes, we should see messages in the kubelet/apiserver/etcd
0000000000000000000000000000000000000000;;		// logs about failing to bind the required ports.
0000000000000000000000000000000000000000;;		SSH(host, "sh", "-c", cmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Quotes a shell literal so it can be nested within another shell scope.
0000000000000000000000000000000000000000;;	func quote(s string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("'\"'\"'%s'\"'\"'", s)
0000000000000000000000000000000000000000;;	}
