0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c96bc767ebf38c408d0fd1d2da1cadaf6cabbc94;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e_node/builder"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConformanceRemote contains the specific functions in the node conformance test suite.
0000000000000000000000000000000000000000;;	type ConformanceRemote struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func InitConformanceRemote() TestSuite {
0000000000000000000000000000000000000000;;		return &ConformanceRemote{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getConformanceDirectory gets node conformance test build directory.
0000000000000000000000000000000000000000;;	func getConformanceDirectory() (string, error) {
0000000000000000000000000000000000000000;;		k8sRoot, err := builder.GetK8sRootDir()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Join(k8sRoot, "test", "e2e_node", "conformance", "build"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// commandToString is a helper function which formats command to string.
0000000000000000000000000000000000000000;;	func commandToString(c *exec.Cmd) string {
0000000000000000000000000000000000000000;;		return strings.Join(append([]string{c.Path}, c.Args[1:]...), " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Image path constants.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		conformanceRegistry         = "gcr.io/google_containers"
0000000000000000000000000000000000000000;;		conformanceArch             = runtime.GOARCH
0000000000000000000000000000000000000000;;		conformanceTarfile          = "node_conformance.tar"
0000000000000000000000000000000000000000;;		conformanceTestBinary       = "e2e_node.test"
0000000000000000000000000000000000000000;;		conformanceImageLoadTimeout = time.Duration(30) * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timestamp is used as an unique id of current test.
0000000000000000000000000000000000000000;;	var timestamp = getTimestamp()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getConformanceImageRepo returns conformance image full repo name.
0000000000000000000000000000000000000000;;	func getConformanceImageRepo() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/node-test-%s:%s", conformanceRegistry, conformanceArch, timestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildConformanceTest builds node conformance test image tarball into binDir.
0000000000000000000000000000000000000000;;	func buildConformanceTest(binDir string) error {
0000000000000000000000000000000000000000;;		// Get node conformance directory.
0000000000000000000000000000000000000000;;		conformancePath, err := getConformanceDirectory()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get node conformance directory: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Build docker image.
0000000000000000000000000000000000000000;;		cmd := exec.Command("make", "-C", conformancePath, "BIN_DIR="+binDir,
0000000000000000000000000000000000000000;;			"REGISTRY="+conformanceRegistry,
0000000000000000000000000000000000000000;;			"ARCH="+conformanceArch,
0000000000000000000000000000000000000000;;			"VERSION="+timestamp)
0000000000000000000000000000000000000000;;		if output, err := cmd.CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to build node conformance docker image: command - %q, error - %v, output - %q",
0000000000000000000000000000000000000000;;				commandToString(cmd), err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Save docker image into tar file.
0000000000000000000000000000000000000000;;		cmd = exec.Command("docker", "save", "-o", filepath.Join(binDir, conformanceTarfile), getConformanceImageRepo())
0000000000000000000000000000000000000000;;		if output, err := cmd.CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to save node conformance docker image into tar file: command - %q, error - %v, output - %q",
0000000000000000000000000000000000000000;;				commandToString(cmd), err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetupTestPackage sets up the test package with binaries k8s required for node conformance test
0000000000000000000000000000000000000000;;	func (c *ConformanceRemote) SetupTestPackage(tardir string) error {
0000000000000000000000000000000000000000;;		// Build the executables
0000000000000000000000000000000000000000;;		if err := builder.BuildGo(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to build the depedencies: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we can find the newly built binaries
0000000000000000000000000000000000000000;;		buildOutputDir, err := builder.GetK8sBuildOutputDir()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to locate kubernetes build output directory %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build node conformance tarball.
0000000000000000000000000000000000000000;;		if err := buildConformanceTest(buildOutputDir); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to build node conformance test %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy files
0000000000000000000000000000000000000000;;		requiredFiles := []string{"kubelet", conformanceTestBinary, conformanceTarfile}
0000000000000000000000000000000000000000;;		for _, file := range requiredFiles {
0000000000000000000000000000000000000000;;			source := filepath.Join(buildOutputDir, file)
0000000000000000000000000000000000000000;;			if _, err := os.Stat(source); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to locate test file %s: %v", file, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			output, err := exec.Command("cp", source, filepath.Join(tardir, file)).CombinedOutput()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to copy %q: error - %v output - %q", file, err, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loadConformanceImage loads node conformance image from tar file.
0000000000000000000000000000000000000000;;	func loadConformanceImage(host, workspace string) error {
0000000000000000000000000000000000000000;;		tarfile := filepath.Join(workspace, conformanceTarfile)
0000000000000000000000000000000000000000;;		if output, err := SSH(host, "timeout", conformanceImageLoadTimeout.String(),
0000000000000000000000000000000000000000;;			"docker", "load", "-i", tarfile); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to load node conformance image from tar file %q: error - %v output - %q",
0000000000000000000000000000000000000000;;				tarfile, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kubeletLauncherLog is the log of kubelet launcher.
0000000000000000000000000000000000000000;;	const kubeletLauncherLog = "kubelet-launcher.log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kubeletPodManifestPath is a fixed known pod manifest path. We can not use the random pod
0000000000000000000000000000000000000000;;	// manifest directory generated in e2e_node.test because we need to mount the directory into
0000000000000000000000000000000000000000;;	// the conformance test container, it's easier if it's a known directory.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Get rid of this once we switch to cluster e2e node bootstrap script.
0000000000000000000000000000000000000000;;	var kubeletPodManifestPath = "conformance-pod-manifest-" + timestamp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodManifestPath returns pod manifest full path.
0000000000000000000000000000000000000000;;	func getPodManifestPath(workspace string) string {
0000000000000000000000000000000000000000;;		return filepath.Join(workspace, kubeletPodManifestPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSystemd returns whether the node is a systemd node.
0000000000000000000000000000000000000000;;	func isSystemd(host string) (bool, error) {
0000000000000000000000000000000000000000;;		// Returns "systemd" if /run/systemd/system is found, empty string otherwise.
0000000000000000000000000000000000000000;;		output, err := SSH(host, "test", "-e", "/run/systemd/system", "&&", "echo", "systemd", "||", "true")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("failed to check systemd: error - %v output - %q", err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimSpace(output) != "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// launchKubelet launches kubelet by running e2e_node.test binary in run-kubelet-mode.
0000000000000000000000000000000000000000;;	// This is a temporary solution, we should change node e2e to use the same node bootstrap
0000000000000000000000000000000000000000;;	// with cluster e2e and launch kubelet outside of the test for both regular node e2e and
0000000000000000000000000000000000000000;;	// node conformance test.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Switch to use standard node bootstrap script.
0000000000000000000000000000000000000000;;	func launchKubelet(host, workspace, results, testArgs string) error {
0000000000000000000000000000000000000000;;		podManifestPath := getPodManifestPath(workspace)
0000000000000000000000000000000000000000;;		if output, err := SSH(host, "mkdir", podManifestPath); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create kubelet pod manifest path %q: error - %v output - %q",
0000000000000000000000000000000000000000;;				podManifestPath, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		startKubeletCmd := fmt.Sprintf("./%s --run-kubelet-mode --logtostderr --node-name=%s"+
0000000000000000000000000000000000000000;;			" --report-dir=%s %s --kubelet-flags=--pod-manifest-path=%s > %s 2>&1",
0000000000000000000000000000000000000000;;			conformanceTestBinary, host, results, testArgs, podManifestPath, filepath.Join(results, kubeletLauncherLog))
0000000000000000000000000000000000000000;;		var cmd []string
0000000000000000000000000000000000000000;;		systemd, err := isSystemd(host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to check systemd: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if systemd {
0000000000000000000000000000000000000000;;			cmd = []string{
0000000000000000000000000000000000000000;;				"systemd-run", "sh", "-c", getSSHCommand(" && ",
0000000000000000000000000000000000000000;;					// Switch to workspace.
0000000000000000000000000000000000000000;;					fmt.Sprintf("cd %s", workspace),
0000000000000000000000000000000000000000;;					// Launch kubelet by running e2e_node.test in run-kubelet-mode.
0000000000000000000000000000000000000000;;					startKubeletCmd,
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cmd = []string{
0000000000000000000000000000000000000000;;				"sh", "-c", getSSHCommand(" && ",
0000000000000000000000000000000000000000;;					// Switch to workspace.
0000000000000000000000000000000000000000;;					fmt.Sprintf("cd %s", workspace),
0000000000000000000000000000000000000000;;					// Launch kubelet by running e2e_node.test in run-kubelet-mode with nohup.
0000000000000000000000000000000000000000;;					fmt.Sprintf("(nohup %s &)", startKubeletCmd),
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Launch kubelet with command: %v", cmd)
0000000000000000000000000000000000000000;;		output, err := SSH(host, cmd...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to launch kubelet with command %v: error - %v output - %q",
0000000000000000000000000000000000000000;;				cmd, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Info("Successfully launch kubelet")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kubeletStopGracePeriod is the grace period to wait before forcibly killing kubelet.
0000000000000000000000000000000000000000;;	const kubeletStopGracePeriod = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stopKubelet stops kubelet launcher and kubelet gracefully.
0000000000000000000000000000000000000000;;	func stopKubelet(host, workspace string) error {
0000000000000000000000000000000000000000;;		glog.Info("Gracefully stop kubelet launcher")
0000000000000000000000000000000000000000;;		if output, err := SSH(host, "pkill", conformanceTestBinary); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to gracefully stop kubelet launcher: error - %v output - %q",
0000000000000000000000000000000000000000;;				err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Info("Wait for kubelet launcher to stop")
0000000000000000000000000000000000000000;;		stopped := false
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < kubeletStopGracePeriod; time.Sleep(time.Second) {
0000000000000000000000000000000000000000;;			// Check whether the process is still running.
0000000000000000000000000000000000000000;;			output, err := SSH(host, "pidof", conformanceTestBinary, "||", "true")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to check kubelet stopping: error - %v output -%q",
0000000000000000000000000000000000000000;;					err, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Kubelet is stopped
0000000000000000000000000000000000000000;;			if strings.TrimSpace(output) == "" {
0000000000000000000000000000000000000000;;				stopped = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !stopped {
0000000000000000000000000000000000000000;;			glog.Info("Forcibly stop kubelet")
0000000000000000000000000000000000000000;;			if output, err := SSH(host, "pkill", "-SIGKILL", conformanceTestBinary); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to forcibly stop kubelet: error - %v output - %q",
0000000000000000000000000000000000000000;;					err, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Info("Successfully stop kubelet")
0000000000000000000000000000000000000000;;		// Clean up the pod manifest path
0000000000000000000000000000000000000000;;		podManifestPath := getPodManifestPath(workspace)
0000000000000000000000000000000000000000;;		if output, err := SSH(host, "rm", "-f", filepath.Join(workspace, podManifestPath)); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to cleanup pod manifest directory %q: error - %v, output - %q",
0000000000000000000000000000000000000000;;				podManifestPath, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunTest runs test on the node.
0000000000000000000000000000000000000000;;	func (c *ConformanceRemote) RunTest(host, workspace, results, imageDesc, junitFilePrefix, testArgs, _ string, timeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		// Install the cni plugins and add a basic CNI configuration.
0000000000000000000000000000000000000000;;		if err := setupCNI(host, workspace); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Configure iptables firewall rules.
0000000000000000000000000000000000000000;;		if err := configureFirewall(host); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Kill any running node processes.
0000000000000000000000000000000000000000;;		cleanupNodeProcesses(host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Load node conformance image.
0000000000000000000000000000000000000000;;		if err := loadConformanceImage(host, workspace); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Launch kubelet.
0000000000000000000000000000000000000000;;		if err := launchKubelet(host, workspace, results, testArgs); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Stop kubelet.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err := stopKubelet(host, workspace); err != nil {
0000000000000000000000000000000000000000;;				// Only log an error if failed to stop kubelet because it is not critical.
0000000000000000000000000000000000000000;;				glog.Errorf("failed to stop kubelet: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the tests
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Starting tests on %q", host)
0000000000000000000000000000000000000000;;		podManifestPath := getPodManifestPath(workspace)
0000000000000000000000000000000000000000;;		cmd := fmt.Sprintf("'timeout -k 30s %fs docker run --rm --privileged=true --net=host -v /:/rootfs -v %s:%s -v %s:/var/result -e TEST_ARGS=--report-prefix=%s %s'",
0000000000000000000000000000000000000000;;			timeout.Seconds(), podManifestPath, podManifestPath, results, junitFilePrefix, getConformanceImageRepo())
0000000000000000000000000000000000000000;;		testOutput, err := SSH(host, "sh", "-c", cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return testOutput, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return testOutput, nil
0000000000000000000000000000000000000000;;	}
