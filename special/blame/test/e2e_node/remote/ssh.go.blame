0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
89520fbcb6164a35f1dde3694dc8ed6486243429;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"os/user"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var sshOptions = flag.String("ssh-options", "", "Commandline options passed to ssh.")
0000000000000000000000000000000000000000;;	var sshEnv = flag.String("ssh-env", "", "Use predefined ssh options for environment.  Options: gce")
0000000000000000000000000000000000000000;;	var sshKey = flag.String("ssh-key", "", "Path to ssh private key.")
0000000000000000000000000000000000000000;;	var sshUser = flag.String("ssh-user", "", "Use predefined user for ssh.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var sshOptionsMap map[string]string
0000000000000000000000000000000000000000;;	var sshDefaultKeyMap map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		usr, err := user.Current()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sshOptionsMap = map[string]string{
0000000000000000000000000000000000000000;;			"gce": "-o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -o CheckHostIP=no -o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o LogLevel=ERROR",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sshDefaultKeyMap = map[string]string{
0000000000000000000000000000000000000000;;			"gce": fmt.Sprintf("%s/.ssh/google_compute_engine", usr.HomeDir),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var hostnameIpOverrides = struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		m map[string]string
0000000000000000000000000000000000000000;;	}{m: make(map[string]string)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddHostnameIp(hostname, ip string) {
0000000000000000000000000000000000000000;;		hostnameIpOverrides.Lock()
0000000000000000000000000000000000000000;;		defer hostnameIpOverrides.Unlock()
0000000000000000000000000000000000000000;;		hostnameIpOverrides.m[hostname] = ip
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetHostnameOrIp converts hostname into ip and apply user if necessary.
0000000000000000000000000000000000000000;;	func GetHostnameOrIp(hostname string) string {
0000000000000000000000000000000000000000;;		hostnameIpOverrides.RLock()
0000000000000000000000000000000000000000;;		defer hostnameIpOverrides.RUnlock()
0000000000000000000000000000000000000000;;		host := hostname
0000000000000000000000000000000000000000;;		if ip, found := hostnameIpOverrides.m[hostname]; found {
0000000000000000000000000000000000000000;;			host = ip
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *sshUser != "" {
0000000000000000000000000000000000000000;;			host = fmt.Sprintf("%s@%s", *sshUser, host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSSHCommand handles proper quoting so that multiple commands are executed in the same shell over ssh
0000000000000000000000000000000000000000;;	func getSSHCommand(sep string, args ...string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("'%s'", strings.Join(args, sep))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SSH executes ssh command with runSSHCommand as root. The `sudo` makes sure that all commands
0000000000000000000000000000000000000000;;	// are executed by root, so that there won't be permission mismatch between different commands.
0000000000000000000000000000000000000000;;	func SSH(host string, cmd ...string) (string, error) {
0000000000000000000000000000000000000000;;		return runSSHCommand("ssh", append([]string{GetHostnameOrIp(host), "--", "sudo"}, cmd...)...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SSHNoSudo executes ssh command with runSSHCommand as normal user. Sometimes we need this,
0000000000000000000000000000000000000000;;	// for example creating a directory that we'll copy files there with scp.
0000000000000000000000000000000000000000;;	func SSHNoSudo(host string, cmd ...string) (string, error) {
0000000000000000000000000000000000000000;;		return runSSHCommand("ssh", append([]string{GetHostnameOrIp(host), "--"}, cmd...)...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runSSHCommand executes the ssh or scp command, adding the flag provided --ssh-options
0000000000000000000000000000000000000000;;	func runSSHCommand(cmd string, args ...string) (string, error) {
0000000000000000000000000000000000000000;;		if *sshKey != "" {
0000000000000000000000000000000000000000;;			args = append([]string{"-i", *sshKey}, args...)
0000000000000000000000000000000000000000;;		} else if key, found := sshDefaultKeyMap[*sshEnv]; found {
0000000000000000000000000000000000000000;;			args = append([]string{"-i", key}, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if env, found := sshOptionsMap[*sshEnv]; found {
0000000000000000000000000000000000000000;;			args = append(strings.Split(env, " "), args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *sshOptions != "" {
0000000000000000000000000000000000000000;;			args = append(strings.Split(*sshOptions, " "), args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output, err := exec.Command(cmd, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return string(output), fmt.Errorf("command [%s %s] failed with error: %v", cmd, strings.Join(args, " "), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(output), nil
0000000000000000000000000000000000000000;;	}
