0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
bfbc52cae485287981a4c04fdbdbbfc980b5735b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/md5"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testCheckpoint = "checkpoint-test"
0000000000000000000000000000000000000000;;		// Container GC Period is 1 minute
0000000000000000000000000000000000000000;;		gcTimeout             = 3 * time.Minute
0000000000000000000000000000000000000000;;		testCheckpointContent = `{"version":"v1","name":"fluentd-gcp-v2.0-vmnqx","namespace":"kube-system","data":{},"checksum":1799154314}`
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Dockershim [Serial] [Disruptive] [Feature:Docker]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("dockerhism-checkpoint-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should clean up pod sandbox checkpoint after pod deletion", func() {
0000000000000000000000000000000000000000;;			podName := "pod-checkpoint-no-disrupt"
0000000000000000000000000000000000000000;;			runPodCheckpointTest(f, podName, func() {
0000000000000000000000000000000000000000;;				checkpoints := findCheckpoints(podName)
0000000000000000000000000000000000000000;;				if len(checkpoints) == 0 {
0000000000000000000000000000000000000000;;					framework.Failf("No checkpoint for the pod was found")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		It("should remove dangling checkpoint file", func() {
0000000000000000000000000000000000000000;;			filename := fmt.Sprintf("%x", md5.Sum([]byte(fmt.Sprintf("%s/%s", testCheckpoint, f.Namespace.Name))))
0000000000000000000000000000000000000000;;			fullpath := path.Join(framework.TestContext.DockershimCheckpointDir, filename)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By(fmt.Sprintf("Write a file at %q", fullpath))
0000000000000000000000000000000000000000;;			err := writeFileAndSync(fullpath, []byte(testCheckpointContent))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err, "Failed to create file %q", fullpath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			By("Check if file is removed")
0000000000000000000000000000000000000000;;			Eventually(func() bool {
0000000000000000000000000000000000000000;;				if _, err := os.Stat(fullpath); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}, gcTimeout, 10*time.Second).Should(BeTrue())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("When pod sandbox checkpoint is missing", func() {
0000000000000000000000000000000000000000;;			It("should complete pod sandbox clean up", func() {
0000000000000000000000000000000000000000;;				podName := "pod-checkpoint-missing"
0000000000000000000000000000000000000000;;				runPodCheckpointTest(f, podName, func() {
0000000000000000000000000000000000000000;;					checkpoints := findCheckpoints(podName)
0000000000000000000000000000000000000000;;					if len(checkpoints) == 0 {
0000000000000000000000000000000000000000;;						framework.Failf("No checkpoint for the pod was found")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					By("Removing checkpoint of test pod")
0000000000000000000000000000000000000000;;					for _, filename := range checkpoints {
0000000000000000000000000000000000000000;;						if len(filename) == 0 {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						framework.Logf("Removing checkpiont %q", filename)
0000000000000000000000000000000000000000;;						_, err := exec.Command("sudo", "rm", filename).CombinedOutput()
0000000000000000000000000000000000000000;;						framework.ExpectNoError(err, "Failed to remove checkpoint file %q: %v", string(filename), err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("When all containers in pod are missing", func() {
0000000000000000000000000000000000000000;;			It("should complete pod sandbox clean up based on the information in sandbox checkpoint", func() {
0000000000000000000000000000000000000000;;				runPodCheckpointTest(f, "pod-containers-missing", func() {
0000000000000000000000000000000000000000;;					By("Gathering pod container ids")
0000000000000000000000000000000000000000;;					stdout, err := exec.Command("sudo", "docker", "ps", "-q", "-f",
0000000000000000000000000000000000000000;;						fmt.Sprintf("name=%s", f.Namespace.Name)).CombinedOutput()
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, "Failed to run docker ps: %v", err)
0000000000000000000000000000000000000000;;					lines := strings.Split(string(stdout), "\n")
0000000000000000000000000000000000000000;;					ids := []string{}
0000000000000000000000000000000000000000;;					for _, id := range lines {
0000000000000000000000000000000000000000;;						id = cleanString(id)
0000000000000000000000000000000000000000;;						if len(id) > 0 {
0000000000000000000000000000000000000000;;							ids = append(ids, id)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By("Stop and remove pod containers")
0000000000000000000000000000000000000000;;					dockerStopCmd := append([]string{"docker", "stop"}, ids...)
0000000000000000000000000000000000000000;;					_, err = exec.Command("sudo", dockerStopCmd...).CombinedOutput()
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, "Failed to run command %v: %v", dockerStopCmd, err)
0000000000000000000000000000000000000000;;					dockerRmCmd := append([]string{"docker", "rm"}, ids...)
0000000000000000000000000000000000000000;;					_, err = exec.Command("sudo", dockerRmCmd...).CombinedOutput()
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, "Failed to run command %v: %v", dockerRmCmd, err)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context("When checkpoint file is corrupted", func() {
0000000000000000000000000000000000000000;;			It("should complete pod sandbox clean up", func() {
0000000000000000000000000000000000000000;;				podName := "pod-checkpoint-corrupted"
0000000000000000000000000000000000000000;;				runPodCheckpointTest(f, podName, func() {
0000000000000000000000000000000000000000;;					By("Corrupt checkpoint file")
0000000000000000000000000000000000000000;;					checkpoints := findCheckpoints(podName)
0000000000000000000000000000000000000000;;					if len(checkpoints) == 0 {
0000000000000000000000000000000000000000;;						framework.Failf("No checkpoint for the pod was found")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, file := range checkpoints {
0000000000000000000000000000000000000000;;						f, err := os.OpenFile(file, os.O_WRONLY|os.O_APPEND, 0644)
0000000000000000000000000000000000000000;;						framework.ExpectNoError(err, "Failed to open file %q", file)
0000000000000000000000000000000000000000;;						_, err = f.WriteString("blabblab")
0000000000000000000000000000000000000000;;						framework.ExpectNoError(err, "Failed to write to file %q", file)
0000000000000000000000000000000000000000;;						f.Sync()
0000000000000000000000000000000000000000;;						f.Close()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runPodCheckpointTest(f *framework.Framework, podName string, twist func()) {
0000000000000000000000000000000000000000;;		podName = podName + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Creating test pod: %s", podName))
0000000000000000000000000000000000000000;;		f.PodClient().CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: podName},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Image: framework.GetPauseImageName(f.ClientSet),
0000000000000000000000000000000000000000;;						Name:  "pause-container",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Performing disruptive operations")
0000000000000000000000000000000000000000;;		twist()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Remove test pod")
0000000000000000000000000000000000000000;;		f.PodClient().DeleteSync(podName, &metav1.DeleteOptions{}, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		By("Waiting for checkpoint to be removed")
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(10*time.Second, gcTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			checkpoints := findCheckpoints(podName)
0000000000000000000000000000000000000000;;			if len(checkpoints) == 0 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			framework.Logf("Checkpoint of %q still exists: %v", podName, checkpoints)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			framework.Failf("Failed to observe checkpoint being removed within timeout: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanString cleans up any trailing spaces and new line character for the input string
0000000000000000000000000000000000000000;;	func cleanString(output string) string {
0000000000000000000000000000000000000000;;		processed := strings.TrimSpace(string(output))
0000000000000000000000000000000000000000;;		regex := regexp.MustCompile(`\r?\n`)
0000000000000000000000000000000000000000;;		processed = regex.ReplaceAllString(processed, "")
0000000000000000000000000000000000000000;;		return processed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeFileAndSync(path string, data []byte) error {
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = f.Write(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Sync()
0000000000000000000000000000000000000000;;		if err1 := f.Close(); err == nil {
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findCheckpoints returns all checkpoint files containing input string
0000000000000000000000000000000000000000;;	func findCheckpoints(match string) []string {
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("Search checkpoints containing %q", match))
0000000000000000000000000000000000000000;;		checkpoints := []string{}
0000000000000000000000000000000000000000;;		stdout, err := exec.Command("sudo", "grep", "-rl", match, framework.TestContext.DockershimCheckpointDir).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("grep from dockershim checkpoint directory returns error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stdout == nil {
0000000000000000000000000000000000000000;;			return checkpoints
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		files := strings.Split(string(stdout), "\n")
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			cleaned := cleanString(file)
0000000000000000000000000000000000000000;;			if len(cleaned) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			checkpoints = append(checkpoints, cleaned)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return checkpoints
0000000000000000000000000000000000000000;;	}
