0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
48687e92e477ac7584e2167428d5336e6db56d7e;test/e2e_node/e2e_service.go[test/e2e_node/e2e_service.go][test/e2e_node/services/services.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package services
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/kardianos/osext"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// E2EServices starts and stops e2e services in a separate process. The test
0000000000000000000000000000000000000000;;	// uses it to start and stop all e2e services.
0000000000000000000000000000000000000000;;	type E2EServices struct {
0000000000000000000000000000000000000000;;		// monitorParent determines whether the sub-processes should watch and die with the current
0000000000000000000000000000000000000000;;		// process.
0000000000000000000000000000000000000000;;		rmDirs        []string
0000000000000000000000000000000000000000;;		monitorParent bool
0000000000000000000000000000000000000000;;		services      *server
0000000000000000000000000000000000000000;;		kubelet       *server
0000000000000000000000000000000000000000;;		logFiles      map[string]logFileData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logFileData holds data about logfiles to fetch with a journalctl command or
0000000000000000000000000000000000000000;;	// symlink from a node's file system.
0000000000000000000000000000000000000000;;	type logFileData struct {
0000000000000000000000000000000000000000;;		files             []string
0000000000000000000000000000000000000000;;		journalctlCommand []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewE2EServices returns a new E2EServices instance.
0000000000000000000000000000000000000000;;	func NewE2EServices(monitorParent bool) *E2EServices {
0000000000000000000000000000000000000000;;		return &E2EServices{
0000000000000000000000000000000000000000;;			monitorParent: monitorParent,
0000000000000000000000000000000000000000;;			// Special log files that need to be collected for additional debugging.
0000000000000000000000000000000000000000;;			logFiles: map[string]logFileData{
0000000000000000000000000000000000000000;;				"kern.log":       {[]string{"/var/log/kern.log"}, []string{"-k"}},
0000000000000000000000000000000000000000;;				"docker.log":     {[]string{"/var/log/docker.log", "/var/log/upstart/docker.log"}, []string{"-u", "docker"}},
0000000000000000000000000000000000000000;;				"cloud-init.log": {[]string{"/var/log/cloud-init.log"}, []string{"-u", "cloud*"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start starts the e2e services in another process by calling back into the
0000000000000000000000000000000000000000;;	// test binary.  Returns when all e2e services are ready or an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We want to statically link e2e services into the test binary, but we don't
0000000000000000000000000000000000000000;;	// want their glog output to pollute the test result. So we run the binary in
0000000000000000000000000000000000000000;;	// run-services-mode to start e2e services in another process.
0000000000000000000000000000000000000000;;	// The function starts 2 processes:
0000000000000000000000000000000000000000;;	// * internal e2e services: services which statically linked in the test binary - apiserver, etcd and
0000000000000000000000000000000000000000;;	// namespace controller.
0000000000000000000000000000000000000000;;	// * kubelet: kubelet binary is outside. (We plan to move main kubelet start logic out when we have
0000000000000000000000000000000000000000;;	// standard kubelet launcher)
0000000000000000000000000000000000000000;;	func (e *E2EServices) Start() error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if !framework.TestContext.NodeConformance {
0000000000000000000000000000000000000000;;			// Start kubelet
0000000000000000000000000000000000000000;;			e.kubelet, err = e.startKubelet()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to start kubelet: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.services, err = e.startInternalServices()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the e2e services.
0000000000000000000000000000000000000000;;	func (e *E2EServices) Stop() {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if !framework.TestContext.NodeConformance {
0000000000000000000000000000000000000000;;				// Collect log files.
0000000000000000000000000000000000000000;;				e.getLogFiles()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if e.services != nil {
0000000000000000000000000000000000000000;;			if err := e.services.kill(); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to stop services: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.kubelet != nil {
0000000000000000000000000000000000000000;;			if err := e.kubelet.kill(); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to stop kubelet: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.rmDirs != nil {
0000000000000000000000000000000000000000;;			for _, d := range e.rmDirs {
0000000000000000000000000000000000000000;;				err := os.RemoveAll(d)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to delete directory %s: %v", d, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunE2EServices actually start the e2e services. This function is used to
0000000000000000000000000000000000000000;;	// start e2e services in current process. This is only used in run-services-mode.
0000000000000000000000000000000000000000;;	func RunE2EServices() {
0000000000000000000000000000000000000000;;		// Populate global DefaultFeatureGate with value from TestContext.FeatureGates.
0000000000000000000000000000000000000000;;		// This way, statically-linked components see the same feature gate config as the test context.
0000000000000000000000000000000000000000;;		utilfeature.DefaultFeatureGate.Set(framework.TestContext.FeatureGates)
0000000000000000000000000000000000000000;;		e := newE2EServices()
0000000000000000000000000000000000000000;;		if err := e.run(); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to run e2e services: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// services.log is the combined log of all services
0000000000000000000000000000000000000000;;		servicesLogFile = "services.log"
0000000000000000000000000000000000000000;;		// LOG_VERBOSITY_LEVEL is consistent with the level used in a cluster e2e test.
0000000000000000000000000000000000000000;;		LOG_VERBOSITY_LEVEL = "4"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startInternalServices starts the internal services in a separate process.
0000000000000000000000000000000000000000;;	func (e *E2EServices) startInternalServices() (*server, error) {
0000000000000000000000000000000000000000;;		testBin, err := osext.Executable()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("can't get current binary: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Pass all flags into the child process, so that it will see the same flag set.
0000000000000000000000000000000000000000;;		startCmd := exec.Command(testBin, append([]string{"--run-services-mode"}, os.Args[1:]...)...)
0000000000000000000000000000000000000000;;		server := newServer("services", startCmd, nil, nil, getServicesHealthCheckURLs(), servicesLogFile, e.monitorParent, false)
0000000000000000000000000000000000000000;;		return server, server.start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLogFiles gets logs of interest either via journalctl or by creating sym
0000000000000000000000000000000000000000;;	// links. Since we scp files from the remote directory, symlinks will be
0000000000000000000000000000000000000000;;	// treated as normal files and file contents will be copied over.
0000000000000000000000000000000000000000;;	func (e *E2EServices) getLogFiles() {
0000000000000000000000000000000000000000;;		// Nothing to do if report dir is not specified.
0000000000000000000000000000000000000000;;		if framework.TestContext.ReportDir == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Info("Fetching log files...")
0000000000000000000000000000000000000000;;		journaldFound := isJournaldAvailable()
0000000000000000000000000000000000000000;;		for targetFileName, logFileData := range e.logFiles {
0000000000000000000000000000000000000000;;			targetLink := path.Join(framework.TestContext.ReportDir, targetFileName)
0000000000000000000000000000000000000000;;			if journaldFound {
0000000000000000000000000000000000000000;;				// Skip log files that do not have an equivalent in journald-based machines.
0000000000000000000000000000000000000000;;				if len(logFileData.journalctlCommand) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Infof("Get log file %q with journalctl command %v.", targetFileName, logFileData.journalctlCommand)
0000000000000000000000000000000000000000;;				out, err := exec.Command("journalctl", logFileData.journalctlCommand...).CombinedOutput()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to get %q from journald: %v, %v", targetFileName, string(out), err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err = ioutil.WriteFile(targetLink, out, 0644); err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("failed to write logs to %q: %v", targetLink, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, file := range logFileData.files {
0000000000000000000000000000000000000000;;				if _, err := os.Stat(file); err != nil {
0000000000000000000000000000000000000000;;					// Expected file not found on this distro.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := copyLogFile(file, targetLink); err != nil {
0000000000000000000000000000000000000000;;					glog.Error(err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isJournaldAvailable returns whether the system executing the tests uses
0000000000000000000000000000000000000000;;	// journald.
0000000000000000000000000000000000000000;;	func isJournaldAvailable() bool {
0000000000000000000000000000000000000000;;		_, err := exec.LookPath("journalctl")
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyLogFile(src, target string) error {
0000000000000000000000000000000000000000;;		// If not a journald based distro, then just symlink files.
0000000000000000000000000000000000000000;;		if out, err := exec.Command("cp", src, target).CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to copy %q to %q: %v, %v", src, target, out, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out, err := exec.Command("chmod", "a+r", target).CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to make log file %q world readable: %v, %v", target, out, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
