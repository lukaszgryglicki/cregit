0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8a61fa8b78d8bea5022d101f030b28736ed91a2b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package services
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var serverStartTimeout = flag.Duration("server-start-timeout", time.Second*120, "Time to wait for each server to become healthy.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A server manages a separate server process started and killed with
0000000000000000000000000000000000000000;;	// commands.
0000000000000000000000000000000000000000;;	type server struct {
0000000000000000000000000000000000000000;;		// name is the name of the server, it is only used for logging.
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		// startCommand is the command used to start the server
0000000000000000000000000000000000000000;;		startCommand *exec.Cmd
0000000000000000000000000000000000000000;;		// killCommand is the command used to stop the server. It is not required. If it
0000000000000000000000000000000000000000;;		// is not specified, `kill` will be used to stop the server.
0000000000000000000000000000000000000000;;		killCommand *exec.Cmd
0000000000000000000000000000000000000000;;		// restartCommand is the command used to restart the server. If provided, it will be used
0000000000000000000000000000000000000000;;		// instead of startCommand when restarting the server.
0000000000000000000000000000000000000000;;		restartCommand *exec.Cmd
0000000000000000000000000000000000000000;;		// healthCheckUrls is the urls used to check whether the server is ready.
0000000000000000000000000000000000000000;;		healthCheckUrls []string
0000000000000000000000000000000000000000;;		// outFilename is the name of the log file. The stdout and stderr of the server
0000000000000000000000000000000000000000;;		// will be redirected to this file.
0000000000000000000000000000000000000000;;		outFilename string
0000000000000000000000000000000000000000;;		// monitorParent determines whether the server should watch its parent process and exit
0000000000000000000000000000000000000000;;		// if its parent is gone.
0000000000000000000000000000000000000000;;		monitorParent bool
0000000000000000000000000000000000000000;;		// restartOnExit determines whether a restart loop is launched with the server
0000000000000000000000000000000000000000;;		restartOnExit bool
0000000000000000000000000000000000000000;;		// Writing to this channel, if it is not nil, stops the restart loop.
0000000000000000000000000000000000000000;;		// When tearing down a server, you should check for this channel and write to it if it exists.
0000000000000000000000000000000000000000;;		stopRestartingCh chan<- bool
0000000000000000000000000000000000000000;;		// Read from this to confirm that the restart loop has stopped.
0000000000000000000000000000000000000000;;		ackStopRestartingCh <-chan bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newServer returns a new server with the given name, commands, health check
0000000000000000000000000000000000000000;;	// URLs, etc.
0000000000000000000000000000000000000000;;	func newServer(name string, start, kill, restart *exec.Cmd, urls []string, outputFileName string, monitorParent, restartOnExit bool) *server {
0000000000000000000000000000000000000000;;		return &server{
0000000000000000000000000000000000000000;;			name:            name,
0000000000000000000000000000000000000000;;			startCommand:    start,
0000000000000000000000000000000000000000;;			killCommand:     kill,
0000000000000000000000000000000000000000;;			restartCommand:  restart,
0000000000000000000000000000000000000000;;			healthCheckUrls: urls,
0000000000000000000000000000000000000000;;			outFilename:     outputFileName,
0000000000000000000000000000000000000000;;			monitorParent:   monitorParent,
0000000000000000000000000000000000000000;;			restartOnExit:   restartOnExit,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// commandToString format command to string.
0000000000000000000000000000000000000000;;	func commandToString(c *exec.Cmd) string {
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(append([]string{c.Path}, c.Args[1:]...), " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *server) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("server %q start-command: `%s`, kill-command: `%s`, restart-command: `%s`, health-check: %v, output-file: %q", s.name,
0000000000000000000000000000000000000000;;			commandToString(s.startCommand), commandToString(s.killCommand), commandToString(s.restartCommand), s.healthCheckUrls, s.outFilename)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readinessCheck checks whether services are ready via the supplied health
0000000000000000000000000000000000000000;;	// check URLs. Once there is an error in errCh, the function will stop waiting
0000000000000000000000000000000000000000;;	// and return the error.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Move this to util
0000000000000000000000000000000000000000;;	func readinessCheck(name string, urls []string, errCh <-chan error) error {
0000000000000000000000000000000000000000;;		glog.Infof("Running readiness check for service %q", name)
0000000000000000000000000000000000000000;;		endTime := time.Now().Add(*serverStartTimeout)
0000000000000000000000000000000000000000;;		blockCh := make(chan error)
0000000000000000000000000000000000000000;;		defer close(blockCh)
0000000000000000000000000000000000000000;;		for endTime.After(time.Now()) {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			// We *always* want to run the health check if there is no error on the channel.
0000000000000000000000000000000000000000;;			// With systemd, reads from errCh report nil because cmd.Run() waits
0000000000000000000000000000000000000000;;			// on systemd-run, rather than the service process. systemd-run quickly
0000000000000000000000000000000000000000;;			// exits with status 0, causing the channel to be closed with no error. In
0000000000000000000000000000000000000000;;			// this case, you want to wait for the health check to complete, rather
0000000000000000000000000000000000000000;;			// than returning from readinessCheck as soon as the channel is closed.
0000000000000000000000000000000000000000;;			case err, ok := <-errCh:
0000000000000000000000000000000000000000;;				if ok { // The channel is not closed, this is a real error
0000000000000000000000000000000000000000;;					if err != nil { // If there is an error, return it
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// If not, keep checking readiness.
0000000000000000000000000000000000000000;;				} else { // The channel is closed, this is only a zero value.
0000000000000000000000000000000000000000;;					// Replace the errCh with blockCh to avoid busy loop,
0000000000000000000000000000000000000000;;					// and keep checking readiness.
0000000000000000000000000000000000000000;;					errCh = blockCh
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(time.Second):
0000000000000000000000000000000000000000;;				ready := true
0000000000000000000000000000000000000000;;				for _, url := range urls {
0000000000000000000000000000000000000000;;					resp, err := http.Head(url)
0000000000000000000000000000000000000000;;					if err != nil || resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;						ready = false
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ready {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("e2e service %q readiness check timeout %v", name, *serverStartTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// start starts the server by running its commands, monitors it with a health
0000000000000000000000000000000000000000;;	// check, and ensures that it is restarted if applicable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note: restartOnExit == true requires len(s.healthCheckUrls) > 0 to work properly.
0000000000000000000000000000000000000000;;	func (s *server) start() error {
0000000000000000000000000000000000000000;;		glog.Infof("Starting server %q with command %q", s.name, commandToString(s.startCommand))
0000000000000000000000000000000000000000;;		errCh := make(chan error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up restart channels if the server is configured for restart on exit.
0000000000000000000000000000000000000000;;		var stopRestartingCh, ackStopRestartingCh chan bool
0000000000000000000000000000000000000000;;		if s.restartOnExit {
0000000000000000000000000000000000000000;;			if len(s.healthCheckUrls) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Tried to start %s which has s.restartOnExit == true, but no health check urls provided.", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stopRestartingCh = make(chan bool)
0000000000000000000000000000000000000000;;			ackStopRestartingCh = make(chan bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.stopRestartingCh = stopRestartingCh
0000000000000000000000000000000000000000;;			s.ackStopRestartingCh = ackStopRestartingCh
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This goroutine actually runs the start command for the server.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer close(errCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create the output filename
0000000000000000000000000000000000000000;;			outPath := path.Join(framework.TestContext.ReportDir, s.outFilename)
0000000000000000000000000000000000000000;;			outfile, err := os.Create(outPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errCh <- fmt.Errorf("failed to create file %q for `%s` %v.", outPath, s, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("Output file for server %q: %v", s.name, outfile.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer outfile.Close()
0000000000000000000000000000000000000000;;			defer outfile.Sync()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set the command to write the output file
0000000000000000000000000000000000000000;;			s.startCommand.Stdout = outfile
0000000000000000000000000000000000000000;;			s.startCommand.Stderr = outfile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If monitorParent is set, set Pdeathsig when starting the server.
0000000000000000000000000000000000000000;;			if s.monitorParent {
0000000000000000000000000000000000000000;;				// Death of this test process should kill the server as well.
0000000000000000000000000000000000000000;;				attrs := &syscall.SysProcAttr{}
0000000000000000000000000000000000000000;;				// Hack to set linux-only field without build tags.
0000000000000000000000000000000000000000;;				deathSigField := reflect.ValueOf(attrs).Elem().FieldByName("Pdeathsig")
0000000000000000000000000000000000000000;;				if deathSigField.IsValid() {
0000000000000000000000000000000000000000;;					deathSigField.Set(reflect.ValueOf(syscall.SIGTERM))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errCh <- fmt.Errorf("failed to set Pdeathsig field (non-linux build)")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s.startCommand.SysProcAttr = attrs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Start the command
0000000000000000000000000000000000000000;;			err = s.startCommand.Start()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errCh <- fmt.Errorf("failed to run %s: %v", s, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !s.restartOnExit {
0000000000000000000000000000000000000000;;				glog.Infof("Waiting for server %q start command to complete", s.name)
0000000000000000000000000000000000000000;;				// If we aren't planning on restarting, ok to Wait() here to release resources.
0000000000000000000000000000000000000000;;				// Otherwise, we Wait() in the restart loop.
0000000000000000000000000000000000000000;;				err = s.startCommand.Wait()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errCh <- fmt.Errorf("failed to run start command for server %q: %v", s.name, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				usedStartCmd := true
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					glog.Infof("Running health check for service %q", s.name)
0000000000000000000000000000000000000000;;					// Wait for an initial health check to pass, so that we are sure the server started.
0000000000000000000000000000000000000000;;					err := readinessCheck(s.name, s.healthCheckUrls, nil)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if usedStartCmd {
0000000000000000000000000000000000000000;;							glog.Infof("Waiting for server %q start command to complete after initial health check failed", s.name)
0000000000000000000000000000000000000000;;							s.startCommand.Wait() // Release resources if necessary.
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// This should not happen, immediately stop the e2eService process.
0000000000000000000000000000000000000000;;						glog.Fatalf("Restart loop readinessCheck failed for %s", s)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.Infof("Initial health check passed for service %q", s.name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Initial health check passed, wait until a health check fails again.
0000000000000000000000000000000000000000;;				stillAlive:
0000000000000000000000000000000000000000;;					for {
0000000000000000000000000000000000000000;;						select {
0000000000000000000000000000000000000000;;						case <-stopRestartingCh:
0000000000000000000000000000000000000000;;							ackStopRestartingCh <- true
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						case <-time.After(time.Second):
0000000000000000000000000000000000000000;;							for _, url := range s.healthCheckUrls {
0000000000000000000000000000000000000000;;								resp, err := http.Head(url)
0000000000000000000000000000000000000000;;								if err != nil || resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;									break stillAlive
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if usedStartCmd {
0000000000000000000000000000000000000000;;						s.startCommand.Wait() // Release resources from last cmd
0000000000000000000000000000000000000000;;						usedStartCmd = false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if s.restartCommand != nil {
0000000000000000000000000000000000000000;;						// Always make a fresh copy of restartCommand before
0000000000000000000000000000000000000000;;						// running, we may have to restart multiple times
0000000000000000000000000000000000000000;;						s.restartCommand = &exec.Cmd{
0000000000000000000000000000000000000000;;							Path:        s.restartCommand.Path,
0000000000000000000000000000000000000000;;							Args:        s.restartCommand.Args,
0000000000000000000000000000000000000000;;							Env:         s.restartCommand.Env,
0000000000000000000000000000000000000000;;							Dir:         s.restartCommand.Dir,
0000000000000000000000000000000000000000;;							Stdin:       s.restartCommand.Stdin,
0000000000000000000000000000000000000000;;							Stdout:      s.restartCommand.Stdout,
0000000000000000000000000000000000000000;;							Stderr:      s.restartCommand.Stderr,
0000000000000000000000000000000000000000;;							ExtraFiles:  s.restartCommand.ExtraFiles,
0000000000000000000000000000000000000000;;							SysProcAttr: s.restartCommand.SysProcAttr,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// Run and wait for exit. This command is assumed to have
0000000000000000000000000000000000000000;;						// short duration, e.g. systemctl restart
0000000000000000000000000000000000000000;;						glog.Infof("Restarting server %q with restart command", s.name)
0000000000000000000000000000000000000000;;						err = s.restartCommand.Run()
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							// This should not happen, immediately stop the e2eService process.
0000000000000000000000000000000000000000;;							glog.Fatalf("Restarting server %s with restartCommand failed. Error: %v.", s, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						s.startCommand = &exec.Cmd{
0000000000000000000000000000000000000000;;							Path:        s.startCommand.Path,
0000000000000000000000000000000000000000;;							Args:        s.startCommand.Args,
0000000000000000000000000000000000000000;;							Env:         s.startCommand.Env,
0000000000000000000000000000000000000000;;							Dir:         s.startCommand.Dir,
0000000000000000000000000000000000000000;;							Stdin:       s.startCommand.Stdin,
0000000000000000000000000000000000000000;;							Stdout:      s.startCommand.Stdout,
0000000000000000000000000000000000000000;;							Stderr:      s.startCommand.Stderr,
0000000000000000000000000000000000000000;;							ExtraFiles:  s.startCommand.ExtraFiles,
0000000000000000000000000000000000000000;;							SysProcAttr: s.startCommand.SysProcAttr,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						glog.Infof("Restarting server %q with start command", s.name)
0000000000000000000000000000000000000000;;						err = s.startCommand.Start()
0000000000000000000000000000000000000000;;						usedStartCmd = true
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							// This should not happen, immediately stop the e2eService process.
0000000000000000000000000000000000000000;;							glog.Fatalf("Restarting server %s with startCommand failed. Error: %v.", s, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return readinessCheck(s.name, s.healthCheckUrls, errCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kill runs the server's kill command.
0000000000000000000000000000000000000000;;	func (s *server) kill() error {
0000000000000000000000000000000000000000;;		glog.Infof("Kill server %q", s.name)
0000000000000000000000000000000000000000;;		name := s.name
0000000000000000000000000000000000000000;;		cmd := s.startCommand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If s has a restart loop, turn it off.
0000000000000000000000000000000000000000;;		if s.restartOnExit {
0000000000000000000000000000000000000000;;			s.stopRestartingCh <- true
0000000000000000000000000000000000000000;;			<-s.ackStopRestartingCh
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.killCommand != nil {
0000000000000000000000000000000000000000;;			return s.killCommand.Run()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmd == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("could not kill %q because both `killCommand` and `startCommand` are nil", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmd.Process == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("%q not running", name)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pid := cmd.Process.Pid
0000000000000000000000000000000000000000;;		if pid <= 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid PID %d for %q", pid, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attempt to shut down the process in a friendly manner before forcing it.
0000000000000000000000000000000000000000;;		waitChan := make(chan error)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			_, err := cmd.Process.Wait()
0000000000000000000000000000000000000000;;			waitChan <- err
0000000000000000000000000000000000000000;;			close(waitChan)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const timeout = 10 * time.Second
0000000000000000000000000000000000000000;;		for _, signal := range []string{"-TERM", "-KILL"} {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Killing process %d (%s) with %s", pid, name, signal)
0000000000000000000000000000000000000000;;			cmd := exec.Command("kill", signal, strconv.Itoa(pid))
0000000000000000000000000000000000000000;;			_, err := cmd.Output()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error signaling process %d (%s) with %s: %v", pid, name, signal, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case err := <-waitChan:
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error stopping %q: %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Success!
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case <-time.After(timeout):
0000000000000000000000000000000000000000;;				// Continue.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("unable to stop %q", name)
0000000000000000000000000000000000000000;;	}
