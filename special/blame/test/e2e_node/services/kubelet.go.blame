0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a83893bb52642b5911e78bd7cf067fbb5619704a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package services
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e_node/builder"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(random-liu): Replace this with standard kubelet launcher.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// args is the type used to accumulate args from the flags with the same name.
0000000000000000000000000000000000000000;;	type args []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String function of flag.Value
0000000000000000000000000000000000000000;;	func (a *args) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprint(*a)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set function of flag.Value
0000000000000000000000000000000000000000;;	func (a *args) Set(value string) error {
0000000000000000000000000000000000000000;;		// Someone else is calling flag.Parse after the flags are parsed in the
0000000000000000000000000000000000000000;;		// test framework. Use this to avoid the flag being parsed twice.
0000000000000000000000000000000000000000;;		// TODO(random-liu): Figure out who is parsing the flags.
0000000000000000000000000000000000000000;;		if flag.Parsed() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Note that we assume all white space in flag string is separating fields
0000000000000000000000000000000000000000;;		na := strings.Fields(value)
0000000000000000000000000000000000000000;;		*a = append(*a, na...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kubeletArgs is the override kubelet args specified by the test runner.
0000000000000000000000000000000000000000;;	var kubeletArgs args
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		flag.Var(&kubeletArgs, "kubelet-flags", "Kubelet flags passed to kubelet, this will override default kubelet flags in the test. Flags specified in multiple kubelet-flags will be concatenate.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunKubelet starts kubelet and waits for termination signal. Once receives the
0000000000000000000000000000000000000000;;	// termination signal, it will stop the kubelet gracefully.
0000000000000000000000000000000000000000;;	func RunKubelet() {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// Enable monitorParent to make sure kubelet will receive termination signal
0000000000000000000000000000000000000000;;		// when test process exits.
0000000000000000000000000000000000000000;;		e := NewE2EServices(true /* monitorParent */)
0000000000000000000000000000000000000000;;		defer e.Stop()
0000000000000000000000000000000000000000;;		e.kubelet, err = e.startKubelet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to start kubelet: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wait until receiving a termination signal.
0000000000000000000000000000000000000000;;		waitForTerminationSignal()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Ports of different e2e services.
0000000000000000000000000000000000000000;;		kubeletPort         = "10250"
0000000000000000000000000000000000000000;;		kubeletReadOnlyPort = "10255"
0000000000000000000000000000000000000000;;		// Health check url of kubelet
0000000000000000000000000000000000000000;;		kubeletHealthCheckURL = "http://127.0.0.1:" + kubeletReadOnlyPort + "/healthz"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startKubelet starts the Kubelet in a separate process or returns an error
0000000000000000000000000000000000000000;;	// if the Kubelet fails to start.
0000000000000000000000000000000000000000;;	func (e *E2EServices) startKubelet() (*server, error) {
0000000000000000000000000000000000000000;;		glog.Info("Starting kubelet")
0000000000000000000000000000000000000000;;		// Create pod manifest path
0000000000000000000000000000000000000000;;		manifestPath, err := createPodManifestDirectory()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.rmDirs = append(e.rmDirs, manifestPath)
0000000000000000000000000000000000000000;;		var killCommand, restartCommand *exec.Cmd
0000000000000000000000000000000000000000;;		var isSystemd bool
0000000000000000000000000000000000000000;;		// Apply default kubelet flags.
0000000000000000000000000000000000000000;;		cmdArgs := []string{}
0000000000000000000000000000000000000000;;		if systemdRun, err := exec.LookPath("systemd-run"); err == nil {
0000000000000000000000000000000000000000;;			// On systemd services, detection of a service / unit works reliably while
0000000000000000000000000000000000000000;;			// detection of a process started from an ssh session does not work.
0000000000000000000000000000000000000000;;			// Since kubelet will typically be run as a service it also makes more
0000000000000000000000000000000000000000;;			// sense to test it that way
0000000000000000000000000000000000000000;;			isSystemd = true
0000000000000000000000000000000000000000;;			unitName := fmt.Sprintf("kubelet-%d.service", rand.Int31())
0000000000000000000000000000000000000000;;			cmdArgs = append(cmdArgs, systemdRun, "--unit="+unitName, "--slice=runtime.slice", "--remain-after-exit", builder.GetKubeletServerBin())
0000000000000000000000000000000000000000;;			killCommand = exec.Command("systemctl", "kill", unitName)
0000000000000000000000000000000000000000;;			restartCommand = exec.Command("systemctl", "restart", unitName)
0000000000000000000000000000000000000000;;			e.logFiles["kubelet.log"] = logFileData{
0000000000000000000000000000000000000000;;				journalctlCommand: []string{"-u", unitName},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdArgs = append(cmdArgs,
0000000000000000000000000000000000000000;;				"--kubelet-cgroups=/kubelet.slice",
0000000000000000000000000000000000000000;;				"--cgroup-root=/",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cmdArgs = append(cmdArgs, builder.GetKubeletServerBin())
0000000000000000000000000000000000000000;;			cmdArgs = append(cmdArgs,
0000000000000000000000000000000000000000;;				"--runtime-cgroups=/docker-daemon",
0000000000000000000000000000000000000000;;				"--kubelet-cgroups=/kubelet",
0000000000000000000000000000000000000000;;				"--cgroup-root=/",
0000000000000000000000000000000000000000;;				"--system-cgroups=/system",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmdArgs = append(cmdArgs,
0000000000000000000000000000000000000000;;			"--api-servers", getAPIServerClientURL(),
0000000000000000000000000000000000000000;;			"--address", "0.0.0.0",
0000000000000000000000000000000000000000;;			"--port", kubeletPort,
0000000000000000000000000000000000000000;;			"--read-only-port", kubeletReadOnlyPort,
0000000000000000000000000000000000000000;;			"--volume-stats-agg-period", "10s", // Aggregate volumes frequently so tests don't need to wait as long
0000000000000000000000000000000000000000;;			"--allow-privileged", "true",
0000000000000000000000000000000000000000;;			"--serialize-image-pulls", "false",
0000000000000000000000000000000000000000;;			"--pod-manifest-path", manifestPath,
0000000000000000000000000000000000000000;;			"--file-check-frequency", "10s", // Check file frequently so tests won't wait too long
0000000000000000000000000000000000000000;;			// Assign a fixed CIDR to the node because there is no node controller.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Note: this MUST be in sync with with the IP in
0000000000000000000000000000000000000000;;			// - cluster/gce/config-test.sh and
0000000000000000000000000000000000000000;;			// - test/e2e_node/conformance/run_test.sh.
0000000000000000000000000000000000000000;;			"--pod-cidr", "10.100.0.0/24",
0000000000000000000000000000000000000000;;			"--eviction-pressure-transition-period", "30s",
0000000000000000000000000000000000000000;;			// Apply test framework feature gates by default. This could also be overridden
0000000000000000000000000000000000000000;;			// by kubelet-flags.
0000000000000000000000000000000000000000;;			"--feature-gates", framework.TestContext.FeatureGates,
0000000000000000000000000000000000000000;;			"--eviction-hard", "memory.available<250Mi,nodefs.available<10%,nodefs.inodesFree<5%", // The hard eviction thresholds.
0000000000000000000000000000000000000000;;			"--eviction-minimum-reclaim", "nodefs.available=5%,nodefs.inodesFree=5%", // The minimum reclaimed resources after eviction.
0000000000000000000000000000000000000000;;			"--v", LOG_VERBOSITY_LEVEL, "--logtostderr",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// Enable kubenet by default.
0000000000000000000000000000000000000000;;		cniBinDir, err := getCNIBinDirectory()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cniConfDir, err := getCNIConfDirectory()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdArgs = append(cmdArgs,
0000000000000000000000000000000000000000;;			"--network-plugin=kubenet",
0000000000000000000000000000000000000000;;			"--cni-bin-dir", cniBinDir,
0000000000000000000000000000000000000000;;			"--cni-conf-dir", cniConfDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Keep hostname override for convenience.
0000000000000000000000000000000000000000;;		if framework.TestContext.NodeName != "" { // If node name is specified, set hostname override.
0000000000000000000000000000000000000000;;			cmdArgs = append(cmdArgs, "--hostname-override", framework.TestContext.NodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Override the default kubelet flags.
0000000000000000000000000000000000000000;;		cmdArgs = append(cmdArgs, kubeletArgs...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adjust the args if we are running kubelet with systemd.
0000000000000000000000000000000000000000;;		if isSystemd {
0000000000000000000000000000000000000000;;			adjustArgsForSystemd(cmdArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)
0000000000000000000000000000000000000000;;		server := newServer(
0000000000000000000000000000000000000000;;			"kubelet",
0000000000000000000000000000000000000000;;			cmd,
0000000000000000000000000000000000000000;;			killCommand,
0000000000000000000000000000000000000000;;			restartCommand,
0000000000000000000000000000000000000000;;			[]string{kubeletHealthCheckURL},
0000000000000000000000000000000000000000;;			"kubelet.log",
0000000000000000000000000000000000000000;;			e.monitorParent,
0000000000000000000000000000000000000000;;			true /* restartOnExit */)
0000000000000000000000000000000000000000;;		return server, server.start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createPodManifestDirectory creates pod manifest directory.
0000000000000000000000000000000000000000;;	func createPodManifestDirectory() (string, error) {
0000000000000000000000000000000000000000;;		cwd, err := os.Getwd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get current working directory: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path, err := ioutil.TempDir(cwd, "pod-manifest")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to create static pod manifest directory: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCNIBinDirectory returns CNI directory.
0000000000000000000000000000000000000000;;	func getCNIBinDirectory() (string, error) {
0000000000000000000000000000000000000000;;		cwd, err := os.Getwd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Join(cwd, "cni", "bin"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCNIConfDirectory returns CNI Configuration directory.
0000000000000000000000000000000000000000;;	func getCNIConfDirectory() (string, error) {
0000000000000000000000000000000000000000;;		cwd, err := os.Getwd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Join(cwd, "cni", "net.d"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adjustArgsForSystemd escape special characters in kubelet arguments for systemd. Systemd
0000000000000000000000000000000000000000;;	// may try to do auto expansion without escaping.
0000000000000000000000000000000000000000;;	func adjustArgsForSystemd(args []string) {
0000000000000000000000000000000000000000;;		for i := range args {
0000000000000000000000000000000000000000;;			args[i] = strings.Replace(args[i], "%", "%%", -1)
0000000000000000000000000000000000000000;;			args[i] = strings.Replace(args[i], "$", "$$", -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
