0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d953befe9c88cd4b37d9e4100650c1f624ea7427;test/e2e_node/etcd.go[test/e2e_node/etcd.go][test/e2e_node/services/etcd.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package services
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v2http"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/transport"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: These tests should not be leveraging v2http
0000000000000000000000000000000000000000;;	// TODO(random-liu): Add service interface to manage services with the same behaviour.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All following configurations are got from etcd source code.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Use embed.NewConfig after etcd3 is supported.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		etcdName           = "etcd"
0000000000000000000000000000000000000000;;		clientURLStr       = "http://localhost:4001" // clientURL has listener created and handles etcd API traffic
0000000000000000000000000000000000000000;;		peerURLStr         = "http://localhost:7001" // peerURL does't have listener created, it is used to pass Etcd validation
0000000000000000000000000000000000000000;;		snapCount          = etcdserver.DefaultSnapCount
0000000000000000000000000000000000000000;;		maxSnapFiles       = 5
0000000000000000000000000000000000000000;;		maxWALFiles        = 5
0000000000000000000000000000000000000000;;		tickMs             = 100
0000000000000000000000000000000000000000;;		electionTicks      = 10
0000000000000000000000000000000000000000;;		etcdHealthCheckURL = clientURLStr + "/v2/keys/" // Trailing slash is required,
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EtcdServer is a server which manages etcd.
0000000000000000000000000000000000000000;;	type EtcdServer struct {
0000000000000000000000000000000000000000;;		*etcdserver.EtcdServer
0000000000000000000000000000000000000000;;		config       *etcdserver.ServerConfig
0000000000000000000000000000000000000000;;		clientListen net.Listener
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEtcd creates a new default etcd server using 'dataDir' for persistence.
0000000000000000000000000000000000000000;;	func NewEtcd(dataDir string) *EtcdServer {
0000000000000000000000000000000000000000;;		clientURLs, err := types.NewURLs([]string{clientURLStr})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to parse client url %q: %v", clientURLStr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		peerURLs, err := types.NewURLs([]string{peerURLStr})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to parse peer url %q: %v", peerURLStr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := &etcdserver.ServerConfig{
0000000000000000000000000000000000000000;;			Name:               etcdName,
0000000000000000000000000000000000000000;;			ClientURLs:         clientURLs,
0000000000000000000000000000000000000000;;			PeerURLs:           peerURLs,
0000000000000000000000000000000000000000;;			DataDir:            dataDir,
0000000000000000000000000000000000000000;;			InitialPeerURLsMap: map[string]types.URLs{etcdName: peerURLs},
0000000000000000000000000000000000000000;;			NewCluster:         true,
0000000000000000000000000000000000000000;;			SnapCount:          snapCount,
0000000000000000000000000000000000000000;;			MaxSnapFiles:       maxSnapFiles,
0000000000000000000000000000000000000000;;			MaxWALFiles:        maxWALFiles,
0000000000000000000000000000000000000000;;			TickMs:             tickMs,
0000000000000000000000000000000000000000;;			ElectionTicks:      electionTicks,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &EtcdServer{
0000000000000000000000000000000000000000;;			config: config,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start starts the etcd server and listening for client connections
0000000000000000000000000000000000000000;;	func (e *EtcdServer) Start() error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		e.EtcdServer, err = etcdserver.NewServer(e.config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// create client listener, there should be only one url
0000000000000000000000000000000000000000;;		e.clientListen, err = createListener(e.config.ClientURLs[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start etcd
0000000000000000000000000000000000000000;;		e.EtcdServer.Start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// setup client listener
0000000000000000000000000000000000000000;;		ch := v2http.NewClientHandler(e.EtcdServer, e.config.ReqTimeout())
0000000000000000000000000000000000000000;;		errCh := make(chan error)
0000000000000000000000000000000000000000;;		go func(l net.Listener) {
0000000000000000000000000000000000000000;;			defer close(errCh)
0000000000000000000000000000000000000000;;			srv := &http.Server{
0000000000000000000000000000000000000000;;				Handler:     ch,
0000000000000000000000000000000000000000;;				ReadTimeout: 5 * time.Minute,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Serve always returns a non-nil error.
0000000000000000000000000000000000000000;;			errCh <- srv.Serve(l)
0000000000000000000000000000000000000000;;		}(e.clientListen)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = readinessCheck("etcd", []string{etcdHealthCheckURL}, errCh)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop closes all connections and stops the Etcd server
0000000000000000000000000000000000000000;;	func (e *EtcdServer) Stop() error {
0000000000000000000000000000000000000000;;		if e.EtcdServer != nil {
0000000000000000000000000000000000000000;;			e.EtcdServer.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.clientListen != nil {
0000000000000000000000000000000000000000;;			err := e.clientListen.Close()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the server's unique name
0000000000000000000000000000000000000000;;	func (e *EtcdServer) Name() string {
0000000000000000000000000000000000000000;;		return etcdName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createListener(url url.URL) (net.Listener, error) {
0000000000000000000000000000000000000000;;		l, err := net.Listen("tcp", url.Host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l, err = transport.NewKeepAliveListener(l, url.Scheme, &tls.Config{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEtcdClientURL() string {
0000000000000000000000000000000000000000;;		return clientURLStr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEtcdHealthCheckURL() string {
0000000000000000000000000000000000000000;;		return etcdHealthCheckURL
0000000000000000000000000000000000000000;;	}
