0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2f7a20eac9254377eb72dcf54a351ccc8912158b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet"
0000000000000000000000000000000000000000;;		kubecontainer "k8s.io/kubernetes/pkg/kubelet/container"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		logString = "This is the expected log content of this node e2e test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logPodName    = "logger-pod"
0000000000000000000000000000000000000000;;		logContName   = "logger-container"
0000000000000000000000000000000000000000;;		checkPodName  = "checker-pod"
0000000000000000000000000000000000000000;;		checkContName = "checker-container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("ContainerLogPath", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("kubelet-container-log-path")
0000000000000000000000000000000000000000;;		Describe("Pod with a container", func() {
0000000000000000000000000000000000000000;;			Context("printed log to stdout", func() {
0000000000000000000000000000000000000000;;				It("should print log to correct log path", func() {
0000000000000000000000000000000000000000;;					podClient := f.PodClient()
0000000000000000000000000000000000000000;;					ns := f.Namespace.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					logDirVolumeName := "log-dir-vol"
0000000000000000000000000000000000000000;;					logDir := kubelet.ContainerLogsDir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					logPod := &v1.Pod{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name: logPodName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							// this pod is expected to exit successfully
0000000000000000000000000000000000000000;;							RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;							Containers: []v1.Container{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;									Name:    logContName,
0000000000000000000000000000000000000000;;									Command: []string{"sh", "-c", "echo " + logString},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					podClient.Create(logPod)
0000000000000000000000000000000000000000;;					err := framework.WaitForPodSuccessInNamespace(f.ClientSet, logPodName, ns)
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, "Failed waiting for pod: %s to enter success state", logPodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// get containerID from created Pod
0000000000000000000000000000000000000000;;					createdLogPod, err := podClient.Get(logPodName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					logConID := kubecontainer.ParseContainerID(createdLogPod.Status.ContainerStatuses[0].ContainerID)
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, "Failed to get pod: %s", logPodName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					expectedlogFile := logDir + "/" + logPodName + "_" + ns + "_" + logContName + "-" + logConID.ID + ".log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					checkPod := &v1.Pod{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Name: checkPodName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;							// this pod is expected to exit successfully
0000000000000000000000000000000000000000;;							RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;							Containers: []v1.Container{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;									Name:  checkContName,
0000000000000000000000000000000000000000;;									// If we find expected log file and contains right content, exit 0
0000000000000000000000000000000000000000;;									// else, keep checking until test timeout
0000000000000000000000000000000000000000;;									Command: []string{"sh", "-c", "while true; do if [ -e " + expectedlogFile + " ] && grep -q " + logString + " " + expectedlogFile + "; then exit 0; fi; sleep 1; done"},
0000000000000000000000000000000000000000;;									VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Name: logDirVolumeName,
0000000000000000000000000000000000000000;;											// mount ContainerLogsDir to the same path in container
0000000000000000000000000000000000000000;;											MountPath: expectedlogFile,
0000000000000000000000000000000000000000;;											ReadOnly:  true,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;									Name: logDirVolumeName,
0000000000000000000000000000000000000000;;									VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;										HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;											Path: expectedlogFile,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					podClient.Create(checkPod)
0000000000000000000000000000000000000000;;					err = framework.WaitForPodSuccessInNamespace(f.ClientSet, checkPodName, ns)
0000000000000000000000000000000000000000;;					framework.ExpectNoError(err, "Failed waiting for pod: %s to enter success state", checkPodName)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
