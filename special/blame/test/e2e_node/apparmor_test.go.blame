0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2f82f4c68b584cb214003346eaa2eaa6fc3ee0a9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("AppArmor [Feature:AppArmor]", func() {
0000000000000000000000000000000000000000;;		if isAppArmorEnabled() {
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				By("Loading AppArmor profiles for testing")
0000000000000000000000000000000000000000;;				framework.ExpectNoError(loadTestProfiles(), "Could not load AppArmor test profiles")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			Context("when running with AppArmor", func() {
0000000000000000000000000000000000000000;;				f := framework.NewDefaultFramework("apparmor-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should reject an unloaded profile", func() {
0000000000000000000000000000000000000000;;					status := runAppArmorTest(f, false, apparmor.ProfileNamePrefix+"non-existant-profile")
0000000000000000000000000000000000000000;;					expectSoftRejection(status)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				It("should enforce a profile blocking writes", func() {
0000000000000000000000000000000000000000;;					status := runAppArmorTest(f, true, apparmor.ProfileNamePrefix+apparmorProfilePrefix+"deny-write")
0000000000000000000000000000000000000000;;					if len(status.ContainerStatuses) == 0 {
0000000000000000000000000000000000000000;;						framework.Failf("Unexpected pod status: %s", spew.Sdump(status))
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					state := status.ContainerStatuses[0].State.Terminated
0000000000000000000000000000000000000000;;					Expect(state).ToNot(BeNil(), "ContainerState: %+v", status.ContainerStatuses[0].State)
0000000000000000000000000000000000000000;;					Expect(state.ExitCode).To(Not(BeZero()), "ContainerStateTerminated: %+v", state)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				It("should enforce a permissive profile", func() {
0000000000000000000000000000000000000000;;					status := runAppArmorTest(f, true, apparmor.ProfileNamePrefix+apparmorProfilePrefix+"audit-write")
0000000000000000000000000000000000000000;;					if len(status.ContainerStatuses) == 0 {
0000000000000000000000000000000000000000;;						framework.Failf("Unexpected pod status: %s", spew.Sdump(status))
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					state := status.ContainerStatuses[0].State.Terminated
0000000000000000000000000000000000000000;;					Expect(state).ToNot(BeNil(), "ContainerState: %+v", status.ContainerStatuses[0].State)
0000000000000000000000000000000000000000;;					Expect(state.ExitCode).To(BeZero(), "ContainerStateTerminated: %+v", state)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			Context("when running without AppArmor", func() {
0000000000000000000000000000000000000000;;				f := framework.NewDefaultFramework("apparmor-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				It("should reject a pod with an AppArmor profile", func() {
0000000000000000000000000000000000000000;;					status := runAppArmorTest(f, false, apparmor.ProfileRuntimeDefault)
0000000000000000000000000000000000000000;;					expectSoftRejection(status)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const apparmorProfilePrefix = "e2e-node-apparmor-test-"
0000000000000000000000000000000000000000;;	const testProfiles = `
0000000000000000000000000000000000000000;;	#include <tunables/global>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	profile e2e-node-apparmor-test-deny-write flags=(attach_disconnected) {
0000000000000000000000000000000000000000;;	  #include <abstractions/base>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  file,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Deny all file writes.
0000000000000000000000000000000000000000;;	  deny /** w,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	profile e2e-node-apparmor-test-audit-write flags=(attach_disconnected) {
0000000000000000000000000000000000000000;;	  #include <abstractions/base>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  file,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Only audit file writes.
0000000000000000000000000000000000000000;;	  audit /** w,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadTestProfiles() error {
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("/tmp", "apparmor")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to open temp file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(f.Name())
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := f.WriteString(testProfiles); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to write profiles to file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(random-liu): The test is run as root now, no need to use sudo here.
0000000000000000000000000000000000000000;;		cmd := exec.Command("sudo", "apparmor_parser", "-r", "-W", f.Name())
0000000000000000000000000000000000000000;;		stderr := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		cmd.Stderr = stderr
0000000000000000000000000000000000000000;;		out, err := cmd.Output()
0000000000000000000000000000000000000000;;		// apparmor_parser does not always return an error code, so consider any stderr output an error.
0000000000000000000000000000000000000000;;		if err != nil || stderr.Len() > 0 {
0000000000000000000000000000000000000000;;			if stderr.Len() > 0 {
0000000000000000000000000000000000000000;;				glog.Warning(stderr.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(out) > 0 {
0000000000000000000000000000000000000000;;				glog.Infof("apparmor_parser: %s", out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to load profiles: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Loaded profiles: %v", out)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runAppArmorTest(f *framework.Framework, shouldRun bool, profile string) v1.PodStatus {
0000000000000000000000000000000000000000;;		pod := createPodWithAppArmor(f, profile)
0000000000000000000000000000000000000000;;		if shouldRun {
0000000000000000000000000000000000000000;;			// The pod needs to start before it stops, so wait for the longer start timeout.
0000000000000000000000000000000000000000;;			framework.ExpectNoError(framework.WaitTimeoutForPodNoLongerRunningInNamespace(
0000000000000000000000000000000000000000;;				f.ClientSet, pod.Name, f.Namespace.Name, framework.PodStartTimeout))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Pod should remain in the pending state. Wait for the Reason to be set to "AppArmor".
0000000000000000000000000000000000000000;;			w, err := f.PodClient().Watch(metav1.SingleObject(metav1.ObjectMeta{Name: pod.Name}))
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			_, err = watch.Until(framework.PodStartTimeout, w, func(e watch.Event) (bool, error) {
0000000000000000000000000000000000000000;;				switch e.Type {
0000000000000000000000000000000000000000;;				case watch.Deleted:
0000000000000000000000000000000000000000;;					return false, errors.NewNotFound(schema.GroupResource{Resource: "pods"}, pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch t := e.Object.(type) {
0000000000000000000000000000000000000000;;				case *v1.Pod:
0000000000000000000000000000000000000000;;					if t.Status.Reason == "AppArmor" {
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, err := f.PodClient().Get(pod.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		return p.Status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPodWithAppArmor(f *framework.Framework, profile string) *v1.Pod {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: fmt.Sprintf("test-apparmor-%s", strings.Replace(profile, "/", "-", -1)),
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					apparmor.ContainerAnnotationKeyPrefix + "test": profile,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{
0000000000000000000000000000000000000000;;					Name:    "test",
0000000000000000000000000000000000000000;;					Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;					Command: []string{"touch", "foo"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.PodClient().Create(pod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectSoftRejection(status v1.PodStatus) {
0000000000000000000000000000000000000000;;		args := []interface{}{"PodStatus: %+v", status}
0000000000000000000000000000000000000000;;		Expect(status.Phase).To(Equal(v1.PodPending), args...)
0000000000000000000000000000000000000000;;		Expect(status.Reason).To(Equal("AppArmor"), args...)
0000000000000000000000000000000000000000;;		Expect(status.Message).To(ContainSubstring("AppArmor"), args...)
0000000000000000000000000000000000000000;;		Expect(status.ContainerStatuses[0].State.Waiting.Reason).To(Equal("Blocked"), args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isAppArmorEnabled() bool {
0000000000000000000000000000000000000000;;		// TODO(tallclair): Pass this through the image setup rather than hardcoding.
0000000000000000000000000000000000000000;;		if strings.Contains(framework.TestContext.NodeName, "-gci-dev-") {
0000000000000000000000000000000000000000;;			gciVersionRe := regexp.MustCompile("-gci-dev-([0-9]+)-")
0000000000000000000000000000000000000000;;			matches := gciVersionRe.FindStringSubmatch(framework.TestContext.NodeName)
0000000000000000000000000000000000000000;;			if len(matches) == 2 {
0000000000000000000000000000000000000000;;				version, err := strconv.Atoi(matches[1])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Error parsing GCI version from NodeName %q: %v", framework.TestContext.NodeName, err)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return version >= 54
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(framework.TestContext.NodeName, "-ubuntu-") {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return apparmor.IsAppArmorEnabled()
0000000000000000000000000000000000000000;;	}
