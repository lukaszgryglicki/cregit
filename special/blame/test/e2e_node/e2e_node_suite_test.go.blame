0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4a7f39737a0c563d7a86ae608ccea196e6fd6f04;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// To run tests in this suite
0000000000000000000000000000000000000000;;	// NOTE: This test suite requires password-less sudo capabilities to run the kubelet and kube-apiserver.
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/api/v1/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		commontest "k8s.io/kubernetes/test/e2e/common"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e_node/services"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e_node/system"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/kardianos/osext"
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		morereporters "github.com/onsi/ginkgo/reporters"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var e2es *services.E2EServices
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(random-liu): Change the following modes to sub-command.
0000000000000000000000000000000000000000;;	var runServicesMode = flag.Bool("run-services-mode", false, "If true, only run services (etcd, apiserver) in current process, and not run test.")
0000000000000000000000000000000000000000;;	var runKubeletMode = flag.Bool("run-kubelet-mode", false, "If true, only start kubelet, and not run test.")
0000000000000000000000000000000000000000;;	var systemValidateMode = flag.Bool("system-validate-mode", false, "If true, only run system validation in current process, and not run test.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		framework.RegisterCommonFlags()
0000000000000000000000000000000000000000;;		framework.RegisterNodeFlags()
0000000000000000000000000000000000000000;;		pflag.CommandLine.AddGoFlagSet(flag.CommandLine)
0000000000000000000000000000000000000000;;		// Mark the run-services-mode flag as hidden to prevent user from using it.
0000000000000000000000000000000000000000;;		pflag.CommandLine.MarkHidden("run-services-mode")
0000000000000000000000000000000000000000;;		// It's weird that if I directly use pflag in TestContext, it will report error.
0000000000000000000000000000000000000000;;		// It seems that someone is using flag.Parse() after init() and TestMain().
0000000000000000000000000000000000000000;;		// TODO(random-liu): Find who is using flag.Parse() and cause errors and move the following logic
0000000000000000000000000000000000000000;;		// into TestContext.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMain(m *testing.M) {
0000000000000000000000000000000000000000;;		pflag.Parse()
0000000000000000000000000000000000000000;;		framework.AfterReadingAllFlags(&framework.TestContext)
0000000000000000000000000000000000000000;;		os.Exit(m.Run())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When running the containerized conformance test, we'll mount the
0000000000000000000000000000000000000000;;	// host root filesystem as readonly to /rootfs.
0000000000000000000000000000000000000000;;	const rootfs = "/rootfs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestE2eNode(t *testing.T) {
0000000000000000000000000000000000000000;;		if *runServicesMode {
0000000000000000000000000000000000000000;;			// If run-services-mode is specified, only run services in current process.
0000000000000000000000000000000000000000;;			services.RunE2EServices()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *runKubeletMode {
0000000000000000000000000000000000000000;;			// If run-kubelet-mode is specified, only start kubelet.
0000000000000000000000000000000000000000;;			services.RunKubelet()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *systemValidateMode {
0000000000000000000000000000000000000000;;			// If system-validate-mode is specified, only run system validation in current process.
0000000000000000000000000000000000000000;;			if framework.TestContext.NodeConformance {
0000000000000000000000000000000000000000;;				// Chroot to /rootfs to make system validation can check system
0000000000000000000000000000000000000000;;				// as in the root filesystem.
0000000000000000000000000000000000000000;;				// TODO(random-liu): Consider to chroot the whole test process to make writing
0000000000000000000000000000000000000000;;				// test easier.
0000000000000000000000000000000000000000;;				if err := syscall.Chroot(rootfs); err != nil {
0000000000000000000000000000000000000000;;					glog.Exitf("chroot %q failed: %v", rootfs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := system.ValidateDefault(framework.TestContext.ContainerRuntime); err != nil {
0000000000000000000000000000000000000000;;				glog.Exitf("system validation failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If run-services-mode is not specified, run test.
0000000000000000000000000000000000000000;;		rand.Seed(time.Now().UTC().UnixNano())
0000000000000000000000000000000000000000;;		RegisterFailHandler(Fail)
0000000000000000000000000000000000000000;;		reporters := []Reporter{}
0000000000000000000000000000000000000000;;		reportDir := framework.TestContext.ReportDir
0000000000000000000000000000000000000000;;		if reportDir != "" {
0000000000000000000000000000000000000000;;			// Create the directory if it doesn't already exists
0000000000000000000000000000000000000000;;			if err := os.MkdirAll(reportDir, 0755); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed creating report directory: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Configure a junit reporter to write to the directory
0000000000000000000000000000000000000000;;				junitFile := fmt.Sprintf("junit_%s_%02d.xml", framework.TestContext.ReportPrefix, config.GinkgoConfig.ParallelNode)
0000000000000000000000000000000000000000;;				junitPath := path.Join(reportDir, junitFile)
0000000000000000000000000000000000000000;;				reporters = append(reporters, morereporters.NewJUnitReporter(junitPath))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		RunSpecsWithDefaultAndCustomReporters(t, "E2eNode Suite", reporters)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setup the kubelet on the node
0000000000000000000000000000000000000000;;	var _ = SynchronizedBeforeSuite(func() []byte {
0000000000000000000000000000000000000000;;		// Run system validation test.
0000000000000000000000000000000000000000;;		Expect(validateSystem()).To(Succeed(), "system validation")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pre-pull the images tests depend on so we can fail immediately if there is an image pull issue
0000000000000000000000000000000000000000;;		// This helps with debugging test flakes since it is hard to tell when a test failure is due to image pulling.
0000000000000000000000000000000000000000;;		if framework.TestContext.PrepullImages {
0000000000000000000000000000000000000000;;			glog.Infof("Pre-pulling images so that they are cached for the tests.")
0000000000000000000000000000000000000000;;			err := PrePullAllImages()
0000000000000000000000000000000000000000;;			Expect(err).ShouldNot(HaveOccurred())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(yifan): Temporary workaround to disable coreos from auto restart
0000000000000000000000000000000000000000;;		// by masking the locksmithd.
0000000000000000000000000000000000000000;;		// We should mask locksmithd when provisioning the machine.
0000000000000000000000000000000000000000;;		maskLocksmithdOnCoreos()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *startServices {
0000000000000000000000000000000000000000;;			// If the services are expected to stop after test, they should monitor the test process.
0000000000000000000000000000000000000000;;			// If the services are expected to keep running after test, they should not monitor the test process.
0000000000000000000000000000000000000000;;			e2es = services.NewE2EServices(*stopServices)
0000000000000000000000000000000000000000;;			Expect(e2es.Start()).To(Succeed(), "should be able to start node services.")
0000000000000000000000000000000000000000;;			glog.Infof("Node services started.  Running tests...")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Infof("Running tests without starting services.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Wait for the node to be ready")
0000000000000000000000000000000000000000;;		waitForNodeReady()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reference common test to make the import valid.
0000000000000000000000000000000000000000;;		commontest.CurrentSuite = commontest.NodeE2E
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}, func([]byte) {
0000000000000000000000000000000000000000;;		// update test context with node configuration.
0000000000000000000000000000000000000000;;		Expect(updateTestContext()).To(Succeed(), "update test context with node config.")
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tear down the kubelet on the node
0000000000000000000000000000000000000000;;	var _ = SynchronizedAfterSuite(func() {}, func() {
0000000000000000000000000000000000000000;;		if e2es != nil {
0000000000000000000000000000000000000000;;			if *startServices && *stopServices {
0000000000000000000000000000000000000000;;				glog.Infof("Stopping node services...")
0000000000000000000000000000000000000000;;				e2es.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Tests Finished")
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateSystem runs system validation in a separate process and returns error if validation fails.
0000000000000000000000000000000000000000;;	func validateSystem() error {
0000000000000000000000000000000000000000;;		testBin, err := osext.Executable()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't get current binary: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Pass all flags into the child process, so that it will see the same flag set.
0000000000000000000000000000000000000000;;		output, err := exec.Command(testBin, append([]string{"--system-validate-mode"}, os.Args[1:]...)...).CombinedOutput()
0000000000000000000000000000000000000000;;		// The output of system validation should have been formatted, directly print here.
0000000000000000000000000000000000000000;;		fmt.Print(string(output))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("system validation failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func maskLocksmithdOnCoreos() {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile("/etc/os-release")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Not all distros contain this file.
0000000000000000000000000000000000000000;;			glog.Infof("Could not read /etc/os-release: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bytes.Contains(data, []byte("ID=coreos")) {
0000000000000000000000000000000000000000;;			output, err := exec.Command("systemctl", "mask", "--now", "locksmithd").CombinedOutput()
0000000000000000000000000000000000000000;;			Expect(err).NotTo(HaveOccurred(), fmt.Sprintf("should be able to mask locksmithd - output: %q", string(output)))
0000000000000000000000000000000000000000;;			glog.Infof("Locksmithd is masked successfully")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForNodeReady() {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			// nodeReadyTimeout is the time to wait for node to become ready.
0000000000000000000000000000000000000000;;			nodeReadyTimeout = 2 * time.Minute
0000000000000000000000000000000000000000;;			// nodeReadyPollInterval is the interval to check node ready.
0000000000000000000000000000000000000000;;			nodeReadyPollInterval = 1 * time.Second
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		client, err := getAPIServerClient()
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "should be able to get apiserver client.")
0000000000000000000000000000000000000000;;		Eventually(func() error {
0000000000000000000000000000000000000000;;			node, err := getNode(client)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to get node: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !nodeutil.IsNodeReady(node) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("node is not ready: %+v", node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nodeReadyTimeout, nodeReadyPollInterval).Should(Succeed())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateTestContext updates the test context with the node name.
0000000000000000000000000000000000000000;;	// TODO(random-liu): Using dynamic kubelet configuration feature to
0000000000000000000000000000000000000000;;	// update test context with node configuration.
0000000000000000000000000000000000000000;;	func updateTestContext() error {
0000000000000000000000000000000000000000;;		client, err := getAPIServerClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get apiserver client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Update test context with current node object.
0000000000000000000000000000000000000000;;		node, err := getNode(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get node: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.TestContext.NodeName = node.Name // Set node name.
0000000000000000000000000000000000000000;;		// Update test context with current kubelet configuration.
0000000000000000000000000000000000000000;;		// This assumes all tests which dynamically change kubelet configuration
0000000000000000000000000000000000000000;;		// must: 1) run in serial; 2) restore kubelet configuration after test.
0000000000000000000000000000000000000000;;		kubeletCfg, err := getCurrentKubeletConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get kubelet configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framework.TestContext.KubeletConfig = *kubeletCfg // Set kubelet config.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNode gets node object from the apiserver.
0000000000000000000000000000000000000000;;	func getNode(c *clientset.Clientset) (*v1.Node, error) {
0000000000000000000000000000000000000000;;		nodes, err := c.Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred(), "should be able to list nodes.")
0000000000000000000000000000000000000000;;		if nodes == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("the node list is nil.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Expect(len(nodes.Items) > 1).NotTo(BeTrue(), "should not be more than 1 nodes.")
0000000000000000000000000000000000000000;;		if len(nodes.Items) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("empty node list: %+v", nodes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &nodes.Items[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAPIServerClient gets a apiserver client.
0000000000000000000000000000000000000000;;	func getAPIServerClient() (*clientset.Clientset, error) {
0000000000000000000000000000000000000000;;		config, err := framework.LoadConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to load config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := clientset.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
