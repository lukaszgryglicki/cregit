0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6430742a6a3f18c34dabd3b5f99d9cffbbb1d56a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package system
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/blang/semver"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// semVerDotsCount is the number of dots in a valid semantic version.
0000000000000000000000000000000000000000;;	const semVerDotsCount int = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// packageManager is an interface that abstracts the basic operations of a
0000000000000000000000000000000000000000;;	// package manager.
0000000000000000000000000000000000000000;;	type packageManager interface {
0000000000000000000000000000000000000000;;		// getPackageVersion returns the version of the package given the
0000000000000000000000000000000000000000;;		// packageName, or an error if no such package exists.
0000000000000000000000000000000000000000;;		getPackageVersion(packageName string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPackageManager returns the package manager on the running machine, and an
0000000000000000000000000000000000000000;;	// error if no package managers is available.
0000000000000000000000000000000000000000;;	func newPackageManager() (packageManager, error) {
0000000000000000000000000000000000000000;;		if m, ok := newDPKG(); ok {
0000000000000000000000000000000000000000;;			return m, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("failed to find package manager")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dpkg implements packageManager. It uses "dpkg-query" to retrieve package
0000000000000000000000000000000000000000;;	// information.
0000000000000000000000000000000000000000;;	type dpkg struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newDPKG returns a Debian package manager. It returns (nil, false) if no such
0000000000000000000000000000000000000000;;	// package manager exists on the running machine.
0000000000000000000000000000000000000000;;	func newDPKG() (packageManager, bool) {
0000000000000000000000000000000000000000;;		_, err := exec.LookPath("dpkg-query")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dpkg{}, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPackageVersion returns the upstream package version for the package given
0000000000000000000000000000000000000000;;	// the packageName, and an error if no such package exists.
0000000000000000000000000000000000000000;;	func (_ dpkg) getPackageVersion(packageName string) (string, error) {
0000000000000000000000000000000000000000;;		output, err := exec.Command("dpkg-query", "--show", "--showformat='${Version}'", packageName).Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("dpkg-query failed: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version := extractUpstreamVersion(string(output))
0000000000000000000000000000000000000000;;		if version == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no version information")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return version, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// packageValidator implements the Validator interface. It validates packages
0000000000000000000000000000000000000000;;	// and their versions.
0000000000000000000000000000000000000000;;	type packageValidator struct {
0000000000000000000000000000000000000000;;		reporter      Reporter
0000000000000000000000000000000000000000;;		kernelRelease string
0000000000000000000000000000000000000000;;		osDistro      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the name of the package validator.
0000000000000000000000000000000000000000;;	func (self *packageValidator) Name() string {
0000000000000000000000000000000000000000;;		return "package"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks packages and their versions against the spec using the
0000000000000000000000000000000000000000;;	// package manager on the running machine, and returns an error on any
0000000000000000000000000000000000000000;;	// package/version mismatch.
0000000000000000000000000000000000000000;;	func (self *packageValidator) Validate(spec SysSpec) (error, error) {
0000000000000000000000000000000000000000;;		if len(spec.PackageSpecs) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if self.kernelRelease, err = getKernelRelease(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if self.osDistro, err = getOSDistro(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manager, err := newPackageManager()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		specs := applyPackageSpecOverride(spec.PackageSpecs, spec.PackageSpecOverrides, self.osDistro)
0000000000000000000000000000000000000000;;		return self.validate(specs, manager)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks packages and their versions against the packageSpecs using
0000000000000000000000000000000000000000;;	// the packageManager, and returns an error on any package/version mismatch.
0000000000000000000000000000000000000000;;	func (self *packageValidator) validate(packageSpecs []PackageSpec, manager packageManager) (error, error) {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		for _, spec := range packageSpecs {
0000000000000000000000000000000000000000;;			// Substitute variables in package name.
0000000000000000000000000000000000000000;;			packageName := resolvePackageName(spec.Name, self.kernelRelease)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nameWithVerRange := fmt.Sprintf("%s (%s)", packageName, spec.VersionRange)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the version of the package on the running machine.
0000000000000000000000000000000000000000;;			version, err := manager.getPackageVersion(packageName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Failed to get the version for the package %q: %s\n", packageName, err)
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;				self.reporter.Report(nameWithVerRange, "not installed", bad)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Version requirement will not be enforced if version range is
0000000000000000000000000000000000000000;;			// not specified in the spec.
0000000000000000000000000000000000000000;;			if spec.VersionRange == "" {
0000000000000000000000000000000000000000;;				self.reporter.Report(packageName, version, good)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Convert both the version range in the spec and the version returned
0000000000000000000000000000000000000000;;			// from package manager to semantic version format, and then check if
0000000000000000000000000000000000000000;;			// the version is in the range.
0000000000000000000000000000000000000000;;			sv, err := semver.Make(toSemVer(version))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to convert %q to semantic version: %s\n", version, err)
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;				self.reporter.Report(nameWithVerRange, "internal error", bad)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			versionRange := semver.MustParseRange(toSemVerRange(spec.VersionRange))
0000000000000000000000000000000000000000;;			if versionRange(sv) {
0000000000000000000000000000000000000000;;				self.reporter.Report(nameWithVerRange, version, good)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("package \"%s %s\" does not meet the spec \"%s (%s)\"", packageName, sv, packageName, spec.VersionRange))
0000000000000000000000000000000000000000;;				self.reporter.Report(nameWithVerRange, version, bad)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getKernelRelease returns the kernel release of the local machine.
0000000000000000000000000000000000000000;;	func getKernelRelease() (string, error) {
0000000000000000000000000000000000000000;;		output, err := exec.Command("uname", "-r").Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get kernel release: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimSpace(string(output)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getOSDistro returns the OS distro of the local machine.
0000000000000000000000000000000000000000;;	func getOSDistro() (string, error) {
0000000000000000000000000000000000000000;;		f := "/etc/lsb-release"
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadFile(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to read %q: %s", f, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		content := string(b)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case strings.Contains(content, "Ubuntu"):
0000000000000000000000000000000000000000;;			return "ubuntu", nil
0000000000000000000000000000000000000000;;		case strings.Contains(content, "Chrome OS"):
0000000000000000000000000000000000000000;;			return "cos", nil
0000000000000000000000000000000000000000;;		case strings.Contains(content, "CoreOS"):
0000000000000000000000000000000000000000;;			return "coreos", nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get OS distro: %s", content)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolvePackageName substitutes the variables in the packageName with the
0000000000000000000000000000000000000000;;	// local information.
0000000000000000000000000000000000000000;;	// E.g., "linux-headers-${KERNEL_RELEASE}" -> "linux-headers-4.4.0-75-generic".
0000000000000000000000000000000000000000;;	func resolvePackageName(packageName string, kernelRelease string) string {
0000000000000000000000000000000000000000;;		packageName = strings.Replace(packageName, "${KERNEL_RELEASE}", kernelRelease, -1)
0000000000000000000000000000000000000000;;		return packageName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyPackageSpecOverride applies the package spec overrides for the given
0000000000000000000000000000000000000000;;	// osDistro to the packageSpecs and returns the applied result.
0000000000000000000000000000000000000000;;	func applyPackageSpecOverride(packageSpecs []PackageSpec, overrides []PackageSpecOverride, osDistro string) []PackageSpec {
0000000000000000000000000000000000000000;;		var override *PackageSpecOverride
0000000000000000000000000000000000000000;;		for _, o := range overrides {
0000000000000000000000000000000000000000;;			if o.OSDistro == osDistro {
0000000000000000000000000000000000000000;;				override = &o
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if override == nil {
0000000000000000000000000000000000000000;;			return packageSpecs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove packages in the spec that matches the overrides in
0000000000000000000000000000000000000000;;		// Subtractions.
0000000000000000000000000000000000000000;;		var out []PackageSpec
0000000000000000000000000000000000000000;;		subtractions := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, spec := range override.Subtractions {
0000000000000000000000000000000000000000;;			subtractions[spec.Name] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, spec := range packageSpecs {
0000000000000000000000000000000000000000;;			if _, ok := subtractions[spec.Name]; !ok {
0000000000000000000000000000000000000000;;				out = append(out, spec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add packages in the spec that matches the overrides in Additions.
0000000000000000000000000000000000000000;;		return append(out, override.Additions...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractUpstreamVersion returns the upstream version of the given full
0000000000000000000000000000000000000000;;	// version in dpkg format. E.g., "1:1.0.6-2ubuntu2.1" -> "1.0.6".
0000000000000000000000000000000000000000;;	func extractUpstreamVersion(version string) string {
0000000000000000000000000000000000000000;;		// The full version is in the format of
0000000000000000000000000000000000000000;;		// "[epoch:]upstream_version[-debian_revision]". See
0000000000000000000000000000000000000000;;		// https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version.
0000000000000000000000000000000000000000;;		version = strings.Trim(version, " '")
0000000000000000000000000000000000000000;;		if i := strings.Index(version, ":"); i != -1 {
0000000000000000000000000000000000000000;;			version = version[i+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i := strings.Index(version, "-"); i != -1 {
0000000000000000000000000000000000000000;;			version = version[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toSemVerRange converts the input to a semantic version range.
0000000000000000000000000000000000000000;;	// E.g., ">=1.0"             -> ">=1.0.x"
0000000000000000000000000000000000000000;;	//       ">=1"               -> ">=1.x"
0000000000000000000000000000000000000000;;	//       ">=1 <=2.3"         -> ">=1.x <=2.3.x"
0000000000000000000000000000000000000000;;	//       ">1 || >3.1.0 !4.2" -> ">1.x || >3.1.0 !4.2.x"
0000000000000000000000000000000000000000;;	func toSemVerRange(input string) string {
0000000000000000000000000000000000000000;;		var output []string
0000000000000000000000000000000000000000;;		fields := strings.Fields(input)
0000000000000000000000000000000000000000;;		for _, f := range fields {
0000000000000000000000000000000000000000;;			numDots, hasDigits := 0, false
0000000000000000000000000000000000000000;;			for _, c := range f {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case c == '.':
0000000000000000000000000000000000000000;;					numDots++
0000000000000000000000000000000000000000;;				case c >= '0' && c <= '9':
0000000000000000000000000000000000000000;;					hasDigits = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasDigits && numDots < semVerDotsCount {
0000000000000000000000000000000000000000;;				f = strings.TrimRight(f, " ")
0000000000000000000000000000000000000000;;				f += ".x"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			output = append(output, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(output, " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toSemVer converts the input to a semantic version, and an empty string on
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	func toSemVer(version string) string {
0000000000000000000000000000000000000000;;		// Remove the first non-digit and non-dot character as well as the ones
0000000000000000000000000000000000000000;;		// following it.
0000000000000000000000000000000000000000;;		// E.g., "1.8.19p1" -> "1.8.19".
0000000000000000000000000000000000000000;;		if i := strings.IndexFunc(version, func(c rune) bool {
0000000000000000000000000000000000000000;;			if (c < '0' || c > '9') && c != '.' {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}); i != -1 {
0000000000000000000000000000000000000000;;			version = version[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the trailing dots if there's any, and then returns an empty
0000000000000000000000000000000000000000;;		// string if nothing left.
0000000000000000000000000000000000000000;;		version = strings.TrimRight(version, ".")
0000000000000000000000000000000000000000;;		if version == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numDots := strings.Count(version, ".")
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case numDots < semVerDotsCount:
0000000000000000000000000000000000000000;;			// Add minor version and patch version.
0000000000000000000000000000000000000000;;			// E.g. "1.18" -> "1.18.0" and "481" -> "481.0.0".
0000000000000000000000000000000000000000;;			version += strings.Repeat(".0", semVerDotsCount-numDots)
0000000000000000000000000000000000000000;;		case numDots > semVerDotsCount:
0000000000000000000000000000000000000000;;			// Remove anything beyond the patch version
0000000000000000000000000000000000000000;;			// E.g. "2.0.10.4" -> "2.0.10".
0000000000000000000000000000000000000000;;			for numDots != semVerDotsCount {
0000000000000000000000000000000000000000;;				if i := strings.LastIndex(version, "."); i != -1 {
0000000000000000000000000000000000000000;;					version = version[:i]
0000000000000000000000000000000000000000;;					numDots--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove leading zeros in major/minor/patch version.
0000000000000000000000000000000000000000;;		// E.g., "2.02"     -> "2.2"
0000000000000000000000000000000000000000;;		//       "8.0.0095" -> "8.0.95"
0000000000000000000000000000000000000000;;		var subs []string
0000000000000000000000000000000000000000;;		for _, s := range strings.Split(version, ".") {
0000000000000000000000000000000000000000;;			s := strings.TrimLeft(s, "0")
0000000000000000000000000000000000000000;;			if s == "" {
0000000000000000000000000000000000000000;;				s = "0"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			subs = append(subs, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(subs, ".")
0000000000000000000000000000000000000000;;	}
