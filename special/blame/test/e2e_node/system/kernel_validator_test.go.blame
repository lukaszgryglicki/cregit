0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3ce7b70e0f165d7b10923edc598227a549ddb0e3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package system
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateKernelVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		v := &KernelValidator{
0000000000000000000000000000000000000000;;			Reporter: DefaultReporter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Currently, testRegex is align with DefaultSysSpec.KernelVersion, but in the future
0000000000000000000000000000000000000000;;		// they may be different.
0000000000000000000000000000000000000000;;		// This is fine, because the test mainly tests the kernel version validation logic,
0000000000000000000000000000000000000000;;		// not the DefaultSysSpec. The DefaultSysSpec should be tested with node e2e.
0000000000000000000000000000000000000000;;		testRegex := []string{`3\.[1-9][0-9].*`, `4\..*`}
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			version string
0000000000000000000000000000000000000000;;			err     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// first version regex matches
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version: "3.19.9-99-test",
0000000000000000000000000000000000000000;;				err:     false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// one of version regexes matches
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version: "4.4.14+",
0000000000000000000000000000000000000000;;				err:     false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// no version regex matches
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version: "2.0.0",
0000000000000000000000000000000000000000;;				err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version: "5.0.0",
0000000000000000000000000000000000000000;;				err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				version: "3.9.0",
0000000000000000000000000000000000000000;;				err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			v.kernelRelease = test.version
0000000000000000000000000000000000000000;;			err := v.validateKernelVersion(KernelSpec{Versions: testRegex})
0000000000000000000000000000000000000000;;			if !test.err {
0000000000000000000000000000000000000000;;				assert.Nil(t, err, "Expect error not to occur with kernel version %q", test.version)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				assert.NotNil(t, err, "Expect error to occur with kenrel version %q", test.version)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateCachedKernelConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		v := &KernelValidator{
0000000000000000000000000000000000000000;;			Reporter: DefaultReporter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testKernelSpec := KernelSpec{
0000000000000000000000000000000000000000;;			Required: []KernelConfig{{Name: "REQUIRED_1"}, {Name: "REQUIRED_2", Aliases: []string{"ALIASE_REQUIRED_2"}}},
0000000000000000000000000000000000000000;;			Optional: []KernelConfig{{Name: "OPTIONAL_1"}, {Name: "OPTIONAL_2"}},
0000000000000000000000000000000000000000;;			Forbidden: []KernelConfig{
0000000000000000000000000000000000000000;;				{Name: "FORBIDDEN_1", Description: "TEST FORBIDDEN"},
0000000000000000000000000000000000000000;;				{Name: "FORBIDDEN_2", Aliases: []string{"ALIASE_FORBIDDEN_2"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for c, test := range []struct {
0000000000000000000000000000000000000000;;			desc   string
0000000000000000000000000000000000000000;;			config map[string]kConfigOption
0000000000000000000000000000000000000000;;			err    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "meet all required configurations should not report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1": builtIn,
0000000000000000000000000000000000000000;;					"REQUIRED_2": asModule,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "one required configuration disabled should report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1": leftOut,
0000000000000000000000000000000000000000;;					"REQUIRED_2": builtIn,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "one required configuration missing should report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1": builtIn,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "alias of required configuration should not report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1":        builtIn,
0000000000000000000000000000000000000000;;					"ALIASE_REQUIRED_2": asModule,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "optional configuration set or not should not report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1": builtIn,
0000000000000000000000000000000000000000;;					"REQUIRED_2": asModule,
0000000000000000000000000000000000000000;;					"OPTIONAL_1": builtIn,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "forbidden configuration disabled should not report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1":  builtIn,
0000000000000000000000000000000000000000;;					"REQUIRED_2":  asModule,
0000000000000000000000000000000000000000;;					"FORBIDDEN_1": leftOut,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "forbidden configuration built-in should report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1":  builtIn,
0000000000000000000000000000000000000000;;					"REQUIRED_2":  asModule,
0000000000000000000000000000000000000000;;					"FORBIDDEN_1": builtIn,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "forbidden configuration built as module should report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1":  builtIn,
0000000000000000000000000000000000000000;;					"REQUIRED_2":  asModule,
0000000000000000000000000000000000000000;;					"FORBIDDEN_1": asModule,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				desc: "alias of forbidden configuration should report error.",
0000000000000000000000000000000000000000;;				config: map[string]kConfigOption{
0000000000000000000000000000000000000000;;					"REQUIRED_1":         builtIn,
0000000000000000000000000000000000000000;;					"REQUIRED_2":         asModule,
0000000000000000000000000000000000000000;;					"ALIASE_FORBIDDEN_2": asModule,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			t.Logf("TestCase #%d %s", c, test.desc)
0000000000000000000000000000000000000000;;			// Add kernel config prefix.
0000000000000000000000000000000000000000;;			for k, v := range test.config {
0000000000000000000000000000000000000000;;				delete(test.config, k)
0000000000000000000000000000000000000000;;				test.config[kConfigPrefix+k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := v.validateCachedKernelConfig(test.config, testKernelSpec)
0000000000000000000000000000000000000000;;			if !test.err {
0000000000000000000000000000000000000000;;				assert.Nil(t, err, "Expect error not to occur with kernel config %q", test.config)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				assert.NotNil(t, err, "Expect error to occur with kenrel config %q", test.config)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateParseKernelConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		config := `CONFIG_1=y
0000000000000000000000000000000000000000;;	CONFIG_2=m
0000000000000000000000000000000000000000;;	CONFIG_3=n`
0000000000000000000000000000000000000000;;		expected := map[string]kConfigOption{
0000000000000000000000000000000000000000;;			"CONFIG_1": builtIn,
0000000000000000000000000000000000000000;;			"CONFIG_2": asModule,
0000000000000000000000000000000000000000;;			"CONFIG_3": leftOut,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := &KernelValidator{
0000000000000000000000000000000000000000;;			Reporter: DefaultReporter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		got, err := v.parseKernelConfig(bytes.NewReader([]byte(config)))
0000000000000000000000000000000000000000;;		assert.Nil(t, err, "Expect error not to occur when parse kernel configuration %q", config)
0000000000000000000000000000000000000000;;		assert.Equal(t, expected, got)
0000000000000000000000000000000000000000;;	}
