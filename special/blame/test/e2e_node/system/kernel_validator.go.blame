0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0c8a8920e3d5c7202b445c4cc754f91ffbacf9a5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package system
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Validator = &KernelValidator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KernelValidator validates kernel. Currently only validate kernel version
0000000000000000000000000000000000000000;;	// and kernel configuration.
0000000000000000000000000000000000000000;;	type KernelValidator struct {
0000000000000000000000000000000000000000;;		kernelRelease string
0000000000000000000000000000000000000000;;		Reporter      Reporter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *KernelValidator) Name() string {
0000000000000000000000000000000000000000;;		return "kernel"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kConfigOption is the possible kernel config option.
0000000000000000000000000000000000000000;;	type kConfigOption string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		builtIn  kConfigOption = "y"
0000000000000000000000000000000000000000;;		asModule kConfigOption = "m"
0000000000000000000000000000000000000000;;		leftOut  kConfigOption = "n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validKConfigRegex is the regex matching kernel configuration line.
0000000000000000000000000000000000000000;;		validKConfigRegex = "^CONFIG_[A-Z0-9_]+=[myn]"
0000000000000000000000000000000000000000;;		// kConfigPrefix is the prefix of kernel configuration.
0000000000000000000000000000000000000000;;		kConfigPrefix = "CONFIG_"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *KernelValidator) Validate(spec SysSpec) (error, error) {
0000000000000000000000000000000000000000;;		release, err := exec.Command("uname", "-r").CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get kernel release: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		k.kernelRelease = strings.TrimSpace(string(release))
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		errs = append(errs, k.validateKernelVersion(spec.KernelSpec))
0000000000000000000000000000000000000000;;		errs = append(errs, k.validateKernelConfig(spec.KernelSpec))
0000000000000000000000000000000000000000;;		return nil, errors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateKernelVersion validates the kernel version.
0000000000000000000000000000000000000000;;	func (k *KernelValidator) validateKernelVersion(kSpec KernelSpec) error {
0000000000000000000000000000000000000000;;		glog.Infof("Validating kernel version")
0000000000000000000000000000000000000000;;		versionRegexps := kSpec.Versions
0000000000000000000000000000000000000000;;		for _, versionRegexp := range versionRegexps {
0000000000000000000000000000000000000000;;			r := regexp.MustCompile(versionRegexp)
0000000000000000000000000000000000000000;;			if r.MatchString(k.kernelRelease) {
0000000000000000000000000000000000000000;;				k.Reporter.Report("KERNEL_VERSION", k.kernelRelease, good)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		k.Reporter.Report("KERNEL_VERSION", k.kernelRelease, bad)
0000000000000000000000000000000000000000;;		return fmt.Errorf("unsupported kernel release: %s", k.kernelRelease)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateKernelConfig validates the kernel configurations.
0000000000000000000000000000000000000000;;	func (k *KernelValidator) validateKernelConfig(kSpec KernelSpec) error {
0000000000000000000000000000000000000000;;		glog.Infof("Validating kernel config")
0000000000000000000000000000000000000000;;		allConfig, err := k.getKernelConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to parse kernel config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k.validateCachedKernelConfig(allConfig, kSpec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateCachedKernelConfig validates the kernel confgiurations cached in internal data type.
0000000000000000000000000000000000000000;;	func (k *KernelValidator) validateCachedKernelConfig(allConfig map[string]kConfigOption, kSpec KernelSpec) error {
0000000000000000000000000000000000000000;;		badConfigs := []string{}
0000000000000000000000000000000000000000;;		// reportAndRecord is a helper function to record bad config when
0000000000000000000000000000000000000000;;		// report.
0000000000000000000000000000000000000000;;		reportAndRecord := func(name, msg, desc string, result ValidationResultType) {
0000000000000000000000000000000000000000;;			if result == bad {
0000000000000000000000000000000000000000;;				badConfigs = append(badConfigs, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// report description when the config is bad or warn.
0000000000000000000000000000000000000000;;			if result != good && desc != "" {
0000000000000000000000000000000000000000;;				msg = msg + " - " + desc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k.Reporter.Report(name, msg, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			required = iota
0000000000000000000000000000000000000000;;			optional
0000000000000000000000000000000000000000;;			forbidden
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		validateOpt := func(config KernelConfig, expect int) {
0000000000000000000000000000000000000000;;			var found, missing ValidationResultType
0000000000000000000000000000000000000000;;			switch expect {
0000000000000000000000000000000000000000;;			case required:
0000000000000000000000000000000000000000;;				found, missing = good, bad
0000000000000000000000000000000000000000;;			case optional:
0000000000000000000000000000000000000000;;				found, missing = good, warn
0000000000000000000000000000000000000000;;			case forbidden:
0000000000000000000000000000000000000000;;				found, missing = bad, good
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var name string
0000000000000000000000000000000000000000;;			var opt kConfigOption
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			for _, name = range append([]string{config.Name}, config.Aliases...) {
0000000000000000000000000000000000000000;;				name = kConfigPrefix + name
0000000000000000000000000000000000000000;;				if opt, ok = allConfig[name]; ok {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				reportAndRecord(name, "not set", config.Description, missing)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch opt {
0000000000000000000000000000000000000000;;			case builtIn:
0000000000000000000000000000000000000000;;				reportAndRecord(name, "enabled", config.Description, found)
0000000000000000000000000000000000000000;;			case asModule:
0000000000000000000000000000000000000000;;				reportAndRecord(name, "enabled (as module)", config.Description, found)
0000000000000000000000000000000000000000;;			case leftOut:
0000000000000000000000000000000000000000;;				reportAndRecord(name, "disabled", config.Description, missing)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				reportAndRecord(name, fmt.Sprintf("unknown option: %s", opt), config.Description, missing)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, config := range kSpec.Required {
0000000000000000000000000000000000000000;;			validateOpt(config, required)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, config := range kSpec.Optional {
0000000000000000000000000000000000000000;;			validateOpt(config, optional)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, config := range kSpec.Forbidden {
0000000000000000000000000000000000000000;;			validateOpt(config, forbidden)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(badConfigs) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected kernel config: %s", strings.Join(badConfigs, " "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getKernelConfigReader search kernel config file in a predefined list. Once the kernel config
0000000000000000000000000000000000000000;;	// file is found it will read the configurations into a byte buffer and return. If the kernel
0000000000000000000000000000000000000000;;	// config file is not found, it will try to load kernel config module and retry again.
0000000000000000000000000000000000000000;;	func (k *KernelValidator) getKernelConfigReader() (io.Reader, error) {
0000000000000000000000000000000000000000;;		possibePaths := []string{
0000000000000000000000000000000000000000;;			"/proc/config.gz",
0000000000000000000000000000000000000000;;			"/boot/config-" + k.kernelRelease,
0000000000000000000000000000000000000000;;			"/usr/src/linux-" + k.kernelRelease + "/.config",
0000000000000000000000000000000000000000;;			"/usr/src/linux/.config",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		configsModule := "configs"
0000000000000000000000000000000000000000;;		modprobeCmd := "modprobe"
0000000000000000000000000000000000000000;;		// loadModule indicates whether we've tried to load kernel config module ourselves.
0000000000000000000000000000000000000000;;		loadModule := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			for _, path := range possibePaths {
0000000000000000000000000000000000000000;;				_, err := os.Stat(path)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Buffer the whole file, so that we can close the file and unload
0000000000000000000000000000000000000000;;				// kernel config module in this function.
0000000000000000000000000000000000000000;;				b, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var r io.Reader
0000000000000000000000000000000000000000;;				r = bytes.NewReader(b)
0000000000000000000000000000000000000000;;				// This is a gzip file (config.gz), unzip it.
0000000000000000000000000000000000000000;;				if filepath.Ext(path) == ".gz" {
0000000000000000000000000000000000000000;;					r, err = gzip.NewReader(r)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return r, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If we've tried to load kernel config module, break and return error.
0000000000000000000000000000000000000000;;			if loadModule {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the kernel config file is not found, try to load the kernel
0000000000000000000000000000000000000000;;			// config module and check again.
0000000000000000000000000000000000000000;;			output, err := exec.Command(modprobeCmd, configsModule).CombinedOutput()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to load kernel module %q: output - %q, err - %v",
0000000000000000000000000000000000000000;;					configsModule, output, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Unload the kernel config module to make sure the validation have no side effect.
0000000000000000000000000000000000000000;;			defer exec.Command(modprobeCmd, "-r", configsModule).Run()
0000000000000000000000000000000000000000;;			loadModule = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no config path in %v is available", possibePaths)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getKernelConfig gets kernel config from kernel config file and convert kernel config to internal type.
0000000000000000000000000000000000000000;;	func (k *KernelValidator) getKernelConfig() (map[string]kConfigOption, error) {
0000000000000000000000000000000000000000;;		r, err := k.getKernelConfigReader()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k.parseKernelConfig(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseKernelConfig converts kernel config to internal type.
0000000000000000000000000000000000000000;;	func (k *KernelValidator) parseKernelConfig(r io.Reader) (map[string]kConfigOption, error) {
0000000000000000000000000000000000000000;;		config := map[string]kConfigOption{}
0000000000000000000000000000000000000000;;		regex := regexp.MustCompile(validKConfigRegex)
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(r)
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line := strings.TrimSpace(s.Text())
0000000000000000000000000000000000000000;;			if !regex.MatchString(line) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields := strings.Split(line, "=")
0000000000000000000000000000000000000000;;			if len(fields) != 2 {
0000000000000000000000000000000000000000;;				glog.Errorf("Unexpected fields number in config %q", line)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config[fields[0]] = kConfigOption(fields[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
