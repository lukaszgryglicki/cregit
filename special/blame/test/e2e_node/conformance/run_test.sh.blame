0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This script is only for demonstrating how to use the node test container. In
0000000000000000000000000000000000000000;;	# production environment, kubelet bootstrap will be more complicated, user
0000000000000000000000000000000000000000;;	# should configure the node test container accordingly.
0000000000000000000000000000000000000000;;	# In addition, this script will also be used in the node e2e test to let it use
0000000000000000000000000000000000000000;;	# the containerized test suite.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# TODO(random-liu): Use standard installer to install kubelet.
0000000000000000000000000000000000000000;;	# TODO(random-liu): Use standard tool to start kubelet in production way (such
0000000000000000000000000000000000000000;;	# as systemd, supervisord etc.)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Refresh sudo credentials if not running on GCE.
0000000000000000000000000000000000000000;;	if ! ping -c 1 -q metadata.google.internal &> /dev/null; then
0000000000000000000000000000000000000000;;	  sudo -v || exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# FOCUS is ginkgo focus to select which tests to run. By default, FOCUS is
0000000000000000000000000000000000000000;;	# initialized as "\[Conformance\]" in the test container to run all conformance
0000000000000000000000000000000000000000;;	# test.
0000000000000000000000000000000000000000;;	FOCUS=${FOCUS:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# SKIP is ginkgo skip to select which tests to skip. By default, SKIP is
0000000000000000000000000000000000000000;;	# initialized as "\[Flaky\]|\[Serial\]" in the test container skipping all
0000000000000000000000000000000000000000;;	# flaky and serial test.
0000000000000000000000000000000000000000;;	SKIP=${SKIP:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# TEST_ARGS is the test arguments. It could be used to override default test
0000000000000000000000000000000000000000;;	# arguments in the container.
0000000000000000000000000000000000000000;;	TEST_ARGS=${TEST_ARGS:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# REGISTRY is the image registry for node test image.
0000000000000000000000000000000000000000;;	REGISTRY=${REGISTRY:-"gcr.io/google_containers"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# ARCH is the architecture of current machine, the script will use this to
0000000000000000000000000000000000000000;;	# select corresponding test container image.
0000000000000000000000000000000000000000;;	ARCH=${ARCH:-"amd64"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# VERSION is the version of the test container image.
0000000000000000000000000000000000000000;;	VERSION=${VERSION:-"0.2"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# KUBELET_BIN is the kubelet binary name. If it is not specified, use the
0000000000000000000000000000000000000000;;	# default binary name "kubelet".
0000000000000000000000000000000000000000;;	KUBELET_BIN=${KUBELET_BIN:-"kubelet"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# KUBELET is the kubelet binary path. If it is not specified, assume kubelet is
0000000000000000000000000000000000000000;;	# in PATH.
0000000000000000000000000000000000000000;;	KUBELET=${KUBELET:-"`which $KUBELET_BIN`"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# LOG_DIR is the absolute path of the directory where the test will collect all
0000000000000000000000000000000000000000;;	# logs to. By default, use the current directory.
0000000000000000000000000000000000000000;;	LOG_DIR=${LOG_DIR:-`pwd`}
0000000000000000000000000000000000000000;;	mkdir -p $LOG_DIR
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# NETWORK_PLUGIN is the network plugin used by kubelet. Do not use network
0000000000000000000000000000000000000000;;	# plugin by default.
0000000000000000000000000000000000000000;;	NETWORK_PLUGIN=${NETWORK_PLUGIN:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# CNI_CONF_DIR is the path to network plugin binaries.
0000000000000000000000000000000000000000;;	CNI_CONF_DIR=${CNI_CONF_DIR:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# CNI_BIN_DIR is the path to network plugin config files.
0000000000000000000000000000000000000000;;	CNI_BIN_DIR=${CNI_BIN_DIR:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# start_kubelet starts kubelet and redirect kubelet log to $LOG_DIR/kubelet.log.
0000000000000000000000000000000000000000;;	kubelet_log=kubelet.log
0000000000000000000000000000000000000000;;	start_kubelet() {
0000000000000000000000000000000000000000;;	  echo "Starting kubelet..."
0000000000000000000000000000000000000000;;	  sudo -b $KUBELET $@ &>$LOG_DIR/$kubelet_log
0000000000000000000000000000000000000000;;	  if [ $? -ne 0 ]; then
0000000000000000000000000000000000000000;;	    echo "Failed to start kubelet"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# wait_kubelet retries for 10 times for kubelet to be ready by checking http://127.0.0.1:10255/healthz.
0000000000000000000000000000000000000000;;	wait_kubelet() {
0000000000000000000000000000000000000000;;	  echo "Health checking kubelet..."
0000000000000000000000000000000000000000;;	  healthCheckURL=http://127.0.0.1:10255/healthz
0000000000000000000000000000000000000000;;	  local maxRetry=10
0000000000000000000000000000000000000000;;	  local cur=1
0000000000000000000000000000000000000000;;	  while [ $cur -le $maxRetry ]; do
0000000000000000000000000000000000000000;;	    curl -s $healthCheckURL > /dev/null
0000000000000000000000000000000000000000;;	    if [ $? -eq 0 ]; then
0000000000000000000000000000000000000000;;	      echo "Kubelet is ready"
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ $cur -eq $maxRetry ]; then
0000000000000000000000000000000000000000;;	      echo "Health check exceeds max retry"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    echo "Kubelet is not ready"
0000000000000000000000000000000000000000;;	    sleep 1
0000000000000000000000000000000000000000;;	    ((cur++))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# kill_kubelet kills kubelet.
0000000000000000000000000000000000000000;;	kill_kubelet() {
0000000000000000000000000000000000000000;;	  echo "Stopping kubelet..."
0000000000000000000000000000000000000000;;	  sudo pkill $KUBELET_BIN
0000000000000000000000000000000000000000;;	  if [ $? -ne 0 ]; then
0000000000000000000000000000000000000000;;	    echo "Failed to stop kubelet."
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# run_test runs the node test container.
0000000000000000000000000000000000000000;;	run_test() {
0000000000000000000000000000000000000000;;	  env=""
0000000000000000000000000000000000000000;;	  if [ ! -z "$FOCUS" ]; then
0000000000000000000000000000000000000000;;	    env="$env -e FOCUS=\"$FOCUS\""
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ ! -z "$SKIP" ]; then
0000000000000000000000000000000000000000;;	    env="$env -e SKIP=\"$SKIP\""
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [ ! -z "$TEST_ARGS" ]; then
0000000000000000000000000000000000000000;;	    env="$env -e TEST_ARGS=\"$TEST_ARGS\""
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  # The test assumes that inside the container:
0000000000000000000000000000000000000000;;	  # * kubelet manifest path is mounted to the same path;
0000000000000000000000000000000000000000;;	  # * log collect directory is mounted to /var/result;
0000000000000000000000000000000000000000;;	  # * root file system is mounted to /rootfs.
0000000000000000000000000000000000000000;;	  sudo sh -c "docker run -it --rm --privileged=true --net=host -v /:/rootfs \
0000000000000000000000000000000000000000;;	    -v $config_dir:$config_dir -v $LOG_DIR:/var/result ${env} $REGISTRY/node-test-$ARCH:$VERSION"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Check whether kubelet is running. If kubelet is running, tell the user to stop
0000000000000000000000000000000000000000;;	# it before running the test.
0000000000000000000000000000000000000000;;	pid=`pidof $KUBELET_BIN`
0000000000000000000000000000000000000000;;	if [ ! -z $pid ]; then
0000000000000000000000000000000000000000;;	  echo "Kubelet is running (pid=$pid), please stop it before running the test."
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	apiserver=http://localhost:8080
0000000000000000000000000000000000000000;;	volume_stats_agg_period=10s
0000000000000000000000000000000000000000;;	allow_privileged=true
0000000000000000000000000000000000000000;;	serialize_image_pulls=false
0000000000000000000000000000000000000000;;	config_dir=`mktemp -d`
0000000000000000000000000000000000000000;;	file_check_frequency=10s
0000000000000000000000000000000000000000;;	pod_cidr=10.100.0.0/24
0000000000000000000000000000000000000000;;	log_level=4
0000000000000000000000000000000000000000;;	start_kubelet --api-servers $apiserver \
0000000000000000000000000000000000000000;;	  --volume-stats-agg-period $volume_stats_agg_period \
0000000000000000000000000000000000000000;;	  --allow-privileged=$allow_privileged \
0000000000000000000000000000000000000000;;	  --serialize-image-pulls=$serialize_image_pulls \
0000000000000000000000000000000000000000;;	  --pod-manifest-path $config_dir \
0000000000000000000000000000000000000000;;	  --file-check-frequency $file_check_frequency \
0000000000000000000000000000000000000000;;	  --pod-cidr=$pod_cidr \
0000000000000000000000000000000000000000;;	  --runtime-cgroups=/docker-daemon \
0000000000000000000000000000000000000000;;	  --kubelet-cgroups=/kubelet \
0000000000000000000000000000000000000000;;	  --system-cgroups=/system \
0000000000000000000000000000000000000000;;	  --cgroup-root=/ \
0000000000000000000000000000000000000000;;	  --network-plugin=$NETWORK_PLUGIN \
0000000000000000000000000000000000000000;;	  --cni-conf-dir=$CNI_CONF_DIR \
0000000000000000000000000000000000000000;;	  --cni-bin-dir=$CNI_BIN_DIR \
0000000000000000000000000000000000000000;;	  --v=$log_level \
0000000000000000000000000000000000000000;;	  --logtostderr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	wait_kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	run_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kill_kubelet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Clean up the kubelet config directory
0000000000000000000000000000000000000000;;	sudo rm -rf $config_dir
