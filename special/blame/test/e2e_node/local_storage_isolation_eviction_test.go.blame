0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
aabedb464719181d8bc1f303663aeac45a20c8b3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type podEvictSpec struct {
0000000000000000000000000000000000000000;;		evicted bool
0000000000000000000000000000000000000000;;		pod     v1.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		totalEvict = 3
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Eviction Policy is described here:
0000000000000000000000000000000000000000;;	// https://github.com/kubernetes/kubernetes/blob/master/docs/proposals/kubelet-eviction.md
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("LocalStorageCapacityIsolationEviction [Slow] [Serial] [Disruptive] [Flaky] [Feature:LocalStorageCapacityIsolation]", func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("localstorage-eviction-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emptyDirVolumeName := "volume-emptydir-pod"
0000000000000000000000000000000000000000;;		podTestSpecs := []podEvictSpec{
0000000000000000000000000000000000000000;;			{evicted: true, // This pod should be evicted because emptyDir (defualt storage type) usage violation
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "emptydir-hog-pod"},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Name:  "container-emptydir-hog-pod",
0000000000000000000000000000000000000000;;								Command: []string{
0000000000000000000000000000000000000000;;									"sh",
0000000000000000000000000000000000000000;;									"-c",
0000000000000000000000000000000000000000;;									"sleep 5; dd if=/dev/urandom of=target-file of=/cache/target-file bs=50000 count=1; while true; do sleep 5; done",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      emptyDirVolumeName,
0000000000000000000000000000000000000000;;										MountPath: "/cache",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: emptyDirVolumeName,
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									EmptyDir: &v1.EmptyDirVolumeSource{
0000000000000000000000000000000000000000;;										SizeLimit: *resource.NewQuantity(int64(1000), resource.BinarySI),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{evicted: true, // This pod should be evicted because emptyDir (memory type) usage violation
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "emptydir-memory-pod"},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Name:  "container-emptydir-memory-pod",
0000000000000000000000000000000000000000;;								Command: []string{
0000000000000000000000000000000000000000;;									"sh",
0000000000000000000000000000000000000000;;									"-c",
0000000000000000000000000000000000000000;;									"sleep 5; dd if=/dev/urandom of=target-file of=/cache/target-file bs=50000 count=1; while true; do sleep 5; done",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      emptyDirVolumeName,
0000000000000000000000000000000000000000;;										MountPath: "/cache",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: emptyDirVolumeName,
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									EmptyDir: &v1.EmptyDirVolumeSource{
0000000000000000000000000000000000000000;;										Medium:    "Memory",
0000000000000000000000000000000000000000;;										SizeLimit: *resource.NewQuantity(int64(10000), resource.BinarySI),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{evicted: false,
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "container-emptydir-pod-critical"},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Name:  "container-emptydir-hog-pod",
0000000000000000000000000000000000000000;;								Command: []string{
0000000000000000000000000000000000000000;;									"sh",
0000000000000000000000000000000000000000;;									"-c",
0000000000000000000000000000000000000000;;									"sleep 5; dd if=/dev/urandom of=target-file of=/cache/target-file bs=50000 count=1; while true; do sleep 5; done",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      emptyDirVolumeName,
0000000000000000000000000000000000000000;;										MountPath: "/cache",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: emptyDirVolumeName,
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									EmptyDir: &v1.EmptyDirVolumeSource{
0000000000000000000000000000000000000000;;										SizeLimit: *resource.NewQuantity(int64(100000), resource.BinarySI),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{evicted: true, // This pod should be evicted because container overlay usage violation
0000000000000000000000000000000000000000;;				pod: v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "container-hog-pod"},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Name:  "container-hog-pod",
0000000000000000000000000000000000000000;;								Command: []string{
0000000000000000000000000000000000000000;;									"sh",
0000000000000000000000000000000000000000;;									"-c",
0000000000000000000000000000000000000000;;									"sleep 5; dd if=/dev/urandom of=target-file bs=50000 count=1; while true; do sleep 5; done",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;									Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;										v1.ResourceStorageOverlay: *resource.NewMilliQuantity(
0000000000000000000000000000000000000000;;											int64(40000),
0000000000000000000000000000000000000000;;											resource.BinarySI),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evictionTestTimeout := 10 * time.Minute
0000000000000000000000000000000000000000;;		testCondition := "EmptyDir/ContainerOverlay usage limit violation"
0000000000000000000000000000000000000000;;		Context(fmt.Sprintf("EmptyDirEviction when we run containers that should cause %s", testCondition), func() {
0000000000000000000000000000000000000000;;			tempSetCurrentKubeletConfig(f, func(initialConfig *componentconfig.KubeletConfiguration) {
0000000000000000000000000000000000000000;;				initialConfig.FeatureGates += ", LocalStorageCapacityIsolation=true"
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			err := utilfeature.DefaultFeatureGate.Set("LocalStorageCapacityIsolation=true")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Failf("Failed to enable feature gate for LocalStorageCapacityIsolation: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runLocalStorageIsolationEvictionTest(f, testCondition, podTestSpecs, evictionTestTimeout, hasInodePressure)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runLocalStorageEvictionTest sets up a testing environment given the provided nodes, and checks a few things:
0000000000000000000000000000000000000000;;	//		pods that exceed their local storage limit are evicted
0000000000000000000000000000000000000000;;	//		pods that didn't exceed their local storage limit are not evicted
0000000000000000000000000000000000000000;;	// runLocalStorageEvictionTest then cleans up the testing environment by deleting provided nodes,
0000000000000000000000000000000000000000;;	func runLocalStorageIsolationEvictionTest(f *framework.Framework, testCondition string, podTestSpecs []podEvictSpec, evictionTestTimeout time.Duration,
0000000000000000000000000000000000000000;;		hasPressureCondition func(*framework.Framework, string) (bool, error)) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context(fmt.Sprintf("EmptyDirEviction when we run containers that should cause %s", testCondition), func() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				By("seting up pods to be used by tests")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, spec := range podTestSpecs {
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("creating pod with container: %s", spec.pod.Name))
0000000000000000000000000000000000000000;;					f.PodClient().CreateSync(&spec.pod)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It(fmt.Sprintf("Test should eventually see %s, and then evict the correct pods", testCondition), func() {
0000000000000000000000000000000000000000;;				evictNum := 0
0000000000000000000000000000000000000000;;				evictMap := make(map[string]string)
0000000000000000000000000000000000000000;;				Eventually(func() error {
0000000000000000000000000000000000000000;;					// Gather current information
0000000000000000000000000000000000000000;;					updatedPodList, err := f.ClientSet.Core().Pods(f.Namespace.Name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("failed to get the list of pod: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					updatedPods := updatedPodList.Items
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for _, p := range updatedPods {
0000000000000000000000000000000000000000;;						framework.Logf("fetching pod %s; phase= %v", p.Name, p.Status.Phase)
0000000000000000000000000000000000000000;;						for _, testPod := range podTestSpecs {
0000000000000000000000000000000000000000;;							if p.Name == testPod.pod.Name {
0000000000000000000000000000000000000000;;								if !testPod.evicted {
0000000000000000000000000000000000000000;;									Expect(p.Status.Phase).NotTo(Equal(v1.PodFailed),
0000000000000000000000000000000000000000;;										fmt.Sprintf("%s pod failed (and shouldn't have failed)", p.Name))
0000000000000000000000000000000000000000;;								} else {
0000000000000000000000000000000000000000;;									if _, ok := evictMap[p.Name]; !ok && p.Status.Phase == v1.PodFailed {
0000000000000000000000000000000000000000;;										evictNum++
0000000000000000000000000000000000000000;;										evictMap[p.Name] = p.Name
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if evictNum == totalEvict {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return fmt.Errorf("pods that caused %s have not been evicted", testCondition)
0000000000000000000000000000000000000000;;				}, evictionTestTimeout, evictionPollInterval).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("making sure we can start a new pod after the test")
0000000000000000000000000000000000000000;;				podName := "test-admit-pod"
0000000000000000000000000000000000000000;;				f.PodClient().CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: podName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image: framework.GetPauseImageNameForHostArch(),
0000000000000000000000000000000000000000;;								Name:  podName,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				By("deleting pods")
0000000000000000000000000000000000000000;;				for _, spec := range podTestSpecs {
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("deleting pod: %s", spec.pod.Name))
0000000000000000000000000000000000000000;;					f.PodClient().DeleteSync(spec.pod.Name, &metav1.DeleteOptions{}, framework.DefaultPodDeletionTimeout)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if CurrentGinkgoTestDescription().Failed {
0000000000000000000000000000000000000000;;					if framework.TestContext.DumpLogsOnFailure {
0000000000000000000000000000000000000000;;						logPodEvents(f)
0000000000000000000000000000000000000000;;						logNodeEvents(f)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					By("sleeping to allow for cleanup of test")
0000000000000000000000000000000000000000;;					time.Sleep(postTestConditionMonitoringPeriod)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
