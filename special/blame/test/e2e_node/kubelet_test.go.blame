0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4a7f39737a0c563d7a86ae608ccea196e6fd6f04;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Kubelet", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("kubelet-test")
0000000000000000000000000000000000000000;;		var podClient *framework.PodClient
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			podClient = f.PodClient()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Context("when scheduling a busybox command in a pod", func() {
0000000000000000000000000000000000000000;;			podName := "busybox-scheduling-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			It("it should print the output to logs [Conformance]", func() {
0000000000000000000000000000000000000000;;				podClient.CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: podName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						// Don't restart the Pod since it is expected to exit
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Name:    podName,
0000000000000000000000000000000000000000;;								Command: []string{"sh", "-c", "echo 'Hello World' ; sleep 240"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Eventually(func() string {
0000000000000000000000000000000000000000;;					sinceTime := metav1.NewTime(time.Now().Add(time.Duration(-1 * time.Hour)))
0000000000000000000000000000000000000000;;					rc, err := podClient.GetLogs(podName, &v1.PodLogOptions{SinceTime: &sinceTime}).Stream()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defer rc.Close()
0000000000000000000000000000000000000000;;					buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;					buf.ReadFrom(rc)
0000000000000000000000000000000000000000;;					return buf.String()
0000000000000000000000000000000000000000;;				}, time.Minute, time.Second*4).Should(Equal("Hello World\n"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Context("when scheduling a busybox command that always fails in a pod", func() {
0000000000000000000000000000000000000000;;			var podName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				podName = "bin-false" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;				podClient.Create(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: podName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						// Don't restart the Pod since it is expected to exit
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Name:    podName,
0000000000000000000000000000000000000000;;								Command: []string{"/bin/false"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should have an error terminated reason", func() {
0000000000000000000000000000000000000000;;				Eventually(func() error {
0000000000000000000000000000000000000000;;					podData, err := podClient.Get(podName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(podData.Status.ContainerStatuses) != 1 {
0000000000000000000000000000000000000000;;						return fmt.Errorf("expected only one container in the pod %q", podName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					contTerminatedState := podData.Status.ContainerStatuses[0].State.Terminated
0000000000000000000000000000000000000000;;					if contTerminatedState == nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("expected state to be terminated. Got pod status: %+v", podData.Status)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if contTerminatedState.Reason != "Error" {
0000000000000000000000000000000000000000;;						return fmt.Errorf("expected terminated state reason to be error. Got %+v", contTerminatedState)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}, time.Minute, time.Second*4).Should(BeNil())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should be possible to delete", func() {
0000000000000000000000000000000000000000;;				err := podClient.Delete(podName, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;				Expect(err).To(BeNil(), fmt.Sprintf("Error deleting Pod %v", err))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Context("when scheduling a busybox Pod with hostAliases", func() {
0000000000000000000000000000000000000000;;			podName := "busybox-host-aliases" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("it should write entries to /etc/hosts", func() {
0000000000000000000000000000000000000000;;				podClient.CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: podName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						// Don't restart the Pod since it is expected to exit
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Name:    podName,
0000000000000000000000000000000000000000;;								Command: []string{"/bin/sh", "-c", "cat /etc/hosts; sleep 6000"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						HostAliases: []v1.HostAlias{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								IP:        "123.45.67.89",
0000000000000000000000000000000000000000;;								Hostnames: []string{"foo", "bar"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Eventually(func() error {
0000000000000000000000000000000000000000;;					rc, err := podClient.GetLogs(podName, &v1.PodLogOptions{}).Stream()
0000000000000000000000000000000000000000;;					defer rc.Close()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;					buf.ReadFrom(rc)
0000000000000000000000000000000000000000;;					hostsFileContent := buf.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !strings.Contains(hostsFileContent, "123.45.67.89\tfoo") || !strings.Contains(hostsFileContent, "123.45.67.89\tbar") {
0000000000000000000000000000000000000000;;						return fmt.Errorf("expected hosts file to contain entries from HostAliases. Got:\n%+v", hostsFileContent)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}, time.Minute, time.Second*4).Should(BeNil())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		Context("when scheduling a read only busybox container", func() {
0000000000000000000000000000000000000000;;			podName := "busybox-readonly-fs" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			It("it should not write to root filesystem [Conformance]", func() {
0000000000000000000000000000000000000000;;				isReadOnly := true
0000000000000000000000000000000000000000;;				podClient.CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: podName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						// Don't restart the Pod since it is expected to exit
0000000000000000000000000000000000000000;;						RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;								Name:    podName,
0000000000000000000000000000000000000000;;								Command: []string{"/bin/sh", "-c", "echo test > /file; sleep 240"},
0000000000000000000000000000000000000000;;								SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;									ReadOnlyRootFilesystem: &isReadOnly,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Eventually(func() string {
0000000000000000000000000000000000000000;;					rc, err := podClient.GetLogs(podName, &v1.PodLogOptions{}).Stream()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defer rc.Close()
0000000000000000000000000000000000000000;;					buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;					buf.ReadFrom(rc)
0000000000000000000000000000000000000000;;					return buf.String()
0000000000000000000000000000000000000000;;				}, time.Minute, time.Second*4).Should(Equal("/bin/sh: can't create /file: Read-only file system\n"))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
