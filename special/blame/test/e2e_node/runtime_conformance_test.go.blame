0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f3d9c142cea72a8a336c499fb09d5f3b5993b2d2;test/e2e_node/conformance_test.go[test/e2e_node/conformance_test.go][test/e2e_node/runtime_conformance_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/images"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		gomegatypes "github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		consistentCheckTimeout = time.Second * 5
0000000000000000000000000000000000000000;;		retryTimeout           = time.Minute * 5
0000000000000000000000000000000000000000;;		pollInterval           = time.Second * 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Container Runtime Conformance Test", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("runtime-conformance")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Describe("container runtime conformance blackbox test", func() {
0000000000000000000000000000000000000000;;			Context("when starting a container that exits", func() {
0000000000000000000000000000000000000000;;				It("it should run with the expected status [Conformance]", func() {
0000000000000000000000000000000000000000;;					restartCountVolumeName := "restart-count"
0000000000000000000000000000000000000000;;					restartCountVolumePath := "/restart-count"
0000000000000000000000000000000000000000;;					testContainer := v1.Container{
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								MountPath: restartCountVolumePath,
0000000000000000000000000000000000000000;;								Name:      restartCountVolumeName,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					testVolumes := []v1.Volume{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name: restartCountVolumeName,
0000000000000000000000000000000000000000;;							VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;								EmptyDir: &v1.EmptyDirVolumeSource{Medium: v1.StorageMediumMemory},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					testCases := []struct {
0000000000000000000000000000000000000000;;						Name          string
0000000000000000000000000000000000000000;;						RestartPolicy v1.RestartPolicy
0000000000000000000000000000000000000000;;						Phase         v1.PodPhase
0000000000000000000000000000000000000000;;						State         ContainerState
0000000000000000000000000000000000000000;;						RestartCount  int32
0000000000000000000000000000000000000000;;						Ready         bool
0000000000000000000000000000000000000000;;					}{
0000000000000000000000000000000000000000;;						{"terminate-cmd-rpa", v1.RestartPolicyAlways, v1.PodRunning, ContainerStateRunning, 2, true},
0000000000000000000000000000000000000000;;						{"terminate-cmd-rpof", v1.RestartPolicyOnFailure, v1.PodSucceeded, ContainerStateTerminated, 1, false},
0000000000000000000000000000000000000000;;						{"terminate-cmd-rpn", v1.RestartPolicyNever, v1.PodFailed, ContainerStateTerminated, 0, false},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, testCase := range testCases {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// It failed at the 1st run, then succeeded at 2nd run, then run forever
0000000000000000000000000000000000000000;;						cmdScripts := `
0000000000000000000000000000000000000000;;	f=%s
0000000000000000000000000000000000000000;;	count=$(echo 'hello' >> $f ; wc -l $f | awk {'print $1'})
0000000000000000000000000000000000000000;;	if [ $count -eq 1 ]; then
0000000000000000000000000000000000000000;;		exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	if [ $count -eq 2 ]; then
0000000000000000000000000000000000000000;;		exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	while true; do sleep 1; done
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;						tmpCmd := fmt.Sprintf(cmdScripts, path.Join(restartCountVolumePath, "restartCount"))
0000000000000000000000000000000000000000;;						testContainer.Name = testCase.Name
0000000000000000000000000000000000000000;;						testContainer.Command = []string{"sh", "-c", tmpCmd}
0000000000000000000000000000000000000000;;						terminateContainer := ConformanceContainer{
0000000000000000000000000000000000000000;;							PodClient:     f.PodClient(),
0000000000000000000000000000000000000000;;							Container:     testContainer,
0000000000000000000000000000000000000000;;							RestartPolicy: testCase.RestartPolicy,
0000000000000000000000000000000000000000;;							Volumes:       testVolumes,
0000000000000000000000000000000000000000;;							PodSecurityContext: &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;								SELinuxOptions: &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;									Level: "s0",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						terminateContainer.Create()
0000000000000000000000000000000000000000;;						defer terminateContainer.Delete()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("it should get the expected 'RestartCount'")
0000000000000000000000000000000000000000;;						Eventually(func() (int32, error) {
0000000000000000000000000000000000000000;;							status, err := terminateContainer.GetStatus()
0000000000000000000000000000000000000000;;							return status.RestartCount, err
0000000000000000000000000000000000000000;;						}, retryTimeout, pollInterval).Should(Equal(testCase.RestartCount))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("it should get the expected 'Phase'")
0000000000000000000000000000000000000000;;						Eventually(terminateContainer.GetPhase, retryTimeout, pollInterval).Should(Equal(testCase.Phase))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("it should get the expected 'Ready' condition")
0000000000000000000000000000000000000000;;						Expect(terminateContainer.IsReady()).Should(Equal(testCase.Ready))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						status, err := terminateContainer.GetStatus()
0000000000000000000000000000000000000000;;						Expect(err).ShouldNot(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("it should get the expected 'State'")
0000000000000000000000000000000000000000;;						Expect(GetContainerState(status.State)).To(Equal(testCase.State))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("it should be possible to delete [Conformance]")
0000000000000000000000000000000000000000;;						Expect(terminateContainer.Delete()).To(Succeed())
0000000000000000000000000000000000000000;;						Eventually(terminateContainer.Present, retryTimeout, pollInterval).Should(BeFalse())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				rootUser := int64(0)
0000000000000000000000000000000000000000;;				nonRootUser := int64(10000)
0000000000000000000000000000000000000000;;				for _, testCase := range []struct {
0000000000000000000000000000000000000000;;					name      string
0000000000000000000000000000000000000000;;					container v1.Container
0000000000000000000000000000000000000000;;					phase     v1.PodPhase
0000000000000000000000000000000000000000;;					message   gomegatypes.GomegaMatcher
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						name: "if TerminationMessagePath is set [Conformance]",
0000000000000000000000000000000000000000;;						container: v1.Container{
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c"},
0000000000000000000000000000000000000000;;							Args:    []string{"/bin/echo -n DONE > /dev/termination-log"},
0000000000000000000000000000000000000000;;							TerminationMessagePath: "/dev/termination-log",
0000000000000000000000000000000000000000;;							SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;								RunAsUser: &rootUser,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						phase:   v1.PodSucceeded,
0000000000000000000000000000000000000000;;						message: Equal("DONE"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						name: "if TerminationMessagePath is set as non-root user and at a non-default path [Conformance]",
0000000000000000000000000000000000000000;;						container: v1.Container{
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c"},
0000000000000000000000000000000000000000;;							Args:    []string{"/bin/echo -n DONE > /dev/termination-custom-log"},
0000000000000000000000000000000000000000;;							TerminationMessagePath: "/dev/termination-custom-log",
0000000000000000000000000000000000000000;;							SecurityContext: &v1.SecurityContext{
0000000000000000000000000000000000000000;;								RunAsUser: &nonRootUser,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						phase:   v1.PodSucceeded,
0000000000000000000000000000000000000000;;						message: Equal("DONE"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						name: "from log output if TerminationMessagePolicy FallbackToLogOnError is set [Conformance]",
0000000000000000000000000000000000000000;;						container: v1.Container{
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c"},
0000000000000000000000000000000000000000;;							Args:    []string{"/bin/echo -n DONE; /bin/false"},
0000000000000000000000000000000000000000;;							TerminationMessagePath:   "/dev/termination-log",
0000000000000000000000000000000000000000;;							TerminationMessagePolicy: v1.TerminationMessageFallbackToLogsOnError,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						phase:   v1.PodFailed,
0000000000000000000000000000000000000000;;						message: Equal("DONE\n"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						name: "as empty when pod succeeds and TerminationMessagePolicy FallbackToLogOnError is set",
0000000000000000000000000000000000000000;;						container: v1.Container{
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c"},
0000000000000000000000000000000000000000;;							Args:    []string{"/bin/echo DONE; /bin/true"},
0000000000000000000000000000000000000000;;							TerminationMessagePath:   "/dev/termination-log",
0000000000000000000000000000000000000000;;							TerminationMessagePolicy: v1.TerminationMessageFallbackToLogsOnError,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						phase:   v1.PodSucceeded,
0000000000000000000000000000000000000000;;						message: Equal(""),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						name: "from file when pod succeeds and TerminationMessagePolicy FallbackToLogOnError is set [Conformance]",
0000000000000000000000000000000000000000;;						container: v1.Container{
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: []string{"/bin/sh", "-c"},
0000000000000000000000000000000000000000;;							Args:    []string{"/bin/echo -n OK > /dev/termination-log; /bin/echo DONE; /bin/true"},
0000000000000000000000000000000000000000;;							TerminationMessagePath:   "/dev/termination-log",
0000000000000000000000000000000000000000;;							TerminationMessagePolicy: v1.TerminationMessageFallbackToLogsOnError,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						phase:   v1.PodSucceeded,
0000000000000000000000000000000000000000;;						message: Equal("OK"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				} {
0000000000000000000000000000000000000000;;					It(fmt.Sprintf("should report termination message %s", testCase.name), func() {
0000000000000000000000000000000000000000;;						testCase.container.Name = "termination-message-container"
0000000000000000000000000000000000000000;;						c := ConformanceContainer{
0000000000000000000000000000000000000000;;							PodClient:     f.PodClient(),
0000000000000000000000000000000000000000;;							Container:     testCase.container,
0000000000000000000000000000000000000000;;							RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("create the container")
0000000000000000000000000000000000000000;;						c.Create()
0000000000000000000000000000000000000000;;						defer c.Delete()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("wait for the container to reach %s", testCase.phase))
0000000000000000000000000000000000000000;;						Eventually(c.GetPhase, retryTimeout, pollInterval).Should(Equal(testCase.phase))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("get the container status")
0000000000000000000000000000000000000000;;						status, err := c.GetStatus()
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("the container should be terminated")
0000000000000000000000000000000000000000;;						Expect(GetContainerState(status.State)).To(Equal(ContainerStateTerminated))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("the termination message should be set")
0000000000000000000000000000000000000000;;						Expect(status.State.Terminated.Message).Should(testCase.message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						By("delete the container")
0000000000000000000000000000000000000000;;						Expect(c.Delete()).To(Succeed())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Context("when running a container with a new image", func() {
0000000000000000000000000000000000000000;;				// The service account only has pull permission
0000000000000000000000000000000000000000;;				auth := `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;		"auths": {
0000000000000000000000000000000000000000;;			"https://gcr.io": {
0000000000000000000000000000000000000000;;				"auth": "X2pzb25fa2V5OnsKICAidHlwZSI6ICJzZXJ2aWNlX2FjY291bnQiLAogICJwcm9qZWN0X2lkIjogImF1dGhlbnRpY2F0ZWQtaW1hZ2UtcHVsbGluZyIsCiAgInByaXZhdGVfa2V5X2lkIjogImI5ZjJhNjY0YWE5YjIwNDg0Y2MxNTg2MDYzZmVmZGExOTIyNGFjM2IiLAogICJwcml2YXRlX2tleSI6ICItLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cbk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQzdTSG5LVEVFaVlMamZcbkpmQVBHbUozd3JCY2VJNTBKS0xxS21GWE5RL3REWGJRK2g5YVl4aldJTDhEeDBKZTc0bVovS01uV2dYRjVLWlNcbm9BNktuSU85Yi9SY1NlV2VpSXRSekkzL1lYVitPNkNjcmpKSXl4anFWam5mVzJpM3NhMzd0OUE5VEZkbGZycm5cbjR6UkpiOWl4eU1YNGJMdHFGR3ZCMDNOSWl0QTNzVlo1ODhrb1FBZmgzSmhhQmVnTWorWjRSYko0aGVpQlFUMDNcbnZVbzViRWFQZVQ5RE16bHdzZWFQV2dydDZOME9VRGNBRTl4bGNJek11MjUzUG4vSzgySFpydEx4akd2UkhNVXhcbng0ZjhwSnhmQ3h4QlN3Z1NORit3OWpkbXR2b0wwRmE3ZGducFJlODZWRDY2ejNZenJqNHlLRXRqc2hLZHl5VWRcbkl5cVhoN1JSQWdNQkFBRUNnZ0VBT3pzZHdaeENVVlFUeEFka2wvSTVTRFVidi9NazRwaWZxYjJEa2FnbmhFcG9cbjFJajJsNGlWMTByOS9uenJnY2p5VlBBd3pZWk1JeDFBZVF0RDdoUzRHWmFweXZKWUc3NkZpWFpQUm9DVlB6b3VcbmZyOGRDaWFwbDV0enJDOWx2QXNHd29DTTdJWVRjZmNWdDdjRTEyRDNRS3NGNlo3QjJ6ZmdLS251WVBmK0NFNlRcbmNNMHkwaCtYRS9kMERvSERoVy96YU1yWEhqOFRvd2V1eXRrYmJzNGYvOUZqOVBuU2dET1lQd2xhbFZUcitGUWFcbkpSd1ZqVmxYcEZBUW14M0Jyd25rWnQzQ2lXV2lGM2QrSGk5RXRVYnRWclcxYjZnK1JRT0licWFtcis4YlJuZFhcbjZWZ3FCQWtKWjhSVnlkeFVQMGQxMUdqdU9QRHhCbkhCbmM0UW9rSXJFUUtCZ1FEMUNlaWN1ZGhXdGc0K2dTeGJcbnplanh0VjFONDFtZHVjQnpvMmp5b1dHbzNQVDh3ckJPL3lRRTM0cU9WSi9pZCs4SThoWjRvSWh1K0pBMDBzNmdcblRuSXErdi9kL1RFalk4MW5rWmlDa21SUFdiWHhhWXR4UjIxS1BYckxOTlFKS2ttOHRkeVh5UHFsOE1veUdmQ1dcbjJ2aVBKS05iNkhabnY5Q3lqZEo5ZzJMRG5RS0JnUUREcVN2eURtaGViOTIzSW96NGxlZ01SK205Z2xYVWdTS2dcbkVzZlllbVJmbU5XQitDN3ZhSXlVUm1ZNU55TXhmQlZXc3dXRldLYXhjK0krYnFzZmx6elZZdFpwMThNR2pzTURcbmZlZWZBWDZCWk1zVXQ3Qmw3WjlWSjg1bnRFZHFBQ0xwWitaLzN0SVJWdWdDV1pRMWhrbmxHa0dUMDI0SkVFKytcbk55SDFnM2QzUlFLQmdRQ1J2MXdKWkkwbVBsRklva0tGTkh1YTBUcDNLb1JTU1hzTURTVk9NK2xIckcxWHJtRjZcbkMwNGNTKzQ0N0dMUkxHOFVUaEpKbTRxckh0Ti9aK2dZOTYvMm1xYjRIakpORDM3TVhKQnZFYTN5ZUxTOHEvK1JcbjJGOU1LamRRaU5LWnhQcG84VzhOSlREWTVOa1BaZGh4a2pzSHdVNGRTNjZwMVRESUU0MGd0TFpaRFFLQmdGaldcbktyblFpTnEzOS9iNm5QOFJNVGJDUUFKbmR3anhTUU5kQTVmcW1rQTlhRk9HbCtqamsxQ1BWa0tNSWxLSmdEYkpcbk9heDl2OUc2Ui9NSTFIR1hmV3QxWU56VnRocjRIdHNyQTB0U3BsbWhwZ05XRTZWejZuQURqdGZQSnMyZUdqdlhcbmpQUnArdjhjY21MK3dTZzhQTGprM3ZsN2VlNXJsWWxNQndNdUdjUHhBb0dBZWRueGJXMVJMbVZubEFpSEx1L0xcbmxtZkF3RFdtRWlJMFVnK1BMbm9Pdk81dFE1ZDRXMS94RU44bFA0cWtzcGtmZk1Rbk5oNFNZR0VlQlQzMlpxQ1RcbkpSZ2YwWGpveXZ2dXA5eFhqTWtYcnBZL3ljMXpmcVRaQzBNTzkvMVVjMWJSR2RaMmR5M2xSNU5XYXA3T1h5Zk9cblBQcE5Gb1BUWGd2M3FDcW5sTEhyR3pNPVxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLVxuIiwKICAiY2xpZW50X2VtYWlsIjogImltYWdlLXB1bGxpbmdAYXV0aGVudGljYXRlZC1pbWFnZS1wdWxsaW5nLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwKICAiY2xpZW50X2lkIjogIjExMzc5NzkxNDUzMDA3MzI3ODcxMiIsCiAgImF1dGhfdXJpIjogImh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi9hdXRoIiwKICAidG9rZW5fdXJpIjogImh0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi90b2tlbiIsCiAgImF1dGhfcHJvdmlkZXJfeDUwOV9jZXJ0X3VybCI6ICJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9vYXV0aDIvdjEvY2VydHMiLAogICJjbGllbnRfeDUwOV9jZXJ0X3VybCI6ICJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9yb2JvdC92MS9tZXRhZGF0YS94NTA5L2ltYWdlLXB1bGxpbmclNDBhdXRoZW50aWNhdGVkLWltYWdlLXB1bGxpbmcuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iCn0=",
0000000000000000000000000000000000000000;;				"email": "image-pulling@authenticated-image-pulling.iam.gserviceaccount.com"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}`
0000000000000000000000000000000000000000;;				secret := &v1.Secret{
0000000000000000000000000000000000000000;;					Data: map[string][]byte{v1.DockerConfigJsonKey: []byte(auth)},
0000000000000000000000000000000000000000;;					Type: v1.SecretTypeDockerConfigJson,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// The following images are not added into NodeImageWhiteList, because this test is
0000000000000000000000000000000000000000;;				// testing image pulling, these images don't need to be prepulled. The ImagePullPolicy
0000000000000000000000000000000000000000;;				// is v1.PullAlways, so it won't be blocked by framework image white list check.
0000000000000000000000000000000000000000;;				for _, testCase := range []struct {
0000000000000000000000000000000000000000;;					description string
0000000000000000000000000000000000000000;;					image       string
0000000000000000000000000000000000000000;;					secret      bool
0000000000000000000000000000000000000000;;					phase       v1.PodPhase
0000000000000000000000000000000000000000;;					waiting     bool
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description: "should not be able to pull image from invalid registry",
0000000000000000000000000000000000000000;;						image:       "invalid.com/invalid/alpine:3.1",
0000000000000000000000000000000000000000;;						phase:       v1.PodPending,
0000000000000000000000000000000000000000;;						waiting:     true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description: "should not be able to pull non-existing image from gcr.io",
0000000000000000000000000000000000000000;;						image:       "gcr.io/google_containers/invalid-image:invalid-tag",
0000000000000000000000000000000000000000;;						phase:       v1.PodPending,
0000000000000000000000000000000000000000;;						waiting:     true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description: "should be able to pull image from gcr.io",
0000000000000000000000000000000000000000;;						image:       "gcr.io/google_containers/alpine-with-bash:1.0",
0000000000000000000000000000000000000000;;						phase:       v1.PodRunning,
0000000000000000000000000000000000000000;;						waiting:     false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description: "should be able to pull image from docker hub",
0000000000000000000000000000000000000000;;						image:       "alpine:3.1",
0000000000000000000000000000000000000000;;						phase:       v1.PodRunning,
0000000000000000000000000000000000000000;;						waiting:     false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description: "should not be able to pull from private registry without secret",
0000000000000000000000000000000000000000;;						image:       "gcr.io/authenticated-image-pulling/alpine:3.1",
0000000000000000000000000000000000000000;;						phase:       v1.PodPending,
0000000000000000000000000000000000000000;;						waiting:     true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description: "should be able to pull from private registry with secret",
0000000000000000000000000000000000000000;;						image:       "gcr.io/authenticated-image-pulling/alpine:3.1",
0000000000000000000000000000000000000000;;						secret:      true,
0000000000000000000000000000000000000000;;						phase:       v1.PodRunning,
0000000000000000000000000000000000000000;;						waiting:     false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				} {
0000000000000000000000000000000000000000;;					testCase := testCase
0000000000000000000000000000000000000000;;					It(testCase.description+" [Conformance]", func() {
0000000000000000000000000000000000000000;;						name := "image-pull-test"
0000000000000000000000000000000000000000;;						command := []string{"/bin/sh", "-c", "while true; do sleep 1; done"}
0000000000000000000000000000000000000000;;						container := ConformanceContainer{
0000000000000000000000000000000000000000;;							PodClient: f.PodClient(),
0000000000000000000000000000000000000000;;							Container: v1.Container{
0000000000000000000000000000000000000000;;								Name:    name,
0000000000000000000000000000000000000000;;								Image:   testCase.image,
0000000000000000000000000000000000000000;;								Command: command,
0000000000000000000000000000000000000000;;								// PullAlways makes sure that the image will always be pulled even if it is present before the test.
0000000000000000000000000000000000000000;;								ImagePullPolicy: v1.PullAlways,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if testCase.secret {
0000000000000000000000000000000000000000;;							secret.Name = "image-pull-secret-" + string(uuid.NewUUID())
0000000000000000000000000000000000000000;;							By("create image pull secret")
0000000000000000000000000000000000000000;;							_, err := f.ClientSet.Core().Secrets(f.Namespace.Name).Create(secret)
0000000000000000000000000000000000000000;;							Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;							defer f.ClientSet.Core().Secrets(f.Namespace.Name).Delete(secret.Name, nil)
0000000000000000000000000000000000000000;;							container.ImagePullSecrets = []string{secret.Name}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// checkContainerStatus checks whether the container status matches expectation.
0000000000000000000000000000000000000000;;						checkContainerStatus := func() error {
0000000000000000000000000000000000000000;;							status, err := container.GetStatus()
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return fmt.Errorf("failed to get container status: %v", err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							// We need to check container state first. The default pod status is pending, If we check
0000000000000000000000000000000000000000;;							// pod phase first, and the expected pod phase is Pending, the container status may not
0000000000000000000000000000000000000000;;							// even show up when we check it.
0000000000000000000000000000000000000000;;							// Check container state
0000000000000000000000000000000000000000;;							if !testCase.waiting {
0000000000000000000000000000000000000000;;								if status.State.Running == nil {
0000000000000000000000000000000000000000;;									return fmt.Errorf("expected container state: Running, got: %q",
0000000000000000000000000000000000000000;;										GetContainerState(status.State))
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if testCase.waiting {
0000000000000000000000000000000000000000;;								if status.State.Waiting == nil {
0000000000000000000000000000000000000000;;									return fmt.Errorf("expected container state: Waiting, got: %q",
0000000000000000000000000000000000000000;;										GetContainerState(status.State))
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								reason := status.State.Waiting.Reason
0000000000000000000000000000000000000000;;								if reason != images.ErrImagePull.Error() &&
0000000000000000000000000000000000000000;;									reason != images.ErrImagePullBackOff.Error() {
0000000000000000000000000000000000000000;;									return fmt.Errorf("unexpected waiting reason: %q", reason)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							// Check pod phase
0000000000000000000000000000000000000000;;							phase, err := container.GetPhase()
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return fmt.Errorf("failed to get pod phase: %v", err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if phase != testCase.phase {
0000000000000000000000000000000000000000;;								return fmt.Errorf("expected pod phase: %q, got: %q", testCase.phase, phase)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// The image registry is not stable, which sometimes causes the test to fail. Add retry mechanism to make this
0000000000000000000000000000000000000000;;						// less flaky.
0000000000000000000000000000000000000000;;						const flakeRetry = 3
0000000000000000000000000000000000000000;;						for i := 1; i <= flakeRetry; i++ {
0000000000000000000000000000000000000000;;							var err error
0000000000000000000000000000000000000000;;							By("create the container")
0000000000000000000000000000000000000000;;							container.Create()
0000000000000000000000000000000000000000;;							By("check the container status")
0000000000000000000000000000000000000000;;							for start := time.Now(); time.Since(start) < retryTimeout; time.Sleep(pollInterval) {
0000000000000000000000000000000000000000;;								if err = checkContainerStatus(); err == nil {
0000000000000000000000000000000000000000;;									break
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							By("delete the container")
0000000000000000000000000000000000000000;;							container.Delete()
0000000000000000000000000000000000000000;;							if err == nil {
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if i < flakeRetry {
0000000000000000000000000000000000000000;;								framework.Logf("No.%d attempt failed: %v, retrying...", i, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								framework.Failf("All %d attempts failed: %v", flakeRetry, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
