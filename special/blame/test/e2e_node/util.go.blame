0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
123cc766482fec67745729fa481b95b1a83440f1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		k8serr "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		v1alpha1 "k8s.io/kubernetes/pkg/apis/componentconfig/v1alpha1"
0000000000000000000000000000000000000000;;		stats "k8s.io/kubernetes/pkg/kubelet/apis/stats/v1alpha1"
0000000000000000000000000000000000000000;;		kubeletmetrics "k8s.io/kubernetes/pkg/kubelet/metrics"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/metrics"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(random-liu): Get this automatically from kubelet flag.
0000000000000000000000000000000000000000;;	var kubeletAddress = flag.String("kubelet-address", "http://127.0.0.1:10255", "Host and port of the kubelet")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var startServices = flag.Bool("start-services", true, "If true, start local node services")
0000000000000000000000000000000000000000;;	var stopServices = flag.Bool("stop-services", true, "If true, stop local node services after running tests")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNodeSummary() (*stats.Summary, error) {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", *kubeletAddress+"/stats/summary", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to build http request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Add("Accept", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := &http.Client{}
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get /stats/summary: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		contentsBytes, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to read /stats/summary: %+v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(strings.NewReader(string(contentsBytes)))
0000000000000000000000000000000000000000;;		summary := stats.Summary{}
0000000000000000000000000000000000000000;;		err = decoder.Decode(&summary)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to parse /stats/summary to go struct: %+v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &summary, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the current KubeletConfiguration
0000000000000000000000000000000000000000;;	func getCurrentKubeletConfig() (*componentconfig.KubeletConfiguration, error) {
0000000000000000000000000000000000000000;;		resp := pollConfigz(5*time.Minute, 5*time.Second)
0000000000000000000000000000000000000000;;		kubeCfg, err := decodeConfigz(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kubeCfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must be called within a Context. Allows the function to modify the KubeletConfiguration during the BeforeEach of the context.
0000000000000000000000000000000000000000;;	// The change is reverted in the AfterEach of the context.
0000000000000000000000000000000000000000;;	// Returns true on success.
0000000000000000000000000000000000000000;;	func tempSetCurrentKubeletConfig(f *framework.Framework, updateFunction func(initialConfig *componentconfig.KubeletConfiguration)) {
0000000000000000000000000000000000000000;;		var oldCfg *componentconfig.KubeletConfiguration
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			configEnabled, err := isKubeletConfigEnabled(f)
0000000000000000000000000000000000000000;;			framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			if configEnabled {
0000000000000000000000000000000000000000;;				oldCfg, err = getCurrentKubeletConfig()
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				clone, err := api.Scheme.DeepCopy(oldCfg)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;				newCfg := clone.(*componentconfig.KubeletConfiguration)
0000000000000000000000000000000000000000;;				updateFunction(newCfg)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(setKubeletConfiguration(f, newCfg))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				framework.Logf("The Dynamic Kubelet Configuration feature is not enabled.\n" +
0000000000000000000000000000000000000000;;					"Pass --feature-gates=DynamicKubeletConfig=true to the Kubelet to enable this feature.\n" +
0000000000000000000000000000000000000000;;					"For `make test-e2e-node`, you can set `TEST_ARGS='--feature-gates=DynamicKubeletConfig=true'`.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		AfterEach(func() {
0000000000000000000000000000000000000000;;			if oldCfg != nil {
0000000000000000000000000000000000000000;;				err := setKubeletConfiguration(f, oldCfg)
0000000000000000000000000000000000000000;;				framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if kubeletConfig is enabled, false otherwise or if we cannot determine if it is.
0000000000000000000000000000000000000000;;	func isKubeletConfigEnabled(f *framework.Framework) (bool, error) {
0000000000000000000000000000000000000000;;		cfgz, err := getCurrentKubeletConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("could not determine whether 'DynamicKubeletConfig' feature is enabled, err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Contains(cfgz.FeatureGates, "DynamicKubeletConfig=true"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Queries the API server for a Kubelet configuration for the node described by framework.TestContext.NodeName
0000000000000000000000000000000000000000;;	func getCurrentKubeletConfigMap(f *framework.Framework) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		return f.ClientSet.Core().ConfigMaps("kube-system").Get(fmt.Sprintf("kubelet-%s", framework.TestContext.NodeName), metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates or updates the configmap for KubeletConfiguration, waits for the Kubelet to restart
0000000000000000000000000000000000000000;;	// with the new configuration. Returns an error if the configuration after waiting 40 seconds
0000000000000000000000000000000000000000;;	// doesn't match what you attempted to set, or if the dynamic configuration feature is disabled.
0000000000000000000000000000000000000000;;	func setKubeletConfiguration(f *framework.Framework, kubeCfg *componentconfig.KubeletConfiguration) error {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			restartGap = 30 * time.Second
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure Dynamic Kubelet Configuration feature is enabled on the Kubelet we are about to reconfigure
0000000000000000000000000000000000000000;;		configEnabled, err := isKubeletConfigEnabled(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("could not determine whether 'DynamicKubeletConfig' feature is enabled, err: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !configEnabled {
0000000000000000000000000000000000000000;;			return fmt.Errorf("The Dynamic Kubelet Configuration feature is not enabled.\n" +
0000000000000000000000000000000000000000;;				"Pass --feature-gates=DynamicKubeletConfig=true to the Kubelet to enable this feature.\n" +
0000000000000000000000000000000000000000;;				"For `make test-e2e-node`, you can set `TEST_ARGS='--feature-gates=DynamicKubeletConfig=true'`.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check whether a configmap for KubeletConfiguration already exists
0000000000000000000000000000000000000000;;		_, err = getCurrentKubeletConfigMap(f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if k8serr.IsNotFound(err) {
0000000000000000000000000000000000000000;;			_, err := createConfigMap(f, kubeCfg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The configmap exists, update it instead of creating it.
0000000000000000000000000000000000000000;;			_, err := updateConfigMap(f, kubeCfg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the Kubelet to restart.
0000000000000000000000000000000000000000;;		time.Sleep(restartGap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve the new config and compare it to the one we attempted to set
0000000000000000000000000000000000000000;;		newKubeCfg, err := getCurrentKubeletConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return an error if the desired config is not in use by now
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(*kubeCfg, *newKubeCfg) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("either the Kubelet did not restart or it did not present the modified configuration via /configz after restarting.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Causes the test to fail, or returns a status 200 response from the /configz endpoint
0000000000000000000000000000000000000000;;	func pollConfigz(timeout time.Duration, pollInterval time.Duration) *http.Response {
0000000000000000000000000000000000000000;;		endpoint := fmt.Sprintf("http://127.0.0.1:8080/api/v1/proxy/nodes/%s/configz", framework.TestContext.NodeName)
0000000000000000000000000000000000000000;;		client := &http.Client{}
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", endpoint, nil)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;		req.Header.Add("Accept", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp *http.Response
0000000000000000000000000000000000000000;;		Eventually(func() bool {
0000000000000000000000000000000000000000;;			resp, err = client.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to get /configz, retrying. Error: %v", err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;				glog.Errorf("/configz response status not 200, retrying. Response was: %+v", resp)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}, timeout, pollInterval).Should(Equal(true))
0000000000000000000000000000000000000000;;		return resp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decodes the http response from /configz and returns a componentconfig.KubeletConfiguration (internal type).
0000000000000000000000000000000000000000;;	func decodeConfigz(resp *http.Response) (*componentconfig.KubeletConfiguration, error) {
0000000000000000000000000000000000000000;;		// This hack because /configz reports the following structure:
0000000000000000000000000000000000000000;;		// {"componentconfig": {the JSON representation of v1alpha1.KubeletConfiguration}}
0000000000000000000000000000000000000000;;		type configzWrapper struct {
0000000000000000000000000000000000000000;;			ComponentConfig v1alpha1.KubeletConfiguration `json:"componentconfig"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configz := configzWrapper{}
0000000000000000000000000000000000000000;;		kubeCfg := componentconfig.KubeletConfiguration{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contentsBytes, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = json.Unmarshal(contentsBytes, &configz)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = api.Scheme.Convert(&configz.ComponentConfig, &kubeCfg, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &kubeCfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constructs a Kubelet ConfigMap targeting the current node running the node e2e tests
0000000000000000000000000000000000000000;;	func makeKubeletConfigMap(nodeName string, kubeCfg *componentconfig.KubeletConfiguration) *v1.ConfigMap {
0000000000000000000000000000000000000000;;		kubeCfgExt := v1alpha1.KubeletConfiguration{}
0000000000000000000000000000000000000000;;		api.Scheme.Convert(kubeCfg, &kubeCfgExt, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bytes, err := json.Marshal(kubeCfgExt)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmap := &v1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: fmt.Sprintf("kubelet-%s", nodeName),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string]string{
0000000000000000000000000000000000000000;;				"kubelet.config": string(bytes),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uses KubeletConfiguration to create a `kubelet-<node-name>` ConfigMap in the "kube-system" namespace.
0000000000000000000000000000000000000000;;	func createConfigMap(f *framework.Framework, kubeCfg *componentconfig.KubeletConfiguration) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		cmap := makeKubeletConfigMap(framework.TestContext.NodeName, kubeCfg)
0000000000000000000000000000000000000000;;		cmap, err := f.ClientSet.Core().ConfigMaps("kube-system").Create(cmap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Similar to createConfigMap, except this updates an existing ConfigMap.
0000000000000000000000000000000000000000;;	func updateConfigMap(f *framework.Framework, kubeCfg *componentconfig.KubeletConfiguration) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		cmap := makeKubeletConfigMap(framework.TestContext.NodeName, kubeCfg)
0000000000000000000000000000000000000000;;		cmap, err := f.ClientSet.Core().ConfigMaps("kube-system").Update(cmap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logPodEvents(f *framework.Framework) {
0000000000000000000000000000000000000000;;		framework.Logf("Summary of pod events during the test:")
0000000000000000000000000000000000000000;;		err := framework.ListNamespaceEvents(f.ClientSet, f.Namespace.Name)
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logNodeEvents(f *framework.Framework) {
0000000000000000000000000000000000000000;;		framework.Logf("Summary of node events during the test:")
0000000000000000000000000000000000000000;;		err := framework.ListNamespaceEvents(f.ClientSet, "")
0000000000000000000000000000000000000000;;		framework.ExpectNoError(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getLocalNode(f *framework.Framework) *v1.Node {
0000000000000000000000000000000000000000;;		nodeList := framework.GetReadySchedulableNodesOrDie(f.ClientSet)
0000000000000000000000000000000000000000;;		Expect(len(nodeList.Items)).To(Equal(1), "Unexpected number of node objects for node e2e. Expects only one node.")
0000000000000000000000000000000000000000;;		return &nodeList.Items[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logs prometheus metrics from the local kubelet.
0000000000000000000000000000000000000000;;	func logKubeletMetrics(metricKeys ...string) {
0000000000000000000000000000000000000000;;		metricSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, key := range metricKeys {
0000000000000000000000000000000000000000;;			metricSet.Insert(kubeletmetrics.KubeletSubsystem + "_" + key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metric, err := metrics.GrabKubeletMetricsWithoutProxy(framework.TestContext.NodeName + ":10255")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Error getting kubelet metrics: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			framework.Logf("Kubelet Metrics: %+v", framework.GetKubeletMetrics(metric, metricSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
