0000000000000000000000000000000000000000;;	// +build linux
5ac9c93de298e75200f7e43d3fc66aabbe50c7b9;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/perftype"
0000000000000000000000000000000000000000;;		nodeperftype "k8s.io/kubernetes/test/e2e_node/perftype"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TimeSeriesTag = "[Result:TimeSeries]"
0000000000000000000000000000000000000000;;		TimeSeriesEnd = "[Finish:TimeSeries]"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dumpDataToFile inserts the current timestamp into the labels and writes the
0000000000000000000000000000000000000000;;	// data for the test into the file with the specified prefix.
0000000000000000000000000000000000000000;;	func dumpDataToFile(data interface{}, labels map[string]string, prefix string) {
0000000000000000000000000000000000000000;;		testName := labels["test"]
0000000000000000000000000000000000000000;;		fileName := path.Join(framework.TestContext.ReportDir, fmt.Sprintf("%s-%s-%s.json", prefix, framework.TestContext.ReportPrefix, testName))
0000000000000000000000000000000000000000;;		labels["timestamp"] = strconv.FormatInt(time.Now().UTC().Unix(), 10)
0000000000000000000000000000000000000000;;		framework.Logf("Dumping perf data for test %q to %q.", testName, fileName)
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(fileName, []byte(framework.PrettyPrintJSON(data)), 0644); err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Failed to write perf data for test %q to %q: %v", testName, fileName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logPerfData writes the perf data to a standalone json file if the
0000000000000000000000000000000000000000;;	// framework.TestContext.ReportDir is non-empty, or to the general build log
0000000000000000000000000000000000000000;;	// otherwise. The perfType identifies which type of the perf data it is, such
0000000000000000000000000000000000000000;;	// as "cpu" and "memory". If an error occurs, no perf data will be logged.
0000000000000000000000000000000000000000;;	func logPerfData(p *perftype.PerfData, perfType string) {
0000000000000000000000000000000000000000;;		if framework.TestContext.ReportDir == "" {
0000000000000000000000000000000000000000;;			framework.PrintPerfData(p)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dumpDataToFile(p, p.Labels, "performance-"+perfType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logDensityTimeSeries writes the time series data of operation and resource
0000000000000000000000000000000000000000;;	// usage to a standalone json file if the framework.TestContext.ReportDir is
0000000000000000000000000000000000000000;;	// non-empty, or to the general build log otherwise. If an error occurs,
0000000000000000000000000000000000000000;;	// no perf data will be logged.
0000000000000000000000000000000000000000;;	func logDensityTimeSeries(rc *ResourceCollector, create, watch map[string]metav1.Time, testInfo map[string]string) {
0000000000000000000000000000000000000000;;		timeSeries := &nodeperftype.NodeTimeSeries{
0000000000000000000000000000000000000000;;			Labels:  testInfo,
0000000000000000000000000000000000000000;;			Version: framework.CurrentKubeletPerfMetricsVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Attach operation time series.
0000000000000000000000000000000000000000;;		timeSeries.OperationData = map[string][]int64{
0000000000000000000000000000000000000000;;			"create":  getCumulatedPodTimeSeries(create),
0000000000000000000000000000000000000000;;			"running": getCumulatedPodTimeSeries(watch),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Attach resource time series.
0000000000000000000000000000000000000000;;		timeSeries.ResourceData = rc.GetResourceTimeSeries()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if framework.TestContext.ReportDir == "" {
0000000000000000000000000000000000000000;;			framework.Logf("%s %s\n%s", TimeSeriesTag, framework.PrettyPrintJSON(timeSeries), TimeSeriesEnd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dumpDataToFile(timeSeries, timeSeries.Labels, "time_series")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type int64arr []int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a int64arr) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a int64arr) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a int64arr) Less(i, j int) bool { return a[i] < a[j] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCumulatedPodTimeSeries gets the cumulative pod number time series.
0000000000000000000000000000000000000000;;	func getCumulatedPodTimeSeries(timePerPod map[string]metav1.Time) []int64 {
0000000000000000000000000000000000000000;;		timeSeries := make(int64arr, 0)
0000000000000000000000000000000000000000;;		for _, ts := range timePerPod {
0000000000000000000000000000000000000000;;			timeSeries = append(timeSeries, ts.Time.UnixNano())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Sort all timestamps.
0000000000000000000000000000000000000000;;		sort.Sort(timeSeries)
0000000000000000000000000000000000000000;;		return timeSeries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLatencyPerfData returns perf data of pod startup latency.
0000000000000000000000000000000000000000;;	func getLatencyPerfData(latency framework.LatencyMetric, testInfo map[string]string) *perftype.PerfData {
0000000000000000000000000000000000000000;;		return &perftype.PerfData{
0000000000000000000000000000000000000000;;			Version: framework.CurrentKubeletPerfMetricsVersion,
0000000000000000000000000000000000000000;;			DataItems: []perftype.DataItem{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Data: map[string]float64{
0000000000000000000000000000000000000000;;						"Perc50":  float64(latency.Perc50) / 1000000,
0000000000000000000000000000000000000000;;						"Perc90":  float64(latency.Perc90) / 1000000,
0000000000000000000000000000000000000000;;						"Perc99":  float64(latency.Perc99) / 1000000,
0000000000000000000000000000000000000000;;						"Perc100": float64(latency.Perc100) / 1000000,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Unit: "ms",
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"datatype":    "latency",
0000000000000000000000000000000000000000;;						"latencytype": "create-pod",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Labels: testInfo,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getThroughputPerfData returns perf data of pod creation startup throughput.
0000000000000000000000000000000000000000;;	func getThroughputPerfData(batchLag time.Duration, e2eLags []framework.PodLatencyData, podsNr int, testInfo map[string]string) *perftype.PerfData {
0000000000000000000000000000000000000000;;		return &perftype.PerfData{
0000000000000000000000000000000000000000;;			Version: framework.CurrentKubeletPerfMetricsVersion,
0000000000000000000000000000000000000000;;			DataItems: []perftype.DataItem{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Data: map[string]float64{
0000000000000000000000000000000000000000;;						"batch":        float64(podsNr) / batchLag.Minutes(),
0000000000000000000000000000000000000000;;						"single-worst": 1.0 / e2eLags[len(e2eLags)-1].Latency.Minutes(),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Unit: "pods/min",
0000000000000000000000000000000000000000;;					Labels: map[string]string{
0000000000000000000000000000000000000000;;						"datatype":    "throughput",
0000000000000000000000000000000000000000;;						"latencytype": "create-pod",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Labels: testInfo,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getTestNodeInfo returns a label map containing the test name and
0000000000000000000000000000000000000000;;	// description, the name of the node on which the test will be run, the image
0000000000000000000000000000000000000000;;	// name of the node, and the node capacities.
0000000000000000000000000000000000000000;;	func getTestNodeInfo(f *framework.Framework, testName, testDesc string) map[string]string {
0000000000000000000000000000000000000000;;		nodeName := framework.TestContext.NodeName
0000000000000000000000000000000000000000;;		node, err := f.ClientSet.Core().Nodes().Get(nodeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpu, ok := node.Status.Capacity["cpu"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			framework.Failf("Fail to fetch CPU capacity value of test node.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		memory, ok := node.Status.Capacity["memory"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			framework.Failf("Fail to fetch Memory capacity value of test node.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpuValue, ok := cpu.AsInt64()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			framework.Failf("Fail to fetch CPU capacity value as Int64.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		memoryValue, ok := memory.AsInt64()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			framework.Failf("Fail to fetch Memory capacity value as Int64.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		image := node.Status.NodeInfo.OSImage
0000000000000000000000000000000000000000;;		if framework.TestContext.ImageDescription != "" {
0000000000000000000000000000000000000000;;			image = fmt.Sprintf("%s (%s)", image, framework.TestContext.ImageDescription)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return map[string]string{
0000000000000000000000000000000000000000;;			"node":    nodeName,
0000000000000000000000000000000000000000;;			"test":    testName,
0000000000000000000000000000000000000000;;			"image":   image,
0000000000000000000000000000000000000000;;			"machine": fmt.Sprintf("cpu:%dcore,memory:%.1fGB", cpuValue, float32(memoryValue)/(1024*1024*1024)),
0000000000000000000000000000000000000000;;			"desc":    testDesc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
