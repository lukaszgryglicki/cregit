0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4a7f39737a0c563d7a86ae608ccea196e6fd6f04;test/e2e_node/runner/run_e2e.go[test/e2e_node/runner/run_e2e.go][test/e2e_node/runner/remote/run_remote.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// To run the node e2e tests remotely against one or more hosts on gce:
0000000000000000000000000000000000000000;;	// $ go run run_remote.go --logtostderr --v 2 --ssh-env gce --hosts <comma separated hosts>
0000000000000000000000000000000000000000;;	// To run the node e2e tests remotely against one or more images on gce and provision them:
0000000000000000000000000000000000000000;;	// $ go run run_remote.go --logtostderr --v 2 --project <project> --zone <zone> --ssh-env gce --images <comma separated images>
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e_node/remote"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/google"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v0.beta"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var testArgs = flag.String("test_args", "", "Space-separated list of arguments to pass to Ginkgo test runner.")
0000000000000000000000000000000000000000;;	var instanceNamePrefix = flag.String("instance-name-prefix", "", "prefix for instance names")
0000000000000000000000000000000000000000;;	var zone = flag.String("zone", "", "gce zone the hosts live in")
0000000000000000000000000000000000000000;;	var project = flag.String("project", "", "gce project the hosts live in")
0000000000000000000000000000000000000000;;	var imageConfigFile = flag.String("image-config-file", "", "yaml file describing images to run")
0000000000000000000000000000000000000000;;	var imageProject = flag.String("image-project", "", "gce project the hosts live in")
0000000000000000000000000000000000000000;;	var images = flag.String("images", "", "images to test")
0000000000000000000000000000000000000000;;	var hosts = flag.String("hosts", "", "hosts to test")
0000000000000000000000000000000000000000;;	var cleanup = flag.Bool("cleanup", true, "If true remove files from remote hosts and delete temporary instances")
0000000000000000000000000000000000000000;;	var deleteInstances = flag.Bool("delete-instances", true, "If true, delete any instances created")
0000000000000000000000000000000000000000;;	var buildOnly = flag.Bool("build-only", false, "If true, build e2e_node_test.tar.gz and exit.")
0000000000000000000000000000000000000000;;	var instanceMetadata = flag.String("instance-metadata", "", "key/value metadata for instances separated by '=' or '<', 'k=v' means the key is 'k' and the value is 'v'; 'k<p' means the key is 'k' and the value is extracted from the local path 'p', e.g. k1=v1,k2<p2")
0000000000000000000000000000000000000000;;	var gubernator = flag.Bool("gubernator", false, "If true, output Gubernator link to view logs")
0000000000000000000000000000000000000000;;	var ginkgoFlags = flag.String("ginkgo-flags", "", "Passed to ginkgo to specify additional flags such as --skip=.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultMachine                = "n1-standard-1"
0000000000000000000000000000000000000000;;		acceleratorTypeResourceFormat = "https://www.googleapis.com/compute/beta/projects/%s/zones/%s/acceleratorTypes/%s"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		computeService *compute.Service
0000000000000000000000000000000000000000;;		arc            Archive
0000000000000000000000000000000000000000;;		suite          remote.TestSuite
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Archive struct {
0000000000000000000000000000000000000000;;		sync.Once
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestResult struct {
0000000000000000000000000000000000000000;;		output string
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;		host   string
0000000000000000000000000000000000000000;;		exitOk bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageConfig specifies what images should be run and how for these tests.
0000000000000000000000000000000000000000;;	// It can be created via the `--images` and `--image-project` flags, or by
0000000000000000000000000000000000000000;;	// specifying the `--image-config-file` flag, pointing to a json or yaml file
0000000000000000000000000000000000000000;;	// of the form:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     images:
0000000000000000000000000000000000000000;;	//       short-name:
0000000000000000000000000000000000000000;;	//         image: gce-image-name
0000000000000000000000000000000000000000;;	//         project: gce-image-project
0000000000000000000000000000000000000000;;	//         machine: for benchmark only, the machine type (GCE instance) to run test
0000000000000000000000000000000000000000;;	//         tests: for benchmark only, a list of ginkgo focus strings to match tests
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(coufon): replace 'image' with 'node' in configurations
0000000000000000000000000000000000000000;;	// and we plan to support testing custom machines other than GCE by specifying host
0000000000000000000000000000000000000000;;	type ImageConfig struct {
0000000000000000000000000000000000000000;;		Images map[string]GCEImage `json:"images"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Accelerator struct {
0000000000000000000000000000000000000000;;		Type  string `json:"type,omitempty"`
0000000000000000000000000000000000000000;;		Count int64  `json:"count, omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Resources struct {
0000000000000000000000000000000000000000;;		Accelerators []Accelerator `json:"accelerators,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GCEImage struct {
0000000000000000000000000000000000000000;;		Image      string `json:"image, omitempty"`
0000000000000000000000000000000000000000;;		Project    string `json:"project"`
0000000000000000000000000000000000000000;;		Metadata   string `json:"metadata"`
0000000000000000000000000000000000000000;;		ImageRegex string `json:"image_regex, omitempty"`
0000000000000000000000000000000000000000;;		// Defaults to using only the latest image. Acceptible values are [0, # of images that match the regex).
0000000000000000000000000000000000000000;;		// If the number of existing previous images is lesser than what is desired, the test will use that is available.
0000000000000000000000000000000000000000;;		PreviousImages int `json:"previous_images, omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Machine   string    `json:"machine, omitempty"`
0000000000000000000000000000000000000000;;		Resources Resources `json:"resources, omitempty"`
0000000000000000000000000000000000000000;;		// This test is for benchmark (no limit verification, more result log, node name has format 'machine-image-uuid') if 'Tests' is non-empty.
0000000000000000000000000000000000000000;;		Tests []string `json:"tests, omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type internalImageConfig struct {
0000000000000000000000000000000000000000;;		images map[string]internalGCEImage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type internalGCEImage struct {
0000000000000000000000000000000000000000;;		image     string
0000000000000000000000000000000000000000;;		project   string
0000000000000000000000000000000000000000;;		resources Resources
0000000000000000000000000000000000000000;;		metadata  *compute.Metadata
0000000000000000000000000000000000000000;;		machine   string
0000000000000000000000000000000000000000;;		tests     []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseFlags parse subcommands and flags
0000000000000000000000000000000000000000;;	func parseFlags() {
0000000000000000000000000000000000000000;;		if len(os.Args) <= 1 {
0000000000000000000000000000000000000000;;			glog.Fatalf("Too few flags specified: %v", os.Args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Parse subcommand.
0000000000000000000000000000000000000000;;		subcommand := os.Args[1]
0000000000000000000000000000000000000000;;		switch subcommand {
0000000000000000000000000000000000000000;;		case "conformance":
0000000000000000000000000000000000000000;;			suite = remote.InitConformanceRemote()
0000000000000000000000000000000000000000;;		// TODO: Add subcommand for node soaking, node conformance, cri validation.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Use node e2e suite by default if no subcommand is specified.
0000000000000000000000000000000000000000;;			suite = remote.InitNodeE2ERemote()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Parse test flags.
0000000000000000000000000000000000000000;;		flag.CommandLine.Parse(os.Args[2:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		parseFlags()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rand.Seed(time.Now().UTC().UnixNano())
0000000000000000000000000000000000000000;;		if *buildOnly {
0000000000000000000000000000000000000000;;			// Build the archive and exit
0000000000000000000000000000000000000000;;			remote.CreateTestArchive(suite)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *hosts == "" && *imageConfigFile == "" && *images == "" {
0000000000000000000000000000000000000000;;			glog.Fatalf("Must specify one of --image-config-file, --hosts, --images.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		computeService, err = getComputeClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Unable to create gcloud compute service using defaults.  Make sure you are authenticated. %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gceImages := &internalImageConfig{
0000000000000000000000000000000000000000;;			images: make(map[string]internalGCEImage),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *imageConfigFile != "" {
0000000000000000000000000000000000000000;;			// parse images
0000000000000000000000000000000000000000;;			imageConfigData, err := ioutil.ReadFile(*imageConfigFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("Could not read image config file provided: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			externalImageConfig := ImageConfig{Images: make(map[string]GCEImage)}
0000000000000000000000000000000000000000;;			err = yaml.Unmarshal(imageConfigData, &externalImageConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("Could not parse image config file: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for shortName, imageConfig := range externalImageConfig.Images {
0000000000000000000000000000000000000000;;				var images []string
0000000000000000000000000000000000000000;;				isRegex, name := false, shortName
0000000000000000000000000000000000000000;;				if imageConfig.ImageRegex != "" && imageConfig.Image == "" {
0000000000000000000000000000000000000000;;					isRegex = true
0000000000000000000000000000000000000000;;					images, err = getGCEImages(imageConfig.ImageRegex, imageConfig.Project, imageConfig.PreviousImages)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Fatalf("Could not retrieve list of images based on image prefix %q: %v", imageConfig.ImageRegex, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					images = []string{imageConfig.Image}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, image := range images {
0000000000000000000000000000000000000000;;					gceImage := internalGCEImage{
0000000000000000000000000000000000000000;;						image:     image,
0000000000000000000000000000000000000000;;						project:   imageConfig.Project,
0000000000000000000000000000000000000000;;						metadata:  getImageMetadata(imageConfig.Metadata),
0000000000000000000000000000000000000000;;						machine:   imageConfig.Machine,
0000000000000000000000000000000000000000;;						tests:     imageConfig.Tests,
0000000000000000000000000000000000000000;;						resources: imageConfig.Resources,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if isRegex && len(images) > 1 {
0000000000000000000000000000000000000000;;						// Use image name when shortName is not unique.
0000000000000000000000000000000000000000;;						name = image
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					gceImages.images[name] = gceImage
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow users to specify additional images via cli flags for local testing
0000000000000000000000000000000000000000;;		// convenience; merge in with config file
0000000000000000000000000000000000000000;;		if *images != "" {
0000000000000000000000000000000000000000;;			if *imageProject == "" {
0000000000000000000000000000000000000000;;				glog.Fatal("Must specify --image-project if you specify --images")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cliImages := strings.Split(*images, ",")
0000000000000000000000000000000000000000;;			for _, img := range cliImages {
0000000000000000000000000000000000000000;;				gceImage := internalGCEImage{
0000000000000000000000000000000000000000;;					image:    img,
0000000000000000000000000000000000000000;;					project:  *imageProject,
0000000000000000000000000000000000000000;;					metadata: getImageMetadata(*instanceMetadata),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gceImages.images[img] = gceImage
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(gceImages.images) != 0 && *zone == "" {
0000000000000000000000000000000000000000;;			glog.Fatal("Must specify --zone flag")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for shortName, image := range gceImages.images {
0000000000000000000000000000000000000000;;			if image.project == "" {
0000000000000000000000000000000000000000;;				glog.Fatalf("Invalid config for %v; must specify a project", shortName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(gceImages.images) != 0 {
0000000000000000000000000000000000000000;;			if *project == "" {
0000000000000000000000000000000000000000;;				glog.Fatal("Must specify --project flag to launch images into")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *instanceNamePrefix == "" {
0000000000000000000000000000000000000000;;			*instanceNamePrefix = "tmp-node-e2e-" + uuid.NewUUID().String()[:8]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup coloring
0000000000000000000000000000000000000000;;		stat, _ := os.Stdout.Stat()
0000000000000000000000000000000000000000;;		useColor := (stat.Mode() & os.ModeCharDevice) != 0
0000000000000000000000000000000000000000;;		blue := ""
0000000000000000000000000000000000000000;;		noColour := ""
0000000000000000000000000000000000000000;;		if useColor {
0000000000000000000000000000000000000000;;			blue = "\033[0;34m"
0000000000000000000000000000000000000000;;			noColour = "\033[0m"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go arc.getArchive()
0000000000000000000000000000000000000000;;		defer arc.deleteArchive()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		results := make(chan *TestResult)
0000000000000000000000000000000000000000;;		running := 0
0000000000000000000000000000000000000000;;		for shortName := range gceImages.images {
0000000000000000000000000000000000000000;;			imageConfig := gceImages.images[shortName]
0000000000000000000000000000000000000000;;			fmt.Printf("Initializing e2e tests using image %s.\n", shortName)
0000000000000000000000000000000000000000;;			running++
0000000000000000000000000000000000000000;;			go func(image *internalGCEImage, junitFilePrefix string) {
0000000000000000000000000000000000000000;;				results <- testImage(image, junitFilePrefix)
0000000000000000000000000000000000000000;;			}(&imageConfig, shortName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *hosts != "" {
0000000000000000000000000000000000000000;;			for _, host := range strings.Split(*hosts, ",") {
0000000000000000000000000000000000000000;;				fmt.Printf("Initializing e2e tests using host %s.\n", host)
0000000000000000000000000000000000000000;;				running++
0000000000000000000000000000000000000000;;				go func(host string, junitFilePrefix string) {
0000000000000000000000000000000000000000;;					results <- testHost(host, *cleanup, "", junitFilePrefix, *ginkgoFlags)
0000000000000000000000000000000000000000;;				}(host, host)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for all tests to complete and emit the results
0000000000000000000000000000000000000000;;		errCount := 0
0000000000000000000000000000000000000000;;		exitOk := true
0000000000000000000000000000000000000000;;		for i := 0; i < running; i++ {
0000000000000000000000000000000000000000;;			tr := <-results
0000000000000000000000000000000000000000;;			host := tr.host
0000000000000000000000000000000000000000;;			fmt.Println() // Print an empty line
0000000000000000000000000000000000000000;;			fmt.Printf("%s>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%s\n", blue, noColour)
0000000000000000000000000000000000000000;;			fmt.Printf("%s>                              START TEST                                >%s\n", blue, noColour)
0000000000000000000000000000000000000000;;			fmt.Printf("%s>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>%s\n", blue, noColour)
0000000000000000000000000000000000000000;;			fmt.Printf("Start Test Suite on Host %s\n", host)
0000000000000000000000000000000000000000;;			fmt.Printf("%s\n", tr.output)
0000000000000000000000000000000000000000;;			if tr.err != nil {
0000000000000000000000000000000000000000;;				errCount++
0000000000000000000000000000000000000000;;				fmt.Printf("Failure Finished Test Suite on Host %s\n%v\n", host, tr.err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Printf("Success Finished Test Suite on Host %s\n", host)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exitOk = exitOk && tr.exitOk
0000000000000000000000000000000000000000;;			fmt.Printf("%s<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<%s\n", blue, noColour)
0000000000000000000000000000000000000000;;			fmt.Printf("%s<                              FINISH TEST                               <%s\n", blue, noColour)
0000000000000000000000000000000000000000;;			fmt.Printf("%s<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<%s\n", blue, noColour)
0000000000000000000000000000000000000000;;			fmt.Println() // Print an empty line
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set the exit code if there were failures
0000000000000000000000000000000000000000;;		if !exitOk {
0000000000000000000000000000000000000000;;			fmt.Printf("Failure: %d errors encountered.\n", errCount)
0000000000000000000000000000000000000000;;			callGubernator(*gubernator)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		callGubernator(*gubernator)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func callGubernator(gubernator bool) {
0000000000000000000000000000000000000000;;		if gubernator {
0000000000000000000000000000000000000000;;			fmt.Println("Running gubernator.sh")
0000000000000000000000000000000000000000;;			output, err := exec.Command("./test/e2e_node/gubernator.sh", "y").Output()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Println("gubernator.sh Failed")
0000000000000000000000000000000000000000;;				fmt.Println(err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Printf("%s", output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *Archive) getArchive() (string, error) {
0000000000000000000000000000000000000000;;		a.Do(func() { a.path, a.err = remote.CreateTestArchive(suite) })
0000000000000000000000000000000000000000;;		return a.path, a.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *Archive) deleteArchive() {
0000000000000000000000000000000000000000;;		path, err := a.getArchive()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.Remove(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getImageMetadata(input string) *compute.Metadata {
0000000000000000000000000000000000000000;;		if input == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("parsing instance metadata: %q", input)
0000000000000000000000000000000000000000;;		raw := parseInstanceMetadata(input)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("parsed instance metadata: %v", raw)
0000000000000000000000000000000000000000;;		metadataItems := []*compute.MetadataItems{}
0000000000000000000000000000000000000000;;		for k, v := range raw {
0000000000000000000000000000000000000000;;			val := v
0000000000000000000000000000000000000000;;			metadataItems = append(metadataItems, &compute.MetadataItems{
0000000000000000000000000000000000000000;;				Key:   k,
0000000000000000000000000000000000000000;;				Value: val,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := compute.Metadata{Items: metadataItems}
0000000000000000000000000000000000000000;;		return &ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run tests in archive against host
0000000000000000000000000000000000000000;;	func testHost(host string, deleteFiles bool, imageDesc, junitFilePrefix, ginkgoFlagsStr string) *TestResult {
0000000000000000000000000000000000000000;;		instance, err := computeService.Instances.Get(*project, *zone, host).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &TestResult{
0000000000000000000000000000000000000000;;				err:    err,
0000000000000000000000000000000000000000;;				host:   host,
0000000000000000000000000000000000000000;;				exitOk: false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.ToUpper(instance.Status) != "RUNNING" {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("instance %s not in state RUNNING, was %s.", host, instance.Status)
0000000000000000000000000000000000000000;;			return &TestResult{
0000000000000000000000000000000000000000;;				err:    err,
0000000000000000000000000000000000000000;;				host:   host,
0000000000000000000000000000000000000000;;				exitOk: false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		externalIp := getExternalIp(instance)
0000000000000000000000000000000000000000;;		if len(externalIp) > 0 {
0000000000000000000000000000000000000000;;			remote.AddHostnameIp(host, externalIp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path, err := arc.getArchive()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Don't log fatal because we need to do any needed cleanup contained in "defer" statements
0000000000000000000000000000000000000000;;			return &TestResult{
0000000000000000000000000000000000000000;;				err: fmt.Errorf("unable to create test archive %v.", err),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output, exitOk, err := remote.RunRemote(suite, path, host, deleteFiles, imageDesc, junitFilePrefix, *testArgs, ginkgoFlagsStr)
0000000000000000000000000000000000000000;;		return &TestResult{
0000000000000000000000000000000000000000;;			output: output,
0000000000000000000000000000000000000000;;			err:    err,
0000000000000000000000000000000000000000;;			host:   host,
0000000000000000000000000000000000000000;;			exitOk: exitOk,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type imageObj struct {
0000000000000000000000000000000000000000;;		creationTime time.Time
0000000000000000000000000000000000000000;;		name         string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (io imageObj) string() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%q created %q", io.name, io.creationTime.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byCreationTime []imageObj
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a byCreationTime) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a byCreationTime) Less(i, j int) bool { return a[i].creationTime.After(a[j].creationTime) }
0000000000000000000000000000000000000000;;	func (a byCreationTime) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a list of image names based on regex and number of previous images requested.
0000000000000000000000000000000000000000;;	func getGCEImages(imageRegex, project string, previousImages int) ([]string, error) {
0000000000000000000000000000000000000000;;		ilc, err := computeService.Images.List(project).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed to list images in project %q: %v", project, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageObjs := []imageObj{}
0000000000000000000000000000000000000000;;		imageRe := regexp.MustCompile(imageRegex)
0000000000000000000000000000000000000000;;		for _, instance := range ilc.Items {
0000000000000000000000000000000000000000;;			if imageRe.MatchString(instance.Name) {
0000000000000000000000000000000000000000;;				creationTime, err := time.Parse(time.RFC3339, instance.CreationTimestamp)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Failed to parse instance creation timestamp %q: %v", instance.CreationTimestamp, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				io := imageObj{
0000000000000000000000000000000000000000;;					creationTime: creationTime,
0000000000000000000000000000000000000000;;					name:         instance.Name,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Found image %q based on regex %q in project %q", io.string(), imageRegex, project)
0000000000000000000000000000000000000000;;				imageObjs = append(imageObjs, io)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(byCreationTime(imageObjs))
0000000000000000000000000000000000000000;;		images := []string{}
0000000000000000000000000000000000000000;;		for _, imageObj := range imageObjs {
0000000000000000000000000000000000000000;;			images = append(images, imageObj.name)
0000000000000000000000000000000000000000;;			previousImages--
0000000000000000000000000000000000000000;;			if previousImages < 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return images, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provision a gce instance using image and run the tests in archive against the instance.
0000000000000000000000000000000000000000;;	// Delete the instance afterward.
0000000000000000000000000000000000000000;;	func testImage(imageConfig *internalGCEImage, junitFilePrefix string) *TestResult {
0000000000000000000000000000000000000000;;		ginkgoFlagsStr := *ginkgoFlags
0000000000000000000000000000000000000000;;		// Check whether the test is for benchmark.
0000000000000000000000000000000000000000;;		if len(imageConfig.tests) > 0 {
0000000000000000000000000000000000000000;;			// Benchmark needs machine type non-empty.
0000000000000000000000000000000000000000;;			if imageConfig.machine == "" {
0000000000000000000000000000000000000000;;				imageConfig.machine = defaultMachine
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Use the Ginkgo focus in benchmark config.
0000000000000000000000000000000000000000;;			ginkgoFlagsStr += (" " + testsToGinkgoFocus(imageConfig.tests))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, err := createInstance(imageConfig)
0000000000000000000000000000000000000000;;		if *deleteInstances {
0000000000000000000000000000000000000000;;			defer deleteInstance(host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &TestResult{
0000000000000000000000000000000000000000;;				err: fmt.Errorf("unable to create gce instance with running docker daemon for image %s.  %v", imageConfig.image, err),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only delete the files if we are keeping the instance and want it cleaned up.
0000000000000000000000000000000000000000;;		// If we are going to delete the instance, don't bother with cleaning up the files
0000000000000000000000000000000000000000;;		deleteFiles := !*deleteInstances && *cleanup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := testHost(host, deleteFiles, imageConfig.image, junitFilePrefix, ginkgoFlagsStr)
0000000000000000000000000000000000000000;;		// This is a temporary solution to collect serial node serial log. Only port 1 contains useful information.
0000000000000000000000000000000000000000;;		// TODO(random-liu): Extract out and unify log collection logic with cluste e2e.
0000000000000000000000000000000000000000;;		serialPortOutput, err := computeService.Instances.GetSerialPortOutput(*project, *zone, host).Port(1).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to collect serial output from node %q: %v", host, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			logFilename := "serial-1.log"
0000000000000000000000000000000000000000;;			err := remote.WriteLog(host, logFilename, serialPortOutput.Contents)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to write serial output from node %q to %q: %v", host, logFilename, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provision a gce instance using image
0000000000000000000000000000000000000000;;	func createInstance(imageConfig *internalGCEImage) (string, error) {
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Creating instance %+v", *imageConfig)
0000000000000000000000000000000000000000;;		name := imageToInstanceName(imageConfig)
0000000000000000000000000000000000000000;;		i := &compute.Instance{
0000000000000000000000000000000000000000;;			Name:        name,
0000000000000000000000000000000000000000;;			MachineType: machineType(imageConfig.machine),
0000000000000000000000000000000000000000;;			NetworkInterfaces: []*compute.NetworkInterface{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					AccessConfigs: []*compute.AccessConfig{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Type: "ONE_TO_ONE_NAT",
0000000000000000000000000000000000000000;;							Name: "External NAT",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Disks: []*compute.AttachedDisk{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					AutoDelete: true,
0000000000000000000000000000000000000000;;					Boot:       true,
0000000000000000000000000000000000000000;;					Type:       "PERSISTENT",
0000000000000000000000000000000000000000;;					InitializeParams: &compute.AttachedDiskInitializeParams{
0000000000000000000000000000000000000000;;						SourceImage: sourceImage(imageConfig.image, imageConfig.project),
0000000000000000000000000000000000000000;;						DiskSizeGb:  20,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, accelerator := range imageConfig.resources.Accelerators {
0000000000000000000000000000000000000000;;			if i.GuestAccelerators == nil {
0000000000000000000000000000000000000000;;				i.GuestAccelerators = []*compute.AcceleratorConfig{}
0000000000000000000000000000000000000000;;				i.Scheduling = &compute.Scheduling{
0000000000000000000000000000000000000000;;					OnHostMaintenance: "TERMINATE",
0000000000000000000000000000000000000000;;					AutomaticRestart:  true,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			aType := fmt.Sprintf(acceleratorTypeResourceFormat, *project, *zone, accelerator.Type)
0000000000000000000000000000000000000000;;			ac := &compute.AcceleratorConfig{
0000000000000000000000000000000000000000;;				AcceleratorCount: accelerator.Count,
0000000000000000000000000000000000000000;;				AcceleratorType:  aType,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i.GuestAccelerators = append(i.GuestAccelerators, ac)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		i.Metadata = imageConfig.metadata
0000000000000000000000000000000000000000;;		if _, err := computeService.Instances.Get(*project, *zone, i.Name).Do(); err != nil {
0000000000000000000000000000000000000000;;			op, err := computeService.Instances.Insert(*project, *zone, i).Do()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				ret := fmt.Sprintf("could not create instance %s: API error: %v", name, err)
0000000000000000000000000000000000000000;;				if op != nil {
0000000000000000000000000000000000000000;;					ret = fmt.Sprintf("%s: %v", ret, op.Error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(ret)
0000000000000000000000000000000000000000;;			} else if op.Error != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("could not create instance %s: %+v", name, op.Error)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instanceRunning := false
0000000000000000000000000000000000000000;;		for i := 0; i < 30 && !instanceRunning; i++ {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				time.Sleep(time.Second * 20)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var instance *compute.Instance
0000000000000000000000000000000000000000;;			instance, err = computeService.Instances.Get(*project, *zone, name).Do()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.ToUpper(instance.Status) != "RUNNING" {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("instance %s not in state RUNNING, was %s.", name, instance.Status)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			externalIp := getExternalIp(instance)
0000000000000000000000000000000000000000;;			if len(externalIp) > 0 {
0000000000000000000000000000000000000000;;				remote.AddHostnameIp(name, externalIp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var output string
0000000000000000000000000000000000000000;;			output, err = remote.SSH(name, "docker", "version")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("instance %s not running docker daemon - Command failed: %s", name, output)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.Contains(output, "Server") {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("instance %s not running docker daemon - Server not found: %s", name, output)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			instanceRunning = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If instance didn't reach running state in time, return with error now.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return name, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Instance reached running state in time, make sure that cloud-init is complete
0000000000000000000000000000000000000000;;		if isCloudInitUsed(imageConfig.metadata) {
0000000000000000000000000000000000000000;;			cloudInitFinished := false
0000000000000000000000000000000000000000;;			for i := 0; i < 60 && !cloudInitFinished; i++ {
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					time.Sleep(time.Second * 20)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var finished string
0000000000000000000000000000000000000000;;				finished, err = remote.SSH(name, "ls", "/var/lib/cloud/instance/boot-finished")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("instance %s has not finished cloud-init script: %s", name, finished)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cloudInitFinished = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isCloudInitUsed(metadata *compute.Metadata) bool {
0000000000000000000000000000000000000000;;		if metadata == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range metadata.Items {
0000000000000000000000000000000000000000;;			if item.Key == "user-data" && strings.HasPrefix(item.Value, "#cloud-config") {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getExternalIp(instance *compute.Instance) string {
0000000000000000000000000000000000000000;;		for i := range instance.NetworkInterfaces {
0000000000000000000000000000000000000000;;			ni := instance.NetworkInterfaces[i]
0000000000000000000000000000000000000000;;			for j := range ni.AccessConfigs {
0000000000000000000000000000000000000000;;				ac := ni.AccessConfigs[j]
0000000000000000000000000000000000000000;;				if len(ac.NatIP) > 0 {
0000000000000000000000000000000000000000;;					return ac.NatIP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getComputeClient() (*compute.Service, error) {
0000000000000000000000000000000000000000;;		const retries = 10
0000000000000000000000000000000000000000;;		const backoff = time.Second * 6
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup the gce client for provisioning instances
0000000000000000000000000000000000000000;;		// Getting credentials on gce jenkins is flaky, so try a couple times
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var cs *compute.Service
0000000000000000000000000000000000000000;;		for i := 0; i < retries; i++ {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				time.Sleep(backoff)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var client *http.Client
0000000000000000000000000000000000000000;;			client, err = google.DefaultClient(oauth2.NoContext, compute.ComputeScope)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cs, err = compute.New(client)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cs, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteInstance(host string) {
0000000000000000000000000000000000000000;;		glog.Infof("Deleting instance %q", host)
0000000000000000000000000000000000000000;;		_, err := computeService.Instances.Delete(*project, *zone, host).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error deleting instance %q: %v", host, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseInstanceMetadata(str string) map[string]string {
0000000000000000000000000000000000000000;;		metadata := make(map[string]string)
0000000000000000000000000000000000000000;;		ss := strings.Split(str, ",")
0000000000000000000000000000000000000000;;		for _, s := range ss {
0000000000000000000000000000000000000000;;			kv := strings.Split(s, "=")
0000000000000000000000000000000000000000;;			if len(kv) == 2 {
0000000000000000000000000000000000000000;;				metadata[kv[0]] = kv[1]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kp := strings.Split(s, "<")
0000000000000000000000000000000000000000;;			if len(kp) != 2 {
0000000000000000000000000000000000000000;;				glog.Fatalf("Invalid instance metadata: %q", s)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v, err := ioutil.ReadFile(kp[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("Failed to read metadata file %q: %v", kp[1], err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metadata[kp[0]] = string(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metadata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func imageToInstanceName(imageConfig *internalGCEImage) string {
0000000000000000000000000000000000000000;;		if imageConfig.machine == "" {
0000000000000000000000000000000000000000;;			return *instanceNamePrefix + "-" + imageConfig.image
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// For benchmark test, node name has the format 'machine-image-uuid' to run
0000000000000000000000000000000000000000;;		// different machine types with the same image in parallel
0000000000000000000000000000000000000000;;		return imageConfig.machine + "-" + imageConfig.image + "-" + uuid.NewUUID().String()[:8]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sourceImage(image, imageProject string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("projects/%s/global/images/%s", imageProject, image)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func machineType(machine string) string {
0000000000000000000000000000000000000000;;		if machine == "" {
0000000000000000000000000000000000000000;;			machine = defaultMachine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("zones/%s/machineTypes/%s", *zone, machine)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testsToGinkgoFocus converts the test string list to Ginkgo focus
0000000000000000000000000000000000000000;;	func testsToGinkgoFocus(tests []string) string {
0000000000000000000000000000000000000000;;		focus := "--focus=\""
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				focus += test
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				focus += ("|" + test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return focus + "\""
0000000000000000000000000000000000000000;;	}
