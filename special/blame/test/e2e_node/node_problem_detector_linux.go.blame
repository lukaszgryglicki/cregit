0000000000000000000000000000000000000000;;	// +build cgo,linux
41618e7d4557faa26dd3eeec24aad479ff6cb4ac;test/e2e/node_problem_detector.go[test/e2e/node_problem_detector.go][test/e2e_node/node_problem_detector_linux.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/api/v1/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("NodeProblemDetector", func() {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			pollInterval   = 1 * time.Second
0000000000000000000000000000000000000000;;			pollConsistent = 5 * time.Second
0000000000000000000000000000000000000000;;			pollTimeout    = 1 * time.Minute
0000000000000000000000000000000000000000;;			image          = "gcr.io/google_containers/node-problem-detector:v0.4.1"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("node-problem-detector")
0000000000000000000000000000000000000000;;		var c clientset.Interface
0000000000000000000000000000000000000000;;		var uid string
0000000000000000000000000000000000000000;;		var ns, name, configName, eventNamespace string
0000000000000000000000000000000000000000;;		var bootTime, nodeTime time.Time
0000000000000000000000000000000000000000;;		BeforeEach(func() {
0000000000000000000000000000000000000000;;			c = f.ClientSet
0000000000000000000000000000000000000000;;			ns = f.Namespace.Name
0000000000000000000000000000000000000000;;			uid = string(uuid.NewUUID())
0000000000000000000000000000000000000000;;			name = "node-problem-detector-" + uid
0000000000000000000000000000000000000000;;			configName = "node-problem-detector-config-" + uid
0000000000000000000000000000000000000000;;			// There is no namespace for Node, event recorder will set default namespace for node events.
0000000000000000000000000000000000000000;;			eventNamespace = metav1.NamespaceDefault
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test system log monitor. We may add other tests if we have more problem daemons in the future.
0000000000000000000000000000000000000000;;		framework.KubeDescribe("SystemLogMonitor", func() {
0000000000000000000000000000000000000000;;			const (
0000000000000000000000000000000000000000;;				// Use test condition to avoid changing the real node condition in use.
0000000000000000000000000000000000000000;;				// TODO(random-liu): Now node condition could be arbitrary string, consider wether we need to
0000000000000000000000000000000000000000;;				// add TestCondition when switching to predefined condition list.
0000000000000000000000000000000000000000;;				condition = v1.NodeConditionType("TestCondition")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// File paths used in the test.
0000000000000000000000000000000000000000;;				logFile      = "/log/test.log"
0000000000000000000000000000000000000000;;				configFile   = "/config/testconfig.json"
0000000000000000000000000000000000000000;;				etcLocaltime = "/etc/localtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Volumes used in the test.
0000000000000000000000000000000000000000;;				configVolume    = "config"
0000000000000000000000000000000000000000;;				logVolume       = "log"
0000000000000000000000000000000000000000;;				localtimeVolume = "localtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Reasons and messages used in the test.
0000000000000000000000000000000000000000;;				defaultReason  = "Default"
0000000000000000000000000000000000000000;;				defaultMessage = "default message"
0000000000000000000000000000000000000000;;				tempReason     = "Temporary"
0000000000000000000000000000000000000000;;				tempMessage    = "temporary error"
0000000000000000000000000000000000000000;;				permReason1    = "Permanent1"
0000000000000000000000000000000000000000;;				permMessage1   = "permanent error 1"
0000000000000000000000000000000000000000;;				permReason2    = "Permanent2"
0000000000000000000000000000000000000000;;				permMessage2   = "permanent error 2"
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			var source, config, hostLogFile string
0000000000000000000000000000000000000000;;			var lookback time.Duration
0000000000000000000000000000000000000000;;			var eventListOptions metav1.ListOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			BeforeEach(func() {
0000000000000000000000000000000000000000;;				By("Calculate Lookback duration")
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				nodeTime, bootTime, err = getNodeTime()
0000000000000000000000000000000000000000;;				Expect(err).To(BeNil())
0000000000000000000000000000000000000000;;				// Set lookback duration longer than node up time.
0000000000000000000000000000000000000000;;				// Assume the test won't take more than 1 hour, in fact it usually only takes 90 seconds.
0000000000000000000000000000000000000000;;				lookback = nodeTime.Sub(bootTime) + time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Randomize the source name
0000000000000000000000000000000000000000;;				source = "kernel-monitor-" + uid
0000000000000000000000000000000000000000;;				config = `
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					"plugin": "filelog",
0000000000000000000000000000000000000000;;					"pluginConfig": {
0000000000000000000000000000000000000000;;						"timestamp": "^.{15}",
0000000000000000000000000000000000000000;;						"message": "kernel: \\[.*\\] (.*)",
0000000000000000000000000000000000000000;;						"timestampFormat": "` + time.Stamp + `"
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"logPath": "` + logFile + `",
0000000000000000000000000000000000000000;;					"lookback": "` + lookback.String() + `",
0000000000000000000000000000000000000000;;					"bufferSize": 10,
0000000000000000000000000000000000000000;;					"source": "` + source + `",
0000000000000000000000000000000000000000;;					"conditions": [
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"type": "` + string(condition) + `",
0000000000000000000000000000000000000000;;						"reason": "` + defaultReason + `",
0000000000000000000000000000000000000000;;						"message": "` + defaultMessage + `"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					],
0000000000000000000000000000000000000000;;					"rules": [
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"type": "temporary",
0000000000000000000000000000000000000000;;						"reason": "` + tempReason + `",
0000000000000000000000000000000000000000;;						"pattern": "` + tempMessage + `"
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"type": "permanent",
0000000000000000000000000000000000000000;;						"condition": "` + string(condition) + `",
0000000000000000000000000000000000000000;;						"reason": "` + permReason1 + `",
0000000000000000000000000000000000000000;;						"pattern": "` + permMessage1 + ".*" + `"
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"type": "permanent",
0000000000000000000000000000000000000000;;						"condition": "` + string(condition) + `",
0000000000000000000000000000000000000000;;						"reason": "` + permReason2 + `",
0000000000000000000000000000000000000000;;						"pattern": "` + permMessage2 + ".*" + `"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					]
0000000000000000000000000000000000000000;;				}`
0000000000000000000000000000000000000000;;				By("Generate event list options")
0000000000000000000000000000000000000000;;				selector := fields.Set{
0000000000000000000000000000000000000000;;					"involvedObject.kind":      "Node",
0000000000000000000000000000000000000000;;					"involvedObject.name":      framework.TestContext.NodeName,
0000000000000000000000000000000000000000;;					"involvedObject.namespace": metav1.NamespaceAll,
0000000000000000000000000000000000000000;;					"source":                   source,
0000000000000000000000000000000000000000;;				}.AsSelector().String()
0000000000000000000000000000000000000000;;				eventListOptions = metav1.ListOptions{FieldSelector: selector}
0000000000000000000000000000000000000000;;				By("Create the test log file")
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				By("Create config map for the node problem detector")
0000000000000000000000000000000000000000;;				_, err = c.Core().ConfigMaps(ns).Create(&v1.ConfigMap{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: configName},
0000000000000000000000000000000000000000;;					Data:       map[string]string{path.Base(configFile): config},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				By("Create the node problem detector")
0000000000000000000000000000000000000000;;				f.PodClient().CreateSync(&v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name: name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						HostNetwork:     true,
0000000000000000000000000000000000000000;;						SecurityContext: &v1.PodSecurityContext{},
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: configVolume,
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									ConfigMap: &v1.ConfigMapVolumeSource{
0000000000000000000000000000000000000000;;										LocalObjectReference: v1.LocalObjectReference{Name: configName},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: logVolume,
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: localtimeVolume,
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									HostPath: &v1.HostPathVolumeSource{Path: etcLocaltime},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    name,
0000000000000000000000000000000000000000;;								Image:   image,
0000000000000000000000000000000000000000;;								Command: []string{"sh", "-c", "touch " + logFile + " && /node-problem-detector --logtostderr --system-log-monitors=" + configFile + fmt.Sprintf(" --apiserver-override=%s?inClusterConfig=false", framework.TestContext.Host)},
0000000000000000000000000000000000000000;;								Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name: "NODE_NAME",
0000000000000000000000000000000000000000;;										ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;											FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;												APIVersion: "v1",
0000000000000000000000000000000000000000;;												FieldPath:  "spec.nodeName",
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      logVolume,
0000000000000000000000000000000000000000;;										MountPath: path.Dir(logFile),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      localtimeVolume,
0000000000000000000000000000000000000000;;										MountPath: etcLocaltime,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      configVolume,
0000000000000000000000000000000000000000;;										MountPath: path.Dir(configFile),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				pod, err := f.PodClient().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;				// TODO: remove hardcoded kubelet volume directory path
0000000000000000000000000000000000000000;;				// framework.TestContext.KubeVolumeDir is currently not populated for node e2e
0000000000000000000000000000000000000000;;				hostLogFile = "/var/lib/kubelet/pods/" + string(pod.UID) + "/volumes/kubernetes.io~empty-dir" + logFile
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			It("should generate node condition and events for corresponding errors", func() {
0000000000000000000000000000000000000000;;				for _, test := range []struct {
0000000000000000000000000000000000000000;;					description      string
0000000000000000000000000000000000000000;;					timestamp        time.Time
0000000000000000000000000000000000000000;;					message          string
0000000000000000000000000000000000000000;;					messageNum       int
0000000000000000000000000000000000000000;;					events           int
0000000000000000000000000000000000000000;;					conditionReason  string
0000000000000000000000000000000000000000;;					conditionMessage string
0000000000000000000000000000000000000000;;					conditionType    v1.ConditionStatus
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description:      "should generate default node condition",
0000000000000000000000000000000000000000;;						conditionReason:  defaultReason,
0000000000000000000000000000000000000000;;						conditionMessage: defaultMessage,
0000000000000000000000000000000000000000;;						conditionType:    v1.ConditionFalse,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description:      "should not generate events for too old log",
0000000000000000000000000000000000000000;;						timestamp:        bootTime.Add(-1 * time.Minute),
0000000000000000000000000000000000000000;;						message:          tempMessage,
0000000000000000000000000000000000000000;;						messageNum:       3,
0000000000000000000000000000000000000000;;						conditionReason:  defaultReason,
0000000000000000000000000000000000000000;;						conditionMessage: defaultMessage,
0000000000000000000000000000000000000000;;						conditionType:    v1.ConditionFalse,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description:      "should not change node condition for too old log",
0000000000000000000000000000000000000000;;						timestamp:        bootTime.Add(-1 * time.Minute),
0000000000000000000000000000000000000000;;						message:          permMessage1,
0000000000000000000000000000000000000000;;						messageNum:       1,
0000000000000000000000000000000000000000;;						conditionReason:  defaultReason,
0000000000000000000000000000000000000000;;						conditionMessage: defaultMessage,
0000000000000000000000000000000000000000;;						conditionType:    v1.ConditionFalse,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description:      "should generate event for old log within lookback duration",
0000000000000000000000000000000000000000;;						timestamp:        nodeTime,
0000000000000000000000000000000000000000;;						message:          tempMessage,
0000000000000000000000000000000000000000;;						messageNum:       3,
0000000000000000000000000000000000000000;;						events:           3,
0000000000000000000000000000000000000000;;						conditionReason:  defaultReason,
0000000000000000000000000000000000000000;;						conditionMessage: defaultMessage,
0000000000000000000000000000000000000000;;						conditionType:    v1.ConditionFalse,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description:      "should change node condition for old log within lookback duration",
0000000000000000000000000000000000000000;;						timestamp:        nodeTime,
0000000000000000000000000000000000000000;;						message:          permMessage1,
0000000000000000000000000000000000000000;;						messageNum:       1,
0000000000000000000000000000000000000000;;						events:           3, // event number should not change
0000000000000000000000000000000000000000;;						conditionReason:  permReason1,
0000000000000000000000000000000000000000;;						conditionMessage: permMessage1,
0000000000000000000000000000000000000000;;						conditionType:    v1.ConditionTrue,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description:      "should generate event for new log",
0000000000000000000000000000000000000000;;						timestamp:        nodeTime.Add(5 * time.Minute),
0000000000000000000000000000000000000000;;						message:          tempMessage,
0000000000000000000000000000000000000000;;						messageNum:       3,
0000000000000000000000000000000000000000;;						events:           6,
0000000000000000000000000000000000000000;;						conditionReason:  permReason1,
0000000000000000000000000000000000000000;;						conditionMessage: permMessage1,
0000000000000000000000000000000000000000;;						conditionType:    v1.ConditionTrue,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description:      "should not update node condition with the same reason",
0000000000000000000000000000000000000000;;						timestamp:        nodeTime.Add(5 * time.Minute),
0000000000000000000000000000000000000000;;						message:          permMessage1 + "different message",
0000000000000000000000000000000000000000;;						messageNum:       1,
0000000000000000000000000000000000000000;;						events:           6, // event number should not change
0000000000000000000000000000000000000000;;						conditionReason:  permReason1,
0000000000000000000000000000000000000000;;						conditionMessage: permMessage1,
0000000000000000000000000000000000000000;;						conditionType:    v1.ConditionTrue,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						description:      "should change node condition for new log",
0000000000000000000000000000000000000000;;						timestamp:        nodeTime.Add(5 * time.Minute),
0000000000000000000000000000000000000000;;						message:          permMessage2,
0000000000000000000000000000000000000000;;						messageNum:       1,
0000000000000000000000000000000000000000;;						events:           6, // event number should not change
0000000000000000000000000000000000000000;;						conditionReason:  permReason2,
0000000000000000000000000000000000000000;;						conditionMessage: permMessage2,
0000000000000000000000000000000000000000;;						conditionType:    v1.ConditionTrue,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				} {
0000000000000000000000000000000000000000;;					By(test.description)
0000000000000000000000000000000000000000;;					if test.messageNum > 0 {
0000000000000000000000000000000000000000;;						By(fmt.Sprintf("Inject %d logs: %q", test.messageNum, test.message))
0000000000000000000000000000000000000000;;						err := injectLog(hostLogFile, test.timestamp, test.message, test.messageNum)
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Wait for %d events generated", test.events))
0000000000000000000000000000000000000000;;					Eventually(func() error {
0000000000000000000000000000000000000000;;						return verifyEvents(c.Core().Events(eventNamespace), eventListOptions, test.events, tempReason, tempMessage)
0000000000000000000000000000000000000000;;					}, pollTimeout, pollInterval).Should(Succeed())
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Make sure only %d events generated", test.events))
0000000000000000000000000000000000000000;;					Consistently(func() error {
0000000000000000000000000000000000000000;;						return verifyEvents(c.Core().Events(eventNamespace), eventListOptions, test.events, tempReason, tempMessage)
0000000000000000000000000000000000000000;;					}, pollConsistent, pollInterval).Should(Succeed())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Make sure node condition %q is set", condition))
0000000000000000000000000000000000000000;;					Eventually(func() error {
0000000000000000000000000000000000000000;;						return verifyNodeCondition(c.Core().Nodes(), condition, test.conditionType, test.conditionReason, test.conditionMessage)
0000000000000000000000000000000000000000;;					}, pollTimeout, pollInterval).Should(Succeed())
0000000000000000000000000000000000000000;;					By(fmt.Sprintf("Make sure node condition %q is stable", condition))
0000000000000000000000000000000000000000;;					Consistently(func() error {
0000000000000000000000000000000000000000;;						return verifyNodeCondition(c.Core().Nodes(), condition, test.conditionType, test.conditionReason, test.conditionMessage)
0000000000000000000000000000000000000000;;					}, pollConsistent, pollInterval).Should(Succeed())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				if CurrentGinkgoTestDescription().Failed && framework.TestContext.DumpLogsOnFailure {
0000000000000000000000000000000000000000;;					By("Get node problem detector log")
0000000000000000000000000000000000000000;;					log, err := framework.GetPodLogs(c, ns, name, name)
0000000000000000000000000000000000000000;;					Expect(err).ShouldNot(HaveOccurred())
0000000000000000000000000000000000000000;;					framework.Logf("Node Problem Detector logs:\n %s", log)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("Delete the node problem detector")
0000000000000000000000000000000000000000;;				f.PodClient().Delete(name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;				By("Wait for the node problem detector to disappear")
0000000000000000000000000000000000000000;;				Expect(framework.WaitForPodToDisappear(c, ns, name, labels.Everything(), pollInterval, pollTimeout)).To(Succeed())
0000000000000000000000000000000000000000;;				By("Delete the config map")
0000000000000000000000000000000000000000;;				c.Core().ConfigMaps(ns).Delete(configName, nil)
0000000000000000000000000000000000000000;;				By("Clean up the events")
0000000000000000000000000000000000000000;;				Expect(c.Core().Events(eventNamespace).DeleteCollection(metav1.NewDeleteOptions(0), eventListOptions)).To(Succeed())
0000000000000000000000000000000000000000;;				By("Clean up the node condition")
0000000000000000000000000000000000000000;;				patch := []byte(fmt.Sprintf(`{"status":{"conditions":[{"$patch":"delete","type":"%s"}]}}`, condition))
0000000000000000000000000000000000000000;;				c.Core().RESTClient().Patch(types.StrategicMergePatchType).Resource("nodes").Name(framework.TestContext.NodeName).SubResource("status").Body(patch).Do()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// injectLog injects kernel log into specified file.
0000000000000000000000000000000000000000;;	func injectLog(file string, timestamp time.Time, log string, num int) error {
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(file, os.O_RDWR|os.O_APPEND, 0666)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		for i := 0; i < num; i++ {
0000000000000000000000000000000000000000;;			_, err := f.WriteString(fmt.Sprintf("%s kernel: [0.000000] %s\n", timestamp.Format(time.Stamp), log))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNodeTime gets node boot time and current time.
0000000000000000000000000000000000000000;;	func getNodeTime() (time.Time, time.Time, error) {
0000000000000000000000000000000000000000;;		// Get node current time.
0000000000000000000000000000000000000000;;		nodeTime := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get system uptime.
0000000000000000000000000000000000000000;;		var info syscall.Sysinfo_t
0000000000000000000000000000000000000000;;		if err := syscall.Sysinfo(&info); err != nil {
0000000000000000000000000000000000000000;;			return time.Time{}, time.Time{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get node boot time. NOTE that because we get node current time before uptime, the boot time
0000000000000000000000000000000000000000;;		// calculated will be a little earlier than the real boot time. This won't affect the correctness
0000000000000000000000000000000000000000;;		// of the test result.
0000000000000000000000000000000000000000;;		bootTime := nodeTime.Add(-time.Duration(info.Uptime) * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodeTime, bootTime, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyEvents verifies there are num specific events generated
0000000000000000000000000000000000000000;;	func verifyEvents(e coreclientset.EventInterface, options metav1.ListOptions, num int, reason, message string) error {
0000000000000000000000000000000000000000;;		events, err := e.List(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for _, event := range events.Items {
0000000000000000000000000000000000000000;;			if event.Reason != reason || event.Message != message {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unexpected event: %v", event)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count += int(event.Count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count != num {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expect event number %d, got %d: %v", num, count, events.Items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyNoEvents verifies there is no event generated
0000000000000000000000000000000000000000;;	func verifyNoEvents(e coreclientset.EventInterface, options metav1.ListOptions) error {
0000000000000000000000000000000000000000;;		events, err := e.List(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(events.Items) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected events: %v", events.Items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyNodeCondition verifies specific node condition is generated, if reason and message are empty, they will not be checked
0000000000000000000000000000000000000000;;	func verifyNodeCondition(n coreclientset.NodeInterface, condition v1.NodeConditionType, status v1.ConditionStatus, reason, message string) error {
0000000000000000000000000000000000000000;;		node, err := n.Get(framework.TestContext.NodeName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, c := nodeutil.GetNodeCondition(&node.Status, condition)
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("node condition %q not found", condition)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Status != status || c.Reason != reason || c.Message != message {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected node condition %q: %+v", condition, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
