0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
598a71848abbb0edf9d11de1edbe46c08c2ab967;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		stats "k8s.io/kubernetes/pkg/kubelet/apis/stats/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		systemdutil "github.com/coreos/go-systemd/util"
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/gstruct"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Summary API", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("summary-test")
0000000000000000000000000000000000000000;;		Context("when querying /stats/summary", func() {
0000000000000000000000000000000000000000;;			AfterEach(func() {
0000000000000000000000000000000000000000;;				if !CurrentGinkgoTestDescription().Failed {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if framework.TestContext.DumpLogsOnFailure {
0000000000000000000000000000000000000000;;					framework.LogFailedContainers(f.ClientSet, f.Namespace.Name, framework.Logf)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				By("Recording processes in system cgroups")
0000000000000000000000000000000000000000;;				recordSystemCgroupProcesses()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			It("should report resource usage through the stats api", func() {
0000000000000000000000000000000000000000;;				const pod0 = "stats-busybox-0"
0000000000000000000000000000000000000000;;				const pod1 = "stats-busybox-1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Creating test pods")
0000000000000000000000000000000000000000;;				numRestarts := int32(1)
0000000000000000000000000000000000000000;;				pods := getSummaryTestPods(f, numRestarts, pod0, pod1)
0000000000000000000000000000000000000000;;				f.PodClient().CreateBatch(pods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Eventually(func() error {
0000000000000000000000000000000000000000;;					for _, pod := range pods {
0000000000000000000000000000000000000000;;						err := verifyPodRestartCount(f, pod.Name, len(pod.Spec.Containers), numRestarts)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}, time.Minute, 5*time.Second).Should(BeNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Wait for cAdvisor to collect 2 stats points
0000000000000000000000000000000000000000;;				time.Sleep(15 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Setup expectations.
0000000000000000000000000000000000000000;;				const (
0000000000000000000000000000000000000000;;					kb int64 = 1000
0000000000000000000000000000000000000000;;					mb int64 = 1000 * kb
0000000000000000000000000000000000000000;;					gb int64 = 1000 * mb
0000000000000000000000000000000000000000;;					tb int64 = 1000 * gb
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					maxStartAge = time.Hour * 24 * 365 // 1 year
0000000000000000000000000000000000000000;;					maxStatsAge = time.Minute
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				fsCapacityBounds := bounded(100*mb, 100*gb)
0000000000000000000000000000000000000000;;				// Expectations for system containers.
0000000000000000000000000000000000000000;;				sysContExpectations := func() types.GomegaMatcher {
0000000000000000000000000000000000000000;;					return gstruct.MatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;						"Name":      gstruct.Ignore(),
0000000000000000000000000000000000000000;;						"StartTime": recent(maxStartAge),
0000000000000000000000000000000000000000;;						"CPU": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"Time":                 recent(maxStatsAge),
0000000000000000000000000000000000000000;;							"UsageNanoCores":       bounded(10000, 2E9),
0000000000000000000000000000000000000000;;							"UsageCoreNanoSeconds": bounded(10000000, 1E15),
0000000000000000000000000000000000000000;;						}),
0000000000000000000000000000000000000000;;						"Memory": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"Time": recent(maxStatsAge),
0000000000000000000000000000000000000000;;							// We don't limit system container memory.
0000000000000000000000000000000000000000;;							"AvailableBytes":  BeNil(),
0000000000000000000000000000000000000000;;							"UsageBytes":      bounded(1*mb, 10*gb),
0000000000000000000000000000000000000000;;							"WorkingSetBytes": bounded(1*mb, 10*gb),
0000000000000000000000000000000000000000;;							// today, this returns the value reported
0000000000000000000000000000000000000000;;							// in /sys/fs/cgroup/memory.stat for rss
0000000000000000000000000000000000000000;;							// this value should really return /sys/fs/cgroup/memory.stat total_rss
0000000000000000000000000000000000000000;;							// as we really want the hierarchical value not the usage local to / cgroup.
0000000000000000000000000000000000000000;;							// for now, i am updating the bounding box to the value as coded, but the
0000000000000000000000000000000000000000;;							// value reported needs to change.
0000000000000000000000000000000000000000;;							// rss only makes sense if you are leaf cgroup
0000000000000000000000000000000000000000;;							"RSSBytes":        bounded(0, 1*gb),
0000000000000000000000000000000000000000;;							"PageFaults":      bounded(1000, 1E9),
0000000000000000000000000000000000000000;;							"MajorPageFaults": bounded(0, 100000),
0000000000000000000000000000000000000000;;						}),
0000000000000000000000000000000000000000;;						"Rootfs":             BeNil(),
0000000000000000000000000000000000000000;;						"Logs":               BeNil(),
0000000000000000000000000000000000000000;;						"UserDefinedMetrics": BeEmpty(),
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				systemContainers := gstruct.Elements{
0000000000000000000000000000000000000000;;					"kubelet": sysContExpectations(),
0000000000000000000000000000000000000000;;					"runtime": sysContExpectations(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// The Kubelet only manages the 'misc' system container if the host is not running systemd.
0000000000000000000000000000000000000000;;				if !systemdutil.IsRunningSystemd() {
0000000000000000000000000000000000000000;;					framework.Logf("Host not running systemd; expecting 'misc' system container.")
0000000000000000000000000000000000000000;;					miscContExpectations := sysContExpectations().(*gstruct.FieldsMatcher)
0000000000000000000000000000000000000000;;					// Misc processes are system-dependent, so relax the memory constraints.
0000000000000000000000000000000000000000;;					miscContExpectations.Fields["Memory"] = ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;						"Time": recent(maxStatsAge),
0000000000000000000000000000000000000000;;						// We don't limit system container memory.
0000000000000000000000000000000000000000;;						"AvailableBytes":  BeNil(),
0000000000000000000000000000000000000000;;						"UsageBytes":      bounded(100*kb, 10*gb),
0000000000000000000000000000000000000000;;						"WorkingSetBytes": bounded(100*kb, 10*gb),
0000000000000000000000000000000000000000;;						"RSSBytes":        bounded(100*kb, 1*gb),
0000000000000000000000000000000000000000;;						"PageFaults":      bounded(1000, 1E9),
0000000000000000000000000000000000000000;;						"MajorPageFaults": bounded(0, 100000),
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					systemContainers["misc"] = miscContExpectations
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Expectations for pods.
0000000000000000000000000000000000000000;;				podExpectations := gstruct.MatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;					"PodRef":    gstruct.Ignore(),
0000000000000000000000000000000000000000;;					"StartTime": recent(maxStartAge),
0000000000000000000000000000000000000000;;					"Containers": gstruct.MatchAllElements(summaryObjectID, gstruct.Elements{
0000000000000000000000000000000000000000;;						"busybox-container": gstruct.MatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"Name":      Equal("busybox-container"),
0000000000000000000000000000000000000000;;							"StartTime": recent(maxStartAge),
0000000000000000000000000000000000000000;;							"CPU": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;								"Time":                 recent(maxStatsAge),
0000000000000000000000000000000000000000;;								"UsageNanoCores":       bounded(100000, 1E9),
0000000000000000000000000000000000000000;;								"UsageCoreNanoSeconds": bounded(10000000, 1E11),
0000000000000000000000000000000000000000;;							}),
0000000000000000000000000000000000000000;;							"Memory": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;								"Time":            recent(maxStatsAge),
0000000000000000000000000000000000000000;;								"AvailableBytes":  bounded(10*kb, 10*mb),
0000000000000000000000000000000000000000;;								"UsageBytes":      bounded(10*kb, 20*mb),
0000000000000000000000000000000000000000;;								"WorkingSetBytes": bounded(10*kb, 20*mb),
0000000000000000000000000000000000000000;;								"RSSBytes":        bounded(1*kb, mb),
0000000000000000000000000000000000000000;;								"PageFaults":      bounded(100, 1000000),
0000000000000000000000000000000000000000;;								"MajorPageFaults": bounded(0, 10),
0000000000000000000000000000000000000000;;							}),
0000000000000000000000000000000000000000;;							"Rootfs": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;								"Time":           recent(maxStatsAge),
0000000000000000000000000000000000000000;;								"AvailableBytes": fsCapacityBounds,
0000000000000000000000000000000000000000;;								"CapacityBytes":  fsCapacityBounds,
0000000000000000000000000000000000000000;;								"UsedBytes":      bounded(kb, 10*mb),
0000000000000000000000000000000000000000;;								"InodesFree":     bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;								"Inodes":         bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;								"InodesUsed":     bounded(0, 1E8),
0000000000000000000000000000000000000000;;							}),
0000000000000000000000000000000000000000;;							"Logs": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;								"Time":           recent(maxStatsAge),
0000000000000000000000000000000000000000;;								"AvailableBytes": fsCapacityBounds,
0000000000000000000000000000000000000000;;								"CapacityBytes":  fsCapacityBounds,
0000000000000000000000000000000000000000;;								"UsedBytes":      bounded(kb, 10*mb),
0000000000000000000000000000000000000000;;								"InodesFree":     bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;								"Inodes":         bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;								"InodesUsed":     bounded(0, 1E8),
0000000000000000000000000000000000000000;;							}),
0000000000000000000000000000000000000000;;							"UserDefinedMetrics": BeEmpty(),
0000000000000000000000000000000000000000;;						}),
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					"Network": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;						"Time":     recent(maxStatsAge),
0000000000000000000000000000000000000000;;						"RxBytes":  bounded(10, 10*mb),
0000000000000000000000000000000000000000;;						"RxErrors": bounded(0, 1000),
0000000000000000000000000000000000000000;;						"TxBytes":  bounded(10, 10*mb),
0000000000000000000000000000000000000000;;						"TxErrors": bounded(0, 1000),
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					"VolumeStats": gstruct.MatchAllElements(summaryObjectID, gstruct.Elements{
0000000000000000000000000000000000000000;;						"test-empty-dir": gstruct.MatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"Name": Equal("test-empty-dir"),
0000000000000000000000000000000000000000;;							"FsStats": gstruct.MatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;								"Time":           recent(maxStatsAge),
0000000000000000000000000000000000000000;;								"AvailableBytes": fsCapacityBounds,
0000000000000000000000000000000000000000;;								"CapacityBytes":  fsCapacityBounds,
0000000000000000000000000000000000000000;;								"UsedBytes":      bounded(kb, 1*mb),
0000000000000000000000000000000000000000;;								"InodesFree":     bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;								"Inodes":         bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;								"InodesUsed":     bounded(0, 1E8),
0000000000000000000000000000000000000000;;							}),
0000000000000000000000000000000000000000;;						}),
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				matchExpectations := ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;					"Node": gstruct.MatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;						"NodeName":         Equal(framework.TestContext.NodeName),
0000000000000000000000000000000000000000;;						"StartTime":        recent(maxStartAge),
0000000000000000000000000000000000000000;;						"SystemContainers": gstruct.MatchAllElements(summaryObjectID, systemContainers),
0000000000000000000000000000000000000000;;						"CPU": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"Time":                 recent(maxStatsAge),
0000000000000000000000000000000000000000;;							"UsageNanoCores":       bounded(100E3, 2E9),
0000000000000000000000000000000000000000;;							"UsageCoreNanoSeconds": bounded(1E9, 1E15),
0000000000000000000000000000000000000000;;						}),
0000000000000000000000000000000000000000;;						"Memory": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"Time":            recent(maxStatsAge),
0000000000000000000000000000000000000000;;							"AvailableBytes":  bounded(100*mb, 100*gb),
0000000000000000000000000000000000000000;;							"UsageBytes":      bounded(10*mb, 10*gb),
0000000000000000000000000000000000000000;;							"WorkingSetBytes": bounded(10*mb, 10*gb),
0000000000000000000000000000000000000000;;							// today, this returns the value reported
0000000000000000000000000000000000000000;;							// in /sys/fs/cgroup/memory.stat for rss
0000000000000000000000000000000000000000;;							// this value should really return /sys/fs/cgroup/memory.stat total_rss
0000000000000000000000000000000000000000;;							// as we really want the hierarchical value not the usage local to / cgroup.
0000000000000000000000000000000000000000;;							// for now, i am updating the bounding box to the value as coded, but the
0000000000000000000000000000000000000000;;							// value reported needs to change.
0000000000000000000000000000000000000000;;							// rss only makes sense if you are leaf cgroup
0000000000000000000000000000000000000000;;							"RSSBytes":        bounded(0, 1*gb),
0000000000000000000000000000000000000000;;							"PageFaults":      bounded(1000, 1E9),
0000000000000000000000000000000000000000;;							"MajorPageFaults": bounded(0, 100000),
0000000000000000000000000000000000000000;;						}),
0000000000000000000000000000000000000000;;						// TODO(#28407): Handle non-eth0 network interface names.
0000000000000000000000000000000000000000;;						"Network": Or(BeNil(), ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"Time":     recent(maxStatsAge),
0000000000000000000000000000000000000000;;							"RxBytes":  bounded(1*mb, 100*gb),
0000000000000000000000000000000000000000;;							"RxErrors": bounded(0, 100000),
0000000000000000000000000000000000000000;;							"TxBytes":  bounded(10*kb, 10*gb),
0000000000000000000000000000000000000000;;							"TxErrors": bounded(0, 100000),
0000000000000000000000000000000000000000;;						})),
0000000000000000000000000000000000000000;;						"Fs": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"Time":           recent(maxStatsAge),
0000000000000000000000000000000000000000;;							"AvailableBytes": fsCapacityBounds,
0000000000000000000000000000000000000000;;							"CapacityBytes":  fsCapacityBounds,
0000000000000000000000000000000000000000;;							// we assume we are not running tests on machines < 10tb of disk
0000000000000000000000000000000000000000;;							"UsedBytes":  bounded(kb, 10*tb),
0000000000000000000000000000000000000000;;							"InodesFree": bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;							"Inodes":     bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;							"InodesUsed": bounded(0, 1E8),
0000000000000000000000000000000000000000;;						}),
0000000000000000000000000000000000000000;;						"Runtime": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;							"ImageFs": ptrMatchAllFields(gstruct.Fields{
0000000000000000000000000000000000000000;;								"Time":           recent(maxStatsAge),
0000000000000000000000000000000000000000;;								"AvailableBytes": fsCapacityBounds,
0000000000000000000000000000000000000000;;								"CapacityBytes":  fsCapacityBounds,
0000000000000000000000000000000000000000;;								// we assume we are not running tests on machines < 10tb of disk
0000000000000000000000000000000000000000;;								"UsedBytes":  bounded(kb, 10*tb),
0000000000000000000000000000000000000000;;								"InodesFree": bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;								"Inodes":     bounded(1E4, 1E8),
0000000000000000000000000000000000000000;;								"InodesUsed": bounded(0, 1E8),
0000000000000000000000000000000000000000;;							}),
0000000000000000000000000000000000000000;;						}),
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					// Ignore extra pods since the tests run in parallel.
0000000000000000000000000000000000000000;;					"Pods": gstruct.MatchElements(summaryObjectID, gstruct.IgnoreExtras, gstruct.Elements{
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s::%s", f.Namespace.Name, pod0): podExpectations,
0000000000000000000000000000000000000000;;						fmt.Sprintf("%s::%s", f.Namespace.Name, pod1): podExpectations,
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				By("Validating /stats/summary")
0000000000000000000000000000000000000000;;				// Give pods a minute to actually start up.
0000000000000000000000000000000000000000;;				Eventually(getNodeSummary, 1*time.Minute, 15*time.Second).Should(matchExpectations)
0000000000000000000000000000000000000000;;				// Then the summary should match the expectations a few more times.
0000000000000000000000000000000000000000;;				Consistently(getNodeSummary, 30*time.Second, 15*time.Second).Should(matchExpectations)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSummaryTestPods(f *framework.Framework, numRestarts int32, names ...string) []*v1.Pod {
0000000000000000000000000000000000000000;;		pods := make([]*v1.Pod, 0, len(names))
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			pods = append(pods, &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name: name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;					RestartPolicy: v1.RestartPolicyAlways,
0000000000000000000000000000000000000000;;					Containers: []v1.Container{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Name:    "busybox-container",
0000000000000000000000000000000000000000;;							Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;							Command: getRestartingContainerCommand("/test-empty-dir-mnt", 0, numRestarts, "ping -c 1 google.com; echo 'hello world' >> /test-empty-dir-mnt/file;"),
0000000000000000000000000000000000000000;;							Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;								Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;									// Must set memory limit to get MemoryStats.AvailableBytes
0000000000000000000000000000000000000000;;									v1.ResourceMemory: resource.MustParse("10M"),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;								{MountPath: "/test-empty-dir-mnt", Name: "test-empty-dir"},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SecurityContext: &v1.PodSecurityContext{
0000000000000000000000000000000000000000;;						SELinuxOptions: &v1.SELinuxOptions{
0000000000000000000000000000000000000000;;							Level: "s0",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;						// TODO(#28393): Test secret volumes
0000000000000000000000000000000000000000;;						// TODO(#28394): Test hostpath volumes
0000000000000000000000000000000000000000;;						{Name: "test-empty-dir", VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{}}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mapping function for gstruct.MatchAllElements
0000000000000000000000000000000000000000;;	func summaryObjectID(element interface{}) string {
0000000000000000000000000000000000000000;;		switch el := element.(type) {
0000000000000000000000000000000000000000;;		case stats.PodStats:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s::%s", el.PodRef.Namespace, el.PodRef.Name)
0000000000000000000000000000000000000000;;		case stats.ContainerStats:
0000000000000000000000000000000000000000;;			return el.Name
0000000000000000000000000000000000000000;;		case stats.VolumeStats:
0000000000000000000000000000000000000000;;			return el.Name
0000000000000000000000000000000000000000;;		case stats.UserDefinedMetric:
0000000000000000000000000000000000000000;;			return el.Name
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			framework.Failf("Unknown type: %T", el)
0000000000000000000000000000000000000000;;			return "???"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convenience functions for common matcher combinations.
0000000000000000000000000000000000000000;;	func ptrMatchAllFields(fields gstruct.Fields) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return gstruct.PointTo(gstruct.MatchAllFields(fields))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bounded(lower, upper interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return gstruct.PointTo(And(
0000000000000000000000000000000000000000;;			BeNumerically(">=", lower),
0000000000000000000000000000000000000000;;			BeNumerically("<=", upper)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recent(d time.Duration) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return WithTransform(func(t metav1.Time) time.Time {
0000000000000000000000000000000000000000;;			return t.Time
0000000000000000000000000000000000000000;;		}, And(
0000000000000000000000000000000000000000;;			BeTemporally(">=", time.Now().Add(-d)),
0000000000000000000000000000000000000000;;			// Now() is the test start time, not the match time, so permit a few extra minutes.
0000000000000000000000000000000000000000;;			BeTemporally("<", time.Now().Add(2*time.Minute))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recordSystemCgroupProcesses() {
0000000000000000000000000000000000000000;;		cfg, err := getCurrentKubeletConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Failed to read kubelet config: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cgroups := map[string]string{
0000000000000000000000000000000000000000;;			"kubelet": cfg.KubeletCgroups,
0000000000000000000000000000000000000000;;			"runtime": cfg.RuntimeCgroups,
0000000000000000000000000000000000000000;;			"misc":    cfg.SystemCgroups,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, cgroup := range cgroups {
0000000000000000000000000000000000000000;;			if cgroup == "" {
0000000000000000000000000000000000000000;;				framework.Logf("Skipping unconfigured cgroup %s", name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pids, err := ioutil.ReadFile(fmt.Sprintf("/sys/fs/cgroup/cpu/%s/cgroup.procs", cgroup))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				framework.Logf("Failed to read processes in cgroup %s: %v", name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			framework.Logf("Processes in %s cgroup (%s):", name, cgroup)
0000000000000000000000000000000000000000;;			for _, pid := range strings.Fields(string(pids)) {
0000000000000000000000000000000000000000;;				path := fmt.Sprintf("/proc/%s/cmdline", pid)
0000000000000000000000000000000000000000;;				cmd, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					framework.Logf("  Failed to read %s: %v", path, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					framework.Logf("  %s", cmd)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
