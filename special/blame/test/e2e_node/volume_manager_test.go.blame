0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
432044e75489cdd8c3b0f5a1b8520bb6c031f570;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("Kubelet Volume Manager", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("kubelet-volume-manager")
0000000000000000000000000000000000000000;;		Describe("Volume Manager", func() {
0000000000000000000000000000000000000000;;			Context("On terminatation of pod with memory backed volume", func() {
0000000000000000000000000000000000000000;;				It("should remove the volume from the node", func() {
0000000000000000000000000000000000000000;;					var (
0000000000000000000000000000000000000000;;						memoryBackedPod *v1.Pod
0000000000000000000000000000000000000000;;						volumeName      string
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;					By("Creating a pod with a memory backed volume that exits success without restart", func() {
0000000000000000000000000000000000000000;;						volumeName = "memory-volume"
0000000000000000000000000000000000000000;;						memoryBackedPod = f.PodClient().Create(&v1.Pod{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Name:      "pod" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;								Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;								RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;								Containers: []v1.Container{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;										Name:    "container" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;										Command: []string{"sh", "-c", "echo"},
0000000000000000000000000000000000000000;;										VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;											{
0000000000000000000000000000000000000000;;												Name:      volumeName,
0000000000000000000000000000000000000000;;												MountPath: "/tmp",
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name: volumeName,
0000000000000000000000000000000000000000;;										VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;											EmptyDir: &v1.EmptyDirVolumeSource{Medium: v1.StorageMediumMemory},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;						err := framework.WaitForPodSuccessInNamespace(f.ClientSet, memoryBackedPod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					By("Verifying the memory backed volume was removed from node", func() {
0000000000000000000000000000000000000000;;						volumePath := fmt.Sprintf("/tmp/%s/volumes/kubernetes.io~empty-dir/%s", string(memoryBackedPod.UID), volumeName)
0000000000000000000000000000000000000000;;						var err error
0000000000000000000000000000000000000000;;						for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;							// need to create a new verification pod on each pass since updates
0000000000000000000000000000000000000000;;							//to the HostPath volume aren't propogated to the pod
0000000000000000000000000000000000000000;;							pod := f.PodClient().Create(&v1.Pod{
0000000000000000000000000000000000000000;;								ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;									Name:      "pod" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;									Namespace: f.Namespace.Name,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;									RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;									Containers: []v1.Container{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Image:   "gcr.io/google_containers/busybox:1.24",
0000000000000000000000000000000000000000;;											Name:    "container" + string(uuid.NewUUID()),
0000000000000000000000000000000000000000;;											Command: []string{"sh", "-c", "if [ -d " + volumePath + " ]; then exit 1; fi;"},
0000000000000000000000000000000000000000;;											VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;												{
0000000000000000000000000000000000000000;;													Name:      "kubelet-pods",
0000000000000000000000000000000000000000;;													MountPath: "/tmp",
0000000000000000000000000000000000000000;;												},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;										{
0000000000000000000000000000000000000000;;											Name: "kubelet-pods",
0000000000000000000000000000000000000000;;											VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;												// TODO: remove hardcoded kubelet volume directory path
0000000000000000000000000000000000000000;;												// framework.TestContext.KubeVolumeDir is currently not populated for node e2e
0000000000000000000000000000000000000000;;												HostPath: &v1.HostPathVolumeSource{Path: "/var/lib/kubelet/pods"},
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							})
0000000000000000000000000000000000000000;;							err = framework.WaitForPodSuccessInNamespace(f.ClientSet, pod.Name, f.Namespace.Name)
0000000000000000000000000000000000000000;;							gp := int64(1)
0000000000000000000000000000000000000000;;							f.PodClient().Delete(pod.Name, &metav1.DeleteOptions{GracePeriodSeconds: &gp})
0000000000000000000000000000000000000000;;							if err == nil {
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							<-time.After(10 * time.Second)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						Expect(err).NotTo(HaveOccurred())
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
