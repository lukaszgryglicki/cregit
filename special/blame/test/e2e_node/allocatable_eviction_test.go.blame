0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
23801c1d1496528a6d0c533c7c8123f1130939d9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package e2e_node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/api/v1/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/componentconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/cm"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/test/e2e/framework"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		. "github.com/onsi/ginkgo"
0000000000000000000000000000000000000000;;		. "github.com/onsi/gomega"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Eviction Policy is described here:
0000000000000000000000000000000000000000;;	// https://github.com/kubernetes/kubernetes/blob/master/docs/proposals/kubelet-eviction.md
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = framework.KubeDescribe("MemoryAllocatableEviction [Slow] [Serial] [Disruptive] [Flaky]", func() {
0000000000000000000000000000000000000000;;		f := framework.NewDefaultFramework("memory-allocatable-eviction-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podTestSpecs := []podTestSpec{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				evictionPriority: 1, // This pod should be evicted before the innocent pod
0000000000000000000000000000000000000000;;				pod:              getMemhogPod("memory-hog-pod", "memory-hog", v1.ResourceRequirements{}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				evictionPriority: 0, // This pod should never be evicted
0000000000000000000000000000000000000000;;				pod:              getInnocentPod(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		evictionTestTimeout := 10 * time.Minute
0000000000000000000000000000000000000000;;		testCondition := "Memory Pressure"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Context(fmt.Sprintf("when we run containers that should cause %s", testCondition), func() {
0000000000000000000000000000000000000000;;			tempSetCurrentKubeletConfig(f, func(initialConfig *componentconfig.KubeletConfiguration) {
0000000000000000000000000000000000000000;;				// Set large system and kube reserved values to trigger allocatable thresholds far before hard eviction thresholds.
0000000000000000000000000000000000000000;;				kubeReserved := getNodeCPUAndMemoryCapacity(f)[v1.ResourceMemory]
0000000000000000000000000000000000000000;;				// The default hard eviction threshold is 250Mb, so Allocatable = Capacity - Reserved - 250Mb
0000000000000000000000000000000000000000;;				// We want Allocatable = 50Mb, so set Reserved = Capacity - Allocatable - 250Mb = Capacity - 300Mb
0000000000000000000000000000000000000000;;				kubeReserved.Sub(resource.MustParse("300Mi"))
0000000000000000000000000000000000000000;;				initialConfig.KubeReserved = componentconfig.ConfigurationMap(map[string]string{"memory": kubeReserved.String()})
0000000000000000000000000000000000000000;;				initialConfig.EnforceNodeAllocatable = []string{cm.NodeAllocatableEnforcementKey}
0000000000000000000000000000000000000000;;				initialConfig.ExperimentalNodeAllocatableIgnoreEvictionThreshold = false
0000000000000000000000000000000000000000;;				initialConfig.CgroupsPerQOS = true
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			// Place the remainder of the test within a context so that the kubelet config is set before and after the test.
0000000000000000000000000000000000000000;;			Context("With kubeconfig updated", func() {
0000000000000000000000000000000000000000;;				runEvictionTest(f, testCondition, podTestSpecs, evictionTestTimeout, hasMemoryPressure)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns TRUE if the node has Memory Pressure, FALSE otherwise
0000000000000000000000000000000000000000;;	func hasMemoryPressure(f *framework.Framework, testCondition string) (bool, error) {
0000000000000000000000000000000000000000;;		localNodeStatus := getLocalNode(f).Status
0000000000000000000000000000000000000000;;		_, pressure := nodeutil.GetNodeCondition(&localNodeStatus, v1.NodeMemoryPressure)
0000000000000000000000000000000000000000;;		Expect(pressure).NotTo(BeNil())
0000000000000000000000000000000000000000;;		hasPressure := pressure.Status == v1.ConditionTrue
0000000000000000000000000000000000000000;;		By(fmt.Sprintf("checking if pod has %s: %v", testCondition, hasPressure))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Additional Logging relating to Memory
0000000000000000000000000000000000000000;;		summary, err := getNodeSummary()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if summary.Node.Memory != nil && summary.Node.Memory.WorkingSetBytes != nil && summary.Node.Memory.AvailableBytes != nil {
0000000000000000000000000000000000000000;;			framework.Logf("Node.Memory.WorkingSetBytes: %d, summary.Node.Memory.AvailableBytes: %d", *summary.Node.Memory.WorkingSetBytes, *summary.Node.Memory.AvailableBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range summary.Pods {
0000000000000000000000000000000000000000;;			framework.Logf("Pod: %s", pod.PodRef.Name)
0000000000000000000000000000000000000000;;			for _, container := range pod.Containers {
0000000000000000000000000000000000000000;;				if container.Memory != nil && container.Memory.WorkingSetBytes != nil {
0000000000000000000000000000000000000000;;					framework.Logf("--- summary Container: %s WorkingSetBytes: %d", container.Name, *container.Memory.WorkingSetBytes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hasPressure, nil
0000000000000000000000000000000000000000;;	}
