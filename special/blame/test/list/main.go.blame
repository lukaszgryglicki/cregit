0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8348cc447f54ffa72cc1bd618c5ca60528fda670;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// list all unit and ginkgo test names that will be run
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"go/parser"
0000000000000000000000000000000000000000;;		"go/token"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		dumpTree = flag.Bool("dump", false, "print AST")
0000000000000000000000000000000000000000;;		dumpJson = flag.Bool("json", false, "output test list as JSON")
0000000000000000000000000000000000000000;;		warn     = flag.Bool("warn", false, "print warnings")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Test struct {
0000000000000000000000000000000000000000;;		Loc      string
0000000000000000000000000000000000000000;;		Name     string
0000000000000000000000000000000000000000;;		TestName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// collect extracts test metadata from a file.
0000000000000000000000000000000000000000;;	// If src is nil, it reads filename for the code, otherwise it
0000000000000000000000000000000000000000;;	// uses src (which may be a string, byte[], or io.Reader).
0000000000000000000000000000000000000000;;	func collect(filename string, src interface{}) []Test {
0000000000000000000000000000000000000000;;		// Create the AST by parsing src.
0000000000000000000000000000000000000000;;		fset := token.NewFileSet() // positions are relative to fset
0000000000000000000000000000000000000000;;		f, err := parser.ParseFile(fset, filename, src, parser.ParseComments)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *dumpTree {
0000000000000000000000000000000000000000;;			ast.Print(fset, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := make([]Test, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ast.Walk(makeWalker("[k8s.io]", fset, &tests), f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unit tests are much simpler to enumerate!
0000000000000000000000000000000000000000;;		if strings.HasSuffix(filename, "_test.go") {
0000000000000000000000000000000000000000;;			packageName := f.Name.Name
0000000000000000000000000000000000000000;;			dirName, _ := filepath.Split(filename)
0000000000000000000000000000000000000000;;			if filepath.Base(dirName) != packageName && *warn {
0000000000000000000000000000000000000000;;				log.Printf("Warning: strange path/package mismatch %s %s\n", filename, packageName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			testPath := "k8s.io/kubernetes/" + dirName[:len(dirName)-1]
0000000000000000000000000000000000000000;;			for _, decl := range f.Decls {
0000000000000000000000000000000000000000;;				funcdecl, ok := decl.(*ast.FuncDecl)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				name := funcdecl.Name.Name
0000000000000000000000000000000000000000;;				if strings.HasPrefix(name, "Test") {
0000000000000000000000000000000000000000;;					tests = append(tests, Test{fset.Position(funcdecl.Pos()).String(), testPath, name})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tests
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// funcName converts a selectorExpr with two idents into a string,
0000000000000000000000000000000000000000;;	// x.y -> "x.y"
0000000000000000000000000000000000000000;;	func funcName(n ast.Expr) string {
0000000000000000000000000000000000000000;;		if sel, ok := n.(*ast.SelectorExpr); ok {
0000000000000000000000000000000000000000;;			if x, ok := sel.X.(*ast.Ident); ok {
0000000000000000000000000000000000000000;;				return x.String() + "." + sel.Sel.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSprintf returns whether the given node is a call to fmt.Sprintf
0000000000000000000000000000000000000000;;	func isSprintf(n ast.Expr) bool {
0000000000000000000000000000000000000000;;		call, ok := n.(*ast.CallExpr)
0000000000000000000000000000000000000000;;		return ok && funcName(call.Fun) == "fmt.Sprintf" && len(call.Args) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type walker struct {
0000000000000000000000000000000000000000;;		path  string
0000000000000000000000000000000000000000;;		fset  *token.FileSet
0000000000000000000000000000000000000000;;		tests *[]Test
0000000000000000000000000000000000000000;;		vals  map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeWalker(path string, fset *token.FileSet, tests *[]Test) *walker {
0000000000000000000000000000000000000000;;		return &walker{path, fset, tests, make(map[string]string)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clone creates a new walker with the given string extending the path.
0000000000000000000000000000000000000000;;	func (w *walker) clone(ext string) *walker {
0000000000000000000000000000000000000000;;		return &walker{w.path + " " + ext, w.fset, w.tests, w.vals}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// firstArg attempts to statically determine the value of the first
0000000000000000000000000000000000000000;;	// argument. It only handles strings, and converts any unknown values
0000000000000000000000000000000000000000;;	// (fmt.Sprintf interpolations) into *.
0000000000000000000000000000000000000000;;	func (w *walker) firstArg(n *ast.CallExpr) string {
0000000000000000000000000000000000000000;;		if len(n.Args) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var lit *ast.BasicLit
0000000000000000000000000000000000000000;;		if isSprintf(n.Args[0]) {
0000000000000000000000000000000000000000;;			return w.firstArg(n.Args[0].(*ast.CallExpr))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lit, ok := n.Args[0].(*ast.BasicLit)
0000000000000000000000000000000000000000;;		if ok && lit.Kind == token.STRING {
0000000000000000000000000000000000000000;;			v, err := strconv.Unquote(lit.Value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.Contains(v, "%") {
0000000000000000000000000000000000000000;;				v = strings.Replace(v, "%d", "*", -1)
0000000000000000000000000000000000000000;;				v = strings.Replace(v, "%v", "*", -1)
0000000000000000000000000000000000000000;;				v = strings.Replace(v, "%s", "*", -1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ident, ok := n.Args[0].(*ast.Ident); ok {
0000000000000000000000000000000000000000;;			if val, ok := w.vals[ident.String()]; ok {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *warn {
0000000000000000000000000000000000000000;;			log.Printf("Warning: dynamic arg value: %v\n", w.fset.Position(n.Args[0].Pos()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "*"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// describeName returns the first argument of a function if it's
0000000000000000000000000000000000000000;;	// a Ginkgo-relevant function (Describe/KubeDescribe/Context),
0000000000000000000000000000000000000000;;	// and the empty string otherwise.
0000000000000000000000000000000000000000;;	func (w *walker) describeName(n *ast.CallExpr) string {
0000000000000000000000000000000000000000;;		switch x := n.Fun.(type) {
0000000000000000000000000000000000000000;;		case *ast.SelectorExpr:
0000000000000000000000000000000000000000;;			if x.Sel.Name != "KubeDescribe" {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.Ident:
0000000000000000000000000000000000000000;;			if x.Name != "Describe" && x.Name != "Context" {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.firstArg(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// itName returns the first argument if it's a call to It(), else "".
0000000000000000000000000000000000000000;;	func (w *walker) itName(n *ast.CallExpr) string {
0000000000000000000000000000000000000000;;		if fun, ok := n.Fun.(*ast.Ident); ok && fun.Name == "It" {
0000000000000000000000000000000000000000;;			return w.firstArg(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit walks the AST, following Ginkgo context and collecting tests.
0000000000000000000000000000000000000000;;	// See the documentation for ast.Walk for more details.
0000000000000000000000000000000000000000;;	func (w *walker) Visit(n ast.Node) ast.Visitor {
0000000000000000000000000000000000000000;;		switch x := n.(type) {
0000000000000000000000000000000000000000;;		case *ast.CallExpr:
0000000000000000000000000000000000000000;;			name := w.describeName(x)
0000000000000000000000000000000000000000;;			if name != "" && len(x.Args) >= 2 {
0000000000000000000000000000000000000000;;				// If calling (Kube)Describe/Context, make a new
0000000000000000000000000000000000000000;;				// walker to recurse with the description added.
0000000000000000000000000000000000000000;;				return w.clone(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = w.itName(x)
0000000000000000000000000000000000000000;;			if name != "" {
0000000000000000000000000000000000000000;;				// We've found an It() call, the full test name
0000000000000000000000000000000000000000;;				// can be determined now.
0000000000000000000000000000000000000000;;				if w.path == "[k8s.io]" && *warn {
0000000000000000000000000000000000000000;;					log.Printf("It without matching Describe: %s\n", w.fset.Position(n.Pos()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*w.tests = append(*w.tests, Test{w.fset.Position(n.Pos()).String(), w.path, name})
0000000000000000000000000000000000000000;;				return nil // Stop walking
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.AssignStmt:
0000000000000000000000000000000000000000;;			// Attempt to track literals that might be used as
0000000000000000000000000000000000000000;;			// arguments. This analysis is very unsound, and ignores
0000000000000000000000000000000000000000;;			// both scope and program flow, but is sufficient for
0000000000000000000000000000000000000000;;			// our minor use case.
0000000000000000000000000000000000000000;;			ident, ok := x.Lhs[0].(*ast.Ident)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				if isSprintf(x.Rhs[0]) {
0000000000000000000000000000000000000000;;					// x := fmt.Sprintf("something", args)
0000000000000000000000000000000000000000;;					w.vals[ident.String()] = w.firstArg(x.Rhs[0].(*ast.CallExpr))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if lit, ok := x.Rhs[0].(*ast.BasicLit); ok && lit.Kind == token.STRING {
0000000000000000000000000000000000000000;;					// x := "a literal string"
0000000000000000000000000000000000000000;;					v, err := strconv.Unquote(lit.Value)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						panic(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.vals[ident.String()] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w // Continue walking
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testList struct {
0000000000000000000000000000000000000000;;		tests []Test
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handlePath walks the filesystem recursively, collecting tests
0000000000000000000000000000000000000000;;	// from files with paths *e2e*.go and *_test.go, ignoring third_party
0000000000000000000000000000000000000000;;	// and staging directories.
0000000000000000000000000000000000000000;;	func (t *testList) handlePath(path string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(path, "third_party") ||
0000000000000000000000000000000000000000;;			strings.Contains(path, "staging") ||
0000000000000000000000000000000000000000;;			strings.Contains(path, "_output") {
0000000000000000000000000000000000000000;;			return filepath.SkipDir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(path, ".go") && strings.Contains(path, "e2e") ||
0000000000000000000000000000000000000000;;			strings.HasSuffix(path, "_test.go") {
0000000000000000000000000000000000000000;;			tests := collect(path, nil)
0000000000000000000000000000000000000000;;			t.tests = append(t.tests, tests...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;		args := flag.Args()
0000000000000000000000000000000000000000;;		if len(args) == 0 {
0000000000000000000000000000000000000000;;			args = append(args, ".")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := testList{}
0000000000000000000000000000000000000000;;		for _, arg := range args {
0000000000000000000000000000000000000000;;			err := filepath.Walk(arg, tests.handlePath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Error walking: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *dumpJson {
0000000000000000000000000000000000000000;;			json, err := json.Marshal(tests.tests)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Println(string(json))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, t := range tests.tests {
0000000000000000000000000000000000000000;;				fmt.Println(t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
