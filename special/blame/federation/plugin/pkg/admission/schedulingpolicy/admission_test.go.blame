0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
3701b3d2d2e3a8cfe32604f66b748361b05d8f13;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package schedulingpolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"html/template"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extensionsv1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/fake"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewAdmissionController(t *testing.T) {
0000000000000000000000000000000000000000;;		tempfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error while creating temporary file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := tempfile.Name()
0000000000000000000000000000000000000000;;		defer os.Remove(p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeconfig := `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	  - name: foo
0000000000000000000000000000000000000000;;	    cluster:
0000000000000000000000000000000000000000;;	      server: https://example.com
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	  - name: alice
0000000000000000000000000000000000000000;;	    user:
0000000000000000000000000000000000000000;;	      token: deadbeef
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	  - name: default
0000000000000000000000000000000000000000;;	    context:
0000000000000000000000000000000000000000;;	      cluster: foo
0000000000000000000000000000000000000000;;	      user: alice
0000000000000000000000000000000000000000;;	current-context: default
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := tempfile.WriteString(kubeconfig); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error while writing test kubeconfig file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			note    string
0000000000000000000000000000000000000000;;			input   string
0000000000000000000000000000000000000000;;			wantErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"no config", "", true},
0000000000000000000000000000000000000000;;			{"bad json", `{"foo": `, true},
0000000000000000000000000000000000000000;;			{"bad yaml", `{foo" `, true},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"missing kubeconfig",
0000000000000000000000000000000000000000;;				`{"foo": {}}`,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"kubeconfig not found",
0000000000000000000000000000000000000000;;				`{
0000000000000000000000000000000000000000;;					"kubeconfig": "/kube-federation-scheduling-policy-file-not-found-test"
0000000000000000000000000000000000000000;;				}`,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"bad retry backoff",
0000000000000000000000000000000000000000;;				fmt.Sprintf(`
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"kubeconfig": %q,
0000000000000000000000000000000000000000;;						"retryBackoff": -1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					`, p),
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"a valid config",
0000000000000000000000000000000000000000;;				fmt.Sprintf(`
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"kubeconfig": %q
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					`, p),
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"a valid config with retry backoff",
0000000000000000000000000000000000000000;;				fmt.Sprintf(`
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"kubeconfig": %q,
0000000000000000000000000000000000000000;;						"retryBackoff": 200
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					`, p),
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			var file io.Reader
0000000000000000000000000000000000000000;;			if tc.input == "" {
0000000000000000000000000000000000000000;;				file = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				file = bytes.NewBufferString(tc.input)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err := newAdmissionController(file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.wantErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Expected error", tc.note)
0000000000000000000000000000000000000000;;			} else if !tc.wantErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Unexpected error: %v", tc.note, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitQueryPayload(t *testing.T) {
0000000000000000000000000000000000000000;;		var body interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serve := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error reading admission payload: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// No errors or annotations.
0000000000000000000000000000000000000000;;			w.Write([]byte(`{}`))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, err := newControllerWithTestServer(serve, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error while creating test admission controller/server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs := makeReplicaSet()
0000000000000000000000000000000000000000;;		rs.Spec.MinReadySeconds = 100
0000000000000000000000000000000000000000;;		attrs := makeAdmissionRecord(rs)
0000000000000000000000000000000000000000;;		err = controller.Admit(attrs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error from admission controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := body.(map[string]interface{})
0000000000000000000000000000000000000000;;		metadata := obj["metadata"].(map[string]interface{})
0000000000000000000000000000000000000000;;		spec := obj["spec"].(map[string]interface{})
0000000000000000000000000000000000000000;;		name := metadata["name"].(string)
0000000000000000000000000000000000000000;;		minReadySeconds := spec["minReadySeconds"].(float64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedName := "myapp"
0000000000000000000000000000000000000000;;		if name != expectedName {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected replicaset.metadata.name to be %v but got: %v", expectedName, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedMinReadySeconds := float64(100)
0000000000000000000000000000000000000000;;		if minReadySeconds != expectedMinReadySeconds {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected replicaset.spec.minReadySeconds to be %v but got: %v", expectedMinReadySeconds, minReadySeconds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitFailInternal(t *testing.T) {
0000000000000000000000000000000000000000;;		serve := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.WriteHeader(200)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, err := newControllerWithTestServer(serve, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error while creating test admission controller/server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;		mockClient.AddReactor("list", "configmaps", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, nil, fmt.Errorf("unknown error")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller.SetInternalKubeClientSet(mockClient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs := makeAdmissionRecord(makeReplicaSet())
0000000000000000000000000000000000000000;;		err = controller.Admit(attrs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected admission controller to fail closed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitPolicyDoesNotExist(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, err := newControllerWithTestServer(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.WriteHeader(404)
0000000000000000000000000000000000000000;;		}, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error while creating test admission controller/server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs := makeAdmissionRecord(makeReplicaSet())
0000000000000000000000000000000000000000;;		err = controller.Admit(attrs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected admission controller to fail open but got error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitFailClosed(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			note       string
0000000000000000000000000000000000000000;;			statusCode int
0000000000000000000000000000000000000000;;			body       string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"server error", 500, ""},
0000000000000000000000000000000000000000;;			{"unmarshal error", 200, "{"},
0000000000000000000000000000000000000000;;			{"undefined result", 404, ``},
0000000000000000000000000000000000000000;;			{"policy errors", 200, `{"errors": ["conflicting replica-set-preferences"]}`},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serve := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				w.WriteHeader(tc.statusCode)
0000000000000000000000000000000000000000;;				if len(tc.body) > 0 {
0000000000000000000000000000000000000000;;					w.Write([]byte(tc.body))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			controller, err := newControllerWithTestServer(serve, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Unexpected error while creating test admission controller/server: %v", tc.note, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj := makeReplicaSet()
0000000000000000000000000000000000000000;;			attrs := admission.NewAttributesRecord(obj, nil, obj.GroupVersionKind(), obj.Namespace, obj.Name, api.Resource("replicasets").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;			err = controller.Admit(attrs)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Expected admission controller to fail closed", tc.note)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitRetries(t *testing.T) {
0000000000000000000000000000000000000000;;		var numQueries int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, err := newControllerWithTestServer(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.WriteHeader(500)
0000000000000000000000000000000000000000;;			numQueries++
0000000000000000000000000000000000000000;;		}, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error while creating test admission controller/server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = controller.Admit(makeAdmissionRecord(makeReplicaSet()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected admission controller to fail closed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if numQueries <= 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected multiple queries/retries but got (numQueries): %v", numQueries)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdmitSuccessWithAnnotationMerge(t *testing.T) {
0000000000000000000000000000000000000000;;		controller, err := newControllerWithTestServer(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.Write([]byte(`
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"annotations": {
0000000000000000000000000000000000000000;;					"foo": "bar-2"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			`))
0000000000000000000000000000000000000000;;		}, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error while creating test admission controller/server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := makeReplicaSet()
0000000000000000000000000000000000000000;;		obj.Annotations = map[string]string{}
0000000000000000000000000000000000000000;;		obj.Annotations["foo"] = "bar"
0000000000000000000000000000000000000000;;		obj.Annotations["bar"] = "baz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs := admission.NewAttributesRecord(obj, nil, obj.GroupVersionKind(), obj.Namespace, obj.Name, api.Resource("replicasets").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;		err = controller.Admit(attrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error from admission controller: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		annotations := attrs.GetObject().(*extensionsv1.ReplicaSet).Annotations
0000000000000000000000000000000000000000;;		expected := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar-2",
0000000000000000000000000000000000000000;;			"bar": "baz",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(annotations, expected) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected annotations to be %v but got: %v", expected, annotations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newControllerWithTestServer(f func(w http.ResponseWriter, r *http.Request), policiesExist bool) (*admissionController, error) {
0000000000000000000000000000000000000000;;		server, err := newTestServer(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeConfigFile, err := makeKubeConfigFile(server.URL, "/some/path/to/decision")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer os.Remove(kubeConfigFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configFile, err := makeAdmissionControlConfigFile(kubeConfigFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer os.Remove(configFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := os.Open(configFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, err := newAdmissionController(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockClient := &fake.Clientset{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var items []api.ConfigMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if policiesExist {
0000000000000000000000000000000000000000;;			items = append(items, api.ConfigMap{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mockClient.AddReactor("list", "configmaps", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			if action.GetNamespace() == policyConfigMapNamespace {
0000000000000000000000000000000000000000;;				return true, &api.ConfigMapList{Items: items}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller.SetInternalKubeClientSet(mockClient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return controller, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestServer(f func(w http.ResponseWriter, r *http.Request)) (*httptest.Server, error) {
0000000000000000000000000000000000000000;;		server := httptest.NewUnstartedServer(http.HandlerFunc(f))
0000000000000000000000000000000000000000;;		server.Start()
0000000000000000000000000000000000000000;;		return server, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeAdmissionControlConfigFile(kubeConfigFile string) (string, error) {
0000000000000000000000000000000000000000;;		tempfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := tempfile.Name()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configFileTmpl := `
0000000000000000000000000000000000000000;;	kubeconfig: {{ .KubeConfigFile }}
0000000000000000000000000000000000000000;;	retryBackoff: {{ .RetryBackoff }}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;		type configFileTemplateInput struct {
0000000000000000000000000000000000000000;;			KubeConfigFile string
0000000000000000000000000000000000000000;;			RetryBackoff   int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		input := configFileTemplateInput{
0000000000000000000000000000000000000000;;			KubeConfigFile: kubeConfigFile,
0000000000000000000000000000000000000000;;			RetryBackoff:   1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmpl, err := template.New("scheduling-policy-config").Parse(configFileTmpl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := tmpl.Execute(tempfile, input); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeKubeConfigFile(baseURL, path string) (string, error) {
0000000000000000000000000000000000000000;;		tempfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := tempfile.Name()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeConfigTmpl := `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	  - name: test
0000000000000000000000000000000000000000;;	    cluster:
0000000000000000000000000000000000000000;;	      server: {{ .BaseURL }}{{ .Path }}
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	  - name: alice
0000000000000000000000000000000000000000;;	    user:
0000000000000000000000000000000000000000;;	      token: deadbeef
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	  - name: default
0000000000000000000000000000000000000000;;	    context:
0000000000000000000000000000000000000000;;	      cluster: test
0000000000000000000000000000000000000000;;	      user: alice
0000000000000000000000000000000000000000;;	current-context: default`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type kubeConfigTemplateInput struct {
0000000000000000000000000000000000000000;;			BaseURL string
0000000000000000000000000000000000000000;;			Path    string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		input := kubeConfigTemplateInput{
0000000000000000000000000000000000000000;;			BaseURL: baseURL,
0000000000000000000000000000000000000000;;			Path:    path,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmpl, err := template.New("kubeconfig").Parse(kubeConfigTmpl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := tmpl.Execute(tempfile, input); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeAdmissionRecord(obj *extensionsv1.ReplicaSet) admission.Attributes {
0000000000000000000000000000000000000000;;		return admission.NewAttributesRecord(obj, nil, obj.GroupVersionKind(), obj.Namespace, obj.Name, api.Resource("replicasets").WithVersion("version"), "", admission.Create, &user.DefaultInfo{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeReplicaSet() *extensionsv1.ReplicaSet {
0000000000000000000000000000000000000000;;		return &extensionsv1.ReplicaSet{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "ReplicaSet",
0000000000000000000000000000000000000000;;				APIVersion: "extensions/v1beta1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "myapp",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensionsv1.ReplicaSetSpec{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
