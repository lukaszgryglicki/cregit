0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
3701b3d2d2e3a8cfe32604f66b748361b05d8f13;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package schedulingpolicy implements a webhook that queries an external API
0000000000000000000000000000000000000000;;	// to obtain scheduling decisions for Federated sources.
0000000000000000000000000000000000000000;;	package schedulingpolicy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/ref"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		pluginName               = "SchedulingPolicy"
0000000000000000000000000000000000000000;;		configKey                = "schedulingPolicy"
0000000000000000000000000000000000000000;;		policyConfigMapNamespace = "kube-federation-scheduling-policy"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default backoff delay for policy engine query retries. The actual
0000000000000000000000000000000000000000;;		// backoff implementation is handled by k8s.io/apiserver/pkg/util/webhook.
0000000000000000000000000000000000000000;;		// If the admission controller config file does not specify a backoff, this
0000000000000000000000000000000000000000;;		// one is used.
0000000000000000000000000000000000000000;;		defaultRetryBackoff = time.Millisecond * 100
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type admissionConfig struct {
0000000000000000000000000000000000000000;;		Kubeconfig   string        `json:"kubeconfig"`
0000000000000000000000000000000000000000;;		RetryBackoff time.Duration `json:"retryBackoff"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type admissionController struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		policyEngineClient       *rest.RESTClient            // client to communicate with policy engine
0000000000000000000000000000000000000000;;		policyEngineRetryBackoff time.Duration               // backoff for policy engine queries
0000000000000000000000000000000000000000;;		client                   internalclientset.Interface // client to communicate with federation-apiserver
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers the plugin.
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register(pluginName, func(file io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			return newAdmissionController(file)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAdmissionController(file io.Reader) (*admissionController, error) {
0000000000000000000000000000000000000000;;		config, err := loadConfig(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		policyEngineClient, err := loadRestClient(config.Kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &admissionController{
0000000000000000000000000000000000000000;;			Handler:                  admission.NewHandler(admission.Create, admission.Update),
0000000000000000000000000000000000000000;;			policyEngineClient:       policyEngineClient,
0000000000000000000000000000000000000000;;			policyEngineRetryBackoff: config.RetryBackoff,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *admissionController) Validate() error {
0000000000000000000000000000000000000000;;		if c.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s requires a client", pluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *admissionController) SetInternalKubeClientSet(client internalclientset.Interface) {
0000000000000000000000000000000000000000;;		c.client = client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *admissionController) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		exists, err := c.policyExists()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return c.handleError(a, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := a.GetObject()
0000000000000000000000000000000000000000;;		decision, err := newPolicyEngineQuery(c.policyEngineClient, c.policyEngineRetryBackoff, obj, a.GetKind()).Do()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return c.handleError(a, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := decision.Error(); err != nil {
0000000000000000000000000000000000000000;;			return c.handleError(a, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mergeAnnotations(obj, decision.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *admissionController) handleError(a admission.Attributes, err error) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.publishEvent(a, err.Error())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return admission.NewForbidden(a, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *admissionController) publishEvent(a admission.Attributes, msg string) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := a.GetObject()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ref, err := ref.GetReference(api.Scheme, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event := &api.Event{
0000000000000000000000000000000000000000;;			InvolvedObject: *ref,
0000000000000000000000000000000000000000;;			Message:        msg,
0000000000000000000000000000000000000000;;			Source: api.EventSource{
0000000000000000000000000000000000000000;;				Component: fmt.Sprintf("schedulingpolicy"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: "Warning",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := c.client.Core().Events(a.GetNamespace()).Create(event); err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *admissionController) policyExists() (bool, error) {
0000000000000000000000000000000000000000;;		lst, err := c.client.Core().ConfigMaps(policyConfigMapNamespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(lst.Items) > 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadConfig(file io.Reader) (*admissionConfig, error) {
0000000000000000000000000000000000000000;;		var cfg admissionConfig
0000000000000000000000000000000000000000;;		if file == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("--admission-control-config-file not specified or invalid")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := yaml.NewYAMLOrJSONDecoder(file, 4096).Decode(&cfg); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cfg.Kubeconfig) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("kubeconfig path must not be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.RetryBackoff == 0 {
0000000000000000000000000000000000000000;;			cfg.RetryBackoff = defaultRetryBackoff
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Scale up value from config (which is unmarshalled as ns).
0000000000000000000000000000000000000000;;			cfg.RetryBackoff *= time.Millisecond
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.RetryBackoff.Nanoseconds() < 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("retryBackoff must not be negative")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &cfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadRestClient(kubeConfigFile string) (*rest.RESTClient, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
0000000000000000000000000000000000000000;;		loadingRules.ExplicitPath = kubeConfigFile
0000000000000000000000000000000000000000;;		loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig, err := loader.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig.ContentConfig.NegotiatedSerializer = dynamic.ContentConfig().NegotiatedSerializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restClient, err := rest.UnversionedRESTClientFor(clientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return restClient, nil
0000000000000000000000000000000000000000;;	}
