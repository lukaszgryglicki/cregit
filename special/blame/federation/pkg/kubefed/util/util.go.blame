0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f07bc138e466d881c7b6e7926645a820b1b64f63;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		fedclient "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		client "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		kubectlcmd "k8s.io/kubernetes/pkg/kubectl/cmd"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// KubeconfigSecretDataKey is the key name used in the secret to
0000000000000000000000000000000000000000;;		// stores a cluster's credentials.
0000000000000000000000000000000000000000;;		KubeconfigSecretDataKey = "kubeconfig"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used in and to create the kube-dns configmap storing the zone info
0000000000000000000000000000000000000000;;		FedDomainMapKey       = "federations"
0000000000000000000000000000000000000000;;		KubeDnsConfigmapName  = "kube-dns"
0000000000000000000000000000000000000000;;		FedDNSZoneName        = "dns-zone-name"
0000000000000000000000000000000000000000;;		FedNameServer         = "nameserver"
0000000000000000000000000000000000000000;;		FedDNSProvider        = "dns-provider"
0000000000000000000000000000000000000000;;		FedDNSProviderCoreDNS = "coredns"
0000000000000000000000000000000000000000;;		KubeDnsStubDomains    = "stubDomains"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultFederationSystemNamespace is the namespace in which
0000000000000000000000000000000000000000;;		// federation system components are hosted.
0000000000000000000000000000000000000000;;		DefaultFederationSystemNamespace = "federation-system"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used to build a clientset for a cluster using the secret
0000000000000000000000000000000000000000;;		userAgentName = "kubefed-tool"
0000000000000000000000000000000000000000;;		KubeAPIQPS    = 20.0
0000000000000000000000000000000000000000;;		KubeAPIBurst  = 30
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rbacAPINotAvailable = "RBAC API not available"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// used to identify the rbac api availability error.
0000000000000000000000000000000000000000;;	type NoRBACAPIError struct {
0000000000000000000000000000000000000000;;		s string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NoRBACAPIError) Error() string {
0000000000000000000000000000000000000000;;		return n.s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AdminConfig provides a filesystem based kubeconfig (via
0000000000000000000000000000000000000000;;	// `PathOptions()`) and a mechanism to talk to the federation
0000000000000000000000000000000000000000;;	// host cluster and the federation control plane api server.
0000000000000000000000000000000000000000;;	type AdminConfig interface {
0000000000000000000000000000000000000000;;		// PathOptions provides filesystem based kubeconfig access.
0000000000000000000000000000000000000000;;		PathOptions() *clientcmd.PathOptions
0000000000000000000000000000000000000000;;		// FedClientSet provides a federation API compliant clientset
0000000000000000000000000000000000000000;;		// to communicate with the federation control plane api server
0000000000000000000000000000000000000000;;		FederationClientset(context, kubeconfigPath string) (*fedclient.Clientset, error)
0000000000000000000000000000000000000000;;		// ClusterFactory provides a mechanism to communicate with the
0000000000000000000000000000000000000000;;		// cluster derived from the context and the kubeconfig.
0000000000000000000000000000000000000000;;		ClusterFactory(context, kubeconfigPath string) cmdutil.Factory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adminConfig implements the AdminConfig interface.
0000000000000000000000000000000000000000;;	type adminConfig struct {
0000000000000000000000000000000000000000;;		pathOptions *clientcmd.PathOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAdminConfig creates an admin config for `kubefed` commands.
0000000000000000000000000000000000000000;;	func NewAdminConfig(pathOptions *clientcmd.PathOptions) AdminConfig {
0000000000000000000000000000000000000000;;		return &adminConfig{
0000000000000000000000000000000000000000;;			pathOptions: pathOptions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *adminConfig) PathOptions() *clientcmd.PathOptions {
0000000000000000000000000000000000000000;;		return a.pathOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *adminConfig) FederationClientset(context, kubeconfigPath string) (*fedclient.Clientset, error) {
0000000000000000000000000000000000000000;;		fedConfig := a.getClientConfig(context, kubeconfigPath)
0000000000000000000000000000000000000000;;		fedClientConfig, err := fedConfig.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fedclient.NewForConfigOrDie(fedClientConfig), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *adminConfig) ClusterFactory(context, kubeconfigPath string) cmdutil.Factory {
0000000000000000000000000000000000000000;;		hostClientConfig := a.getClientConfig(context, kubeconfigPath)
0000000000000000000000000000000000000000;;		return cmdutil.NewFactory(hostClientConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *adminConfig) getClientConfig(context, kubeconfigPath string) clientcmd.ClientConfig {
0000000000000000000000000000000000000000;;		loadingRules := *a.pathOptions.LoadingRules
0000000000000000000000000000000000000000;;		loadingRules.Precedence = a.pathOptions.GetLoadingPrecedence()
0000000000000000000000000000000000000000;;		loadingRules.ExplicitPath = kubeconfigPath
0000000000000000000000000000000000000000;;		overrides := &clientcmd.ConfigOverrides{
0000000000000000000000000000000000000000;;			CurrentContext: context,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(&loadingRules, overrides)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubcommandOptions holds the configuration required by the subcommands of
0000000000000000000000000000000000000000;;	// `kubefed`.
0000000000000000000000000000000000000000;;	type SubcommandOptions struct {
0000000000000000000000000000000000000000;;		Name                      string
0000000000000000000000000000000000000000;;		Host                      string
0000000000000000000000000000000000000000;;		FederationSystemNamespace string
0000000000000000000000000000000000000000;;		Kubeconfig                string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SubcommandOptions) Bind(flags *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		flags.StringVar(&o.Kubeconfig, "kubeconfig", "", "Path to the kubeconfig file to use for CLI requests.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.Host, "host-cluster-context", "", "Host cluster context")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.FederationSystemNamespace, "federation-system-namespace", DefaultFederationSystemNamespace, "Namespace in the host cluster where the federation system components are installed")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *SubcommandOptions) SetName(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		name, err := kubectlcmd.NameFromCommandArgs(cmd, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.Name = name
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateKubeconfigSecret(clientset client.Interface, kubeconfig *clientcmdapi.Config, namespace, name, federationName, clusterName string, dryRun bool) (*api.Secret, error) {
0000000000000000000000000000000000000000;;		configBytes, err := clientcmd.Write(*kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations := map[string]string{
0000000000000000000000000000000000000000;;			federationapi.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if clusterName != "" {
0000000000000000000000000000000000000000;;			annotations[federationapi.ClusterNameAnnotation] = clusterName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build the secret object with the minified and flattened
0000000000000000000000000000000000000000;;		// kubeconfig content.
0000000000000000000000000000000000000000;;		secret := &api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Annotations: annotations,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				KubeconfigSecretDataKey: configBytes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dryRun {
0000000000000000000000000000000000000000;;			return clientset.Core().Secrets(namespace).Create(secret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return secret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var kubeconfigGetterForSecret = func(secret *api.Secret) clientcmd.KubeconfigGetter {
0000000000000000000000000000000000000000;;		return func() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;			var data []byte
0000000000000000000000000000000000000000;;			ok := false
0000000000000000000000000000000000000000;;			data, ok = secret.Data[KubeconfigSecretDataKey]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("secret does not have data with key: %s", KubeconfigSecretDataKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return clientcmd.Load(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetClientsetFromSecret(secret *api.Secret, serverAddress string) (*client.Clientset, error) {
0000000000000000000000000000000000000000;;		clusterConfig, err := buildConfigFromSecret(secret, serverAddress)
0000000000000000000000000000000000000000;;		if err == nil && clusterConfig != nil {
0000000000000000000000000000000000000000;;			clientset := client.NewForConfigOrDie(restclient.AddUserAgent(clusterConfig, userAgentName))
0000000000000000000000000000000000000000;;			return clientset, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetServerAddress(c *federationapi.Cluster) (string, error) {
0000000000000000000000000000000000000000;;		hostIP, err := utilnet.ChooseHostInterface()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range c.Spec.ServerAddressByClientCIDRs {
0000000000000000000000000000000000000000;;			_, cidrnet, err := net.ParseCIDR(item.ClientCIDR)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cidrnet.Contains(hostIP) {
0000000000000000000000000000000000000000;;				return item.ServerAddress, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildConfigFromSecret(secret *api.Secret, serverAddress string) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		var clusterConfig *restclient.Config
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// Pre-1.7, the secret contained a serialized kubeconfig which contained appropriate credentials.
0000000000000000000000000000000000000000;;		// Post-1.7, the secret contains credentials for a service account.
0000000000000000000000000000000000000000;;		// Check for the service account credentials, and use them if they exist; if not, use the
0000000000000000000000000000000000000000;;		// serialized kubeconfig.
0000000000000000000000000000000000000000;;		token, tokenFound := secret.Data["token"]
0000000000000000000000000000000000000000;;		ca, caFound := secret.Data["ca.crt"]
0000000000000000000000000000000000000000;;		if tokenFound != caFound {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("secret should have values for either both 'ca.crt' and 'token' in its Data, or neither: %v", secret)
0000000000000000000000000000000000000000;;		} else if tokenFound && caFound {
0000000000000000000000000000000000000000;;			clusterConfig, err = clientcmd.BuildConfigFromFlags(serverAddress, "")
0000000000000000000000000000000000000000;;			clusterConfig.CAData = ca
0000000000000000000000000000000000000000;;			clusterConfig.BearerToken = string(token)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			kubeconfigGetter := kubeconfigGetterForSecret(secret)
0000000000000000000000000000000000000000;;			clusterConfig, err = clientcmd.BuildConfigFromKubeconfigGetter(serverAddress, kubeconfigGetter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterConfig.QPS = KubeAPIQPS
0000000000000000000000000000000000000000;;		clusterConfig.Burst = KubeAPIBurst
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clusterConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetVersionedClientForRBACOrFail discovers the versioned rbac APIs and gets the versioned
0000000000000000000000000000000000000000;;	// clientset for either the preferred version or the first listed version (if no preference listed)
0000000000000000000000000000000000000000;;	// TODO: We need to evaluate the usage of RESTMapper interface to achieve te same functionality
0000000000000000000000000000000000000000;;	func GetVersionedClientForRBACOrFail(hostFactory cmdutil.Factory) (client.Interface, error) {
0000000000000000000000000000000000000000;;		discoveryclient, err := hostFactory.DiscoveryClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rbacVersion, err := getRBACVersion(discoveryclient)
0000000000000000000000000000000000000000;;		if err != nil && !discoveryclient.Fresh() {
0000000000000000000000000000000000000000;;			discoveryclient.Invalidate()
0000000000000000000000000000000000000000;;			rbacVersion, err = getRBACVersion(discoveryclient)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hostFactory.ClientSetForVersion(rbacVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRBACVersion(discoveryclient discovery.CachedDiscoveryInterface) (*schema.GroupVersion, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groupList, err := discoveryclient.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Couldn't get clientset to create RBAC roles in the host cluster: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, g := range groupList.Groups {
0000000000000000000000000000000000000000;;			if g.Name == rbac.GroupName {
0000000000000000000000000000000000000000;;				if g.PreferredVersion.GroupVersion != "" {
0000000000000000000000000000000000000000;;					gv, err := schema.ParseGroupVersion(g.PreferredVersion.GroupVersion)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &gv, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, version := range g.Versions {
0000000000000000000000000000000000000000;;					if version.GroupVersion != "" {
0000000000000000000000000000000000000000;;						gv, err := schema.ParseGroupVersion(version.GroupVersion)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return &gv, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, &NoRBACAPIError{rbacAPINotAvailable}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterServiceAccountName returns the name of a service account
0000000000000000000000000000000000000000;;	// whose credentials are used by the host cluster to access the
0000000000000000000000000000000000000000;;	// client cluster.
0000000000000000000000000000000000000000;;	func ClusterServiceAccountName(joiningClusterName, hostContext string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s-%s", joiningClusterName, hostContext)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoleName returns the name of a ClusterRole and its associated
0000000000000000000000000000000000000000;;	// ClusterRoleBinding that are used to allow the service account to
0000000000000000000000000000000000000000;;	// access necessary resources on the cluster.
0000000000000000000000000000000000000000;;	func ClusterRoleName(federationName, serviceAccountName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("federation-controller-manager:%s-%s", federationName, serviceAccountName)
0000000000000000000000000000000000000000;;	}
