0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
eae64d20b7a3effc664b3a5f4b303f686d64fb00;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubefed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/kubefed/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		extensions "k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		kubectlcmd "k8s.io/kubernetes/pkg/kubectl/cmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// defaultClusterCIDR is the default CIDR range accepted by the
0000000000000000000000000000000000000000;;		// joining API server. See `apis/federation.ClusterSpec` for
0000000000000000000000000000000000000000;;		// details.
0000000000000000000000000000000000000000;;		// TODO(madhusudancs): Make this value customizable.
0000000000000000000000000000000000000000;;		defaultClientCIDR           = "0.0.0.0/0"
0000000000000000000000000000000000000000;;		CMNameSuffix                = "controller-manager"
0000000000000000000000000000000000000000;;		serviceAccountSecretTimeout = 30 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		join_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Join a cluster to a federation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        Current context is assumed to be a federation API
0000000000000000000000000000000000000000;;	        server. Please use the --context flag otherwise.`)
0000000000000000000000000000000000000000;;		join_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Join a cluster to a federation by specifying the
0000000000000000000000000000000000000000;;			# cluster name and the context name of the federation
0000000000000000000000000000000000000000;;			# control plane's host cluster. Cluster name must be
0000000000000000000000000000000000000000;;			# a valid RFC 1123 subdomain name. Cluster context
0000000000000000000000000000000000000000;;			# must be specified if the cluster name is different
0000000000000000000000000000000000000000;;			# than the cluster's context in the local kubeconfig.
0000000000000000000000000000000000000000;;			kubefed join foo --host-cluster-context=bar`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type joinFederation struct {
0000000000000000000000000000000000000000;;		commonOptions util.SubcommandOptions
0000000000000000000000000000000000000000;;		options       joinFederationOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type joinFederationOptions struct {
0000000000000000000000000000000000000000;;		clusterContext string
0000000000000000000000000000000000000000;;		secretName     string
0000000000000000000000000000000000000000;;		dryRun         bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *joinFederationOptions) Bind(flags *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		flags.StringVar(&o.clusterContext, "cluster-context", "", "Name of the cluster's context in the local kubeconfig. Defaults to cluster name if unspecified.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.secretName, "secret-name", "", "Name of the secret where the cluster's credentials will be stored in the host cluster. This name should be a valid RFC 1035 label. Defaults to cluster name if unspecified.")
0000000000000000000000000000000000000000;;		flags.MarkDeprecated("secret-name", "kubefed now generates a secret name, and this flag will be removed in a future release.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdJoin defines the `join` command that joins a cluster to a
0000000000000000000000000000000000000000;;	// federation.
0000000000000000000000000000000000000000;;	func NewCmdJoin(f cmdutil.Factory, cmdOut io.Writer, config util.AdminConfig) *cobra.Command {
0000000000000000000000000000000000000000;;		opts := &joinFederation{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "join CLUSTER_NAME --host-cluster-context=HOST_CONTEXT",
0000000000000000000000000000000000000000;;			Short:   "Join a cluster to a federation",
0000000000000000000000000000000000000000;;			Long:    join_long,
0000000000000000000000000000000000000000;;			Example: join_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.Complete(cmd, args, config))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.Run(f, cmdOut, config, cmd))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdutil.AddApplyAnnotationFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddValidateFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddPrinterFlags(cmd)
0000000000000000000000000000000000000000;;		cmdutil.AddGeneratorFlags(cmd, cmdutil.ClusterV1Beta1GeneratorName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags := cmd.Flags()
0000000000000000000000000000000000000000;;		opts.commonOptions.Bind(flags)
0000000000000000000000000000000000000000;;		opts.options.Bind(flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete ensures that options are valid and marshals them if necessary.
0000000000000000000000000000000000000000;;	func (j *joinFederation) Complete(cmd *cobra.Command, args []string, config util.AdminConfig) error {
0000000000000000000000000000000000000000;;		err := j.commonOptions.SetName(cmd, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j.options.dryRun = cmdutil.GetDryRunFlag(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if j.options.clusterContext == "" {
0000000000000000000000000000000000000000;;			j.options.clusterContext = j.commonOptions.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Args and flags: name %s, host: %s, host-system-namespace: %s, kubeconfig: %s, cluster-context: %s, secret-name: %s, dry-run: %s", j.commonOptions.Name, j.commonOptions.Host, j.commonOptions.FederationSystemNamespace, j.commonOptions.Kubeconfig, j.options.clusterContext, j.options.secretName, j.options.dryRun)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Performing preflight checks.")
0000000000000000000000000000000000000000;;		err = j.performPreflightChecks(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// performPreflightChecks checks that the host and joining clusters are in
0000000000000000000000000000000000000000;;	// a consistent state.
0000000000000000000000000000000000000000;;	// TODO: This currently only verifies a few things. Add more checks.
0000000000000000000000000000000000000000;;	func (j *joinFederation) performPreflightChecks(config util.AdminConfig) error {
0000000000000000000000000000000000000000;;		joiningClusterFactory := j.joningClusterFactory(config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If RBAC is not available, then skip checking for a service account.
0000000000000000000000000000000000000000;;		// If RBAC availability cannot be determined, return an error.
0000000000000000000000000000000000000000;;		rbacVersionedClientset, err := util.GetVersionedClientForRBACOrFail(joiningClusterFactory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(*util.NoRBACAPIError); ok {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure there is no existing service account in the joining cluster.
0000000000000000000000000000000000000000;;		saName := util.ClusterServiceAccountName(j.commonOptions.Name, j.commonOptions.Host)
0000000000000000000000000000000000000000;;		sa, err := rbacVersionedClientset.Core().ServiceAccounts(j.commonOptions.FederationSystemNamespace).Get(saName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if sa != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("service account already exists in joining cluster")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// joiningClusterClientset returns a factory for the joining cluster.
0000000000000000000000000000000000000000;;	func (j *joinFederation) joningClusterFactory(config util.AdminConfig) cmdutil.Factory {
0000000000000000000000000000000000000000;;		return config.ClusterFactory(j.options.clusterContext, j.commonOptions.Kubeconfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run is the implementation of the `join federation` command.
0000000000000000000000000000000000000000;;	func (j *joinFederation) Run(f cmdutil.Factory, cmdOut io.Writer, config util.AdminConfig, cmd *cobra.Command) error {
0000000000000000000000000000000000000000;;		clusterContext := j.options.clusterContext
0000000000000000000000000000000000000000;;		dryRun := j.options.dryRun
0000000000000000000000000000000000000000;;		federationNamespace := j.commonOptions.FederationSystemNamespace
0000000000000000000000000000000000000000;;		host := j.commonOptions.Host
0000000000000000000000000000000000000000;;		kubeconfig := j.commonOptions.Kubeconfig
0000000000000000000000000000000000000000;;		joiningClusterName := j.commonOptions.Name
0000000000000000000000000000000000000000;;		secretName := j.options.secretName
0000000000000000000000000000000000000000;;		if secretName == "" {
0000000000000000000000000000000000000000;;			secretName = k8s_api_v1.SimpleNameGenerator.GenerateName(j.commonOptions.Name + "-")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		joiningClusterFactory := j.joningClusterFactory(config)
0000000000000000000000000000000000000000;;		joiningClusterClientset, err := joiningClusterFactory.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not create client for joining cluster: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostFactory := config.ClusterFactory(host, kubeconfig)
0000000000000000000000000000000000000000;;		hostClientset, err := hostFactory.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not create client for host cluster: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		federationName, err := getFederationName(hostClientset, federationNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to get the federation name: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Info("Creating federation system namespace in joining cluster")
0000000000000000000000000000000000000000;;		_, err = createFederationSystemNamespace(joiningClusterClientset, federationNamespace, federationName, joiningClusterName, dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error creating federation system namespace in joining cluster: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Created federation system namespace in joining cluster")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		po := config.PathOptions()
0000000000000000000000000000000000000000;;		po.LoadingRules.ExplicitPath = kubeconfig
0000000000000000000000000000000000000000;;		clientConfig, err := po.GetStartingConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not load clientConfig from %s: %v", kubeconfig, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceAccountName := ""
0000000000000000000000000000000000000000;;		clusterRoleName := ""
0000000000000000000000000000000000000000;;		// Check for RBAC in the joining cluster. If it supports RBAC, then create
0000000000000000000000000000000000000000;;		// a service account and use its credentials; otherwise, use the credentials
0000000000000000000000000000000000000000;;		// from the local kubeconfig.
0000000000000000000000000000000000000000;;		glog.V(2).Info("Creating cluster credentials secret")
0000000000000000000000000000000000000000;;		rbacClientset, err := util.GetVersionedClientForRBACOrFail(joiningClusterFactory)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			if _, serviceAccountName, clusterRoleName, err = createRBACSecret(hostClientset, rbacClientset, federationNamespace, federationName, joiningClusterName, host, clusterContext, secretName, dryRun); err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Could not create cluster credentials secret: %v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if _, ok := err.(*util.NoRBACAPIError); ok {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// We are not using the `kubectl create secret` machinery through
0000000000000000000000000000000000000000;;				// `RunCreateSubcommand` as we do to the cluster resource below
0000000000000000000000000000000000000000;;				// because we have a bunch of requirements that the machinery does
0000000000000000000000000000000000000000;;				// not satisfy.
0000000000000000000000000000000000000000;;				// 1. We want to create the secret in a specific namespace, which
0000000000000000000000000000000000000000;;				//    is neither the "default" namespace nor the one specified
0000000000000000000000000000000000000000;;				//    via the `--namespace` flag.
0000000000000000000000000000000000000000;;				// 2. `SecretGeneratorV1` requires LiteralSources in a string-ified
0000000000000000000000000000000000000000;;				//    form that it parses to generate the secret data key-value
0000000000000000000000000000000000000000;;				//    pairs. We, however, have the key-value pairs ready without a
0000000000000000000000000000000000000000;;				//    need for parsing.
0000000000000000000000000000000000000000;;				// 3. The result printing mechanism needs to be mostly quiet. We
0000000000000000000000000000000000000000;;				//    don't have to print the created secret in the default case.
0000000000000000000000000000000000000000;;				// Having said that, secret generation machinery could be altered to
0000000000000000000000000000000000000000;;				// suit our needs, but it is far less invasive and readable this way.
0000000000000000000000000000000000000000;;				_, err = createSecret(hostClientset, clientConfig, federationNamespace, federationName, joiningClusterName, clusterContext, secretName, dryRun)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Failed creating the cluster credentials secret: %v", err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Failed to get or verify absence of RBAC client: %v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Cluster credentials secret created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Info("Creating a generator for the cluster API object")
0000000000000000000000000000000000000000;;		generator, err := clusterGenerator(clientConfig, joiningClusterName, clusterContext, secretName, serviceAccountName, clusterRoleName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to create a generator for the cluster API object: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Created a generator for the cluster API object")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Info("Running create cluster command against the federation API server")
0000000000000000000000000000000000000000;;		err = kubectlcmd.RunCreateSubcommand(f, cmd, cmdOut, &kubectlcmd.CreateSubcommandOptions{
0000000000000000000000000000000000000000;;			Name:                joiningClusterName,
0000000000000000000000000000000000000000;;			StructuredGenerator: generator,
0000000000000000000000000000000000000000;;			DryRun:              dryRun,
0000000000000000000000000000000000000000;;			OutputFormat:        cmdutil.GetFlagString(cmd, "output"),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed running create cluster command against the federation API server: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Successfully ran create cluster command against the federation API server")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We further need to create a configmap named kube-config in the
0000000000000000000000000000000000000000;;		// just registered cluster which will be consumed by the kube-dns
0000000000000000000000000000000000000000;;		// of this cluster.
0000000000000000000000000000000000000000;;		glog.V(2).Info("Creating configmap in host cluster")
0000000000000000000000000000000000000000;;		_, err = createConfigMap(hostClientset, config, federationNamespace, federationName, joiningClusterName, clusterContext, kubeconfig, dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to create configmap in cluster: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Created configmap in host cluster")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// minifyConfig is a wrapper around `clientcmdapi.MinifyConfig()` that
0000000000000000000000000000000000000000;;	// sets the current context to the given context before calling
0000000000000000000000000000000000000000;;	// `clientcmdapi.MinifyConfig()`.
0000000000000000000000000000000000000000;;	func minifyConfig(clientConfig *clientcmdapi.Config, context string) (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		// MinifyConfig inline-modifies the passed clientConfig. So we make a
0000000000000000000000000000000000000000;;		// copy of it before passing the config to it. A shallow copy is
0000000000000000000000000000000000000000;;		// sufficient because the underlying fields will be reconstructed by
0000000000000000000000000000000000000000;;		// MinifyConfig anyway.
0000000000000000000000000000000000000000;;		newClientConfig := *clientConfig
0000000000000000000000000000000000000000;;		newClientConfig.CurrentContext = context
0000000000000000000000000000000000000000;;		err := clientcmdapi.MinifyConfig(&newClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &newClientConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createSecret extracts the kubeconfig for a given cluster and populates
0000000000000000000000000000000000000000;;	// a secret with that kubeconfig.
0000000000000000000000000000000000000000;;	func createSecret(clientset internalclientset.Interface, clientConfig *clientcmdapi.Config, namespace, federationName, joiningClusterName, contextName, secretName string, dryRun bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		// Minify the kubeconfig to ensure that there is only information
0000000000000000000000000000000000000000;;		// relevant to the cluster we are registering.
0000000000000000000000000000000000000000;;		newClientConfig, err := minifyConfig(clientConfig, contextName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to minify the kubeconfig for the given context %q: %v", contextName, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flatten the kubeconfig to ensure that all the referenced file
0000000000000000000000000000000000000000;;		// contents are inlined.
0000000000000000000000000000000000000000;;		err = clientcmdapi.FlattenConfig(newClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to flatten the kubeconfig for the given context %q: %v", contextName, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return util.CreateKubeconfigSecret(clientset, newClientConfig, namespace, secretName, federationName, joiningClusterName, dryRun)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createConfigMap creates a configmap with name kube-dns in the joining cluster
0000000000000000000000000000000000000000;;	// which stores the information about this federation zone name.
0000000000000000000000000000000000000000;;	// If the configmap with this name already exists, its updated with this information.
0000000000000000000000000000000000000000;;	func createConfigMap(hostClientSet internalclientset.Interface, config util.AdminConfig, fedSystemNamespace, federationName, joiningClusterName, targetClusterContext, kubeconfigPath string, dryRun bool) (*api.ConfigMap, error) {
0000000000000000000000000000000000000000;;		cmDep, err := getCMDeployment(hostClientSet, fedSystemNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		domainMap, ok := cmDep.Annotations[util.FedDomainMapKey]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("kube-dns config map data missing from controller manager annotations")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		targetFactory := config.ClusterFactory(targetClusterContext, kubeconfigPath)
0000000000000000000000000000000000000000;;		targetClientSet, err := targetFactory.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingConfigMap, err := targetClientSet.Core().ConfigMaps(metav1.NamespaceSystem).Get(util.KubeDnsConfigmapName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if isNotFound(err) {
0000000000000000000000000000000000000000;;			newConfigMap := &api.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      util.KubeDnsConfigmapName,
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespaceSystem,
0000000000000000000000000000000000000000;;					Annotations: map[string]string{
0000000000000000000000000000000000000000;;						federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;						federation.ClusterNameAnnotation:    joiningClusterName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Data: map[string]string{
0000000000000000000000000000000000000000;;					util.FedDomainMapKey: domainMap,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newConfigMap = populateStubDomainsIfRequired(newConfigMap, cmDep.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if dryRun {
0000000000000000000000000000000000000000;;				return newConfigMap, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return targetClientSet.Core().ConfigMaps(metav1.NamespaceSystem).Create(newConfigMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if existingConfigMap.Data == nil {
0000000000000000000000000000000000000000;;			existingConfigMap.Data = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := existingConfigMap.Data[util.FedDomainMapKey]; ok {
0000000000000000000000000000000000000000;;			// Append this federation info
0000000000000000000000000000000000000000;;			existingConfigMap.Data[util.FedDomainMapKey] = appendConfigMapString(existingConfigMap.Data[util.FedDomainMapKey], cmDep.Annotations[util.FedDomainMapKey])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// For some reason the configMap exists but this data is empty
0000000000000000000000000000000000000000;;			existingConfigMap.Data[util.FedDomainMapKey] = cmDep.Annotations[util.FedDomainMapKey]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return existingConfigMap, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return targetClientSet.Core().ConfigMaps(metav1.NamespaceSystem).Update(existingConfigMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clusterGenerator extracts the cluster information from the supplied
0000000000000000000000000000000000000000;;	// kubeconfig and builds a StructuredGenerator for the
0000000000000000000000000000000000000000;;	// `federation/cluster` API resource.
0000000000000000000000000000000000000000;;	func clusterGenerator(clientConfig *clientcmdapi.Config, name, contextName, secretName, serviceAccountName, clusterRoleName string) (kubectl.StructuredGenerator, error) {
0000000000000000000000000000000000000000;;		// Get the context from the config.
0000000000000000000000000000000000000000;;		ctx, found := clientConfig.Contexts[contextName]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cluster context %q not found", contextName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the cluster object corresponding to the supplied context.
0000000000000000000000000000000000000000;;		cluster, found := clientConfig.Clusters[ctx.Cluster]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cluster endpoint not found for %q", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extract the scheme portion of the cluster APIServer endpoint and
0000000000000000000000000000000000000000;;		// default it to `https` if it isn't specified.
0000000000000000000000000000000000000000;;		scheme := extractScheme(cluster.Server)
0000000000000000000000000000000000000000;;		serverAddress := cluster.Server
0000000000000000000000000000000000000000;;		if scheme == "" {
0000000000000000000000000000000000000000;;			// Use "https" as the default scheme.
0000000000000000000000000000000000000000;;			scheme := "https"
0000000000000000000000000000000000000000;;			serverAddress = strings.Join([]string{scheme, serverAddress}, "://")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generator := &kubectl.ClusterGeneratorV1Beta1{
0000000000000000000000000000000000000000;;			Name:               name,
0000000000000000000000000000000000000000;;			ClientCIDR:         defaultClientCIDR,
0000000000000000000000000000000000000000;;			ServerAddress:      serverAddress,
0000000000000000000000000000000000000000;;			SecretName:         secretName,
0000000000000000000000000000000000000000;;			ServiceAccountName: serviceAccountName,
0000000000000000000000000000000000000000;;			ClusterRoleName:    clusterRoleName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return generator, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractScheme parses the given URL to extract the scheme portion
0000000000000000000000000000000000000000;;	// out of it.
0000000000000000000000000000000000000000;;	func extractScheme(url string) string {
0000000000000000000000000000000000000000;;		scheme := ""
0000000000000000000000000000000000000000;;		segs := strings.SplitN(url, "://", 2)
0000000000000000000000000000000000000000;;		if len(segs) == 2 {
0000000000000000000000000000000000000000;;			scheme = segs[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scheme
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCMDeployment(hostClientSet internalclientset.Interface, fedNamespace string) (*extensions.Deployment, error) {
0000000000000000000000000000000000000000;;		depList, err := hostClientSet.Extensions().Deployments(fedNamespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, dep := range depList.Items {
0000000000000000000000000000000000000000;;			if strings.HasSuffix(dep.Name, CMNameSuffix) {
0000000000000000000000000000000000000000;;				return &dep, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("could not find the deployment for controller manager in host cluster")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendConfigMapString(existing string, toAppend string) string {
0000000000000000000000000000000000000000;;		if existing == "" {
0000000000000000000000000000000000000000;;			return toAppend
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		values := strings.Split(existing, ",")
0000000000000000000000000000000000000000;;		for _, v := range values {
0000000000000000000000000000000000000000;;			// Somehow this federation string is already present,
0000000000000000000000000000000000000000;;			// Nothing should be done
0000000000000000000000000000000000000000;;			if v == toAppend {
0000000000000000000000000000000000000000;;				return existing
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s,%s", existing, toAppend)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getFederationName gets the federation name from the appropriate annotation on the
0000000000000000000000000000000000000000;;	// control manager deployment.
0000000000000000000000000000000000000000;;	func getFederationName(hostClientSet internalclientset.Interface, fedNamespace string) (string, error) {
0000000000000000000000000000000000000000;;		d, err := getCMDeployment(hostClientSet, fedNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name, ok := d.Annotations[federation.FederationNameAnnotation]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Federation control manager does not have federation name annotation. Please recreate the federation with a newer version of kubefed, or use an older version of kubefed to join this cluster.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func populateStubDomainsIfRequired(configMap *api.ConfigMap, annotations map[string]string) *api.ConfigMap {
0000000000000000000000000000000000000000;;		dnsProvider := annotations[util.FedDNSProvider]
0000000000000000000000000000000000000000;;		dnsZoneName := annotations[util.FedDNSZoneName]
0000000000000000000000000000000000000000;;		nameServer := annotations[util.FedNameServer]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dnsProvider != util.FedDNSProviderCoreDNS || dnsZoneName == "" || nameServer == "" {
0000000000000000000000000000000000000000;;			return configMap
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		configMap.Data[util.KubeDnsStubDomains] = fmt.Sprintf(`{"%s":["%s"]}`, dnsZoneName, nameServer)
0000000000000000000000000000000000000000;;		return configMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createFederationSystemNamespace creates the federation-system namespace in the cluster
0000000000000000000000000000000000000000;;	// associated with clusterClientset, if it doesn't already exist.
0000000000000000000000000000000000000000;;	func createFederationSystemNamespace(clusterClientset internalclientset.Interface, federationNamespace, federationName, joiningClusterName string, dryRun bool) (*api.Namespace, error) {
0000000000000000000000000000000000000000;;		federationNS := &api.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: federationNamespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;					federation.ClusterNameAnnotation:    joiningClusterName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return federationNS, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := clusterClientset.Core().Namespaces().Create(federationNS)
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not create federation-system namespace in client: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return federationNS, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createRBACSecret creates a secret in the joining cluster using a service account, and
0000000000000000000000000000000000000000;;	// populates that secret into the host cluster to allow it to access the joining cluster.
0000000000000000000000000000000000000000;;	func createRBACSecret(hostClusterClientset, joiningClusterClientset internalclientset.Interface, namespace, federationName, joiningClusterName, hostClusterContext, joiningClusterContext, secretName string, dryRun bool) (*api.Secret, string, string, error) {
0000000000000000000000000000000000000000;;		glog.V(2).Info("Creating service account in joining cluster")
0000000000000000000000000000000000000000;;		saName, err := createServiceAccount(joiningClusterClientset, namespace, federationName, joiningClusterName, hostClusterContext, dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error creating service account in joining cluster: %v", err)
0000000000000000000000000000000000000000;;			return nil, "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Created service account in joining cluster")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Info("Creating role binding for service account in joining cluster")
0000000000000000000000000000000000000000;;		crb, err := createClusterRoleBinding(joiningClusterClientset, saName, namespace, federationName, joiningClusterName, dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error creating role binding for service account in joining cluster: %v", err)
0000000000000000000000000000000000000000;;			return nil, "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Created role binding for service account in joining cluster")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Info("Creating secret in host cluster")
0000000000000000000000000000000000000000;;		secret, err := populateSecretInHostCluster(joiningClusterClientset, hostClusterClientset, saName, namespace, federationName, joiningClusterName, secretName, dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error creating secret in host cluster: %v", err)
0000000000000000000000000000000000000000;;			return nil, "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Created secret in host cluster")
0000000000000000000000000000000000000000;;		return secret, saName, crb.Name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createServiceAccount creates a service account in the cluster associated with clusterClientset with
0000000000000000000000000000000000000000;;	// credentials that will be used by the host cluster to access its API server.
0000000000000000000000000000000000000000;;	func createServiceAccount(clusterClientset internalclientset.Interface, namespace, federationName, joiningClusterName, hostContext string, dryRun bool) (string, error) {
0000000000000000000000000000000000000000;;		saName := util.ClusterServiceAccountName(joiningClusterName, hostContext)
0000000000000000000000000000000000000000;;		sa := &api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      saName,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;					federation.ClusterNameAnnotation:    joiningClusterName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return saName, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new service account.
0000000000000000000000000000000000000000;;		_, err := clusterClientset.Core().ServiceAccounts(namespace).Create(sa)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return saName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createClusterRoleBinding creates an RBAC role and binding that allows the
0000000000000000000000000000000000000000;;	// service account identified by saName to access all resources in all namespaces
0000000000000000000000000000000000000000;;	// in the cluster associated with clusterClientset.
0000000000000000000000000000000000000000;;	func createClusterRoleBinding(clusterClientset internalclientset.Interface, saName, namespace, federationName, joiningClusterName string, dryRun bool) (*rbac.ClusterRoleBinding, error) {
0000000000000000000000000000000000000000;;		roleName := util.ClusterRoleName(federationName, saName)
0000000000000000000000000000000000000000;;		role := &rbac.ClusterRole{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      roleName,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;					federation.ClusterNameAnnotation:    joiningClusterName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				rbac.NewRule(rbac.VerbAll).Groups(rbac.APIGroupAll).Resources(rbac.ResourceAll).RuleOrDie(),
0000000000000000000000000000000000000000;;				rbac.NewRule("get").URLs("/healthz").RuleOrDie(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: This should limit its access to only necessary resources.
0000000000000000000000000000000000000000;;		rolebinding, err := rbac.NewClusterBinding(roleName).SAs(namespace, saName).Binding()
0000000000000000000000000000000000000000;;		rolebinding.ObjectMeta.Namespace = namespace
0000000000000000000000000000000000000000;;		rolebinding.ObjectMeta.Annotations = map[string]string{
0000000000000000000000000000000000000000;;			federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;			federation.ClusterNameAnnotation:    joiningClusterName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not create role binding for service account: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return &rolebinding, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = clusterClientset.Rbac().ClusterRoles().Create(role)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not create role for service account in joining cluster: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = clusterClientset.Rbac().ClusterRoleBindings().Create(&rolebinding)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not create role binding for service account in joining cluster: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rolebinding, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// populateSecretInHostCluster copies the service account secret for saName from the cluster
0000000000000000000000000000000000000000;;	// referenced by clusterClientset to the client referenced by hostClientset, putting it in a secret
0000000000000000000000000000000000000000;;	// named secretName in the provided namespace.
0000000000000000000000000000000000000000;;	func populateSecretInHostCluster(clusterClientset, hostClientset internalclientset.Interface, saName, namespace, federationName, joiningClusterName, secretName string, dryRun bool) (*api.Secret, error) {
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			// The secret is created indirectly with the service account, and so there is no local copy to return in a dry run.
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get the secret from the joining cluster.
0000000000000000000000000000000000000000;;		var sa *api.ServiceAccount
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(1*time.Second, serviceAccountSecretTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			sa, err = clusterClientset.Core().ServiceAccounts(namespace).Get(saName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return len(sa.Secrets) == 1, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Getting secret named: %s", sa.Secrets[0].Name)
0000000000000000000000000000000000000000;;		var secret *api.Secret
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, serviceAccountSecretTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			secret, err = clusterClientset.Core().Secrets(namespace).Get(sa.Secrets[0].Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not get service account secret from joining cluster: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a parallel secret in the host cluster.
0000000000000000000000000000000000000000;;		v1Secret := api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      secretName,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;					federation.ClusterNameAnnotation:    joiningClusterName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: secret.Data,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Creating secret in host cluster named: %s", v1Secret.Name)
0000000000000000000000000000000000000000;;		_, err = hostClientset.Core().Secrets(namespace).Create(&v1Secret)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Could not create secret in host cluster: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1Secret, nil
0000000000000000000000000000000000000000;;	}
