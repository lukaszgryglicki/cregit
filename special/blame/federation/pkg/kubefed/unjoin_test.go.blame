0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1f89c5d2763b7527251904d7959bb19923c4f4a4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubefed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		kubefedtesting "k8s.io/kubernetes/federation/pkg/kubefed/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/kubefed/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnjoinFederation(t *testing.T) {
0000000000000000000000000000000000000000;;		cmdErrMsg := ""
0000000000000000000000000000000000000000;;		cmdutil.BehaviorOnFatal(func(str string, code int) {
0000000000000000000000000000000000000000;;			cmdErrMsg = str
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeKubeFiles, err := kubefedtesting.FakeKubeconfigFiles()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer kubefedtesting.RemoveFakeKubeconfigFiles(fakeKubeFiles)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			cluster            string
0000000000000000000000000000000000000000;;			wantCluster        string
0000000000000000000000000000000000000000;;			wantSecret         string
0000000000000000000000000000000000000000;;			kubeconfigGlobal   string
0000000000000000000000000000000000000000;;			kubeconfigExplicit string
0000000000000000000000000000000000000000;;			expectedServer     string
0000000000000000000000000000000000000000;;			expectedErr        string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Tests that the contexts and credentials are read from the
0000000000000000000000000000000000000000;;			// global, default kubeconfig and the correct cluster resource
0000000000000000000000000000000000000000;;			// is deregisterd and configmap kube-dns is removed from that cluster.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cluster:            "syndicate",
0000000000000000000000000000000000000000;;				wantCluster:        "syndicate",
0000000000000000000000000000000000000000;;				wantSecret:         "",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:   fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit: "",
0000000000000000000000000000000000000000;;				expectedServer:     "https://10.20.30.40",
0000000000000000000000000000000000000000;;				expectedErr:        "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Tests that the contexts and credentials are read from the
0000000000000000000000000000000000000000;;			// explicit kubeconfig file specified and the correct cluster
0000000000000000000000000000000000000000;;			// resource is deregisterd and configmap kube-dns is removed from that cluster.
0000000000000000000000000000000000000000;;			// kubeconfig contains a single cluster and context.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cluster:            "ally",
0000000000000000000000000000000000000000;;				wantCluster:        "ally",
0000000000000000000000000000000000000000;;				wantSecret:         "",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:   fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit: fakeKubeFiles[1],
0000000000000000000000000000000000000000;;				expectedServer:     "http://ally256.example.com:80",
0000000000000000000000000000000000000000;;				expectedErr:        "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Tests that the contexts and credentials are read from the
0000000000000000000000000000000000000000;;			// explicit kubeconfig file specified and the correct cluster
0000000000000000000000000000000000000000;;			// resource is deregisterd and configmap kube-dns is removed from that
0000000000000000000000000000000000000000;;			// cluster. kubeconfig consists of multiple clusters and contexts.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cluster:            "confederate",
0000000000000000000000000000000000000000;;				wantCluster:        "confederate",
0000000000000000000000000000000000000000;;				wantSecret:         "",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:   fakeKubeFiles[1],
0000000000000000000000000000000000000000;;				kubeconfigExplicit: fakeKubeFiles[2],
0000000000000000000000000000000000000000;;				expectedServer:     "https://10.8.8.8",
0000000000000000000000000000000000000000;;				expectedErr:        "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Negative test to ensure that we get the right warning
0000000000000000000000000000000000000000;;			// when the specified cluster to deregister is not found.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cluster:            "noexist",
0000000000000000000000000000000000000000;;				wantCluster:        "affiliate",
0000000000000000000000000000000000000000;;				wantSecret:         "",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:   fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit: "",
0000000000000000000000000000000000000000;;				expectedServer:     "https://10.20.30.40",
0000000000000000000000000000000000000000;;				expectedErr:        fmt.Sprintf("WARNING: cluster %q not found in federation, so its credentials' secret couldn't be deleted", "affiliate"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Negative test to ensure that we get the right warning
0000000000000000000000000000000000000000;;			// when the specified cluster's credentials secret is not
0000000000000000000000000000000000000000;;			// found.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cluster:            "affiliate",
0000000000000000000000000000000000000000;;				wantCluster:        "affiliate",
0000000000000000000000000000000000000000;;				wantSecret:         "noexist",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:   fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit: "",
0000000000000000000000000000000000000000;;				expectedServer:     "https://10.20.30.40",
0000000000000000000000000000000000000000;;				expectedErr:        fmt.Sprintf("WARNING: secret %q not found in the host cluster, so it couldn't be deleted. Cluster has already been removed from the federation.", "noexist"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// TODO: Figure out a way to test the scenarios of configmap deletion
0000000000000000000000000000000000000000;;			// As of now we delete the config map after deriving the clientset using
0000000000000000000000000000000000000000;;			// the cluster object we retrieved from the federation server and the
0000000000000000000000000000000000000000;;			// secret object retrieved from the base cluster.
0000000000000000000000000000000000000000;;			// Still to find out a way to introduce some fakes and unit test this path.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			cmdErrMsg = ""
0000000000000000000000000000000000000000;;			f := testUnjoinFederationFactory(tc.cluster, tc.expectedServer, tc.wantSecret)
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;			errBuf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hostFactory := fakeUnjoinHostFactory(tc.cluster)
0000000000000000000000000000000000000000;;			adminConfig, err := kubefedtesting.NewFakeAdminConfig(hostFactory, nil, "", tc.kubeconfigGlobal)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := NewCmdUnjoin(f, buf, errBuf, adminConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd.Flags().Set("kubeconfig", tc.kubeconfigExplicit)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("host", "substrate")
0000000000000000000000000000000000000000;;			cmd.Run(cmd, []string{tc.wantCluster})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.expectedErr == "" {
0000000000000000000000000000000000000000;;				// uses the name from the cluster, not the response
0000000000000000000000000000000000000000;;				// Actual data passed are tested in the fake secret and cluster
0000000000000000000000000000000000000000;;				// REST clients.
0000000000000000000000000000000000000000;;				if msg := buf.String(); msg != fmt.Sprintf("Successfully removed cluster %q from federation\n", tc.cluster) {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected output: %s", i, msg)
0000000000000000000000000000000000000000;;					if cmdErrMsg != "" {
0000000000000000000000000000000000000000;;						t.Errorf("[%d] unexpected error message: %s", i, cmdErrMsg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO: There are warnings posted on errBuf, which we ignore as of now
0000000000000000000000000000000000000000;;				// and we should be able to test out these warnings also in future.
0000000000000000000000000000000000000000;;				// This is linked to the previous todo comment.
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if errMsg := errBuf.String(); errMsg != tc.expectedErr {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expected warning: %s, got: %s, output: %s", i, tc.expectedErr, errMsg, buf.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testUnjoinFederationFactory(name, server, secret string) cmdutil.Factory {
0000000000000000000000000000000000000000;;		urlPrefix := "/clusters/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster := fakeCluster(name, name, server, true)
0000000000000000000000000000000000000000;;		if secret != "" {
0000000000000000000000000000000000000000;;			cluster.Spec.SecretRef.Name = secret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, _, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		codec := testapi.Federation.Codec()
0000000000000000000000000000000000000000;;		tf.ClientConfig = kubefedtesting.DefaultClientConfig()
0000000000000000000000000000000000000000;;		ns := testapi.Federation.NegotiatedSerializer()
0000000000000000000000000000000000000000;;		tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;			GroupName:            "federation",
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case strings.HasPrefix(p, urlPrefix):
0000000000000000000000000000000000000000;;					got := strings.TrimPrefix(p, urlPrefix)
0000000000000000000000000000000000000000;;					if got != name {
0000000000000000000000000000000000000000;;						return nil, errors.NewNotFound(federationapi.Resource("clusters"), got)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					switch m {
0000000000000000000000000000000000000000;;					case http.MethodGet:
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &cluster)}, nil
0000000000000000000000000000000000000000;;					case http.MethodDelete:
0000000000000000000000000000000000000000;;						status := metav1.Status{
0000000000000000000000000000000000000000;;							Status: "Success",
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &status)}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected method: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tf.Namespace = "test"
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeUnjoinHostFactory(clusterName string) cmdutil.Factory {
0000000000000000000000000000000000000000;;		secretsPrefix := "/api/v1/namespaces/federation-system/secrets/"
0000000000000000000000000000000000000000;;		clusterRolePrefix := "/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/"
0000000000000000000000000000000000000000;;		serviceAccountPrefix := "/api/v1/namespaces/federation-system/serviceaccounts/"
0000000000000000000000000000000000000000;;		clusterRoleBindingPrefix := "/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Using dummy bytes for now
0000000000000000000000000000000000000000;;		configBytes, _ := clientcmd.Write(clientcmdapi.Config{})
0000000000000000000000000000000000000000;;		secretObject := v1.Secret{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Secret",
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      clusterName,
0000000000000000000000000000000000000000;;				Namespace: util.DefaultFederationSystemNamespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"kubeconfig": configBytes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		ns := dynamic.ContentConfig().NegotiatedSerializer
0000000000000000000000000000000000000000;;		tf.ClientConfig = kubefedtesting.DefaultClientConfig()
0000000000000000000000000000000000000000;;		tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case strings.HasPrefix(p, secretsPrefix):
0000000000000000000000000000000000000000;;					switch m {
0000000000000000000000000000000000000000;;					case http.MethodDelete:
0000000000000000000000000000000000000000;;						got := strings.TrimPrefix(p, secretsPrefix)
0000000000000000000000000000000000000000;;						if got != clusterName {
0000000000000000000000000000000000000000;;							return nil, errors.NewNotFound(api.Resource("secrets"), got)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						status := metav1.Status{
0000000000000000000000000000000000000000;;							Status: "Success",
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &status)}, nil
0000000000000000000000000000000000000000;;					case http.MethodGet:
0000000000000000000000000000000000000000;;						got := strings.TrimPrefix(p, secretsPrefix)
0000000000000000000000000000000000000000;;						if got != clusterName {
0000000000000000000000000000000000000000;;							return nil, errors.NewNotFound(api.Resource("secrets"), got)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &secretObject)}, nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected request method: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case strings.HasPrefix(p, serviceAccountPrefix) && m == http.MethodDelete:
0000000000000000000000000000000000000000;;					got := strings.TrimPrefix(p, serviceAccountPrefix)
0000000000000000000000000000000000000000;;					want := serviceAccountName(clusterName)
0000000000000000000000000000000000000000;;					if got != want {
0000000000000000000000000000000000000000;;						return nil, errors.NewNotFound(api.Resource("serviceaccounts"), got)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					status := metav1.Status{
0000000000000000000000000000000000000000;;						Status: "Success",
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &status)}, nil
0000000000000000000000000000000000000000;;				case strings.HasPrefix(p, clusterRoleBindingPrefix) && m == http.MethodDelete:
0000000000000000000000000000000000000000;;					got := strings.TrimPrefix(p, clusterRoleBindingPrefix)
0000000000000000000000000000000000000000;;					want := util.ClusterRoleName(testFederationName, serviceAccountName(clusterName))
0000000000000000000000000000000000000000;;					if got != want {
0000000000000000000000000000000000000000;;						return nil, errors.NewNotFound(api.Resource("clusterrolebindings"), got)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					status := metav1.Status{
0000000000000000000000000000000000000000;;						Status: "Success",
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &status)}, nil
0000000000000000000000000000000000000000;;				case strings.HasPrefix(p, clusterRolePrefix) && m == http.MethodDelete:
0000000000000000000000000000000000000000;;					got := strings.TrimPrefix(p, clusterRolePrefix)
0000000000000000000000000000000000000000;;					want := util.ClusterRoleName(testFederationName, serviceAccountName(clusterName))
0000000000000000000000000000000000000000;;					if got != want {
0000000000000000000000000000000000000000;;						return nil, errors.NewNotFound(api.Resource("clusterroles"), got)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					status := metav1.Status{
0000000000000000000000000000000000000000;;						Status: "Success",
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &status)}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
