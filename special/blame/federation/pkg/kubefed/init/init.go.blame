0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9d469461e839945a4559e30ddbb98eeb5e9aa174;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(madhusdancs):
0000000000000000000000000000000000000000;;	// 1. Make printSuccess prepend protocol/scheme to the IPs/hostnames.
0000000000000000000000000000000000000000;;	// 2. Separate etcd container from API server pod as a first step towards enabling HA.
0000000000000000000000000000000000000000;;	// 3. Make API server and controller manager replicas customizable via the HA work.
0000000000000000000000000000000000000000;;	package init
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		triple "k8s.io/client-go/util/cert/triple"
0000000000000000000000000000000000000000;;		kubeconfigutil "k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/dnsprovider/providers/coredns"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/kubefed/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		client "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		APIServerCN                 = "federation-apiserver"
0000000000000000000000000000000000000000;;		ControllerManagerCN         = "federation-controller-manager"
0000000000000000000000000000000000000000;;		AdminCN                     = "admin"
0000000000000000000000000000000000000000;;		HostClusterLocalDNSZoneName = "cluster.local."
0000000000000000000000000000000000000000;;		APIServerNameSuffix         = "apiserver"
0000000000000000000000000000000000000000;;		CMNameSuffix                = "controller-manager"
0000000000000000000000000000000000000000;;		CredentialSuffix            = "credentials"
0000000000000000000000000000000000000000;;		KubeconfigNameSuffix        = "kubeconfig"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// User name used by federation controller manager to make
0000000000000000000000000000000000000000;;		// calls to federation API server.
0000000000000000000000000000000000000000;;		ControllerManagerUser = "federation-controller-manager"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the ServiceAccount used by the federation controller manager
0000000000000000000000000000000000000000;;		// to access the secrets in the host cluster.
0000000000000000000000000000000000000000;;		ControllerManagerSA = "federation-controller-manager"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Group name of the legacy/core API group
0000000000000000000000000000000000000000;;		legacyAPIGroup = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lbAddrRetryInterval = 5 * time.Second
0000000000000000000000000000000000000000;;		podWaitInterval     = 2 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiserverServiceTypeFlag      = "api-server-service-type"
0000000000000000000000000000000000000000;;		apiserverAdvertiseAddressFlag = "api-server-advertise-address"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dnsProviderSecretName = "federation-dns-provider.conf"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServerSecurePortName = "https"
0000000000000000000000000000000000000000;;		// Set the secure port to 8443 to avoid requiring root privileges
0000000000000000000000000000000000000000;;		// to bind to port < 1000.  The apiserver's service will still
0000000000000000000000000000000000000000;;		// expose on port 443.
0000000000000000000000000000000000000000;;		apiServerSecurePort = 8443
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		init_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Initialize a federation control plane.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        Federation control plane is hosted inside a Kubernetes
0000000000000000000000000000000000000000;;	        cluster. The host cluster must be specified using the
0000000000000000000000000000000000000000;;	        --host-cluster-context flag.`)
0000000000000000000000000000000000000000;;		init_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Initialize federation control plane for a federation
0000000000000000000000000000000000000000;;			# named foo in the host cluster whose local kubeconfig
0000000000000000000000000000000000000000;;			# context is bar.
0000000000000000000000000000000000000000;;			kubefed init foo --host-cluster-context=bar`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		componentLabel = map[string]string{
0000000000000000000000000000000000000000;;			"app": "federated-cluster",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiserverSvcSelector = map[string]string{
0000000000000000000000000000000000000000;;			"app":    "federated-cluster",
0000000000000000000000000000000000000000;;			"module": "federation-apiserver",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiserverPodLabels = map[string]string{
0000000000000000000000000000000000000000;;			"app":    "federated-cluster",
0000000000000000000000000000000000000000;;			"module": "federation-apiserver",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controllerManagerPodLabels = map[string]string{
0000000000000000000000000000000000000000;;			"app":    "federated-cluster",
0000000000000000000000000000000000000000;;			"module": "federation-controller-manager",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initFederation struct {
0000000000000000000000000000000000000000;;		commonOptions util.SubcommandOptions
0000000000000000000000000000000000000000;;		options       initFederationOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initFederationOptions struct {
0000000000000000000000000000000000000000;;		dnsZoneName                      string
0000000000000000000000000000000000000000;;		serverImage                      string
0000000000000000000000000000000000000000;;		dnsProvider                      string
0000000000000000000000000000000000000000;;		dnsProviderConfig                string
0000000000000000000000000000000000000000;;		etcdImage                        string
0000000000000000000000000000000000000000;;		etcdPVCapacity                   string
0000000000000000000000000000000000000000;;		etcdPVStorageClass               string
0000000000000000000000000000000000000000;;		etcdPersistentStorage            bool
0000000000000000000000000000000000000000;;		dryRun                           bool
0000000000000000000000000000000000000000;;		apiServerOverridesString         string
0000000000000000000000000000000000000000;;		apiServerOverrides               map[string]string
0000000000000000000000000000000000000000;;		controllerManagerOverridesString string
0000000000000000000000000000000000000000;;		controllerManagerOverrides       map[string]string
0000000000000000000000000000000000000000;;		apiServerServiceTypeString       string
0000000000000000000000000000000000000000;;		apiServerServiceType             v1.ServiceType
0000000000000000000000000000000000000000;;		apiServerAdvertiseAddress        string
0000000000000000000000000000000000000000;;		apiServerEnableHTTPBasicAuth     bool
0000000000000000000000000000000000000000;;		apiServerEnableTokenAuth         bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *initFederationOptions) Bind(flags *pflag.FlagSet, defaultServerImage, defaultEtcdImage string) {
0000000000000000000000000000000000000000;;		flags.StringVar(&o.dnsZoneName, "dns-zone-name", "", "DNS suffix for this federation. Federated Service DNS names are published with this suffix.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.serverImage, "image", defaultServerImage, "Image to use for federation API server and controller manager binaries.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.dnsProvider, "dns-provider", "", "Dns provider to be used for this deployment.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.dnsProviderConfig, "dns-provider-config", "", "Config file path on local file system for configuring DNS provider.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.etcdImage, "etcd-image", defaultEtcdImage, "Image to use for etcd server.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.etcdPVCapacity, "etcd-pv-capacity", "10Gi", "Size of persistent volume claim to be used for etcd.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.etcdPVStorageClass, "etcd-pv-storage-class", "", "The storage class of the persistent volume claim used for etcd.   Must be provided if a default storage class is not enabled for the host cluster.")
0000000000000000000000000000000000000000;;		flags.BoolVar(&o.etcdPersistentStorage, "etcd-persistent-storage", true, "Use persistent volume for etcd. Defaults to 'true'.")
0000000000000000000000000000000000000000;;		flags.BoolVar(&o.dryRun, "dry-run", false, "dry run without sending commands to server.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.apiServerOverridesString, "apiserver-arg-overrides", "", "comma separated list of federation-apiserver arguments to override: Example \"--arg1=value1,--arg2=value2...\"")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.controllerManagerOverridesString, "controllermanager-arg-overrides", "", "comma separated list of federation-controller-manager arguments to override: Example \"--arg1=value1,--arg2=value2...\"")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.apiServerServiceTypeString, apiserverServiceTypeFlag, string(v1.ServiceTypeLoadBalancer), "The type of service to create for federation API server. Options: 'LoadBalancer' (default), 'NodePort'.")
0000000000000000000000000000000000000000;;		flags.StringVar(&o.apiServerAdvertiseAddress, apiserverAdvertiseAddressFlag, "", "Preferred address to advertise api server nodeport service. Valid only if '"+apiserverServiceTypeFlag+"=NodePort'.")
0000000000000000000000000000000000000000;;		flags.BoolVar(&o.apiServerEnableHTTPBasicAuth, "apiserver-enable-basic-auth", false, "Enables HTTP Basic authentication for the federation-apiserver. Defaults to false.")
0000000000000000000000000000000000000000;;		flags.BoolVar(&o.apiServerEnableTokenAuth, "apiserver-enable-token-auth", false, "Enables token authentication for the federation-apiserver. Defaults to false.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdInit defines the `init` command that bootstraps a federation
0000000000000000000000000000000000000000;;	// control plane inside a set of host clusters.
0000000000000000000000000000000000000000;;	func NewCmdInit(cmdOut io.Writer, config util.AdminConfig, defaultServerImage, defaultEtcdImage string) *cobra.Command {
0000000000000000000000000000000000000000;;		opts := &initFederation{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "init FEDERATION_NAME --host-cluster-context=HOST_CONTEXT",
0000000000000000000000000000000000000000;;			Short:   "init initializes a federation control plane",
0000000000000000000000000000000000000000;;			Long:    init_long,
0000000000000000000000000000000000000000;;			Example: init_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.Complete(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.Run(cmdOut, config))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags := cmd.Flags()
0000000000000000000000000000000000000000;;		opts.commonOptions.Bind(flags)
0000000000000000000000000000000000000000;;		opts.options.Bind(flags, defaultServerImage, defaultEtcdImage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type entityKeyPairs struct {
0000000000000000000000000000000000000000;;		ca                *triple.KeyPair
0000000000000000000000000000000000000000;;		server            *triple.KeyPair
0000000000000000000000000000000000000000;;		controllerManager *triple.KeyPair
0000000000000000000000000000000000000000;;		admin             *triple.KeyPair
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type credentials struct {
0000000000000000000000000000000000000000;;		username        string
0000000000000000000000000000000000000000;;		password        string
0000000000000000000000000000000000000000;;		token           string
0000000000000000000000000000000000000000;;		certEntKeyPairs *entityKeyPairs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete ensures that options are valid and marshals them if necessary.
0000000000000000000000000000000000000000;;	func (i *initFederation) Complete(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;		if len(i.options.dnsProvider) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("--dns-provider is mandatory")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := i.commonOptions.SetName(cmd, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i.options.apiServerServiceType = v1.ServiceType(i.options.apiServerServiceTypeString)
0000000000000000000000000000000000000000;;		if i.options.apiServerServiceType != v1.ServiceTypeLoadBalancer && i.options.apiServerServiceType != v1.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid %s: %s, should be either %s or %s", apiserverServiceTypeFlag, i.options.apiServerServiceType, v1.ServiceTypeLoadBalancer, v1.ServiceTypeNodePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i.options.apiServerAdvertiseAddress != "" {
0000000000000000000000000000000000000000;;			ip := net.ParseIP(i.options.apiServerAdvertiseAddress)
0000000000000000000000000000000000000000;;			if ip == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid %s: %s, should be a valid ip address", apiserverAdvertiseAddressFlag, i.options.apiServerAdvertiseAddress)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i.options.apiServerServiceType != v1.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;				return fmt.Errorf("%s should be passed only with '%s=NodePort'", apiserverAdvertiseAddressFlag, apiserverServiceTypeFlag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i.options.apiServerOverrides, err = marshallOverrides(i.options.apiServerOverridesString)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error marshalling --apiserver-arg-overrides: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.options.controllerManagerOverrides, err = marshallOverrides(i.options.controllerManagerOverridesString)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error marshalling --controllermanager-arg-overrides: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i.options.dnsProviderConfig != "" {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(i.options.dnsProviderConfig); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error reading file provided to --dns-provider-config flag, err: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run initializes a federation control plane.
0000000000000000000000000000000000000000;;	// See the design doc in https://github.com/kubernetes/kubernetes/pull/34484
0000000000000000000000000000000000000000;;	// for details.
0000000000000000000000000000000000000000;;	func (i *initFederation) Run(cmdOut io.Writer, config util.AdminConfig) error {
0000000000000000000000000000000000000000;;		hostFactory := config.ClusterFactory(i.commonOptions.Host, i.commonOptions.Kubeconfig)
0000000000000000000000000000000000000000;;		hostClientset, err := hostFactory.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rbacAvailable := true
0000000000000000000000000000000000000000;;		rbacVersionedClientset, err := util.GetVersionedClientForRBACOrFail(hostFactory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(*util.NoRBACAPIError); !ok {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the error is type NoRBACAPIError, We continue to create the rest of
0000000000000000000000000000000000000000;;			// the resources, without the SA and roles (in the abscense of RBAC support).
0000000000000000000000000000000000000000;;			rbacAvailable = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverName := fmt.Sprintf("%s-%s", i.commonOptions.Name, APIServerNameSuffix)
0000000000000000000000000000000000000000;;		serverCredName := fmt.Sprintf("%s-%s", serverName, CredentialSuffix)
0000000000000000000000000000000000000000;;		cmName := fmt.Sprintf("%s-%s", i.commonOptions.Name, CMNameSuffix)
0000000000000000000000000000000000000000;;		cmKubeconfigName := fmt.Sprintf("%s-%s", cmName, KubeconfigNameSuffix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dnsProviderConfigBytes []byte
0000000000000000000000000000000000000000;;		if i.options.dnsProviderConfig != "" {
0000000000000000000000000000000000000000;;			dnsProviderConfigBytes, err = ioutil.ReadFile(i.options.dnsProviderConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error reading file provided to --dns-provider-config flag, err: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(cmdOut, "Creating a namespace %s for federation system components...", i.commonOptions.FederationSystemNamespace)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Creating a namespace %s for federation system components", i.commonOptions.FederationSystemNamespace)
0000000000000000000000000000000000000000;;		_, err = createNamespace(hostClientset, i.commonOptions.Name, i.commonOptions.FederationSystemNamespace, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(cmdOut, " done")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprint(cmdOut, "Creating federation control plane service...")
0000000000000000000000000000000000000000;;		glog.V(4).Info("Creating federation control plane service")
0000000000000000000000000000000000000000;;		svc, ips, hostnames, err := createService(cmdOut, hostClientset, i.commonOptions.FederationSystemNamespace, serverName, i.commonOptions.Name, i.options.apiServerAdvertiseAddress, i.options.apiServerServiceType, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(cmdOut, " done")
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Created service named %s with IP addresses %v, hostnames %v", svc.Name, ips, hostnames)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprint(cmdOut, "Creating federation control plane objects (credentials, persistent volume claim)...")
0000000000000000000000000000000000000000;;		glog.V(4).Info("Generating TLS certificates and credentials for communicating with the federation API server")
0000000000000000000000000000000000000000;;		credentials, err := generateCredentials(i.commonOptions.FederationSystemNamespace, i.commonOptions.Name, svc.Name, HostClusterLocalDNSZoneName, serverCredName, ips, hostnames, i.options.apiServerEnableHTTPBasicAuth, i.options.apiServerEnableTokenAuth, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the secret containing the credentials.
0000000000000000000000000000000000000000;;		_, err = createAPIServerCredentialsSecret(hostClientset, i.commonOptions.FederationSystemNamespace, serverCredName, i.commonOptions.Name, credentials, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info("Certificates and credentials generated")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Info("Creating an entry in the kubeconfig file with the certificate and credential data")
0000000000000000000000000000000000000000;;		_, err = createControllerManagerKubeconfigSecret(hostClientset, i.commonOptions.FederationSystemNamespace, i.commonOptions.Name, svc.Name, cmKubeconfigName, credentials.certEntKeyPairs, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info("Credentials secret successfully created")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Info("Creating a persistent volume and a claim to store the federation API server's state, including etcd data")
0000000000000000000000000000000000000000;;		var pvc *api.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		if i.options.etcdPersistentStorage {
0000000000000000000000000000000000000000;;			pvc, err = createPVC(hostClientset, i.commonOptions.FederationSystemNamespace, svc.Name, i.commonOptions.Name, i.options.etcdPVCapacity, i.options.etcdPVStorageClass, i.options.dryRun)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info("Persistent volume and claim created")
0000000000000000000000000000000000000000;;		fmt.Fprintln(cmdOut, " done")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Since only one IP address can be specified as advertise address,
0000000000000000000000000000000000000000;;		// we arbitrarily pick the first available IP address
0000000000000000000000000000000000000000;;		// Pick user provided apiserverAdvertiseAddress over other available IP addresses.
0000000000000000000000000000000000000000;;		advertiseAddress := i.options.apiServerAdvertiseAddress
0000000000000000000000000000000000000000;;		if advertiseAddress == "" && len(ips) > 0 {
0000000000000000000000000000000000000000;;			advertiseAddress = ips[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprint(cmdOut, "Creating federation component deployments...")
0000000000000000000000000000000000000000;;		glog.V(4).Info("Creating federation control plane components")
0000000000000000000000000000000000000000;;		_, err = createAPIServer(hostClientset, i.commonOptions.FederationSystemNamespace, serverName, i.commonOptions.Name, i.options.serverImage, i.options.etcdImage, advertiseAddress, serverCredName, i.options.apiServerEnableHTTPBasicAuth, i.options.apiServerEnableTokenAuth, i.options.apiServerOverrides, pvc, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info("Successfully created federation API server")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sa := &api.ServiceAccount{}
0000000000000000000000000000000000000000;;		sa.Name = ""
0000000000000000000000000000000000000000;;		// Create a service account and related RBAC roles if the host cluster has RBAC support.
0000000000000000000000000000000000000000;;		// TODO: We must evaluate creating a separate service account even when RBAC support is missing
0000000000000000000000000000000000000000;;		if rbacAvailable {
0000000000000000000000000000000000000000;;			glog.V(4).Info("Creating service account for federation controller manager in the host cluster")
0000000000000000000000000000000000000000;;			sa, err = createControllerManagerSA(rbacVersionedClientset, i.commonOptions.FederationSystemNamespace, i.commonOptions.Name, i.options.dryRun)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Info("Successfully created federation controller manager service account")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Info("Creating RBAC role and role bindings for the federation controller manager's service account")
0000000000000000000000000000000000000000;;			_, _, err = createRoleBindings(rbacVersionedClientset, i.commonOptions.FederationSystemNamespace, sa.Name, i.commonOptions.Name, i.options.dryRun)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Info("Successfully created RBAC role and role bindings")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Info("Creating a DNS provider config secret")
0000000000000000000000000000000000000000;;		dnsProviderSecret, err := createDNSProviderConfigSecret(hostClientset, i.commonOptions.FederationSystemNamespace, dnsProviderSecretName, i.commonOptions.Name, dnsProviderConfigBytes, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info("Successfully created DNS provider config secret")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Info("Creating federation controller manager deployment")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = createControllerManager(hostClientset, i.commonOptions.FederationSystemNamespace, i.commonOptions.Name, svc.Name, cmName, i.options.serverImage, cmKubeconfigName, i.options.dnsZoneName, i.options.dnsProvider, i.options.dnsProviderConfig, sa.Name, dnsProviderSecret, i.options.controllerManagerOverrides, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info("Successfully created federation controller manager deployment")
0000000000000000000000000000000000000000;;		fmt.Fprintln(cmdOut, " done")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprint(cmdOut, "Updating kubeconfig...")
0000000000000000000000000000000000000000;;		glog.V(4).Info("Updating kubeconfig")
0000000000000000000000000000000000000000;;		// Pick the first ip/hostname to update the api server endpoint in kubeconfig and also to give information to user
0000000000000000000000000000000000000000;;		// In case of NodePort Service for api server, ips are node external ips.
0000000000000000000000000000000000000000;;		endpoint := ""
0000000000000000000000000000000000000000;;		if len(ips) > 0 {
0000000000000000000000000000000000000000;;			endpoint = ips[0]
0000000000000000000000000000000000000000;;		} else if len(hostnames) > 0 {
0000000000000000000000000000000000000000;;			endpoint = hostnames[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the service is nodeport, need to append the port to endpoint as it is non-standard port
0000000000000000000000000000000000000000;;		if i.options.apiServerServiceType == v1.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;			endpoint = endpoint + ":" + strconv.Itoa(int(svc.Spec.Ports[0].NodePort))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = updateKubeconfig(config, i.commonOptions.Name, endpoint, i.commonOptions.Kubeconfig, credentials, i.options.dryRun)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Failed to update kubeconfig: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(cmdOut, " done")
0000000000000000000000000000000000000000;;		glog.V(4).Info("Successfully updated kubeconfig")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !i.options.dryRun {
0000000000000000000000000000000000000000;;			fmt.Fprint(cmdOut, "Waiting for federation control plane to come up...")
0000000000000000000000000000000000000000;;			glog.V(4).Info("Waiting for federation control plane to come up")
0000000000000000000000000000000000000000;;			fedPods := []string{serverName, cmName}
0000000000000000000000000000000000000000;;			err = waitForPods(cmdOut, hostClientset, fedPods, i.commonOptions.FederationSystemNamespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = waitSrvHealthy(cmdOut, config, i.commonOptions.Name, i.commonOptions.Kubeconfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Info("Federation control plane running")
0000000000000000000000000000000000000000;;			fmt.Fprintln(cmdOut, " done")
0000000000000000000000000000000000000000;;			return printSuccess(cmdOut, ips, hostnames, svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintln(cmdOut, "Federation control plane runs (dry run)")
0000000000000000000000000000000000000000;;		glog.V(4).Info("Federation control plane runs (dry run)")
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createNamespace(clientset client.Interface, federationName, namespace string, dryRun bool) (*api.Namespace, error) {
0000000000000000000000000000000000000000;;		ns := &api.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return ns, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientset.Core().Namespaces().Create(ns)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createService(cmdOut io.Writer, clientset client.Interface, namespace, svcName, federationName, apiserverAdvertiseAddress string, apiserverServiceType v1.ServiceType, dryRun bool) (*api.Service, []string, []string, error) {
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        svcName,
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Labels:      componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type:     api.ServiceType(apiserverServiceType),
0000000000000000000000000000000000000000;;				Selector: apiserverSvcSelector,
0000000000000000000000000000000000000000;;				Ports: []api.ServicePort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       "https",
0000000000000000000000000000000000000000;;						Protocol:   "TCP",
0000000000000000000000000000000000000000;;						Port:       443,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromString(apiServerSecurePortName),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return svc, nil, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		svc, err = clientset.Core().Services(namespace).Create(svc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ips := []string{}
0000000000000000000000000000000000000000;;		hostnames := []string{}
0000000000000000000000000000000000000000;;		if apiserverServiceType == v1.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			ips, hostnames, err = waitForLoadBalancerAddress(cmdOut, clientset, svc, dryRun)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if apiserverAdvertiseAddress != "" {
0000000000000000000000000000000000000000;;				ips = append(ips, apiserverAdvertiseAddress)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ips, err = getClusterNodeIPs(clientset)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return svc, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return svc, ips, hostnames, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getClusterNodeIPs(clientset client.Interface) ([]string, error) {
0000000000000000000000000000000000000000;;		preferredAddressTypes := []api.NodeAddressType{
0000000000000000000000000000000000000000;;			api.NodeExternalIP,
0000000000000000000000000000000000000000;;			api.NodeInternalIP,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeList, err := clientset.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeAddresses := []string{}
0000000000000000000000000000000000000000;;		for _, node := range nodeList.Items {
0000000000000000000000000000000000000000;;		OuterLoop:
0000000000000000000000000000000000000000;;			for _, addressType := range preferredAddressTypes {
0000000000000000000000000000000000000000;;				for _, address := range node.Status.Addresses {
0000000000000000000000000000000000000000;;					if address.Type == addressType {
0000000000000000000000000000000000000000;;						nodeAddresses = append(nodeAddresses, address.Address)
0000000000000000000000000000000000000000;;						break OuterLoop
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodeAddresses, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForLoadBalancerAddress(cmdOut io.Writer, clientset client.Interface, svc *api.Service, dryRun bool) ([]string, []string, error) {
0000000000000000000000000000000000000000;;		ips := []string{}
0000000000000000000000000000000000000000;;		hostnames := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return ips, hostnames, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := wait.PollImmediateInfinite(lbAddrRetryInterval, func() (bool, error) {
0000000000000000000000000000000000000000;;			fmt.Fprint(cmdOut, ".")
0000000000000000000000000000000000000000;;			pollSvc, err := clientset.Core().Services(svc.Namespace).Get(svc.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ings := pollSvc.Status.LoadBalancer.Ingress; len(ings) > 0 {
0000000000000000000000000000000000000000;;				for _, ing := range ings {
0000000000000000000000000000000000000000;;					if len(ing.IP) > 0 {
0000000000000000000000000000000000000000;;						ips = append(ips, ing.IP)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(ing.Hostname) > 0 {
0000000000000000000000000000000000000000;;						hostnames = append(hostnames, ing.Hostname)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(ips) > 0 || len(hostnames) > 0 {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ips, hostnames, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateCredentials(svcNamespace, name, svcName, localDNSZoneName, serverCredName string, ips, hostnames []string, enableHTTPBasicAuth, enableTokenAuth, dryRun bool) (*credentials, error) {
0000000000000000000000000000000000000000;;		credentials := credentials{
0000000000000000000000000000000000000000;;			username: AdminCN,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if enableHTTPBasicAuth {
0000000000000000000000000000000000000000;;			credentials.password = string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if enableTokenAuth {
0000000000000000000000000000000000000000;;			credentials.token = string(uuid.NewUUID())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entKeyPairs, err := genCerts(svcNamespace, name, svcName, localDNSZoneName, ips, hostnames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		credentials.certEntKeyPairs = entKeyPairs
0000000000000000000000000000000000000000;;		return &credentials, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genCerts(svcNamespace, name, svcName, localDNSZoneName string, ips, hostnames []string) (*entityKeyPairs, error) {
0000000000000000000000000000000000000000;;		ca, err := triple.NewCA(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create CA key and certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server, err := triple.NewServerKeyPair(ca, APIServerCN, svcName, svcNamespace, localDNSZoneName, ips, hostnames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create federation API server key and certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cm, err := triple.NewClientKeyPair(ca, ControllerManagerCN, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create federation controller manager client key and certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		admin, err := triple.NewClientKeyPair(ca, AdminCN, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create client key and certificate for an admin: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &entityKeyPairs{
0000000000000000000000000000000000000000;;			ca:                ca,
0000000000000000000000000000000000000000;;			server:            server,
0000000000000000000000000000000000000000;;			controllerManager: cm,
0000000000000000000000000000000000000000;;			admin:             admin,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAPIServerCredentialsSecret(clientset client.Interface, namespace, credentialsName, federationName string, credentials *credentials, dryRun bool) (*api.Secret, error) {
0000000000000000000000000000000000000000;;		// Build the secret object with API server credentials.
0000000000000000000000000000000000000000;;		data := map[string][]byte{
0000000000000000000000000000000000000000;;			"ca.crt":     certutil.EncodeCertPEM(credentials.certEntKeyPairs.ca.Cert),
0000000000000000000000000000000000000000;;			"server.crt": certutil.EncodeCertPEM(credentials.certEntKeyPairs.server.Cert),
0000000000000000000000000000000000000000;;			"server.key": certutil.EncodePrivateKeyPEM(credentials.certEntKeyPairs.server.Key),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if credentials.password != "" {
0000000000000000000000000000000000000000;;			data["basicauth.csv"] = authFileContents(credentials.username, credentials.password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if credentials.token != "" {
0000000000000000000000000000000000000000;;			data["token.csv"] = authFileContents(credentials.username, credentials.token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secret := &api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        credentialsName,
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: data,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return secret, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Boilerplate to create the secret in the host cluster.
0000000000000000000000000000000000000000;;		return clientset.Core().Secrets(namespace).Create(secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createControllerManagerKubeconfigSecret(clientset client.Interface, namespace, name, svcName, kubeconfigName string, entKeyPairs *entityKeyPairs, dryRun bool) (*api.Secret, error) {
0000000000000000000000000000000000000000;;		config := kubeconfigutil.CreateWithCerts(
0000000000000000000000000000000000000000;;			fmt.Sprintf("https://%s", svcName),
0000000000000000000000000000000000000000;;			name,
0000000000000000000000000000000000000000;;			ControllerManagerUser,
0000000000000000000000000000000000000000;;			certutil.EncodeCertPEM(entKeyPairs.ca.Cert),
0000000000000000000000000000000000000000;;			certutil.EncodePrivateKeyPEM(entKeyPairs.controllerManager.Key),
0000000000000000000000000000000000000000;;			certutil.EncodeCertPEM(entKeyPairs.controllerManager.Cert),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return util.CreateKubeconfigSecret(clientset, config, namespace, kubeconfigName, name, "", dryRun)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPVC(clientset client.Interface, namespace, svcName, federationName, etcdPVCapacity, etcdPVStorageClass string, dryRun bool) (*api.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		capacity, err := resource.ParseQuantity(etcdPVCapacity)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var storageClassName *string
0000000000000000000000000000000000000000;;		if len(etcdPVStorageClass) > 0 {
0000000000000000000000000000000000000000;;			storageClassName = &etcdPVStorageClass
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvc := &api.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      fmt.Sprintf("%s-etcd-claim", svcName),
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Labels:    componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []api.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					api.ReadWriteOnce,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Resources: api.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: api.ResourceList{
0000000000000000000000000000000000000000;;						api.ResourceStorage: capacity,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StorageClassName: storageClassName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return pvc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientset.Core().PersistentVolumeClaims(namespace).Create(pvc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createAPIServer(clientset client.Interface, namespace, name, federationName, serverImage, etcdImage, advertiseAddress, credentialsName string, hasHTTPBasicAuthFile, hasTokenAuthFile bool, argOverrides map[string]string, pvc *api.PersistentVolumeClaim, dryRun bool) (*extensions.Deployment, error) {
0000000000000000000000000000000000000000;;		command := []string{
0000000000000000000000000000000000000000;;			"/hyperkube",
0000000000000000000000000000000000000000;;			"federation-apiserver",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		argsMap := map[string]string{
0000000000000000000000000000000000000000;;			"--bind-address":         "0.0.0.0",
0000000000000000000000000000000000000000;;			"--etcd-servers":         "http://localhost:2379",
0000000000000000000000000000000000000000;;			"--secure-port":          fmt.Sprintf("%d", apiServerSecurePort),
0000000000000000000000000000000000000000;;			"--client-ca-file":       "/etc/federation/apiserver/ca.crt",
0000000000000000000000000000000000000000;;			"--tls-cert-file":        "/etc/federation/apiserver/server.crt",
0000000000000000000000000000000000000000;;			"--tls-private-key-file": "/etc/federation/apiserver/server.key",
0000000000000000000000000000000000000000;;			"--admission-control":    "NamespaceLifecycle",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if advertiseAddress != "" {
0000000000000000000000000000000000000000;;			argsMap["--advertise-address"] = advertiseAddress
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasHTTPBasicAuthFile {
0000000000000000000000000000000000000000;;			argsMap["--basic-auth-file"] = "/etc/federation/apiserver/basicauth.csv"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasTokenAuthFile {
0000000000000000000000000000000000000000;;			argsMap["--token-auth-file"] = "/etc/federation/apiserver/token.csv"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := argMapsToArgStrings(argsMap, argOverrides)
0000000000000000000000000000000000000000;;		command = append(command, args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dep := &extensions.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Labels:      componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: 1,
0000000000000000000000000000000000000000;;				Template: api.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        name,
0000000000000000000000000000000000000000;;						Labels:      apiserverPodLabels,
0000000000000000000000000000000000000000;;						Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    "apiserver",
0000000000000000000000000000000000000000;;								Image:   serverImage,
0000000000000000000000000000000000000000;;								Command: command,
0000000000000000000000000000000000000000;;								Ports: []api.ContainerPort{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:          apiServerSecurePortName,
0000000000000000000000000000000000000000;;										ContainerPort: apiServerSecurePort,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:          "local",
0000000000000000000000000000000000000000;;										ContainerPort: 8080,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								VolumeMounts: []api.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      credentialsName,
0000000000000000000000000000000000000000;;										MountPath: "/etc/federation/apiserver",
0000000000000000000000000000000000000000;;										ReadOnly:  true,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "etcd",
0000000000000000000000000000000000000000;;								Image: etcdImage,
0000000000000000000000000000000000000000;;								Command: []string{
0000000000000000000000000000000000000000;;									"/usr/local/bin/etcd",
0000000000000000000000000000000000000000;;									"--data-dir",
0000000000000000000000000000000000000000;;									"/var/etcd/data",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: []api.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: credentialsName,
0000000000000000000000000000000000000000;;								VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;									Secret: &api.SecretVolumeSource{
0000000000000000000000000000000000000000;;										SecretName: credentialsName,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pvc != nil {
0000000000000000000000000000000000000000;;			dataVolumeName := "etcddata"
0000000000000000000000000000000000000000;;			etcdVolume := api.Volume{
0000000000000000000000000000000000000000;;				Name: dataVolumeName,
0000000000000000000000000000000000000000;;				VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;					PersistentVolumeClaim: &api.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;						ClaimName: pvc.Name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			etcdVolumeMount := api.VolumeMount{
0000000000000000000000000000000000000000;;				Name:      dataVolumeName,
0000000000000000000000000000000000000000;;				MountPath: "/var/etcd",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dep.Spec.Template.Spec.Volumes = append(dep.Spec.Template.Spec.Volumes, etcdVolume)
0000000000000000000000000000000000000000;;			for i, container := range dep.Spec.Template.Spec.Containers {
0000000000000000000000000000000000000000;;				if container.Name == "etcd" {
0000000000000000000000000000000000000000;;					dep.Spec.Template.Spec.Containers[i].VolumeMounts = append(dep.Spec.Template.Spec.Containers[i].VolumeMounts, etcdVolumeMount)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return dep, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createdDep, err := clientset.Extensions().Deployments(namespace).Create(dep)
0000000000000000000000000000000000000000;;		return createdDep, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createControllerManagerSA(clientset client.Interface, namespace, federationName string, dryRun bool) (*api.ServiceAccount, error) {
0000000000000000000000000000000000000000;;		sa := &api.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        ControllerManagerSA,
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Labels:      componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientset.Core().ServiceAccounts(namespace).Create(sa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createRoleBindings(clientset client.Interface, namespace, saName, federationName string, dryRun bool) (*rbac.Role, *rbac.RoleBinding, error) {
0000000000000000000000000000000000000000;;		roleName := "federation-system:federation-controller-manager"
0000000000000000000000000000000000000000;;		role := &rbac.Role{
0000000000000000000000000000000000000000;;			// a role to use for bootstrapping the federation-controller-manager so it can access
0000000000000000000000000000000000000000;;			// secrets in the host cluster to access other clusters.
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        roleName,
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Labels:      componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Rules: []rbac.PolicyRule{
0000000000000000000000000000000000000000;;				rbac.NewRule("get", "list", "watch").Groups(legacyAPIGroup).Resources("secrets").RuleOrDie(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rolebinding, err := rbac.NewRoleBinding(roleName, namespace).SAs(namespace, saName).Binding()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rolebinding.Labels = componentLabel
0000000000000000000000000000000000000000;;		rolebinding.Annotations = map[string]string{federation.FederationNameAnnotation: federationName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return role, &rolebinding, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newRole, err := clientset.Rbac().Roles(namespace).Create(role)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newRolebinding, err := clientset.Rbac().RoleBindings(namespace).Create(&rolebinding)
0000000000000000000000000000000000000000;;		return newRole, newRolebinding, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createControllerManager(clientset client.Interface, namespace, name, svcName, cmName, image, kubeconfigName, dnsZoneName, dnsProvider, dnsProviderConfig, saName string, dnsProviderSecret *api.Secret, argOverrides map[string]string, dryRun bool) (*extensions.Deployment, error) {
0000000000000000000000000000000000000000;;		command := []string{
0000000000000000000000000000000000000000;;			"/hyperkube",
0000000000000000000000000000000000000000;;			"federation-controller-manager",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		argsMap := map[string]string{
0000000000000000000000000000000000000000;;			"--kubeconfig": "/etc/federation/controller-manager/kubeconfig",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		argsMap["--master"] = fmt.Sprintf("https://%s", svcName)
0000000000000000000000000000000000000000;;		argsMap["--dns-provider"] = dnsProvider
0000000000000000000000000000000000000000;;		argsMap["--federation-name"] = name
0000000000000000000000000000000000000000;;		argsMap["--zone-name"] = dnsZoneName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := argMapsToArgStrings(argsMap, argOverrides)
0000000000000000000000000000000000000000;;		command = append(command, args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dep := &extensions.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      cmName,
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;				Labels:    componentLabel,
0000000000000000000000000000000000000000;;				// We additionally update the details (in annotations) about the
0000000000000000000000000000000000000000;;				// kube-dns config map which needs to be created in the clusters
0000000000000000000000000000000000000000;;				// registering to this federation (at kubefed join).
0000000000000000000000000000000000000000;;				// We wont otherwise have this information available at kubefed join.
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					// TODO: the name/domain name pair should ideally be checked for naming convention
0000000000000000000000000000000000000000;;					// as done in kube-dns federation flags check.
0000000000000000000000000000000000000000;;					// https://github.com/kubernetes/dns/blob/master/pkg/dns/federation/federation.go
0000000000000000000000000000000000000000;;					// TODO v2: Until kube-dns can handle trailing periods we strip them all.
0000000000000000000000000000000000000000;;					//          See https://github.com/kubernetes/dns/issues/67
0000000000000000000000000000000000000000;;					util.FedDomainMapKey:                fmt.Sprintf("%s=%s", name, strings.TrimRight(dnsZoneName, ".")),
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensions.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: 1,
0000000000000000000000000000000000000000;;				Template: api.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        cmName,
0000000000000000000000000000000000000000;;						Labels:      controllerManagerPodLabels,
0000000000000000000000000000000000000000;;						Annotations: map[string]string{federation.FederationNameAnnotation: name},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: api.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []api.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    "controller-manager",
0000000000000000000000000000000000000000;;								Image:   image,
0000000000000000000000000000000000000000;;								Command: command,
0000000000000000000000000000000000000000;;								VolumeMounts: []api.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      kubeconfigName,
0000000000000000000000000000000000000000;;										MountPath: "/etc/federation/controller-manager",
0000000000000000000000000000000000000000;;										ReadOnly:  true,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Env: []api.EnvVar{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name: "POD_NAMESPACE",
0000000000000000000000000000000000000000;;										ValueFrom: &api.EnvVarSource{
0000000000000000000000000000000000000000;;											FieldRef: &api.ObjectFieldSelector{
0000000000000000000000000000000000000000;;												FieldPath: "metadata.namespace",
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: []api.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: kubeconfigName,
0000000000000000000000000000000000000000;;								VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;									Secret: &api.SecretVolumeSource{
0000000000000000000000000000000000000000;;										SecretName: kubeconfigName,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if saName != "" {
0000000000000000000000000000000000000000;;			dep.Spec.Template.Spec.ServiceAccountName = saName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dnsProviderSecret != nil {
0000000000000000000000000000000000000000;;			dep = addDNSProviderConfig(dep, dnsProviderSecret.Name)
0000000000000000000000000000000000000000;;			if dnsProvider == util.FedDNSProviderCoreDNS {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				dep, err = addCoreDNSServerAnnotation(dep, dnsZoneName, dnsProviderConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dryRun {
0000000000000000000000000000000000000000;;			return dep, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientset.Extensions().Deployments(namespace).Create(dep)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshallOverrides(overrideArgString string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		if overrideArgString == "" {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		argsMap := make(map[string]string)
0000000000000000000000000000000000000000;;		overrideArgs := strings.Split(overrideArgString, ",")
0000000000000000000000000000000000000000;;		for _, overrideArg := range overrideArgs {
0000000000000000000000000000000000000000;;			splitArg := strings.SplitN(overrideArg, "=", 2)
0000000000000000000000000000000000000000;;			if len(splitArg) != 2 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("wrong format for override arg: %s", overrideArg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key := strings.TrimSpace(splitArg[0])
0000000000000000000000000000000000000000;;			val := strings.TrimSpace(splitArg[1])
0000000000000000000000000000000000000000;;			if len(key) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("wrong format for override arg: %s, arg name cannot be empty", overrideArg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			argsMap[key] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return argsMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func argMapsToArgStrings(argsMap, overrides map[string]string) []string {
0000000000000000000000000000000000000000;;		for key, val := range overrides {
0000000000000000000000000000000000000000;;			argsMap[key] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args := []string{}
0000000000000000000000000000000000000000;;		for key, value := range argsMap {
0000000000000000000000000000000000000000;;			args = append(args, fmt.Sprintf("%s=%s", key, value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This is needed for the unit test deep copy to get an exact match
0000000000000000000000000000000000000000;;		sort.Strings(args)
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPods(cmdOut io.Writer, clientset client.Interface, fedPods []string, namespace string) error {
0000000000000000000000000000000000000000;;		err := wait.PollInfinite(podWaitInterval, func() (bool, error) {
0000000000000000000000000000000000000000;;			fmt.Fprint(cmdOut, ".")
0000000000000000000000000000000000000000;;			podCheck := len(fedPods)
0000000000000000000000000000000000000000;;			podList, err := clientset.Core().Pods(namespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;				for _, fedPod := range fedPods {
0000000000000000000000000000000000000000;;					if strings.HasPrefix(pod.Name, fedPod) && pod.Status.Phase == "Running" {
0000000000000000000000000000000000000000;;						podCheck -= 1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				//ensure that all pods are in running state or keep waiting
0000000000000000000000000000000000000000;;				if podCheck == 0 {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitSrvHealthy(cmdOut io.Writer, config util.AdminConfig, context, kubeconfig string) error {
0000000000000000000000000000000000000000;;		fedClientSet, err := config.FederationClientset(context, kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fedDiscoveryClient := fedClientSet.Discovery()
0000000000000000000000000000000000000000;;		err = wait.PollInfinite(podWaitInterval, func() (bool, error) {
0000000000000000000000000000000000000000;;			fmt.Fprint(cmdOut, ".")
0000000000000000000000000000000000000000;;			body, err := fedDiscoveryClient.RESTClient().Get().AbsPath("/healthz").Do().Raw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.EqualFold(string(body), "ok") {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printSuccess(cmdOut io.Writer, ips, hostnames []string, svc *api.Service) error {
0000000000000000000000000000000000000000;;		svcEndpoints := append(ips, hostnames...)
0000000000000000000000000000000000000000;;		endpoints := strings.Join(svcEndpoints, ", ")
0000000000000000000000000000000000000000;;		if svc.Spec.Type == api.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;			endpoints = ips[0] + ":" + strconv.Itoa(int(svc.Spec.Ports[0].NodePort))
0000000000000000000000000000000000000000;;			if len(ips) > 1 {
0000000000000000000000000000000000000000;;				endpoints = endpoints + ", ..."
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(cmdOut, "Federation API server is running at: %s\n", endpoints)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateKubeconfig(config util.AdminConfig, name, endpoint, kubeConfigPath string, credentials *credentials, dryRun bool) error {
0000000000000000000000000000000000000000;;		po := config.PathOptions()
0000000000000000000000000000000000000000;;		po.LoadingRules.ExplicitPath = kubeConfigPath
0000000000000000000000000000000000000000;;		kubeconfig, err := po.GetStartingConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Populate API server endpoint info.
0000000000000000000000000000000000000000;;		cluster := clientcmdapi.NewCluster()
0000000000000000000000000000000000000000;;		// Prefix "https" as the URL scheme to endpoint.
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(endpoint, "https://") {
0000000000000000000000000000000000000000;;			endpoint = fmt.Sprintf("https://%s", endpoint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cluster.Server = endpoint
0000000000000000000000000000000000000000;;		cluster.CertificateAuthorityData = certutil.EncodeCertPEM(credentials.certEntKeyPairs.ca.Cert)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Populate credentials.
0000000000000000000000000000000000000000;;		authInfo := clientcmdapi.NewAuthInfo()
0000000000000000000000000000000000000000;;		authInfo.ClientCertificateData = certutil.EncodeCertPEM(credentials.certEntKeyPairs.admin.Cert)
0000000000000000000000000000000000000000;;		authInfo.ClientKeyData = certutil.EncodePrivateKeyPEM(credentials.certEntKeyPairs.admin.Key)
0000000000000000000000000000000000000000;;		authInfo.Token = credentials.token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var httpBasicAuthInfo *clientcmdapi.AuthInfo
0000000000000000000000000000000000000000;;		if credentials.password != "" {
0000000000000000000000000000000000000000;;			httpBasicAuthInfo = clientcmdapi.NewAuthInfo()
0000000000000000000000000000000000000000;;			httpBasicAuthInfo.Password = credentials.password
0000000000000000000000000000000000000000;;			httpBasicAuthInfo.Username = credentials.username
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Populate context.
0000000000000000000000000000000000000000;;		context := clientcmdapi.NewContext()
0000000000000000000000000000000000000000;;		context.Cluster = name
0000000000000000000000000000000000000000;;		context.AuthInfo = name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the config struct with API server endpoint info,
0000000000000000000000000000000000000000;;		// credentials and context.
0000000000000000000000000000000000000000;;		kubeconfig.Clusters[name] = cluster
0000000000000000000000000000000000000000;;		kubeconfig.AuthInfos[name] = authInfo
0000000000000000000000000000000000000000;;		if httpBasicAuthInfo != nil {
0000000000000000000000000000000000000000;;			kubeconfig.AuthInfos[fmt.Sprintf("%s-basic-auth", name)] = httpBasicAuthInfo
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeconfig.Contexts[name] = context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dryRun {
0000000000000000000000000000000000000000;;			// Write the update kubeconfig.
0000000000000000000000000000000000000000;;			if err := clientcmd.ModifyConfig(po, *kubeconfig, true); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createDNSProviderConfigSecret(clientset client.Interface, namespace, name, federationName string, dnsProviderConfigBytes []byte, dryRun bool) (*api.Secret, error) {
0000000000000000000000000000000000000000;;		if dnsProviderConfigBytes == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretSpec := &api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Namespace:   namespace,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				name: dnsProviderConfigBytes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var secret *api.Secret
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if !dryRun {
0000000000000000000000000000000000000000;;			secret, err = clientset.Core().Secrets(namespace).Create(secretSpec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return secret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addDNSProviderConfig(dep *extensions.Deployment, secretName string) *extensions.Deployment {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			dnsProviderConfigVolume    = "config-volume"
0000000000000000000000000000000000000000;;			dnsProviderConfigMountPath = "/etc/federation/dns-provider"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a volume from dns-provider secret
0000000000000000000000000000000000000000;;		volume := api.Volume{
0000000000000000000000000000000000000000;;			Name: dnsProviderConfigVolume,
0000000000000000000000000000000000000000;;			VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;				Secret: &api.SecretVolumeSource{
0000000000000000000000000000000000000000;;					SecretName: secretName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dep.Spec.Template.Spec.Volumes = append(dep.Spec.Template.Spec.Volumes, volume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mount dns-provider secret volume to controller-manager container
0000000000000000000000000000000000000000;;		volumeMount := api.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      dnsProviderConfigVolume,
0000000000000000000000000000000000000000;;			MountPath: dnsProviderConfigMountPath,
0000000000000000000000000000000000000000;;			ReadOnly:  true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dep.Spec.Template.Spec.Containers[0].VolumeMounts = append(dep.Spec.Template.Spec.Containers[0].VolumeMounts, volumeMount)
0000000000000000000000000000000000000000;;		dep.Spec.Template.Spec.Containers[0].Command = append(dep.Spec.Template.Spec.Containers[0].Command, fmt.Sprintf("--dns-provider-config=%s/%s", dnsProviderConfigMountPath, secretName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dep
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authFileContents returns a CSV string containing the contents of an
0000000000000000000000000000000000000000;;	// authentication file in the format required by the federation-apiserver.
0000000000000000000000000000000000000000;;	func authFileContents(username, authSecret string) []byte {
0000000000000000000000000000000000000000;;		return []byte(fmt.Sprintf("%s,%s,%s\n", authSecret, username, uuid.NewUUID()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addCoreDNSServerAnnotation(deployment *extensions.Deployment, dnsZoneName, dnsProviderConfig string) (*extensions.Deployment, error) {
0000000000000000000000000000000000000000;;		var cfg coredns.Config
0000000000000000000000000000000000000000;;		if err := gcfg.ReadFileInto(&cfg, dnsProviderConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment.Annotations[util.FedDNSZoneName] = dnsZoneName
0000000000000000000000000000000000000000;;		deployment.Annotations[util.FedNameServer] = cfg.Global.CoreDNSEndpoints
0000000000000000000000000000000000000000;;		deployment.Annotations[util.FedDNSProvider] = util.FedDNSProviderCoreDNS
0000000000000000000000000000000000000000;;		return deployment, nil
0000000000000000000000000000000000000000;;	}
