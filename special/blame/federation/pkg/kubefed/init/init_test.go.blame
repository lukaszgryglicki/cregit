0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
77c81c897ace5cce0c4e76c663ac3af8aace5c75;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package init
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		rbacv1beta1 "k8s.io/api/rbac/v1beta1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/dnsprovider/providers/coredns"
0000000000000000000000000000000000000000;;		kubefedtesting "k8s.io/kubernetes/federation/pkg/kubefed/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/kubefed/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		cmdtesting "k8s.io/kubernetes/pkg/kubectl/cmd/testing"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testNamespace    = "test-ns"
0000000000000000000000000000000000000000;;		testSvcName      = "test-service"
0000000000000000000000000000000000000000;;		testCertValidity = 1 * time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		helloMsg = "Hello, certificate test!"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lbIP     = "10.20.30.40"
0000000000000000000000000000000000000000;;		nodeIP   = "10.20.30.50"
0000000000000000000000000000000000000000;;		nodePort = 32111
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testAPIGroup   = "testGroup"
0000000000000000000000000000000000000000;;		testAPIVersion = "testVersion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInitFederation(t *testing.T) {
0000000000000000000000000000000000000000;;		cmdErrMsg := ""
0000000000000000000000000000000000000000;;		cmdutil.BehaviorOnFatal(func(str string, code int) {
0000000000000000000000000000000000000000;;			cmdErrMsg = str
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeKubeFiles, err := kubefedtesting.FakeKubeconfigFiles()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer kubefedtesting.RemoveFakeKubeconfigFiles(fakeKubeFiles)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			federation                   string
0000000000000000000000000000000000000000;;			kubeconfigGlobal             string
0000000000000000000000000000000000000000;;			kubeconfigExplicit           string
0000000000000000000000000000000000000000;;			dnsZoneName                  string
0000000000000000000000000000000000000000;;			lbIP                         string
0000000000000000000000000000000000000000;;			apiserverServiceType         v1.ServiceType
0000000000000000000000000000000000000000;;			advertiseAddress             string
0000000000000000000000000000000000000000;;			serverImage                  string
0000000000000000000000000000000000000000;;			etcdImage                    string
0000000000000000000000000000000000000000;;			etcdPVCapacity               string
0000000000000000000000000000000000000000;;			etcdPVStorageClass           string
0000000000000000000000000000000000000000;;			etcdPersistence              string
0000000000000000000000000000000000000000;;			expectedErr                  string
0000000000000000000000000000000000000000;;			dnsProvider                  string
0000000000000000000000000000000000000000;;			dnsProviderConfig            string
0000000000000000000000000000000000000000;;			dryRun                       string
0000000000000000000000000000000000000000;;			apiserverArgOverrides        string
0000000000000000000000000000000000000000;;			cmArgOverrides               string
0000000000000000000000000000000000000000;;			apiserverEnableHTTPBasicAuth bool
0000000000000000000000000000000000000000;;			apiserverEnableTokenAuth     bool
0000000000000000000000000000000000000000;;			isRBACAPIAvailable           bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				federation:            "union",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:      fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit:    "",
0000000000000000000000000000000000000000;;				dnsZoneName:           "example.test.",
0000000000000000000000000000000000000000;;				lbIP:                  lbIP,
0000000000000000000000000000000000000000;;				apiserverServiceType:  v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				serverImage:           "example.test/foo:bar",
0000000000000000000000000000000000000000;;				etcdPVCapacity:        "5Gi",
0000000000000000000000000000000000000000;;				etcdPersistence:       "true",
0000000000000000000000000000000000000000;;				expectedErr:           "",
0000000000000000000000000000000000000000;;				dnsProvider:           util.FedDNSProviderCoreDNS,
0000000000000000000000000000000000000000;;				dnsProviderConfig:     "dns-provider.conf",
0000000000000000000000000000000000000000;;				dryRun:                "",
0000000000000000000000000000000000000000;;				apiserverArgOverrides: "--client-ca-file=override,--log-dir=override",
0000000000000000000000000000000000000000;;				cmArgOverrides:        "--dns-provider=override,--log-dir=override",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				federation:           "union",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:     fakeKubeFiles[1],
0000000000000000000000000000000000000000;;				kubeconfigExplicit:   fakeKubeFiles[2],
0000000000000000000000000000000000000000;;				dnsZoneName:          "example.test.",
0000000000000000000000000000000000000000;;				lbIP:                 lbIP,
0000000000000000000000000000000000000000;;				apiserverServiceType: v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				serverImage:          "example.test/foo:bar",
0000000000000000000000000000000000000000;;				etcdPVCapacity:       "", //test for default value of pvc-size
0000000000000000000000000000000000000000;;				etcdPersistence:      "true",
0000000000000000000000000000000000000000;;				expectedErr:          "",
0000000000000000000000000000000000000000;;				dryRun:               "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				federation:           "union",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:     fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit:   "",
0000000000000000000000000000000000000000;;				dnsZoneName:          "example.test.",
0000000000000000000000000000000000000000;;				lbIP:                 lbIP,
0000000000000000000000000000000000000000;;				apiserverServiceType: v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				serverImage:          "example.test/foo:bar",
0000000000000000000000000000000000000000;;				etcdPVCapacity:       "",
0000000000000000000000000000000000000000;;				etcdPersistence:      "true",
0000000000000000000000000000000000000000;;				expectedErr:          "",
0000000000000000000000000000000000000000;;				dryRun:               "valid-run",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				federation:           "union",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:     fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit:   "",
0000000000000000000000000000000000000000;;				dnsZoneName:          "example.test.",
0000000000000000000000000000000000000000;;				lbIP:                 lbIP,
0000000000000000000000000000000000000000;;				apiserverServiceType: v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				serverImage:          "example.test/foo:bar",
0000000000000000000000000000000000000000;;				etcdPVCapacity:       "5Gi",
0000000000000000000000000000000000000000;;				etcdPersistence:      "false",
0000000000000000000000000000000000000000;;				expectedErr:          "",
0000000000000000000000000000000000000000;;				dryRun:               "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				federation:           "union",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:     fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit:   "",
0000000000000000000000000000000000000000;;				dnsZoneName:          "example.test.",
0000000000000000000000000000000000000000;;				apiserverServiceType: v1.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				serverImage:          "example.test/foo:bar",
0000000000000000000000000000000000000000;;				etcdPVCapacity:       "5Gi",
0000000000000000000000000000000000000000;;				etcdPersistence:      "true",
0000000000000000000000000000000000000000;;				expectedErr:          "",
0000000000000000000000000000000000000000;;				dryRun:               "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				federation:           "union",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:     fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit:   "",
0000000000000000000000000000000000000000;;				dnsZoneName:          "example.test.",
0000000000000000000000000000000000000000;;				apiserverServiceType: v1.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				advertiseAddress:     nodeIP,
0000000000000000000000000000000000000000;;				serverImage:          "example.test/foo:bar",
0000000000000000000000000000000000000000;;				etcdPVCapacity:       "5Gi",
0000000000000000000000000000000000000000;;				etcdPersistence:      "true",
0000000000000000000000000000000000000000;;				expectedErr:          "",
0000000000000000000000000000000000000000;;				dryRun:               "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				federation:           "union",
0000000000000000000000000000000000000000;;				kubeconfigGlobal:     fakeKubeFiles[0],
0000000000000000000000000000000000000000;;				kubeconfigExplicit:   "",
0000000000000000000000000000000000000000;;				dnsZoneName:          "example.test.",
0000000000000000000000000000000000000000;;				apiserverServiceType: v1.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				advertiseAddress:     nodeIP,
0000000000000000000000000000000000000000;;				serverImage:          "example.test/foo:bar",
0000000000000000000000000000000000000000;;				etcdImage:            "gcr.io/google_containers/etcd:latest",
0000000000000000000000000000000000000000;;				etcdPVCapacity:       "5Gi",
0000000000000000000000000000000000000000;;				etcdPVStorageClass:   "fast",
0000000000000000000000000000000000000000;;				etcdPersistence:      "true",
0000000000000000000000000000000000000000;;				expectedErr:          "",
0000000000000000000000000000000000000000;;				dryRun:               "",
0000000000000000000000000000000000000000;;				apiserverEnableHTTPBasicAuth: true,
0000000000000000000000000000000000000000;;				apiserverEnableTokenAuth:     true,
0000000000000000000000000000000000000000;;				isRBACAPIAvailable:           true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultEtcdImage := "gcr.io/google_containers/etcd:3.0.17"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//TODO: implement a negative case for dry run
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			cmdErrMsg = ""
0000000000000000000000000000000000000000;;			tmpDirPath := ""
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.dnsProvider == "" {
0000000000000000000000000000000000000000;;				tc.dnsProvider = "google-clouddns"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.dnsProviderConfig != "" {
0000000000000000000000000000000000000000;;				tmpfile, err := ioutil.TempFile("", tc.dnsProviderConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tc.dnsProviderConfig = tmpfile.Name()
0000000000000000000000000000000000000000;;				defer os.Remove(tmpfile.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check pkg/kubectl/cmd/testing/fake (fakeAPIFactory.DiscoveryClient()) for details of tmpDir
0000000000000000000000000000000000000000;;			// We want an unique discovery cache path for each test run, else the case from previous case would be used
0000000000000000000000000000000000000000;;			tmpDirPath, err = ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer os.Remove(tmpDirPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If tc.etcdImage is set, setting the etcd image via the flag will be
0000000000000000000000000000000000000000;;			// validated.  If not set, the default value will be validated.
0000000000000000000000000000000000000000;;			if tc.etcdImage == "" {
0000000000000000000000000000000000000000;;				tc.etcdImage = defaultEtcdImage
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hostFactory, err := fakeInitHostFactory(tc.apiserverServiceType, tc.federation, util.DefaultFederationSystemNamespace, tc.advertiseAddress, tc.lbIP, tc.dnsZoneName, tc.serverImage, tc.etcdImage, tc.dnsProvider, tc.dnsProviderConfig, tc.etcdPersistence, tc.etcdPVCapacity, tc.etcdPVStorageClass, tc.apiserverArgOverrides, tc.cmArgOverrides, tmpDirPath, tc.apiserverEnableHTTPBasicAuth, tc.apiserverEnableTokenAuth, tc.isRBACAPIAvailable)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			adminConfig, err := kubefedtesting.NewFakeAdminConfig(hostFactory, nil, "", tc.kubeconfigGlobal)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := NewCmdInit(buf, adminConfig, "serverImage", defaultEtcdImage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd.Flags().Set("kubeconfig", tc.kubeconfigExplicit)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("host-cluster-context", "substrate")
0000000000000000000000000000000000000000;;			cmd.Flags().Set("dns-zone-name", tc.dnsZoneName)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("image", tc.serverImage)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("etcd-image", tc.etcdImage)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("dns-provider", tc.dnsProvider)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("apiserver-arg-overrides", tc.apiserverArgOverrides)
0000000000000000000000000000000000000000;;			cmd.Flags().Set("controllermanager-arg-overrides", tc.cmArgOverrides)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.dnsProviderConfig != "" {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("dns-provider-config", tc.dnsProviderConfig)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.etcdPVCapacity != "" {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("etcd-pv-capacity", tc.etcdPVCapacity)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.etcdPVStorageClass != "" {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("etcd-pv-storage-class", tc.etcdPVStorageClass)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.etcdPersistence != "true" {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("etcd-persistent-storage", tc.etcdPersistence)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.apiserverServiceType != v1.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;				cmd.Flags().Set(apiserverServiceTypeFlag, string(tc.apiserverServiceType))
0000000000000000000000000000000000000000;;				cmd.Flags().Set(apiserverAdvertiseAddressFlag, tc.advertiseAddress)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.dryRun == "valid-run" {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("dry-run", "true")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.apiserverEnableHTTPBasicAuth {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("apiserver-enable-basic-auth", "true")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tc.apiserverEnableTokenAuth {
0000000000000000000000000000000000000000;;				cmd.Flags().Set("apiserver-enable-token-auth", "true")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd.Run(cmd, []string{tc.federation})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.expectedErr == "" {
0000000000000000000000000000000000000000;;				// uses the name from the federation, not the response
0000000000000000000000000000000000000000;;				// Actual data passed are tested in the fake secret and cluster
0000000000000000000000000000000000000000;;				// REST clients.
0000000000000000000000000000000000000000;;				endpoint := getEndpoint(tc.apiserverServiceType, tc.lbIP, tc.advertiseAddress)
0000000000000000000000000000000000000000;;				wantedSuffix := fmt.Sprintf("Federation API server is running at: %s\n", endpoint)
0000000000000000000000000000000000000000;;				if tc.dryRun != "" {
0000000000000000000000000000000000000000;;					wantedSuffix = fmt.Sprintf("Federation control plane runs (dry run)\n")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if got := buf.String(); !strings.HasSuffix(got, wantedSuffix) {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected output: got: %s, wanted suffix: %s", i, got, wantedSuffix)
0000000000000000000000000000000000000000;;					if cmdErrMsg != "" {
0000000000000000000000000000000000000000;;						t.Errorf("[%d] unexpected error message: %s", i, cmdErrMsg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if cmdErrMsg != tc.expectedErr {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] expected error: %s, got: %s, output: %s", i, tc.expectedErr, cmdErrMsg, buf.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testKubeconfigUpdate(t, tc.apiserverServiceType, tc.federation, tc.advertiseAddress, tc.lbIP, tc.kubeconfigGlobal, tc.kubeconfigExplicit, tc.apiserverEnableHTTPBasicAuth, tc.apiserverEnableTokenAuth)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMarshallAndMergeOverrides(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			overrideParams string
0000000000000000000000000000000000000000;;			expectedSet    sets.String
0000000000000000000000000000000000000000;;			expectedErr    string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				overrideParams: "valid-format-param1=override1,valid-format-param2=override2",
0000000000000000000000000000000000000000;;				expectedSet:    sets.NewString("arg2=val2", "arg1=val1", "valid-format-param1=override1", "valid-format-param2=override2"),
0000000000000000000000000000000000000000;;				expectedErr:    "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				overrideParams: "valid-format-param1=override1,arg1=override1",
0000000000000000000000000000000000000000;;				expectedSet:    sets.NewString("arg2=val2", "arg1=override1", "valid-format-param1=override1"),
0000000000000000000000000000000000000000;;				expectedErr:    "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				overrideParams: "zero-value-arg=",
0000000000000000000000000000000000000000;;				expectedSet:    sets.NewString("arg2=val2", "arg1=val1", "zero-value-arg="),
0000000000000000000000000000000000000000;;				expectedErr:    "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				overrideParams: "wrong-format-arg",
0000000000000000000000000000000000000000;;				expectedErr:    "wrong format for override arg: wrong-format-arg",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// TODO: Multiple arg values separated by , are not supported yet
0000000000000000000000000000000000000000;;				overrideParams: "multiple-equalto-char=first-key=1",
0000000000000000000000000000000000000000;;				expectedSet:    sets.NewString("arg2=val2", "arg1=val1", "multiple-equalto-char=first-key=1"),
0000000000000000000000000000000000000000;;				expectedErr:    "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				overrideParams: "=wrong-format-only-value",
0000000000000000000000000000000000000000;;				expectedErr:    "wrong format for override arg: =wrong-format-only-value, arg name cannot be empty",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			args, err := marshallOverrides(tc.overrideParams)
0000000000000000000000000000000000000000;;			if tc.expectedErr == "" {
0000000000000000000000000000000000000000;;				origArgs := map[string]string{
0000000000000000000000000000000000000000;;					"arg1": "val1",
0000000000000000000000000000000000000000;;					"arg2": "val2",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				merged := argMapsToArgStrings(origArgs, args)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				got := sets.NewString(merged...)
0000000000000000000000000000000000000000;;				want := tc.expectedSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !got.Equal(want) {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected output: got: %v, want: %v", i, got, want)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err.Error() != tc.expectedErr {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected error output: got: %s, want: %s", i, err.Error(), tc.expectedErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestCertsTLS tests TLS handshake with client authentication for any server
0000000000000000000000000000000000000000;;	// name. There is a separate test below to test the certificate generation
0000000000000000000000000000000000000000;;	// end-to-end over HTTPS.
0000000000000000000000000000000000000000;;	// TODO(madhusudancs): Consider using a deterministic random number generator
0000000000000000000000000000000000000000;;	// for generating certificates in tests.
0000000000000000000000000000000000000000;;	func TestCertsTLS(t *testing.T) {
0000000000000000000000000000000000000000;;		params := []certParams{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cAddr:     "10.1.2.3",
0000000000000000000000000000000000000000;;				ips:       []string{"10.1.2.3", "10.2.3.4"},
0000000000000000000000000000000000000000;;				hostnames: []string{"federation.test", "federation2.test"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				cAddr:     "10.10.20.30",
0000000000000000000000000000000000000000;;				ips:       []string{"10.20.30.40", "10.64.128.4"},
0000000000000000000000000000000000000000;;				hostnames: []string{"tls.federation.test"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsCfgs, err := tlsConfigs(params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to generate tls configs: %v", err)
0000000000000000000000000000000000000000;;			// No point in proceeding further
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			serverName string
0000000000000000000000000000000000000000;;			sCfg       *tls.Config
0000000000000000000000000000000000000000;;			cCfg       *tls.Config
0000000000000000000000000000000000000000;;			failType   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "10.1.2.3",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "10.2.3.4",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "federation.test",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "federation2.test",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "10.20.30.40",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[1].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[1].client,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "tls.federation.test",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[1].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[1].client,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "10.100.200.50",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;				failType:   "HostnameError",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "noexist.test",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;				failType:   "HostnameError",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "10.64.128.4",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;				failType:   "HostnameError",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "tls.federation.test",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;				failType:   "HostnameError",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "10.1.2.3",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[1].client,
0000000000000000000000000000000000000000;;				failType:   "UnknownAuthorityError",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "federation2.test",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[1].client,
0000000000000000000000000000000000000000;;				failType:   "UnknownAuthorityError",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "10.1.2.3",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[1].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;				failType:   "HostnameError",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverName: "federation2.test",
0000000000000000000000000000000000000000;;				sCfg:       tlsCfgs[1].server,
0000000000000000000000000000000000000000;;				cCfg:       tlsCfgs[0].client,
0000000000000000000000000000000000000000;;				failType:   "HostnameError",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			// Make a copy of the client config before modifying it.
0000000000000000000000000000000000000000;;			// We can't do a regular pointer deref shallow copy because
0000000000000000000000000000000000000000;;			// tls.Config contains an unexported sync.Once field which
0000000000000000000000000000000000000000;;			// must not be copied. This was pointed out by go vet.
0000000000000000000000000000000000000000;;			cCfg := copyTLSConfig(tc.cCfg)
0000000000000000000000000000000000000000;;			cCfg.ServerName = tc.serverName
0000000000000000000000000000000000000000;;			cCfg.BuildNameToCertificate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := tlsHandshake(t, tc.sCfg, cCfg)
0000000000000000000000000000000000000000;;			if len(tc.failType) > 0 {
0000000000000000000000000000000000000000;;				switch tc.failType {
0000000000000000000000000000000000000000;;				case "HostnameError":
0000000000000000000000000000000000000000;;					if _, ok := err.(x509.HostnameError); !ok {
0000000000000000000000000000000000000000;;						t.Errorf("[%d] unexpected error: want x509.HostnameError, got: %T", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case "UnknownAuthorityError":
0000000000000000000000000000000000000000;;					if _, ok := err.(x509.UnknownAuthorityError); !ok {
0000000000000000000000000000000000000000;;						t.Errorf("[%d] unexpected error: want x509.UnknownAuthorityError, got: %T", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t.Errorf("cannot handle error type: %s", tc.failType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestCertsHTTPS cannot test client authentication for non-localhost server
0000000000000000000000000000000000000000;;	// names, but it tests TLS handshake end-to-end over HTTPS.
0000000000000000000000000000000000000000;;	func TestCertsHTTPS(t *testing.T) {
0000000000000000000000000000000000000000;;		params := []certParams{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Unfortunately, due to the limitation in the way Go
0000000000000000000000000000000000000000;;				// net/http/httptest package sets up the test HTTPS/TLS server,
0000000000000000000000000000000000000000;;				// 127.0.0.1 is the only accepted server address. So, we need to
0000000000000000000000000000000000000000;;				// generate certificates for this address.
0000000000000000000000000000000000000000;;				cAddr:     "127.0.0.1",
0000000000000000000000000000000000000000;;				ips:       []string{"127.0.0.1"},
0000000000000000000000000000000000000000;;				hostnames: []string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Unfortunately, due to the limitation in the way Go
0000000000000000000000000000000000000000;;				// net/http/httptest package sets up the test HTTPS/TLS server,
0000000000000000000000000000000000000000;;				// 127.0.0.1 is the only accepted server address. So, we need to
0000000000000000000000000000000000000000;;				// generate certificates for this address.
0000000000000000000000000000000000000000;;				cAddr:     "localhost",
0000000000000000000000000000000000000000;;				ips:       []string{"127.0.0.1"},
0000000000000000000000000000000000000000;;				hostnames: []string{"localhost"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsCfgs, err := tlsConfigs(params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to generate tls configs: %v", err)
0000000000000000000000000000000000000000;;			// No point in proceeding further
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			sCfg *tls.Config
0000000000000000000000000000000000000000;;			cCfg *tls.Config
0000000000000000000000000000000000000000;;			fail bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				sCfg: tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg: tlsCfgs[0].client,
0000000000000000000000000000000000000000;;				fail: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				sCfg: tlsCfgs[0].server,
0000000000000000000000000000000000000000;;				cCfg: tlsCfgs[1].client,
0000000000000000000000000000000000000000;;				fail: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				sCfg: tlsCfgs[1].server,
0000000000000000000000000000000000000000;;				cCfg: tlsCfgs[0].client,
0000000000000000000000000000000000000000;;				fail: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			// Make a copy of the client config before modifying it.
0000000000000000000000000000000000000000;;			// We can't do a regular pointer deref shallow copy because
0000000000000000000000000000000000000000;;			// tls.Config contains an unexported sync.Once field which
0000000000000000000000000000000000000000;;			// must not be copied. This was pointed out by go vet.
0000000000000000000000000000000000000000;;			cCfg := copyTLSConfig(tc.cCfg)
0000000000000000000000000000000000000000;;			cCfg.BuildNameToCertificate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s, err := fakeHTTPSServer(tc.sCfg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error starting TLS server: %v", i, err)
0000000000000000000000000000000000000000;;				// No point in proceeding
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tr := &http.Transport{
0000000000000000000000000000000000000000;;				TLSClientConfig: cCfg,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			client := &http.Client{Transport: tr}
0000000000000000000000000000000000000000;;			resp, err := client.Get(s.URL)
0000000000000000000000000000000000000000;;			if tc.fail {
0000000000000000000000000000000000000000;;				_, ok := err.(*url.Error)
0000000000000000000000000000000000000000;;				if !ok || !strings.HasSuffix(err.Error(), "x509: certificate signed by unknown authority") {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected error: want x509.HostnameError, got: %T", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// We are done for this test.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error while sending GET request to the server: %T", i, err)
0000000000000000000000000000000000000000;;				// No point in proceeding
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			got, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error reading server response: %v", i, err)
0000000000000000000000000000000000000000;;			} else if string(got) != helloMsg {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] want %q, got %q", i, helloMsg, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeInitHostFactory(apiserverServiceType v1.ServiceType, federationName, namespaceName, advertiseAddress, lbIp, dnsZoneName, serverImage, etcdImage, dnsProvider, dnsProviderConfig, etcdPersistence, etcdPVCapacity, etcdPVStorageClass, apiserverOverrideArg, cmOverrideArg, tmpDirPath string, apiserverEnableHTTPBasicAuth, apiserverEnableTokenAuth, isRBACAPIAvailable bool) (cmdutil.Factory, error) {
0000000000000000000000000000000000000000;;		svcName := federationName + "-apiserver"
0000000000000000000000000000000000000000;;		svcUrlPrefix := "/api/v1/namespaces/federation-system/services"
0000000000000000000000000000000000000000;;		credSecretName := svcName + "-credentials"
0000000000000000000000000000000000000000;;		cmKubeconfigSecretName := federationName + "-controller-manager-kubeconfig"
0000000000000000000000000000000000000000;;		pvCap := "10Gi"
0000000000000000000000000000000000000000;;		if etcdPVCapacity != "" {
0000000000000000000000000000000000000000;;			pvCap = etcdPVCapacity
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capacity, err := resource.ParseQuantity(pvCap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pvcName := svcName + "-etcd-claim"
0000000000000000000000000000000000000000;;		replicas := int32(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace := v1.Namespace{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Namespace",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Default.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: namespaceName,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc := v1.Service{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Service",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Default.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Name:      svcName,
0000000000000000000000000000000000000000;;				Labels:    componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type:     apiserverServiceType,
0000000000000000000000000000000000000000;;				Selector: apiserverSvcSelector,
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:       "https",
0000000000000000000000000000000000000000;;						Protocol:   "TCP",
0000000000000000000000000000000000000000;;						Port:       443,
0000000000000000000000000000000000000000;;						TargetPort: intstr.FromString(apiServerSecurePortName),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcWithLB := svc
0000000000000000000000000000000000000000;;		svcWithLB.Status = v1.ServiceStatus{
0000000000000000000000000000000000000000;;			LoadBalancer: v1.LoadBalancerStatus{
0000000000000000000000000000000000000000;;				Ingress: []v1.LoadBalancerIngress{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						IP: lbIp,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		credSecret := v1.Secret{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Secret",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Default.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      credSecretName,
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmKubeconfigSecret := v1.Secret{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Secret",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Default.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      cmKubeconfigSecretName,
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmDNSProviderSecret := v1.Secret{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Secret",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Default.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      dnsProviderSecretName,
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var storageClassName *string
0000000000000000000000000000000000000000;;		if len(etcdPVStorageClass) > 0 {
0000000000000000000000000000000000000000;;			storageClassName = &etcdPVStorageClass
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvc := v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "PersistentVolumeClaim",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Default.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      pvcName,
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Labels:    componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;					v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceStorage: capacity,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				StorageClassName: storageClassName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sa := v1.ServiceAccount{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "ServiceAccount",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Default.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "federation-controller-manager",
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Labels:    componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role := rbacv1beta1.Role{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Role",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Rbac.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "federation-system:federation-controller-manager",
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Labels:    componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Rules: []rbacv1beta1.PolicyRule{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Verbs:     []string{"get", "list", "watch"},
0000000000000000000000000000000000000000;;					APIGroups: []string{""},
0000000000000000000000000000000000000000;;					Resources: []string{"secrets"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rolebinding := rbacv1beta1.RoleBinding{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "RoleBinding",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Rbac.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "federation-system:federation-controller-manager",
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Labels:    componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subjects: []rbacv1beta1.Subject{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Kind:      "ServiceAccount",
0000000000000000000000000000000000000000;;					APIGroup:  "",
0000000000000000000000000000000000000000;;					Name:      "federation-controller-manager",
0000000000000000000000000000000000000000;;					Namespace: "federation-system",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RoleRef: rbacv1beta1.RoleRef{
0000000000000000000000000000000000000000;;				APIGroup: "rbac.authorization.k8s.io",
0000000000000000000000000000000000000000;;				Kind:     "Role",
0000000000000000000000000000000000000000;;				Name:     "federation-system:federation-controller-manager",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node := v1.Node{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Node",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Extensions.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: nodeIP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;				Addresses: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;						Address: nodeIP,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeList := v1.NodeList{}
0000000000000000000000000000000000000000;;		nodeList.Items = append(nodeList.Items, node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		address := lbIp
0000000000000000000000000000000000000000;;		if apiserverServiceType == v1.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;			if advertiseAddress != "" {
0000000000000000000000000000000000000000;;				address = advertiseAddress
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				address = nodeIP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiserverCommand := []string{
0000000000000000000000000000000000000000;;			"/hyperkube",
0000000000000000000000000000000000000000;;			"federation-apiserver",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiserverArgs := []string{
0000000000000000000000000000000000000000;;			"--bind-address=0.0.0.0",
0000000000000000000000000000000000000000;;			"--etcd-servers=http://localhost:2379",
0000000000000000000000000000000000000000;;			fmt.Sprintf("--secure-port=%d", apiServerSecurePort),
0000000000000000000000000000000000000000;;			"--tls-cert-file=/etc/federation/apiserver/server.crt",
0000000000000000000000000000000000000000;;			"--tls-private-key-file=/etc/federation/apiserver/server.key",
0000000000000000000000000000000000000000;;			"--admission-control=NamespaceLifecycle",
0000000000000000000000000000000000000000;;			fmt.Sprintf("--advertise-address=%s", address),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if apiserverOverrideArg != "" {
0000000000000000000000000000000000000000;;			apiserverArgs = append(apiserverArgs, "--client-ca-file=override")
0000000000000000000000000000000000000000;;			apiserverArgs = append(apiserverArgs, "--log-dir=override")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			apiserverArgs = append(apiserverArgs, "--client-ca-file=/etc/federation/apiserver/ca.crt")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiserverEnableHTTPBasicAuth {
0000000000000000000000000000000000000000;;			apiserverArgs = append(apiserverArgs, "--basic-auth-file=/etc/federation/apiserver/basicauth.csv")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiserverEnableTokenAuth {
0000000000000000000000000000000000000000;;			apiserverArgs = append(apiserverArgs, "--token-auth-file=/etc/federation/apiserver/token.csv")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(apiserverArgs)
0000000000000000000000000000000000000000;;		apiserverCommand = append(apiserverCommand, apiserverArgs...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiserver := &v1beta1.Deployment{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Deployment",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Extensions.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        svcName,
0000000000000000000000000000000000000000;;				Namespace:   namespaceName,
0000000000000000000000000000000000000000;;				Labels:      componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Selector: nil,
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        svcName,
0000000000000000000000000000000000000000;;						Labels:      apiserverPodLabels,
0000000000000000000000000000000000000000;;						Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    "apiserver",
0000000000000000000000000000000000000000;;								Image:   serverImage,
0000000000000000000000000000000000000000;;								Command: apiserverCommand,
0000000000000000000000000000000000000000;;								Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:          apiServerSecurePortName,
0000000000000000000000000000000000000000;;										ContainerPort: apiServerSecurePort,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:          "local",
0000000000000000000000000000000000000000;;										ContainerPort: 8080,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      credSecretName,
0000000000000000000000000000000000000000;;										MountPath: "/etc/federation/apiserver",
0000000000000000000000000000000000000000;;										ReadOnly:  true,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "etcd",
0000000000000000000000000000000000000000;;								Image: etcdImage,
0000000000000000000000000000000000000000;;								Command: []string{
0000000000000000000000000000000000000000;;									"/usr/local/bin/etcd",
0000000000000000000000000000000000000000;;									"--data-dir",
0000000000000000000000000000000000000000;;									"/var/etcd/data",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: credSecretName,
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;										SecretName: credSecretName,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if etcdPersistence == "true" {
0000000000000000000000000000000000000000;;			dataVolumeName := "etcddata"
0000000000000000000000000000000000000000;;			etcdVolume := v1.Volume{
0000000000000000000000000000000000000000;;				Name: dataVolumeName,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					PersistentVolumeClaim: &v1.PersistentVolumeClaimVolumeSource{
0000000000000000000000000000000000000000;;						ClaimName: pvcName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			etcdVolumeMount := v1.VolumeMount{
0000000000000000000000000000000000000000;;				Name:      dataVolumeName,
0000000000000000000000000000000000000000;;				MountPath: "/var/etcd",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			apiserver.Spec.Template.Spec.Volumes = append(apiserver.Spec.Template.Spec.Volumes, etcdVolume)
0000000000000000000000000000000000000000;;			for i, container := range apiserver.Spec.Template.Spec.Containers {
0000000000000000000000000000000000000000;;				if container.Name == "etcd" {
0000000000000000000000000000000000000000;;					apiserver.Spec.Template.Spec.Containers[i].VolumeMounts = append(apiserver.Spec.Template.Spec.Containers[i].VolumeMounts, etcdVolumeMount)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmCommand := []string{
0000000000000000000000000000000000000000;;			"/hyperkube",
0000000000000000000000000000000000000000;;			"federation-controller-manager",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmArgs := []string{
0000000000000000000000000000000000000000;;			"--kubeconfig=/etc/federation/controller-manager/kubeconfig",
0000000000000000000000000000000000000000;;			fmt.Sprintf("--federation-name=%s", federationName),
0000000000000000000000000000000000000000;;			fmt.Sprintf("--zone-name=%s", dnsZoneName),
0000000000000000000000000000000000000000;;			fmt.Sprintf("--master=https://%s", svcName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmOverrideArg != "" {
0000000000000000000000000000000000000000;;			cmArgs = append(cmArgs, "--dns-provider=override")
0000000000000000000000000000000000000000;;			cmArgs = append(cmArgs, "--log-dir=override")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cmArgs = append(cmArgs, fmt.Sprintf("--dns-provider=%s", dnsProvider))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Strings(cmArgs)
0000000000000000000000000000000000000000;;		cmCommand = append(cmCommand, cmArgs...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmName := federationName + "-controller-manager"
0000000000000000000000000000000000000000;;		cm := &v1beta1.Deployment{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Deployment",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Extensions.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      cmName,
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;				Labels:    componentLabel,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					util.FedDomainMapKey:                fmt.Sprintf("%s=%s", federationName, strings.TrimRight(dnsZoneName, ".")),
0000000000000000000000000000000000000000;;					federation.FederationNameAnnotation: federationName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1beta1.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;				Selector: nil,
0000000000000000000000000000000000000000;;				Template: v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:        cmName,
0000000000000000000000000000000000000000;;						Labels:      controllerManagerPodLabels,
0000000000000000000000000000000000000000;;						Annotations: map[string]string{federation.FederationNameAnnotation: federationName},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []v1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:    "controller-manager",
0000000000000000000000000000000000000000;;								Image:   serverImage,
0000000000000000000000000000000000000000;;								Command: cmCommand,
0000000000000000000000000000000000000000;;								VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:      cmKubeconfigSecretName,
0000000000000000000000000000000000000000;;										MountPath: "/etc/federation/controller-manager",
0000000000000000000000000000000000000000;;										ReadOnly:  true,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name: "POD_NAMESPACE",
0000000000000000000000000000000000000000;;										ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;											FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;												FieldPath: "metadata.namespace",
0000000000000000000000000000000000000000;;											},
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: cmKubeconfigSecretName,
0000000000000000000000000000000000000000;;								VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;									Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;										SecretName: cmKubeconfigSecretName,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isRBACAPIAvailable {
0000000000000000000000000000000000000000;;			cm.Spec.Template.Spec.ServiceAccountName = "federation-controller-manager"
0000000000000000000000000000000000000000;;			cm.Spec.Template.Spec.DeprecatedServiceAccount = "federation-controller-manager"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dnsProviderConfig != "" {
0000000000000000000000000000000000000000;;			cm = addDNSProviderConfigTest(cm, cmDNSProviderSecret.Name)
0000000000000000000000000000000000000000;;			if dnsProvider == util.FedDNSProviderCoreDNS {
0000000000000000000000000000000000000000;;				cm, err = addCoreDNSServerAnnotationTest(cm, dnsZoneName, dnsProviderConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList := v1.PodList{}
0000000000000000000000000000000000000000;;		apiServerPod := v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Extensions.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      svcName,
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Phase: "Running",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmPod := v1.Pod{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Pod",
0000000000000000000000000000000000000000;;				APIVersion: testapi.Extensions.GroupVersion().String(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      cmName,
0000000000000000000000000000000000000000;;				Namespace: namespaceName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Phase: "Running",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList.Items = append(podList.Items, apiServerPod)
0000000000000000000000000000000000000000;;		podList.Items = append(podList.Items, cmPod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiGroupList := &metav1.APIGroupList{}
0000000000000000000000000000000000000000;;		testGroup := metav1.APIGroup{
0000000000000000000000000000000000000000;;			Name: testAPIGroup,
0000000000000000000000000000000000000000;;			Versions: []metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					GroupVersion: testAPIGroup + "/" + testAPIVersion,
0000000000000000000000000000000000000000;;					Version:      testAPIVersion,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rbacGroup := metav1.APIGroup{
0000000000000000000000000000000000000000;;			Name: rbac.GroupName,
0000000000000000000000000000000000000000;;			Versions: []metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					GroupVersion: rbac.GroupName + "/v1beta1",
0000000000000000000000000000000000000000;;					Version:      "v1beta1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiGroupList.Groups = append(apiGroupList.Groups, testGroup)
0000000000000000000000000000000000000000;;		if isRBACAPIAvailable {
0000000000000000000000000000000000000000;;			apiGroupList.Groups = append(apiGroupList.Groups, rbacGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, tf, codec, _ := cmdtesting.NewAPIFactory()
0000000000000000000000000000000000000000;;		extCodec := testapi.Extensions.Codec()
0000000000000000000000000000000000000000;;		rbacCodec := testapi.Rbac.Codec()
0000000000000000000000000000000000000000;;		ns := dynamic.ContentConfig().NegotiatedSerializer
0000000000000000000000000000000000000000;;		tf.ClientConfig = kubefedtesting.DefaultClientConfig()
0000000000000000000000000000000000000000;;		tf.TmpDir = tmpDirPath
0000000000000000000000000000000000000000;;		tf.Client = &fake.RESTClient{
0000000000000000000000000000000000000000;;			APIRegistry:          api.Registry,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: ns,
0000000000000000000000000000000000000000;;			Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				switch p, m := req.URL.Path, req.Method; {
0000000000000000000000000000000000000000;;				case p == "/healthz":
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: ioutil.NopCloser(bytes.NewReader([]byte("ok")))}, nil
0000000000000000000000000000000000000000;;				case p == "/api" && m == http.MethodGet:
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &metav1.APIVersions{})}, nil
0000000000000000000000000000000000000000;;				case p == "/apis" && m == http.MethodGet:
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, apiGroupList)}, nil
0000000000000000000000000000000000000000;;				case p == "/api/v1/namespaces" && m == http.MethodPost:
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var got v1.Namespace
0000000000000000000000000000000000000000;;					_, _, err = codec.Decode(body, nil, &got)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !apiequality.Semantic.DeepEqual(got, namespace) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected namespace object\n\tDiff: %s", diff.ObjectGoPrintDiff(got, namespace))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusCreated, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &namespace)}, nil
0000000000000000000000000000000000000000;;				case p == svcUrlPrefix && m == http.MethodPost:
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var got v1.Service
0000000000000000000000000000000000000000;;					_, _, err = codec.Decode(body, nil, &got)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !apiequality.Semantic.DeepEqual(got, svc) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected service object\n\tDiff: %s", diff.ObjectGoPrintDiff(got, svc))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if apiserverServiceType == v1.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;						svc.Spec.Type = v1.ServiceTypeNodePort
0000000000000000000000000000000000000000;;						svc.Spec.Ports[0].NodePort = nodePort
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusCreated, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &svc)}, nil
0000000000000000000000000000000000000000;;				case strings.HasPrefix(p, svcUrlPrefix) && m == http.MethodGet:
0000000000000000000000000000000000000000;;					got := strings.TrimPrefix(p, svcUrlPrefix+"/")
0000000000000000000000000000000000000000;;					if got != svcName {
0000000000000000000000000000000000000000;;						return nil, errors.NewNotFound(api.Resource("services"), got)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &svcWithLB)}, nil
0000000000000000000000000000000000000000;;				case p == "/api/v1/namespaces/federation-system/secrets" && m == http.MethodPost:
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var got, want v1.Secret
0000000000000000000000000000000000000000;;					_, _, err = codec.Decode(body, nil, &got)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					switch got.Name {
0000000000000000000000000000000000000000;;					case credSecretName:
0000000000000000000000000000000000000000;;						want = credSecret
0000000000000000000000000000000000000000;;						if apiserverEnableHTTPBasicAuth {
0000000000000000000000000000000000000000;;							if got.Data["basicauth.csv"] == nil {
0000000000000000000000000000000000000000;;								return nil, fmt.Errorf("expected secret data key 'basicauth.csv', but got nil")
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							if got.Data["basicauth.csv"] != nil {
0000000000000000000000000000000000000000;;								return nil, fmt.Errorf("unexpected secret data key 'basicauth.csv'")
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if apiserverEnableTokenAuth {
0000000000000000000000000000000000000000;;							if got.Data["token.csv"] == nil {
0000000000000000000000000000000000000000;;								return nil, fmt.Errorf("expected secret data key 'token.csv', but got nil")
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							if got.Data["token.csv"] != nil {
0000000000000000000000000000000000000000;;								return nil, fmt.Errorf("unexpected secret data key 'token.csv'")
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case cmKubeconfigSecretName:
0000000000000000000000000000000000000000;;						want = cmKubeconfigSecret
0000000000000000000000000000000000000000;;					case dnsProviderSecretName:
0000000000000000000000000000000000000000;;						want = cmDNSProviderSecret
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					got.Data = nil
0000000000000000000000000000000000000000;;					if !apiequality.Semantic.DeepEqual(got, want) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected secret object\n\tDiff: %s", diff.ObjectGoPrintDiff(got, want))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusCreated, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &want)}, nil
0000000000000000000000000000000000000000;;				case p == "/api/v1/namespaces/federation-system/persistentvolumeclaims" && m == http.MethodPost:
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var got v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;					_, _, err = codec.Decode(body, nil, &got)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !apiequality.Semantic.DeepEqual(got, pvc) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected PVC object\n\tDiff: %s", diff.ObjectGoPrintDiff(got, pvc))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusCreated, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &pvc)}, nil
0000000000000000000000000000000000000000;;				case p == "/apis/extensions/v1beta1/namespaces/federation-system/deployments" && m == http.MethodPost:
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var got, want v1beta1.Deployment
0000000000000000000000000000000000000000;;					_, _, err = codec.Decode(body, nil, &got)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					switch got.Name {
0000000000000000000000000000000000000000;;					case svcName:
0000000000000000000000000000000000000000;;						want = *apiserver
0000000000000000000000000000000000000000;;					case cmName:
0000000000000000000000000000000000000000;;						want = *cm
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					//want = *cm
0000000000000000000000000000000000000000;;					if !apiequality.Semantic.DeepEqual(got, want) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected deployment object\n\tDiff: %s", diff.ObjectGoPrintDiff(got, want))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusCreated, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(extCodec, &want)}, nil
0000000000000000000000000000000000000000;;				case p == "/api/v1/namespaces/federation-system/pods" && m == http.MethodGet:
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &podList)}, nil
0000000000000000000000000000000000000000;;				case p == "/api/v1/namespaces/federation-system/serviceaccounts" && m == http.MethodPost:
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var got v1.ServiceAccount
0000000000000000000000000000000000000000;;					_, _, err = codec.Decode(body, nil, &got)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !helper.Semantic.DeepEqual(got, sa) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected service account object\n\tDiff: %s", diff.ObjectGoPrintDiff(got, sa))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusCreated, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &sa)}, nil
0000000000000000000000000000000000000000;;				case p == "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/federation-system/roles" && m == http.MethodPost:
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var got rbacv1beta1.Role
0000000000000000000000000000000000000000;;					_, _, err = codec.Decode(body, nil, &got)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !helper.Semantic.DeepEqual(got, role) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected role object\n\tDiff: %s", diff.ObjectGoPrintDiff(got, role))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusCreated, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(rbacCodec, &role)}, nil
0000000000000000000000000000000000000000;;				case p == "/apis/rbac.authorization.k8s.io/v1beta1/namespaces/federation-system/rolebindings" && m == http.MethodPost:
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var got rbacv1beta1.RoleBinding
0000000000000000000000000000000000000000;;					_, _, err = codec.Decode(body, nil, &got)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !helper.Semantic.DeepEqual(got, rolebinding) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unexpected rolebinding object\n\tDiff: %s", diff.ObjectGoPrintDiff(got, rolebinding))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusCreated, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(rbacCodec, &rolebinding)}, nil
0000000000000000000000000000000000000000;;				case p == "/api/v1/nodes" && m == http.MethodGet:
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: http.StatusOK, Header: kubefedtesting.DefaultHeader(), Body: kubefedtesting.ObjBody(codec, &nodeList)}, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unexpected request: %#v\n%#v", req.URL, req)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testKubeconfigUpdate(t *testing.T, apiserverServiceType v1.ServiceType, federationName, advertiseAddress, lbIP, kubeconfigGlobal, kubeconfigExplicit string, apiserverEnableHTTPBasicAuth, apiserverEnableTokenAuth bool) {
0000000000000000000000000000000000000000;;		filename := kubeconfigGlobal
0000000000000000000000000000000000000000;;		if kubeconfigExplicit != "" {
0000000000000000000000000000000000000000;;			filename = kubeconfigExplicit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config, err := clientcmd.LoadFromFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to open kubeconfig file: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster, ok := config.Clusters[federationName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("No cluster info for %q", federationName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoint := getEndpoint(apiserverServiceType, lbIP, advertiseAddress)
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(endpoint, "https://") {
0000000000000000000000000000000000000000;;			endpoint = fmt.Sprintf("https://%s", endpoint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cluster.Server != endpoint {
0000000000000000000000000000000000000000;;			t.Errorf("Want federation API server endpoint %q, got %q", endpoint, cluster.Server)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authInfo, ok := config.AuthInfos[federationName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("No credentials for %q", federationName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(authInfo.ClientCertificateData) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected client certificate to be non-empty")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(authInfo.ClientKeyData) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected client key to be non-empty")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiserverEnableTokenAuth && len(authInfo.Token) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected token to be empty: got: %s", authInfo.Token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiserverEnableTokenAuth && len(authInfo.Token) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected token to be non-empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		httpBasicAuthInfo, ok := config.AuthInfos[fmt.Sprintf("%s-basic-auth", federationName)]
0000000000000000000000000000000000000000;;		if !apiserverEnableHTTPBasicAuth && ok {
0000000000000000000000000000000000000000;;			t.Errorf("Expected basic auth AuthInfo entry not to exist: got %v", httpBasicAuthInfo)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if apiserverEnableHTTPBasicAuth {
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("Expected basic auth AuthInfo entry to exist")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if httpBasicAuthInfo.Username != "admin" {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected username in basic auth AuthInfo entry: got %s, want admin", httpBasicAuthInfo.Username)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(httpBasicAuthInfo.Password) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected basic auth AuthInfo entry to contain password")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context, ok := config.Contexts[federationName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("No context for %q", federationName)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if context.Cluster != federationName {
0000000000000000000000000000000000000000;;			t.Errorf("Want context cluster name: %q, got: %q", federationName, context.Cluster)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if context.AuthInfo != federationName {
0000000000000000000000000000000000000000;;			t.Errorf("Want context auth info: %q, got: %q", federationName, context.AuthInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clientServerTLSConfigs struct {
0000000000000000000000000000000000000000;;		server *tls.Config
0000000000000000000000000000000000000000;;		client *tls.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type certParams struct {
0000000000000000000000000000000000000000;;		cAddr     string
0000000000000000000000000000000000000000;;		ips       []string
0000000000000000000000000000000000000000;;		hostnames []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tlsHandshake(t *testing.T, sCfg, cCfg *tls.Config) error {
0000000000000000000000000000000000000000;;		// Tried to use net.Pipe() instead of TCP. But the connections returned by
0000000000000000000000000000000000000000;;		// net.Pipe() do a fully-synchronous reads and writes on both the ends.
0000000000000000000000000000000000000000;;		// So if a TLS handshake fails, they can't return the error until the
0000000000000000000000000000000000000000;;		// other side reads the message which it did not expect. Since the other
0000000000000000000000000000000000000000;;		// side does not read the message it did not expect, the server and
0000000000000000000000000000000000000000;;		// clients hang. Since TCP is non-blocking we use that as transport
0000000000000000000000000000000000000000;;		// instead. One could have as well used a Unix Domain Socket, but TCP is
0000000000000000000000000000000000000000;;		// more portable.
0000000000000000000000000000000000000000;;		s, err := tls.Listen("tcp", "", sCfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create a test TLS server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errCh := make(chan error)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				conn, err := s.Accept()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errCh <- fmt.Errorf("failed to accept a TLS connection: %v", err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gotByte := make([]byte, len(helloMsg))
0000000000000000000000000000000000000000;;				_, err = conn.Read(gotByte)
0000000000000000000000000000000000000000;;				if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;					errCh <- fmt.Errorf("failed to read input: %v", err)
0000000000000000000000000000000000000000;;				} else if got := string(gotByte); got != helloMsg {
0000000000000000000000000000000000000000;;					errCh <- fmt.Errorf("got %q, want %q", got, helloMsg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				errCh <- nil
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// workaround [::] not working in ipv4 only systems (https://github.com/golang/go/issues/18806)
0000000000000000000000000000000000000000;;		// TODO: remove with Golang 1.9 with https://go-review.googlesource.com/c/45088/
0000000000000000000000000000000000000000;;		addr := strings.TrimPrefix(s.Addr().String(), "[::]")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := tls.Dial("tcp", addr, cCfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Intentionally not serializing the error received because we want to
0000000000000000000000000000000000000000;;			// test for the failure case in the caller test function.
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer c.Close()
0000000000000000000000000000000000000000;;		if _, err := c.Write([]byte(helloMsg)); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to write to server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return <-errCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeHTTPSServer(sCfg *tls.Config) (*httptest.Server, error) {
0000000000000000000000000000000000000000;;		s := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			fmt.Fprint(w, helloMsg)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.TLS.Certificates = sCfg.Certificates
0000000000000000000000000000000000000000;;		s.TLS.RootCAs = sCfg.RootCAs
0000000000000000000000000000000000000000;;		s.TLS.ClientAuth = sCfg.ClientAuth
0000000000000000000000000000000000000000;;		s.TLS.ClientCAs = sCfg.ClientCAs
0000000000000000000000000000000000000000;;		s.TLS.InsecureSkipVerify = sCfg.InsecureSkipVerify
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tlsConfigs(params []certParams) ([]clientServerTLSConfigs, error) {
0000000000000000000000000000000000000000;;		tlsCfgs := []clientServerTLSConfigs{}
0000000000000000000000000000000000000000;;		for i, p := range params {
0000000000000000000000000000000000000000;;			sCfg, cCfg, err := genServerClientTLSConfigs(testNamespace, p.cAddr, testSvcName, HostClusterLocalDNSZoneName, p.ips, p.hostnames)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("[%d] failed to generate tls configs: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsCfgs = append(tlsCfgs, clientServerTLSConfigs{sCfg, cCfg})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tlsCfgs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genServerClientTLSConfigs(namespace, name, svcName, localDNSZoneName string, ips, hostnames []string) (*tls.Config, *tls.Config, error) {
0000000000000000000000000000000000000000;;		entKeyPairs, err := genCerts(namespace, name, svcName, localDNSZoneName, ips, hostnames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unexpected error generating certs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		roots := x509.NewCertPool()
0000000000000000000000000000000000000000;;		roots.AddCert(entKeyPairs.ca.Cert)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverCert := tls.Certificate{
0000000000000000000000000000000000000000;;			Certificate: [][]byte{
0000000000000000000000000000000000000000;;				entKeyPairs.server.Cert.Raw,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PrivateKey: entKeyPairs.server.Key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmCert := tls.Certificate{
0000000000000000000000000000000000000000;;			Certificate: [][]byte{
0000000000000000000000000000000000000000;;				entKeyPairs.controllerManager.Cert.Raw,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PrivateKey: entKeyPairs.controllerManager.Key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sCfg := &tls.Config{
0000000000000000000000000000000000000000;;			Certificates:       []tls.Certificate{serverCert},
0000000000000000000000000000000000000000;;			RootCAs:            roots,
0000000000000000000000000000000000000000;;			ClientAuth:         tls.RequireAndVerifyClientCert,
0000000000000000000000000000000000000000;;			ClientCAs:          roots,
0000000000000000000000000000000000000000;;			InsecureSkipVerify: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cCfg := &tls.Config{
0000000000000000000000000000000000000000;;			Certificates: []tls.Certificate{cmCert},
0000000000000000000000000000000000000000;;			RootCAs:      roots,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sCfg, cCfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyTLSConfig(cfg *tls.Config) *tls.Config {
0000000000000000000000000000000000000000;;		// We are copying only the required fields.
0000000000000000000000000000000000000000;;		return &tls.Config{
0000000000000000000000000000000000000000;;			Certificates:       cfg.Certificates,
0000000000000000000000000000000000000000;;			RootCAs:            cfg.RootCAs,
0000000000000000000000000000000000000000;;			ClientAuth:         cfg.ClientAuth,
0000000000000000000000000000000000000000;;			ClientCAs:          cfg.ClientCAs,
0000000000000000000000000000000000000000;;			InsecureSkipVerify: cfg.InsecureSkipVerify,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEndpoint(apiserverServiceType v1.ServiceType, lbIP, advertiseAddress string) string {
0000000000000000000000000000000000000000;;		endpoint := lbIP
0000000000000000000000000000000000000000;;		if apiserverServiceType == v1.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;			if advertiseAddress != "" {
0000000000000000000000000000000000000000;;				endpoint = advertiseAddress + ":" + strconv.Itoa(nodePort)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				endpoint = nodeIP + ":" + strconv.Itoa(nodePort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return endpoint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Reuse the function addDNSProviderConfig once that function is converted to use versioned objects.
0000000000000000000000000000000000000000;;	func addDNSProviderConfigTest(dep *v1beta1.Deployment, secretName string) *v1beta1.Deployment {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			dnsProviderConfigVolume    = "config-volume"
0000000000000000000000000000000000000000;;			dnsProviderConfigMountPath = "/etc/federation/dns-provider"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a volume from dns-provider secret
0000000000000000000000000000000000000000;;		volume := v1.Volume{
0000000000000000000000000000000000000000;;			Name: dnsProviderConfigVolume,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;					SecretName: secretName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dep.Spec.Template.Spec.Volumes = append(dep.Spec.Template.Spec.Volumes, volume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mount dns-provider secret volume to controller-manager container
0000000000000000000000000000000000000000;;		volumeMount := v1.VolumeMount{
0000000000000000000000000000000000000000;;			Name:      dnsProviderConfigVolume,
0000000000000000000000000000000000000000;;			MountPath: dnsProviderConfigMountPath,
0000000000000000000000000000000000000000;;			ReadOnly:  true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dep.Spec.Template.Spec.Containers[0].VolumeMounts = append(dep.Spec.Template.Spec.Containers[0].VolumeMounts, volumeMount)
0000000000000000000000000000000000000000;;		dep.Spec.Template.Spec.Containers[0].Command = append(dep.Spec.Template.Spec.Containers[0].Command, fmt.Sprintf("--dns-provider-config=%s/%s", dnsProviderConfigMountPath, secretName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dep
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Reuse the function addCoreDNSServerAnnotation once that function is converted to use versioned objects.
0000000000000000000000000000000000000000;;	func addCoreDNSServerAnnotationTest(deployment *v1beta1.Deployment, dnsZoneName, dnsProviderConfig string) (*v1beta1.Deployment, error) {
0000000000000000000000000000000000000000;;		var cfg coredns.Config
0000000000000000000000000000000000000000;;		if err := gcfg.ReadFileInto(&cfg, dnsProviderConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment.Annotations[util.FedDNSZoneName] = dnsZoneName
0000000000000000000000000000000000000000;;		deployment.Annotations[util.FedNameServer] = cfg.Global.CoreDNSEndpoints
0000000000000000000000000000000000000000;;		deployment.Annotations[util.FedDNSProvider] = util.FedDNSProviderCoreDNS
0000000000000000000000000000000000000000;;		return deployment, nil
0000000000000000000000000000000000000000;;	}
