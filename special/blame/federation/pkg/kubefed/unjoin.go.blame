0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1f89c5d2763b7527251904d7959bb19923c4f4a4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package kubefed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/kubefed/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/cmd/templates"
0000000000000000000000000000000000000000;;		cmdutil "k8s.io/kubernetes/pkg/kubectl/cmd/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubectl/resource"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		unjoin_long = templates.LongDesc(`
0000000000000000000000000000000000000000;;			Unjoin removes a cluster from a federation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        Current context is assumed to be a federation endpoint.
0000000000000000000000000000000000000000;;	        Please use the --context flag otherwise.`)
0000000000000000000000000000000000000000;;		unjoin_example = templates.Examples(`
0000000000000000000000000000000000000000;;			# Unjoin removes the specified cluster from a federation.
0000000000000000000000000000000000000000;;			# Federation control plane's host cluster context name
0000000000000000000000000000000000000000;;			# must be specified via the --host-cluster-context flag
0000000000000000000000000000000000000000;;			# to properly cleanup the credentials.
0000000000000000000000000000000000000000;;			kubectl unjoin foo --host-cluster-context=bar --cluster-context=baz`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unjoinFederation struct {
0000000000000000000000000000000000000000;;		commonOptions util.SubcommandOptions
0000000000000000000000000000000000000000;;		options       unjoinFederationOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unjoinFederationOptions struct {
0000000000000000000000000000000000000000;;		clusterContext string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *unjoinFederationOptions) Bind(flags *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		flags.StringVar(&o.clusterContext, "cluster-context", "", "Name of the cluster's context in the local kubeconfig. Defaults to cluster name if unspecified.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCmdUnjoin defines the `unjoin` command that removes a cluster
0000000000000000000000000000000000000000;;	// from a federation.
0000000000000000000000000000000000000000;;	func NewCmdUnjoin(f cmdutil.Factory, cmdOut, cmdErr io.Writer, config util.AdminConfig) *cobra.Command {
0000000000000000000000000000000000000000;;		opts := &unjoinFederation{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use:     "unjoin CLUSTER_NAME --host-cluster-context=HOST_CONTEXT",
0000000000000000000000000000000000000000;;			Short:   "Unjoins a cluster from a federation",
0000000000000000000000000000000000000000;;			Long:    unjoin_long,
0000000000000000000000000000000000000000;;			Example: unjoin_example,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.commonOptions.SetName(cmd, args))
0000000000000000000000000000000000000000;;				cmdutil.CheckErr(opts.Run(f, cmdOut, cmdErr, config))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags := cmd.Flags()
0000000000000000000000000000000000000000;;		opts.commonOptions.Bind(flags)
0000000000000000000000000000000000000000;;		opts.options.Bind(flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unjoinFederation is the implementation of the `unjoin` command.
0000000000000000000000000000000000000000;;	func (u *unjoinFederation) Run(f cmdutil.Factory, cmdOut, cmdErr io.Writer, config util.AdminConfig) error {
0000000000000000000000000000000000000000;;		if u.options.clusterContext == "" {
0000000000000000000000000000000000000000;;			u.options.clusterContext = u.commonOptions.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster, err := popCluster(f, u.commonOptions.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cluster == nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(cmdErr, "WARNING: cluster %q not found in federation, so its credentials' secret couldn't be deleted", u.commonOptions.Name)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We want a separate client factory to communicate with the
0000000000000000000000000000000000000000;;		// federation host cluster. See join_federation.go for details.
0000000000000000000000000000000000000000;;		hostFactory := config.ClusterFactory(u.commonOptions.Host, u.commonOptions.Kubeconfig)
0000000000000000000000000000000000000000;;		hostClientset, err := hostFactory.ClientSet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretName := cluster.Spec.SecretRef.Name
0000000000000000000000000000000000000000;;		secret, err := hostClientset.Core().Secrets(u.commonOptions.FederationSystemNamespace).Get(secretName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if isNotFound(err) {
0000000000000000000000000000000000000000;;			// If this is the case, we cannot get the cluster clientset to delete the
0000000000000000000000000000000000000000;;			// config map from that cluster and obviously cannot delete the not existing secret.
0000000000000000000000000000000000000000;;			// We just publish the warning as cluster has already been removed from federation.
0000000000000000000000000000000000000000;;			fmt.Fprintf(cmdErr, "WARNING: secret %q not found in the host cluster, so it couldn't be deleted. Cluster has already been removed from the federation.", secretName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(cmdErr, "WARNING: Error retrieving secret from the base cluster")
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unjoiningClusterFactory := config.ClusterFactory(u.options.clusterContext, u.commonOptions.Kubeconfig)
0000000000000000000000000000000000000000;;		unjoiningClusterClientset, err := unjoiningClusterFactory.ClientSet()
0000000000000000000000000000000000000000;;		outerErr := err
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Attempt to get a clientset using information from the cluster.
0000000000000000000000000000000000000000;;			unjoiningClusterClientset, err = getClientsetFromCluster(secret, cluster)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to get clientset from kubeconfig or cluster: %v, %v", outerErr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = deleteSecret(hostClientset, cluster.Spec.SecretRef.Name, u.commonOptions.FederationSystemNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(cmdErr, "WARNING: secret %q could not be deleted: %v", secretName, err)
0000000000000000000000000000000000000000;;			// We anyways continue to try and delete the config map but with above warning
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We need to ensure updating the config map created in the deregistered cluster
0000000000000000000000000000000000000000;;		// This configmap was created/updated when the cluster joined this federation to aid
0000000000000000000000000000000000000000;;		// the kube-dns of that cluster to aid service discovery.
0000000000000000000000000000000000000000;;		err = updateConfigMapFromCluster(hostClientset, unjoiningClusterClientset, u.commonOptions.FederationSystemNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(cmdErr, "WARNING: Encountered error in deleting kube-dns configmap: %v", err)
0000000000000000000000000000000000000000;;			// We anyways continue to print success message but with above warning
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the service account in the unjoining cluster.
0000000000000000000000000000000000000000;;		err = deleteServiceAccountFromCluster(unjoiningClusterClientset, cluster, u.commonOptions.FederationSystemNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(cmdErr, "WARNING: Encountered error in deleting service account: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the cluster role and role binding in the unjoining cluster.
0000000000000000000000000000000000000000;;		err = deleteClusterRoleBindingFromCluster(unjoiningClusterClientset, cluster)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(cmdErr, "WARNING: Encountered error in deleting cluster role bindings: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintf(cmdOut, "Successfully removed cluster %q from federation\n", u.commonOptions.Name)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// popCluster fetches the cluster object with the given name, deletes
0000000000000000000000000000000000000000;;	// it and returns the deleted cluster object.
0000000000000000000000000000000000000000;;	func popCluster(f cmdutil.Factory, name string) (*federationapi.Cluster, error) {
0000000000000000000000000000000000000000;;		mapper, typer := f.Object()
0000000000000000000000000000000000000000;;		gvks, _, err := typer.ObjectKinds(&federationapi.Cluster{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvk := gvks[0]
0000000000000000000000000000000000000000;;		mapping, err := mapper.RESTMapping(schema.GroupKind{Group: gvk.Group, Kind: gvk.Kind}, gvk.Version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := f.ClientForMapping(mapping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rh := resource.NewHelper(client, mapping)
0000000000000000000000000000000000000000;;		obj, err := rh.Get("", name, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isNotFound(err) {
0000000000000000000000000000000000000000;;			// Cluster isn't registered, there isn't anything to be done here.
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cluster, ok := obj.(*federationapi.Cluster)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected object type: expected \"federation/v1beta1.Cluster\", got %T: obj: %#v", obj, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the cluster resource in the federation API server by
0000000000000000000000000000000000000000;;		// calling rh.Delete()
0000000000000000000000000000000000000000;;		return cluster, rh.Delete("", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateConfigMapFromCluster(hostClientset, unjoiningClusterClientset internalclientset.Interface, fedSystemNamespace string) error {
0000000000000000000000000000000000000000;;		cmDep, err := getCMDeployment(hostClientset, fedSystemNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		domainMap, ok := cmDep.Annotations[util.FedDomainMapKey]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("kube-dns config map data missing from controller manager annotations")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configMap, err := unjoiningClusterClientset.Core().ConfigMaps(metav1.NamespaceSystem).Get(util.KubeDnsConfigmapName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		needUpdate := false
0000000000000000000000000000000000000000;;		if _, ok := configMap.Data[util.FedDomainMapKey]; ok {
0000000000000000000000000000000000000000;;			configMap.Data[util.FedDomainMapKey] = removeConfigMapString(configMap.Data[util.FedDomainMapKey], domainMap)
0000000000000000000000000000000000000000;;			needUpdate = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := configMap.Data[util.KubeDnsStubDomains]; ok {
0000000000000000000000000000000000000000;;			delete(configMap.Data, util.KubeDnsStubDomains)
0000000000000000000000000000000000000000;;			needUpdate = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if needUpdate {
0000000000000000000000000000000000000000;;			_, err = unjoiningClusterClientset.Core().ConfigMaps(metav1.NamespaceSystem).Update(configMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteSecret deletes the secret with the given name from the host
0000000000000000000000000000000000000000;;	// cluster.
0000000000000000000000000000000000000000;;	func deleteSecret(clientset internalclientset.Interface, name, namespace string) error {
0000000000000000000000000000000000000000;;		orphanDependents := false
0000000000000000000000000000000000000000;;		return clientset.Core().Secrets(namespace).Delete(name, &metav1.DeleteOptions{OrphanDependents: &orphanDependents})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isNotFound checks if the given error is a NotFound status error.
0000000000000000000000000000000000000000;;	func isNotFound(err error) bool {
0000000000000000000000000000000000000000;;		statusErr := err
0000000000000000000000000000000000000000;;		if urlErr, ok := err.(*url.Error); ok {
0000000000000000000000000000000000000000;;			statusErr = urlErr.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.IsNotFound(statusErr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getClientsetFromCluster(secret *api.Secret, cluster *federationapi.Cluster) (*internalclientset.Clientset, error) {
0000000000000000000000000000000000000000;;		serverAddress, err := util.GetServerAddress(cluster)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if serverAddress == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get server address for the cluster: %s", cluster.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := util.GetClientsetFromSecret(secret, serverAddress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if clientset == nil {
0000000000000000000000000000000000000000;;			// There is a possibility that the clientset is nil without any error reported
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed for get client to access cluster: %s", cluster.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeConfigMapString returns an empty string if last value is removed
0000000000000000000000000000000000000000;;	// or returns the remaining comma separated strings minus the one to be removed
0000000000000000000000000000000000000000;;	func removeConfigMapString(str string, toRemove string) string {
0000000000000000000000000000000000000000;;		if str == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		values := strings.Split(str, ",")
0000000000000000000000000000000000000000;;		if len(values) == 1 {
0000000000000000000000000000000000000000;;			if values[0] == toRemove {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Somehow our federation string is not here
0000000000000000000000000000000000000000;;				// Dont do anything further
0000000000000000000000000000000000000000;;				return values[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, v := range values {
0000000000000000000000000000000000000000;;			if v == toRemove {
0000000000000000000000000000000000000000;;				values = append(values[:i], values[i+1:]...)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(values, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteServiceAccountFromCluster removes the service account that the federation control plane uses
0000000000000000000000000000000000000000;;	// to access the cluster from the cluster that is leaving the federation.
0000000000000000000000000000000000000000;;	func deleteServiceAccountFromCluster(unjoiningClusterClientset internalclientset.Interface, cluster *federationapi.Cluster, fedSystemNamespace string) error {
0000000000000000000000000000000000000000;;		serviceAccountName, ok := cluster.ObjectMeta.Annotations[kubectl.ServiceAccountNameAnnotation]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// If there is no service account name annotation, assume that this cluster does not have a federation control plane service account.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unjoiningClusterClientset.Core().ServiceAccounts(fedSystemNamespace).Delete(serviceAccountName, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteClusterRoleBindingFromCluster deletes the ClusterRole and ClusterRoleBinding from the
0000000000000000000000000000000000000000;;	// cluster that is leaving the federation.
0000000000000000000000000000000000000000;;	func deleteClusterRoleBindingFromCluster(unjoiningClusterClientset internalclientset.Interface, cluster *federationapi.Cluster) error {
0000000000000000000000000000000000000000;;		clusterRoleName, ok := cluster.ObjectMeta.Annotations[kubectl.ClusterRoleNameAnnotation]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// If there is no cluster role name annotation, assume that this cluster does not have cluster role bindings.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := unjoiningClusterClientset.Rbac().ClusterRoleBindings().Delete(clusterRoleName, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsMethodNotSupported(err) && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = unjoiningClusterClientset.Rbac().ClusterRoles().Delete(clusterRoleName, &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsMethodNotSupported(err) && !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
