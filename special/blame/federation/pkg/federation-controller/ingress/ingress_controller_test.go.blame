0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ae1adb178ecfe767f811d73b11c2dcd113646bc8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ingress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensionsv1beta1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		fakefedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/deletionhelper"
0000000000000000000000000000000000000000;;		finalizersutil "k8s.io/kubernetes/federation/pkg/federation-controller/util/finalizers"
0000000000000000000000000000000000000000;;		. "k8s.io/kubernetes/federation/pkg/federation-controller/util/test"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		fakekubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxTrials         = 20
0000000000000000000000000000000000000000;;		clusters   string = "clusters"
0000000000000000000000000000000000000000;;		ingresses  string = "ingresses"
0000000000000000000000000000000000000000;;		configmaps string = "configmaps"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIngressController(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeClusterList := federationapi.ClusterList{Items: []federationapi.Cluster{}}
0000000000000000000000000000000000000000;;		fakeConfigMapList1 := apiv1.ConfigMapList{Items: []apiv1.ConfigMap{}}
0000000000000000000000000000000000000000;;		fakeConfigMapList2 := apiv1.ConfigMapList{Items: []apiv1.ConfigMap{}}
0000000000000000000000000000000000000000;;		cluster1 := NewCluster("cluster1", apiv1.ConditionTrue)
0000000000000000000000000000000000000000;;		cluster2 := NewCluster("cluster2", apiv1.ConditionTrue)
0000000000000000000000000000000000000000;;		cfg1 := NewConfigMap("foo")
0000000000000000000000000000000000000000;;		cfg2 := NewConfigMap("bar") // Different UID from cfg1, so that we can check that they get reconciled.
0000000000000000000000000000000000000000;;		assert.NotEqual(t, cfg1.Data[uidKey], cfg2.Data[uidKey], fmt.Sprintf("ConfigMap in cluster 2 must initially not equal that in cluster 1 for this test - please fix test"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Creating fake infrastructure")
0000000000000000000000000000000000000000;;		fedClient := &fakefedclientset.Clientset{}
0000000000000000000000000000000000000000;;		RegisterFakeList(clusters, &fedClient.Fake, &fakeClusterList)
0000000000000000000000000000000000000000;;		RegisterFakeList(ingresses, &fedClient.Fake, &extensionsv1beta1.IngressList{Items: []extensionsv1beta1.Ingress{}})
0000000000000000000000000000000000000000;;		fedIngressWatch := RegisterFakeWatch(ingresses, &fedClient.Fake)
0000000000000000000000000000000000000000;;		clusterWatch := RegisterFakeWatch(clusters, &fedClient.Fake)
0000000000000000000000000000000000000000;;		fedClusterUpdateChan := RegisterFakeCopyOnUpdate(clusters, &fedClient.Fake, clusterWatch)
0000000000000000000000000000000000000000;;		fedIngressUpdateChan := RegisterFakeCopyOnUpdate(ingresses, &fedClient.Fake, fedIngressWatch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster1Client := &fakekubeclientset.Clientset{}
0000000000000000000000000000000000000000;;		RegisterFakeList(ingresses, &cluster1Client.Fake, &extensionsv1beta1.IngressList{Items: []extensionsv1beta1.Ingress{}})
0000000000000000000000000000000000000000;;		RegisterFakeList(configmaps, &cluster1Client.Fake, &fakeConfigMapList1)
0000000000000000000000000000000000000000;;		cluster1IngressWatch := RegisterFakeWatch(ingresses, &cluster1Client.Fake)
0000000000000000000000000000000000000000;;		cluster1ConfigMapWatch := RegisterFakeWatch(configmaps, &cluster1Client.Fake)
0000000000000000000000000000000000000000;;		cluster1IngressCreateChan := RegisterFakeCopyOnCreate(ingresses, &cluster1Client.Fake, cluster1IngressWatch)
0000000000000000000000000000000000000000;;		cluster1IngressUpdateChan := RegisterFakeCopyOnUpdate(ingresses, &cluster1Client.Fake, cluster1IngressWatch)
0000000000000000000000000000000000000000;;		cluster1ConfigMapUpdateChan := RegisterFakeCopyOnUpdate(configmaps, &cluster1Client.Fake, cluster1ConfigMapWatch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster2Client := &fakekubeclientset.Clientset{}
0000000000000000000000000000000000000000;;		RegisterFakeList(ingresses, &cluster2Client.Fake, &extensionsv1beta1.IngressList{Items: []extensionsv1beta1.Ingress{}})
0000000000000000000000000000000000000000;;		RegisterFakeList(configmaps, &cluster2Client.Fake, &fakeConfigMapList2)
0000000000000000000000000000000000000000;;		cluster2IngressWatch := RegisterFakeWatch(ingresses, &cluster2Client.Fake)
0000000000000000000000000000000000000000;;		cluster2ConfigMapWatch := RegisterFakeWatch(configmaps, &cluster2Client.Fake)
0000000000000000000000000000000000000000;;		cluster2IngressCreateChan := RegisterFakeCopyOnCreate(ingresses, &cluster2Client.Fake, cluster2IngressWatch)
0000000000000000000000000000000000000000;;		cluster2ConfigMapUpdateChan := RegisterFakeCopyOnUpdate(configmaps, &cluster2Client.Fake, cluster2ConfigMapWatch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientFactoryFunc := func(cluster *federationapi.Cluster) (kubeclientset.Interface, error) {
0000000000000000000000000000000000000000;;			switch cluster.Name {
0000000000000000000000000000000000000000;;			case cluster1.Name:
0000000000000000000000000000000000000000;;				return cluster1Client, nil
0000000000000000000000000000000000000000;;			case cluster2.Name:
0000000000000000000000000000000000000000;;				return cluster2Client, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Unknown cluster")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ingressController := NewIngressController(fedClient)
0000000000000000000000000000000000000000;;		ingressInformer := ToFederatedInformerForTestOnly(ingressController.ingressFederatedInformer)
0000000000000000000000000000000000000000;;		ingressInformer.SetClientFactory(clientFactoryFunc)
0000000000000000000000000000000000000000;;		configMapInformer := ToFederatedInformerForTestOnly(ingressController.configMapFederatedInformer)
0000000000000000000000000000000000000000;;		configMapInformer.SetClientFactory(clientFactoryFunc)
0000000000000000000000000000000000000000;;		ingressController.clusterAvailableDelay = time.Second
0000000000000000000000000000000000000000;;		ingressController.ingressReviewDelay = 100 * time.Millisecond
0000000000000000000000000000000000000000;;		ingressController.configMapReviewDelay = 100 * time.Millisecond
0000000000000000000000000000000000000000;;		ingressController.smallDelay = 100 * time.Millisecond
0000000000000000000000000000000000000000;;		ingressController.updateTimeout = 5 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		t.Log("Running Ingress Controller")
0000000000000000000000000000000000000000;;		ingressController.Run(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Here we are creating the ingress with first cluster annotation.
0000000000000000000000000000000000000000;;		// Add another test without that annotation when
0000000000000000000000000000000000000000;;		// https://github.com/kubernetes/kubernetes/issues/36540 is fixed.
0000000000000000000000000000000000000000;;		fedIngress := extensionsv1beta1.Ingress{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "test-ingress",
0000000000000000000000000000000000000000;;				Namespace: "mynamespace",
0000000000000000000000000000000000000000;;				SelfLink:  "/api/v1/namespaces/mynamespace/ingress/test-ingress",
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					firstClusterAnnotation: cluster1.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: extensionsv1beta1.IngressStatus{
0000000000000000000000000000000000000000;;				LoadBalancer: apiv1.LoadBalancerStatus{
0000000000000000000000000000000000000000;;					Ingress: make([]apiv1.LoadBalancerIngress, 0, 0),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Adding cluster 1")
0000000000000000000000000000000000000000;;		clusterWatch.Add(cluster1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Adding Ingress UID ConfigMap to cluster 1")
0000000000000000000000000000000000000000;;		cluster1ConfigMapWatch.Add(cfg1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Checking that UID annotation on Cluster 1 annotation was correctly updated prior to adding Federated Ingress")
0000000000000000000000000000000000000000;;		cluster := GetClusterFromChan(fedClusterUpdateChan)
0000000000000000000000000000000000000000;;		assert.NotNil(t, cluster)
0000000000000000000000000000000000000000;;		assert.Equal(t, cluster.ObjectMeta.Annotations[uidAnnotationKey], cfg1.Data[uidKey])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Adding cluster 2")
0000000000000000000000000000000000000000;;		clusterWatch.Add(cluster2)
0000000000000000000000000000000000000000;;		cluster2ConfigMapWatch.Add(cfg2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Checking that a configmap updates are propagated prior to Federated Ingress")
0000000000000000000000000000000000000000;;		referenceUid := cfg1.Data[uidKey]
0000000000000000000000000000000000000000;;		uid1, providerId1 := GetConfigMapUidAndProviderId(t, cluster1ConfigMapUpdateChan)
0000000000000000000000000000000000000000;;		uid2, providerId2 := GetConfigMapUidAndProviderId(t, cluster2ConfigMapUpdateChan)
0000000000000000000000000000000000000000;;		t.Logf("uid2 = %v and ref = %v", uid2, referenceUid)
0000000000000000000000000000000000000000;;		assert.True(t, referenceUid == uid1, "Expected cluster1 configmap uid %q to be equal to referenceUid %q", uid1, referenceUid)
0000000000000000000000000000000000000000;;		assert.True(t, referenceUid == uid2, "Expected cluster2 configmap uid %q to be equal to referenceUid %q", uid2, referenceUid)
0000000000000000000000000000000000000000;;		assert.True(t, providerId1 != providerId2, "Expected cluster1 providerUid %q to be unique and different from cluster2 providerUid %q", providerId1, providerId2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test add federated ingress.
0000000000000000000000000000000000000000;;		t.Log("Adding Federated Ingress")
0000000000000000000000000000000000000000;;		fedIngressWatch.Add(&fedIngress)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Checking that appropriate finalizers are added")
0000000000000000000000000000000000000000;;		// There should be an update to add both the finalizers.
0000000000000000000000000000000000000000;;		updatedIngress := GetIngressFromChan(t, fedIngressUpdateChan)
0000000000000000000000000000000000000000;;		AssertHasFinalizer(t, updatedIngress, deletionhelper.FinalizerDeleteFromUnderlyingClusters)
0000000000000000000000000000000000000000;;		AssertHasFinalizer(t, updatedIngress, metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;		fedIngress = *updatedIngress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Checking that Ingress was correctly created in cluster 1")
0000000000000000000000000000000000000000;;		createdIngress := GetIngressFromChan(t, cluster1IngressCreateChan)
0000000000000000000000000000000000000000;;		assert.NotNil(t, createdIngress)
0000000000000000000000000000000000000000;;		cluster1Ingress := *createdIngress
0000000000000000000000000000000000000000;;		assert.True(t, reflect.DeepEqual(fedIngress.Spec, cluster1Ingress.Spec), "Spec of created ingress is not equal")
0000000000000000000000000000000000000000;;		assert.True(t, util.ObjectMetaEquivalent(fedIngress.ObjectMeta, cluster1Ingress.ObjectMeta),
0000000000000000000000000000000000000000;;			"Metadata of created object is not equivalent")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for finalizers to appear in federation store.
0000000000000000000000000000000000000000;;		assert.NoError(t, WaitForFinalizersInFederationStore(ingressController, ingressController.ingressInformerStore,
0000000000000000000000000000000000000000;;			types.NamespacedName{Namespace: fedIngress.Namespace, Name: fedIngress.Name}.String()), "finalizers not found in federated ingress")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for the cluster ingress to appear in cluster store.
0000000000000000000000000000000000000000;;		assert.NoError(t, WaitForIngressInClusterStore(ingressController.ingressFederatedInformer.GetTargetStore(), cluster1.Name,
0000000000000000000000000000000000000000;;			types.NamespacedName{Namespace: createdIngress.Namespace, Name: createdIngress.Name}.String()),
0000000000000000000000000000000000000000;;			"Created ingress not found in underlying cluster store")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test that IP address gets transferred from cluster ingress to federated ingress.
0000000000000000000000000000000000000000;;		t.Log("Checking that IP address gets transferred from cluster ingress to federated ingress")
0000000000000000000000000000000000000000;;		cluster1Ingress.Status.LoadBalancer.Ingress = append(cluster1Ingress.Status.LoadBalancer.Ingress,
0000000000000000000000000000000000000000;;			apiv1.LoadBalancerIngress{IP: "1.2.3.4"})
0000000000000000000000000000000000000000;;		glog.Infof("Setting artificial IP address for cluster1 ingress")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for trial := 0; trial < maxTrials; trial++ {
0000000000000000000000000000000000000000;;			cluster1IngressWatch.Modify(&cluster1Ingress)
0000000000000000000000000000000000000000;;			// Wait for store to see the updated cluster ingress.
0000000000000000000000000000000000000000;;			key := types.NamespacedName{Namespace: createdIngress.Namespace, Name: createdIngress.Name}.String()
0000000000000000000000000000000000000000;;			if err := WaitForStatusUpdate(t, ingressController.ingressFederatedInformer.GetTargetStore(),
0000000000000000000000000000000000000000;;				cluster1.Name, key, cluster1Ingress.Status.LoadBalancer, time.Second); err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := WaitForFedStatusUpdate(t, ingressController.ingressInformerStore,
0000000000000000000000000000000000000000;;				key, cluster1Ingress.Status.LoadBalancer, time.Second); err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for trial := 0; trial < maxTrials; trial++ {
0000000000000000000000000000000000000000;;			updatedIngress = GetIngressFromChan(t, fedIngressUpdateChan)
0000000000000000000000000000000000000000;;			assert.NotNil(t, updatedIngress, "Cluster's ingress load balancer status was not correctly transferred to the federated ingress")
0000000000000000000000000000000000000000;;			if updatedIngress == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(cluster1Ingress.Status.LoadBalancer.Ingress, updatedIngress.Status.LoadBalancer.Ingress) {
0000000000000000000000000000000000000000;;				fedIngress.Status.LoadBalancer = updatedIngress.Status.LoadBalancer
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("Status check failed: expected: %v actual: %v", cluster1Ingress.Status, updatedIngress.Status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Status check: expected: %v actual: %v", cluster1Ingress.Status, updatedIngress.Status)
0000000000000000000000000000000000000000;;		assert.True(t, reflect.DeepEqual(cluster1Ingress.Status.LoadBalancer.Ingress, updatedIngress.Status.LoadBalancer.Ingress),
0000000000000000000000000000000000000000;;			fmt.Sprintf("Ingress IP was not transferred from cluster ingress to federated ingress.  %v is not equal to %v",
0000000000000000000000000000000000000000;;				cluster1Ingress.Status.LoadBalancer.Ingress, updatedIngress.Status.LoadBalancer.Ingress))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NoError(t, WaitForStatusUpdate(t, ingressController.ingressFederatedInformer.GetTargetStore(),
0000000000000000000000000000000000000000;;			cluster1.Name, types.NamespacedName{Namespace: createdIngress.Namespace, Name: createdIngress.Name}.String(),
0000000000000000000000000000000000000000;;			cluster1Ingress.Status.LoadBalancer, time.Second))
0000000000000000000000000000000000000000;;		assert.NoError(t, WaitForFedStatusUpdate(t, ingressController.ingressInformerStore,
0000000000000000000000000000000000000000;;			types.NamespacedName{Namespace: createdIngress.Namespace, Name: createdIngress.Name}.String(),
0000000000000000000000000000000000000000;;			cluster1Ingress.Status.LoadBalancer, time.Second))
0000000000000000000000000000000000000000;;		t.Logf("expected: %v, actual: %v", createdIngress, updatedIngress)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test update federated ingress.
0000000000000000000000000000000000000000;;		if fedIngress.ObjectMeta.Annotations == nil {
0000000000000000000000000000000000000000;;			fedIngress.ObjectMeta.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fedIngress.ObjectMeta.Annotations["A"] = "B"
0000000000000000000000000000000000000000;;		fedIngress.ObjectMeta.Annotations[federationapi.FederationClusterSelectorAnnotation] = `[{"key": "cluster", "operator": "in", "values": ["cluster1","cluster2"]}]`
0000000000000000000000000000000000000000;;		t.Log("Modifying Federated Ingress")
0000000000000000000000000000000000000000;;		fedIngressWatch.Modify(&fedIngress)
0000000000000000000000000000000000000000;;		t.Log("Checking that Ingress was correctly updated in cluster 1")
0000000000000000000000000000000000000000;;		var updatedIngress2 *extensionsv1beta1.Ingress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for trial := 0; trial < maxTrials; trial++ {
0000000000000000000000000000000000000000;;			updatedIngress2 = GetIngressFromChan(t, cluster1IngressUpdateChan)
0000000000000000000000000000000000000000;;			assert.NotNil(t, updatedIngress2)
0000000000000000000000000000000000000000;;			if updatedIngress2 == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(fedIngress.Spec, updatedIngress.Spec) &&
0000000000000000000000000000000000000000;;				updatedIngress2.ObjectMeta.Annotations["A"] == fedIngress.ObjectMeta.Annotations["A"] {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.True(t, reflect.DeepEqual(updatedIngress2.Spec, fedIngress.Spec), "Spec of updated ingress is not equal")
0000000000000000000000000000000000000000;;		assert.Equal(t, updatedIngress2.ObjectMeta.Annotations["A"], fedIngress.ObjectMeta.Annotations["A"], "Updated annotation not transferred from federated to cluster ingress.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fedIngress.Annotations[staticIPNameKeyWritable] = "foo" // Make sure that the base object has a static IP name first.
0000000000000000000000000000000000000000;;		fedIngressWatch.Modify(&fedIngress)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Log("Checking that the ingress got created in cluster 2 after a global ip was assigned")
0000000000000000000000000000000000000000;;		createdIngress2 := GetIngressFromChan(t, cluster2IngressCreateChan)
0000000000000000000000000000000000000000;;		assert.NotNil(t, createdIngress2)
0000000000000000000000000000000000000000;;		assert.True(t, reflect.DeepEqual(fedIngress.Spec, createdIngress2.Spec), "Spec of created ingress is not equal")
0000000000000000000000000000000000000000;;		t.Logf("created meta: %v fed meta: %v", createdIngress2.ObjectMeta, fedIngress.ObjectMeta)
0000000000000000000000000000000000000000;;		assert.True(t, util.ObjectMetaEquivalent(fedIngress.ObjectMeta, createdIngress2.ObjectMeta), "Metadata of created object is not equivalent")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(stop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetConfigMapUidAndProviderId(t *testing.T, c chan runtime.Object) (string, string) {
0000000000000000000000000000000000000000;;		updatedConfigMap := GetConfigMapFromChan(c)
0000000000000000000000000000000000000000;;		assert.NotNil(t, updatedConfigMap, "ConfigMap should have received an update")
0000000000000000000000000000000000000000;;		assert.NotNil(t, updatedConfigMap.Data, "ConfigMap data is empty")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, key := range []string{uidKey, providerUidKey} {
0000000000000000000000000000000000000000;;			val, ok := updatedConfigMap.Data[key]
0000000000000000000000000000000000000000;;			assert.True(t, ok, fmt.Sprintf("Didn't receive an update for key %v: %v", key, updatedConfigMap.Data))
0000000000000000000000000000000000000000;;			assert.True(t, len(val) > 0, fmt.Sprintf("Received an empty update for key %v", key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedConfigMap.Data[uidKey], updatedConfigMap.Data[providerUidKey]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetIngressFromChan(t *testing.T, c chan runtime.Object) *extensionsv1beta1.Ingress {
0000000000000000000000000000000000000000;;		obj := GetObjectFromChan(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ingress, ok := obj.(*extensionsv1beta1.Ingress)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Logf("Object on channel was not of type *extensionsv1beta1.Ingress: %v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ingress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetConfigMapFromChan(c chan runtime.Object) *apiv1.ConfigMap {
0000000000000000000000000000000000000000;;		if configMap := GetObjectFromChan(c); configMap == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return configMap.(*apiv1.ConfigMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetClusterFromChan(c chan runtime.Object) *federationapi.Cluster {
0000000000000000000000000000000000000000;;		if cluster := GetObjectFromChan(c); cluster == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return cluster.(*federationapi.Cluster)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewConfigMap(uid string) *apiv1.ConfigMap {
0000000000000000000000000000000000000000;;		return &apiv1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      uidConfigMapName,
0000000000000000000000000000000000000000;;				Namespace: uidConfigMapNamespace,
0000000000000000000000000000000000000000;;				SelfLink:  "/api/v1/namespaces/" + uidConfigMapNamespace + "/configmap/" + uidConfigMapName,
0000000000000000000000000000000000000000;;				// TODO: Remove: Annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string]string{
0000000000000000000000000000000000000000;;				uidKey: uid,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for finalizers to appear in federation store.
0000000000000000000000000000000000000000;;	func WaitForFinalizersInFederationStore(ingressController *IngressController, store cache.Store, key string) error {
0000000000000000000000000000000000000000;;		retryInterval := 100 * time.Millisecond
0000000000000000000000000000000000000000;;		timeout := wait.ForeverTestTimeout
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			obj, found, err := store.GetByKey(key)
0000000000000000000000000000000000000000;;			if !found || err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ingress := obj.(*extensionsv1beta1.Ingress)
0000000000000000000000000000000000000000;;			hasOrphanFinalizer, err := finalizersutil.HasFinalizer(ingress, metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hasDeleteFinalizer, err := finalizersutil.HasFinalizer(ingress, deletionhelper.FinalizerDeleteFromUnderlyingClusters)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasOrphanFinalizer && hasDeleteFinalizer {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for the cluster ingress to appear in cluster store.
0000000000000000000000000000000000000000;;	func WaitForIngressInClusterStore(store util.FederatedReadOnlyStore, clusterName, key string) error {
0000000000000000000000000000000000000000;;		retryInterval := 100 * time.Millisecond
0000000000000000000000000000000000000000;;		timeout := wait.ForeverTestTimeout
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, found, err := store.GetByKey(clusterName, key)
0000000000000000000000000000000000000000;;			if found && err == nil {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for ingress status to be updated to match the desiredStatus.
0000000000000000000000000000000000000000;;	func WaitForStatusUpdate(t *testing.T, store util.FederatedReadOnlyStore, clusterName, key string, desiredStatus apiv1.LoadBalancerStatus, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		retryInterval := 100 * time.Millisecond
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			obj, found, err := store.GetByKey(clusterName, key)
0000000000000000000000000000000000000000;;			if !found || err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ingress := obj.(*extensionsv1beta1.Ingress)
0000000000000000000000000000000000000000;;			return reflect.DeepEqual(ingress.Status.LoadBalancer, desiredStatus), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for ingress status to be updated to match the desiredStatus.
0000000000000000000000000000000000000000;;	func WaitForFedStatusUpdate(t *testing.T, store cache.Store, key string, desiredStatus apiv1.LoadBalancerStatus, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		retryInterval := 100 * time.Millisecond
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			obj, found, err := store.GetByKey(key)
0000000000000000000000000000000000000000;;			if !found || err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ingress := obj.(*extensionsv1beta1.Ingress)
0000000000000000000000000000000000000000;;			return reflect.DeepEqual(ingress.Status.LoadBalancer, desiredStatus), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
