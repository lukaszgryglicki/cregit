0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1353dc55051227671112e5ec5975b863b6ce64af;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		cache "k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		fedapi "k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		v1beta1 "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/service/ingress"
0000000000000000000000000000000000000000;;		fedutil "k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/clusterselector"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/deletionhelper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/eventsink"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		serviceSyncPeriod = 30 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		UserAgentName = "federation-service-controller"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reviewDelay           = 10 * time.Second
0000000000000000000000000000000000000000;;		updateTimeout         = 30 * time.Second
0000000000000000000000000000000000000000;;		allClustersKey        = "ALL_CLUSTERS"
0000000000000000000000000000000000000000;;		clusterAvailableDelay = time.Second * 20
0000000000000000000000000000000000000000;;		ControllerName        = "services"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		RequiredResources = []schema.GroupVersionResource{v1.SchemeGroupVersion.WithResource("services")}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ServiceController struct {
0000000000000000000000000000000000000000;;		federationClient fedclientset.Interface
0000000000000000000000000000000000000000;;		// A store of services, populated by the serviceController
0000000000000000000000000000000000000000;;		serviceStore corelisters.ServiceLister
0000000000000000000000000000000000000000;;		// Watches changes to all services
0000000000000000000000000000000000000000;;		serviceController cache.Controller
0000000000000000000000000000000000000000;;		federatedInformer fedutil.FederatedInformer
0000000000000000000000000000000000000000;;		eventBroadcaster  record.EventBroadcaster
0000000000000000000000000000000000000000;;		eventRecorder     record.EventRecorder
0000000000000000000000000000000000000000;;		// services that need to be synced
0000000000000000000000000000000000000000;;		queue *workqueue.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For triggering all services reconciliation. This is used when
0000000000000000000000000000000000000000;;		// a new cluster becomes available.
0000000000000000000000000000000000000000;;		clusterDeliverer *fedutil.DelayingDeliverer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deletionHelper *deletionhelper.DeletionHelper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reviewDelay           time.Duration
0000000000000000000000000000000000000000;;		clusterAvailableDelay time.Duration
0000000000000000000000000000000000000000;;		updateTimeout         time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointFederatedInformer fedutil.FederatedInformer
0000000000000000000000000000000000000000;;		federatedUpdater          fedutil.FederatedUpdater
0000000000000000000000000000000000000000;;		objectDeliverer           *fedutil.DelayingDeliverer
0000000000000000000000000000000000000000;;		flowcontrolBackoff        *flowcontrol.Backoff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new service controller to keep service objects between
0000000000000000000000000000000000000000;;	// the federation and member clusters in sync.
0000000000000000000000000000000000000000;;	func New(federationClient fedclientset.Interface) *ServiceController {
0000000000000000000000000000000000000000;;		broadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		broadcaster.StartRecordingToSink(eventsink.NewFederatedEventSink(federationClient))
0000000000000000000000000000000000000000;;		recorder := broadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: UserAgentName})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &ServiceController{
0000000000000000000000000000000000000000;;			federationClient:      federationClient,
0000000000000000000000000000000000000000;;			eventBroadcaster:      broadcaster,
0000000000000000000000000000000000000000;;			eventRecorder:         recorder,
0000000000000000000000000000000000000000;;			queue:                 workqueue.New(),
0000000000000000000000000000000000000000;;			reviewDelay:           reviewDelay,
0000000000000000000000000000000000000000;;			clusterAvailableDelay: clusterAvailableDelay,
0000000000000000000000000000000000000000;;			updateTimeout:         updateTimeout,
0000000000000000000000000000000000000000;;			flowcontrolBackoff:    flowcontrol.NewBackOff(5*time.Second, time.Minute),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.objectDeliverer = fedutil.NewDelayingDeliverer()
0000000000000000000000000000000000000000;;		s.clusterDeliverer = fedutil.NewDelayingDeliverer()
0000000000000000000000000000000000000000;;		var serviceIndexer cache.Indexer
0000000000000000000000000000000000000000;;		serviceIndexer, s.serviceController = cache.NewIndexerInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;					return s.federationClient.Core().Services(metav1.NamespaceAll).List(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					return s.federationClient.Core().Services(metav1.NamespaceAll).Watch(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&v1.Service{},
0000000000000000000000000000000000000000;;			serviceSyncPeriod,
0000000000000000000000000000000000000000;;			fedutil.NewTriggerOnAllChanges(func(obj pkgruntime.Object) {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Delivering notification from federation: %v", obj)
0000000000000000000000000000000000000000;;				s.deliverObject(obj, 0, false)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		s.serviceStore = corelisters.NewServiceLister(serviceIndexer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterLifecycle := fedutil.ClusterLifecycleHandlerFuncs{
0000000000000000000000000000000000000000;;			ClusterAvailable: func(cluster *v1beta1.Cluster) {
0000000000000000000000000000000000000000;;				s.clusterDeliverer.DeliverAfter(allClustersKey, nil, clusterAvailableDelay)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fedInformerFactory := func(cluster *v1beta1.Cluster, targetClient kubeclientset.Interface) (cache.Store, cache.Controller) {
0000000000000000000000000000000000000000;;			return cache.NewInformer(
0000000000000000000000000000000000000000;;				&cache.ListWatch{
0000000000000000000000000000000000000000;;					ListFunc: func(options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;						return targetClient.Core().Services(metav1.NamespaceAll).List(options)
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;						return targetClient.Core().Services(metav1.NamespaceAll).Watch(options)
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&v1.Service{},
0000000000000000000000000000000000000000;;				controller.NoResyncPeriodFunc(),
0000000000000000000000000000000000000000;;				// Trigger reconciliation whenever something in federated cluster is changed. In most cases it
0000000000000000000000000000000000000000;;				// would be just confirmation that some service operation succeeded.
0000000000000000000000000000000000000000;;				fedutil.NewTriggerOnAllChanges(
0000000000000000000000000000000000000000;;					func(obj pkgruntime.Object) {
0000000000000000000000000000000000000000;;						glog.V(5).Infof("Delivering service notification from federated cluster %s: %v", cluster.Name, obj)
0000000000000000000000000000000000000000;;						s.deliverObject(obj, s.reviewDelay, false)
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.federatedInformer = fedutil.NewFederatedInformer(federationClient, fedInformerFactory, &clusterLifecycle)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.federatedUpdater = fedutil.NewFederatedUpdater(s.federatedInformer, "service", updateTimeout, s.eventRecorder,
0000000000000000000000000000000000000000;;			func(client kubeclientset.Interface, obj pkgruntime.Object) error {
0000000000000000000000000000000000000000;;				svc := obj.(*v1.Service)
0000000000000000000000000000000000000000;;				_, err := client.Core().Services(svc.Namespace).Create(svc)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(client kubeclientset.Interface, obj pkgruntime.Object) error {
0000000000000000000000000000000000000000;;				svc := obj.(*v1.Service)
0000000000000000000000000000000000000000;;				_, err := client.Core().Services(svc.Namespace).Update(svc)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(client kubeclientset.Interface, obj pkgruntime.Object) error {
0000000000000000000000000000000000000000;;				svc := obj.(*v1.Service)
0000000000000000000000000000000000000000;;				orphanDependents := false
0000000000000000000000000000000000000000;;				err := client.Core().Services(svc.Namespace).Delete(svc.Name, &metav1.DeleteOptions{OrphanDependents: &orphanDependents})
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Federated informers on endpoints in federated clusters.
0000000000000000000000000000000000000000;;		// This will enable to check if service ingress endpoints in federated clusters are reachable
0000000000000000000000000000000000000000;;		s.endpointFederatedInformer = fedutil.NewFederatedInformer(
0000000000000000000000000000000000000000;;			federationClient,
0000000000000000000000000000000000000000;;			func(cluster *v1beta1.Cluster, targetClient kubeclientset.Interface) (
0000000000000000000000000000000000000000;;				cache.Store, cache.Controller) {
0000000000000000000000000000000000000000;;				return cache.NewInformer(
0000000000000000000000000000000000000000;;					&cache.ListWatch{
0000000000000000000000000000000000000000;;						ListFunc: func(options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;							return targetClient.Core().Endpoints(metav1.NamespaceAll).List(options)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;							return targetClient.Core().Endpoints(metav1.NamespaceAll).Watch(options)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					&v1.Endpoints{},
0000000000000000000000000000000000000000;;					controller.NoResyncPeriodFunc(),
0000000000000000000000000000000000000000;;					fedutil.NewTriggerOnMetaAndFieldChanges(
0000000000000000000000000000000000000000;;						"Subsets",
0000000000000000000000000000000000000000;;						func(obj pkgruntime.Object) {
0000000000000000000000000000000000000000;;							glog.V(5).Infof("Delivering endpoint notification from federated cluster %s :%v", cluster.Name, obj)
0000000000000000000000000000000000000000;;							s.deliverObject(obj, s.reviewDelay, false)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&fedutil.ClusterLifecycleHandlerFuncs{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.deletionHelper = deletionhelper.NewDeletionHelper(
0000000000000000000000000000000000000000;;			s.updateService,
0000000000000000000000000000000000000000;;			// objNameFunc
0000000000000000000000000000000000000000;;			func(obj pkgruntime.Object) string {
0000000000000000000000000000000000000000;;				service := obj.(*v1.Service)
0000000000000000000000000000000000000000;;				return fmt.Sprintf("%s/%s", service.Namespace, service.Name)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			s.federatedInformer,
0000000000000000000000000000000000000000;;			s.federatedUpdater,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sends the given updated object to apiserver.
0000000000000000000000000000000000000000;;	// Assumes that the given object is a service.
0000000000000000000000000000000000000000;;	func (s *ServiceController) updateService(obj pkgruntime.Object) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		service := obj.(*v1.Service)
0000000000000000000000000000000000000000;;		return s.federationClient.Core().Services(service.Namespace).Update(service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run starts informers, delay deliverers and workers. Workers continuously watch for events which could
0000000000000000000000000000000000000000;;	// be from federation or federated clusters and tries to reconcile the service objects from federation to
0000000000000000000000000000000000000000;;	// federated clusters.
0000000000000000000000000000000000000000;;	func (s *ServiceController) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		glog.Infof("Starting federation service controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;		defer s.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.federatedInformer.Start()
0000000000000000000000000000000000000000;;		defer s.federatedInformer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.endpointFederatedInformer.Start()
0000000000000000000000000000000000000000;;		defer s.endpointFederatedInformer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.objectDeliverer.StartWithHandler(func(item *fedutil.DelayingDelivererItem) {
0000000000000000000000000000000000000000;;			s.queue.Add(item.Value.(string))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		defer s.objectDeliverer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.clusterDeliverer.StartWithHandler(func(_ *fedutil.DelayingDelivererItem) {
0000000000000000000000000000000000000000;;			s.deliverServicesOnClusterChange()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		defer s.clusterDeliverer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fedutil.StartBackoffGC(s.flowcontrolBackoff, stopCh)
0000000000000000000000000000000000000000;;		go s.serviceController.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(s.fedServiceWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;		glog.Infof("Shutting down federation service controller")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reconciliationStatus string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		statusAllOk               = reconciliationStatus("ALL_OK")
0000000000000000000000000000000000000000;;		statusRecoverableError    = reconciliationStatus("RECOVERABLE_ERROR")
0000000000000000000000000000000000000000;;		statusNonRecoverableError = reconciliationStatus("NON_RECOVERABLE_ERROR")
0000000000000000000000000000000000000000;;		statusNotSynced           = reconciliationStatus("NOSYNC")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ServiceController) workerFunction() bool {
0000000000000000000000000000000000000000;;		key, quit := s.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := key.(string)
0000000000000000000000000000000000000000;;		status := s.reconcileService(service)
0000000000000000000000000000000000000000;;		switch status {
0000000000000000000000000000000000000000;;		case statusAllOk:
0000000000000000000000000000000000000000;;		// do nothing, reconcile is successful.
0000000000000000000000000000000000000000;;		case statusNotSynced:
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Delivering notification for %q after clusterAvailableDelay", service)
0000000000000000000000000000000000000000;;			s.deliverService(service, s.clusterAvailableDelay, false)
0000000000000000000000000000000000000000;;		case statusRecoverableError:
0000000000000000000000000000000000000000;;			s.deliverService(service, 0, true)
0000000000000000000000000000000000000000;;		case statusNonRecoverableError:
0000000000000000000000000000000000000000;;			// do nothing, error is already logged.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fedServiceWorker runs a worker thread that just dequeues items, processes them, and marks them done.
0000000000000000000000000000000000000000;;	func (s *ServiceController) fedServiceWorker() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if quit := s.workerFunction(); quit {
0000000000000000000000000000000000000000;;				glog.Infof("service controller worker queue shutting down")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delete deletes the given service or returns error if the deletion was not complete.
0000000000000000000000000000000000000000;;	func (s *ServiceController) delete(service *v1.Service) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Handling deletion of service: %v", *service)
0000000000000000000000000000000000000000;;		_, err := s.deletionHelper.HandleObjectInUnderlyingClusters(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = s.federationClient.Core().Services(service.Namespace).Delete(service.Name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Its all good if the error is not found error. That means it is deleted already and we do not have to do anything.
0000000000000000000000000000000000000000;;			// This is expected when we are processing an update as a result of service finalizer deletion.
0000000000000000000000000000000000000000;;			// The process that deleted the last finalizer is also going to delete the service and we do not have to do anything.
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to delete service: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ServiceController) deliverServicesOnClusterChange() {
0000000000000000000000000000000000000000;;		if !s.isSynced() {
0000000000000000000000000000000000000000;;			s.clusterDeliverer.DeliverAfter(allClustersKey, nil, s.clusterAvailableDelay)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Delivering all service as cluster status changed")
0000000000000000000000000000000000000000;;		serviceList, err := s.serviceStore.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("error listing federated services: %v", err))
0000000000000000000000000000000000000000;;			s.clusterDeliverer.DeliverAfter(allClustersKey, nil, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, service := range serviceList {
0000000000000000000000000000000000000000;;			s.deliverObject(service, 0, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ServiceController) deliverObject(object interface{}, delay time.Duration, failed bool) {
0000000000000000000000000000000000000000;;		switch value := object.(type) {
0000000000000000000000000000000000000000;;		case *v1.Service:
0000000000000000000000000000000000000000;;			s.deliverService(types.NamespacedName{Namespace: value.Namespace, Name: value.Name}.String(), delay, failed)
0000000000000000000000000000000000000000;;		case *v1.Endpoints:
0000000000000000000000000000000000000000;;			s.deliverService(types.NamespacedName{Namespace: value.Namespace, Name: value.Name}.String(), delay, failed)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Warningf("Unknown object received: %v", object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds backoff to delay if this delivery is related to some failure. Resets backoff if there was no failure.
0000000000000000000000000000000000000000;;	func (s *ServiceController) deliverService(key string, delay time.Duration, failed bool) {
0000000000000000000000000000000000000000;;		if failed {
0000000000000000000000000000000000000000;;			s.flowcontrolBackoff.Next(key, time.Now())
0000000000000000000000000000000000000000;;			delay = delay + s.flowcontrolBackoff.Get(key)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.flowcontrolBackoff.Reset(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.objectDeliverer.DeliverAfter(key, key, delay)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check whether all data stores are in sync. False is returned if any of the informer/stores is not yet synced with
0000000000000000000000000000000000000000;;	// the corresponding api server.
0000000000000000000000000000000000000000;;	func (s *ServiceController) isSynced() bool {
0000000000000000000000000000000000000000;;		if !s.federatedInformer.ClustersSynced() {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Cluster list not synced")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serviceClusters, err := s.federatedInformer.GetReadyClusters()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get ready clusters: %v", err))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.federatedInformer.GetTargetStore().ClustersSynced(serviceClusters) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.endpointFederatedInformer.ClustersSynced() {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Cluster list not synced")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpointClusters, err := s.endpointFederatedInformer.GetReadyClusters()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get ready clusters: %v", err))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.endpointFederatedInformer.GetTargetStore().ClustersSynced(endpointClusters) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reconcileService triggers reconciliation of a federated service with corresponding services in federated clusters.
0000000000000000000000000000000000000000;;	// This function is called on service Addition/Deletion/Updation either in federated cluster or in federation.
0000000000000000000000000000000000000000;;	func (s *ServiceController) reconcileService(key string) reconciliationStatus {
0000000000000000000000000000000000000000;;		if !s.isSynced() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Data store not synced, delaying reconcilation: %v", key)
0000000000000000000000000000000000000000;;			return statusNotSynced
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Invalid key %q received, unable to split key to namespace and name, err: %v", key, err))
0000000000000000000000000000000000000000;;			return statusNonRecoverableError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service, err := s.serviceStore.Services(namespace).Get(name)
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			// Not a federated service, ignoring.
0000000000000000000000000000000000000000;;			return statusAllOk
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to retrieve federated service %q from store: %v", key, err))
0000000000000000000000000000000000000000;;			return statusRecoverableError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Reconciling federated service: %s", key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a copy before modifying the service to prevent race condition with other readers of service from store
0000000000000000000000000000000000000000;;		fedServiceObj, err := api.Scheme.DeepCopy(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Error in copying obj: %s, %v", key, err))
0000000000000000000000000000000000000000;;			return statusNonRecoverableError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fedService, ok := fedServiceObj.(*v1.Service)
0000000000000000000000000000000000000000;;		if err != nil || !ok {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Unknown obj received from store: %#v, %v", fedServiceObj, err))
0000000000000000000000000000000000000000;;			return statusNonRecoverableError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle deletion of federated service
0000000000000000000000000000000000000000;;		if fedService.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			if err := s.delete(fedService); err != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("Failed to delete %s: %v", key, err))
0000000000000000000000000000000000000000;;				s.eventRecorder.Eventf(fedService, api.EventTypeWarning, "DeleteFailed", "Deleting service failed: %v", err)
0000000000000000000000000000000000000000;;				return statusRecoverableError
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Deleting federated service succeeded: %s", key)
0000000000000000000000000000000000000000;;			s.eventRecorder.Eventf(fedService, api.EventTypeNormal, "DeleteSucceed", "Deleting service succeeded")
0000000000000000000000000000000000000000;;			return statusAllOk
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the required finalizers before creating a service in underlying clusters. This ensures that the
0000000000000000000000000000000000000000;;		// dependent services in underlying clusters are deleted when the federated service is deleted.
0000000000000000000000000000000000000000;;		updatedServiceObj, err := s.deletionHelper.EnsureFinalizers(fedService)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to ensure setting finalizer for service %s: %v", key, err))
0000000000000000000000000000000000000000;;			return statusRecoverableError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fedService = updatedServiceObj.(*v1.Service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Synchronize the federated service in all underlying ready clusters.
0000000000000000000000000000000000000000;;		clusters, err := s.federatedInformer.GetReadyClusters()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get ready cluster list: %v", err))
0000000000000000000000000000000000000000;;			return statusRecoverableError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newLBStatus := newLoadbalancerStatus()
0000000000000000000000000000000000000000;;		newServiceIngress := ingress.NewFederatedServiceIngress()
0000000000000000000000000000000000000000;;		operations := make([]fedutil.FederatedOperation, 0)
0000000000000000000000000000000000000000;;		for _, cluster := range clusters {
0000000000000000000000000000000000000000;;			// Aggregate all operations to perform on all federated clusters
0000000000000000000000000000000000000000;;			operation, err := getOperationsToPerformOnCluster(s.federatedInformer, cluster, fedService, clusterselector.SendToCluster)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return statusRecoverableError
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if operation != nil {
0000000000000000000000000000000000000000;;				operations = append(operations, *operation)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Aggregate LoadBalancerStatus from all services in federated clusters to update status in federated service
0000000000000000000000000000000000000000;;			lbStatus, err := s.getServiceStatusInCluster(cluster, key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return statusRecoverableError
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(lbStatus.Ingress) > 0 {
0000000000000000000000000000000000000000;;				newLBStatus.Ingress = append(newLBStatus.Ingress, lbStatus.Ingress...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Add/Update federated service ingress only if there are reachable endpoints backing the lb service
0000000000000000000000000000000000000000;;				endpoints, err := s.getServiceEndpointsInCluster(cluster, key)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return statusRecoverableError
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// if there are no endpoints created for the service then the loadbalancer ingress
0000000000000000000000000000000000000000;;				// is not reachable, so do not consider such loadbalancer ingresses for federated
0000000000000000000000000000000000000000;;				// service ingresses
0000000000000000000000000000000000000000;;				if len(endpoints) > 0 {
0000000000000000000000000000000000000000;;					clusterIngress := fedapi.ClusterServiceIngress{
0000000000000000000000000000000000000000;;						Cluster: cluster.Name,
0000000000000000000000000000000000000000;;						Items:   lbStatus.Ingress,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					newServiceIngress.Items = append(newServiceIngress.Items, clusterIngress)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(operations) != 0 {
0000000000000000000000000000000000000000;;			err = s.federatedUpdater.Update(operations)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;					runtime.HandleError(fmt.Errorf("Failed to execute updates for %s: %v", key, err))
0000000000000000000000000000000000000000;;					return statusRecoverableError
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the federated service if there are any updates in clustered service (status/endpoints)
0000000000000000000000000000000000000000;;		err = s.updateFederatedService(fedService, newLBStatus, newServiceIngress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return statusRecoverableError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Everything is in order in federated clusters for service %s", key)
0000000000000000000000000000000000000000;;		return statusAllOk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clusterSelectorFunc func(map[string]string, map[string]string) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getOperationsToPerformOnCluster returns the operations to be performed so that clustered service is in sync with federated service
0000000000000000000000000000000000000000;;	func getOperationsToPerformOnCluster(informer fedutil.FederatedInformer, cluster *v1beta1.Cluster, fedService *v1.Service, selector clusterSelectorFunc) (*fedutil.FederatedOperation, error) {
0000000000000000000000000000000000000000;;		var operation *fedutil.FederatedOperation
0000000000000000000000000000000000000000;;		var operationType fedutil.FederatedOperationType = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := types.NamespacedName{Namespace: fedService.Namespace, Name: fedService.Name}.String()
0000000000000000000000000000000000000000;;		clusterServiceObj, found, err := informer.GetTargetStore().GetByKey(cluster.Name, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get %s service from %s: %v", key, cluster.Name, err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		send, err := selector(cluster.Labels, fedService.ObjectMeta.Annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error processing ClusterSelector cluster: %s for service map: %s error: %s", cluster.Name, key, err.Error())
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else if !send {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Skipping cluster: %s for service: %s reason: cluster selectors do not match: %-v %-v", cluster.Name, key, cluster.ObjectMeta.Labels, fedService.ObjectMeta.Annotations[v1beta1.FederationClusterSelectorAnnotation])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desiredService := &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: fedutil.DeepCopyRelevantObjectMeta(fedService.ObjectMeta),
0000000000000000000000000000000000000000;;			Spec:       *(fedutil.DeepCopyApiTypeOrPanic(&fedService.Spec).(*v1.ServiceSpec)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case found && send:
0000000000000000000000000000000000000000;;			clusterService, ok := clusterServiceObj.(*v1.Service)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("Unexpected error for %q: %v", key, err))
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ClusterIP and NodePort are allocated to Service by cluster, so retain the same if any while updating
0000000000000000000000000000000000000000;;			desiredService.Spec.ClusterIP = clusterService.Spec.ClusterIP
0000000000000000000000000000000000000000;;			for _, cPort := range clusterService.Spec.Ports {
0000000000000000000000000000000000000000;;				for i, fPort := range clusterService.Spec.Ports {
0000000000000000000000000000000000000000;;					if fPort.Name == cPort.Name && fPort.Protocol == cPort.Protocol && fPort.Port == cPort.Port {
0000000000000000000000000000000000000000;;						desiredService.Spec.Ports[i].NodePort = cPort.NodePort
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update existing service, if needed.
0000000000000000000000000000000000000000;;			if !Equivalent(desiredService, clusterService) {
0000000000000000000000000000000000000000;;				operationType = fedutil.OperationTypeUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Service in underlying cluster %s does not match, Desired: %+v, Existing: %+v", cluster.Name, desiredService, clusterService)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// ResourceVersion of cluster service can be different from federated service,
0000000000000000000000000000000000000000;;				// so do not update ResourceVersion while updating cluster service
0000000000000000000000000000000000000000;;				desiredService.ResourceVersion = clusterService.ResourceVersion
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Service in underlying cluster %s is up to date: %+v", cluster.Name, desiredService)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case found && !send:
0000000000000000000000000000000000000000;;			operationType = fedutil.OperationTypeDelete
0000000000000000000000000000000000000000;;		case !found && send:
0000000000000000000000000000000000000000;;			operationType = fedutil.OperationTypeAdd
0000000000000000000000000000000000000000;;			desiredService.ResourceVersion = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Creating service in underlying cluster %s: %+v", cluster.Name, desiredService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(operationType) > 0 {
0000000000000000000000000000000000000000;;			operation = &fedutil.FederatedOperation{
0000000000000000000000000000000000000000;;				Type:        operationType,
0000000000000000000000000000000000000000;;				Obj:         desiredService,
0000000000000000000000000000000000000000;;				ClusterName: cluster.Name,
0000000000000000000000000000000000000000;;				Key:         key,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return operation, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getServiceStatusInCluster returns service status in federated cluster
0000000000000000000000000000000000000000;;	func (s *ServiceController) getServiceStatusInCluster(cluster *v1beta1.Cluster, key string) (*v1.LoadBalancerStatus, error) {
0000000000000000000000000000000000000000;;		lbStatus := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterServiceObj, serviceFound, err := s.federatedInformer.GetTargetStore().GetByKey(cluster.Name, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get %s service from %s: %v", key, cluster.Name, err))
0000000000000000000000000000000000000000;;			return lbStatus, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if serviceFound {
0000000000000000000000000000000000000000;;			clusterService, ok := clusterServiceObj.(*v1.Service)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Unknown object received: %v", clusterServiceObj)
0000000000000000000000000000000000000000;;				runtime.HandleError(err)
0000000000000000000000000000000000000000;;				return lbStatus, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lbStatus = &clusterService.Status.LoadBalancer
0000000000000000000000000000000000000000;;			newLbStatus := &loadbalancerStatus{*lbStatus}
0000000000000000000000000000000000000000;;			sort.Sort(newLbStatus)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lbStatus, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getServiceEndpointsInCluster returns ready endpoints corresonding to service in federated cluster
0000000000000000000000000000000000000000;;	func (s *ServiceController) getServiceEndpointsInCluster(cluster *v1beta1.Cluster, key string) ([]v1.EndpointAddress, error) {
0000000000000000000000000000000000000000;;		addresses := []v1.EndpointAddress{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterEndpointsObj, endpointsFound, err := s.endpointFederatedInformer.GetTargetStore().GetByKey(cluster.Name, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get %s endpoint from %s: %v", key, cluster.Name, err))
0000000000000000000000000000000000000000;;			return addresses, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if endpointsFound {
0000000000000000000000000000000000000000;;			clusterEndpoints, ok := clusterEndpointsObj.(*v1.Endpoints)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Warningf("Unknown object received: %v", clusterEndpointsObj)
0000000000000000000000000000000000000000;;				return addresses, fmt.Errorf("Unknown object received: %v", clusterEndpointsObj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, subset := range clusterEndpoints.Subsets {
0000000000000000000000000000000000000000;;				if len(subset.Addresses) > 0 {
0000000000000000000000000000000000000000;;					addresses = append(addresses, subset.Addresses...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addresses, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateFederatedService updates the federated service with aggregated lbStatus and serviceIngresses
0000000000000000000000000000000000000000;;	// and also updates the dns records as needed
0000000000000000000000000000000000000000;;	func (s *ServiceController) updateFederatedService(fedService *v1.Service, newLBStatus *loadbalancerStatus, newServiceIngress *ingress.FederatedServiceIngress) error {
0000000000000000000000000000000000000000;;		key := types.NamespacedName{Namespace: fedService.Namespace, Name: fedService.Name}.String()
0000000000000000000000000000000000000000;;		needUpdate := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort the endpoints so that we can compare
0000000000000000000000000000000000000000;;		sort.Sort(newLBStatus)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(fedService.Status.LoadBalancer.Ingress, newLBStatus.Ingress) {
0000000000000000000000000000000000000000;;			fedService.Status.LoadBalancer.Ingress = newLBStatus.Ingress
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Federated service loadbalancer status updated for %s: %v", key, newLBStatus.Ingress)
0000000000000000000000000000000000000000;;			needUpdate = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingServiceIngress, err := ingress.ParseFederatedServiceIngress(fedService)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to parse endpoint annotations for service %s: %v", key, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: We should have a reliable cluster health check(should consider quorum) to detect cluster is not
0000000000000000000000000000000000000000;;		// reachable and remove dns records for them. Until a reliable cluster health check is available, below code is
0000000000000000000000000000000000000000;;		// a workaround to not remove the existing dns records which were created before the cluster went offline.
0000000000000000000000000000000000000000;;		unreadyClusters, err := s.federatedInformer.GetUnreadyClusters()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get unready cluster list: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cluster := range unreadyClusters {
0000000000000000000000000000000000000000;;			lbIngress := existingServiceIngress.GetClusterLoadBalancerIngresses(cluster.Name)
0000000000000000000000000000000000000000;;			newServiceIngress.AddClusterLoadBalancerIngresses(cluster.Name, lbIngress)
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Cluster %s is Offline, Preserving previously available status for Service %s", cluster.Name, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update federated service status and/or ingress annotations if changed
0000000000000000000000000000000000000000;;		sort.Sort(newServiceIngress)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(existingServiceIngress.Items, newServiceIngress.Items) {
0000000000000000000000000000000000000000;;			fedService = ingress.UpdateIngressAnnotation(fedService, newServiceIngress)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Federated service loadbalancer ingress updated for %s: existing: %#v, desired: %#v", key, existingServiceIngress, newServiceIngress)
0000000000000000000000000000000000000000;;			needUpdate = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if needUpdate {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			fedService, err = s.federationClient.Core().Services(fedService.Namespace).UpdateStatus(fedService)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("Error updating the federation service object %s: %v", key, err))
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equivalent Checks if cluster-independent, user provided data in two given services are equal. If in the future the
0000000000000000000000000000000000000000;;	// services structure is expanded then any field that is not populated by the api server should be included here.
0000000000000000000000000000000000000000;;	func Equivalent(s1, s2 *v1.Service) bool {
0000000000000000000000000000000000000000;;		// TODO: should also check for all annotations except FederationServiceIngressAnnotation
0000000000000000000000000000000000000000;;		return s1.Name == s2.Name && s1.Namespace == s2.Namespace &&
0000000000000000000000000000000000000000;;			(reflect.DeepEqual(s1.Labels, s2.Labels) || (len(s1.Labels) == 0 && len(s2.Labels) == 0)) &&
0000000000000000000000000000000000000000;;			reflect.DeepEqual(s1.Spec, s2.Spec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type loadbalancerStatus struct {
0000000000000000000000000000000000000000;;		v1.LoadBalancerStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLoadbalancerStatus() *loadbalancerStatus {
0000000000000000000000000000000000000000;;		return &loadbalancerStatus{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lbs loadbalancerStatus) Len() int {
0000000000000000000000000000000000000000;;		return len(lbs.Ingress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lbs loadbalancerStatus) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		ipComparison := strings.Compare(lbs.Ingress[i].IP, lbs.Ingress[j].IP)
0000000000000000000000000000000000000000;;		hostnameComparison := strings.Compare(lbs.Ingress[i].Hostname, lbs.Ingress[j].Hostname)
0000000000000000000000000000000000000000;;		if ipComparison < 0 || (ipComparison == 0 && hostnameComparison < 0) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lbs loadbalancerStatus) Swap(i, j int) {
0000000000000000000000000000000000000000;;		lbs.Ingress[i].IP, lbs.Ingress[j].IP = lbs.Ingress[j].IP, lbs.Ingress[i].IP
0000000000000000000000000000000000000000;;		lbs.Ingress[i].Hostname, lbs.Ingress[j].Hostname = lbs.Ingress[j].Hostname, lbs.Ingress[i].Hostname
0000000000000000000000000000000000000000;;	}
