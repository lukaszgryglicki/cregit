0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1353dc55051227671112e5ec5975b863b6ce64af;federation/pkg/federation-controller/service/dns.go[federation/pkg/federation-controller/service/dns.go][federation/pkg/federation-controller/service/dns/dns.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/dnsprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/dnsprovider/rrstype"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/service/ingress"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ControllerName = "service-dns"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		UserAgentName = "federation-service-dns-controller"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// minDNSTTL is the minimum safe DNS TTL value to use (in seconds).  We use this as the TTL for all DNS records.
0000000000000000000000000000000000000000;;		minDNSTTL = 180
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceSyncPeriod = 30 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ServiceDNSController struct {
0000000000000000000000000000000000000000;;		// Client to federation api server
0000000000000000000000000000000000000000;;		federationClient fedclientset.Interface
0000000000000000000000000000000000000000;;		dns              dnsprovider.Interface
0000000000000000000000000000000000000000;;		federationName   string
0000000000000000000000000000000000000000;;		// serviceDNSSuffix is the DNS suffix we use when publishing service DNS names
0000000000000000000000000000000000000000;;		serviceDNSSuffix string
0000000000000000000000000000000000000000;;		// zoneName and zoneID are used to identify the zone in which to put records
0000000000000000000000000000000000000000;;		zoneName string
0000000000000000000000000000000000000000;;		zoneID   string
0000000000000000000000000000000000000000;;		dnsZones dnsprovider.Zones
0000000000000000000000000000000000000000;;		// each federation should be configured with a single zone (e.g. "mycompany.com")
0000000000000000000000000000000000000000;;		dnsZone dnsprovider.Zone
0000000000000000000000000000000000000000;;		// Informer Store for federated services
0000000000000000000000000000000000000000;;		serviceStore corelisters.ServiceLister
0000000000000000000000000000000000000000;;		// Informer controller for federated services
0000000000000000000000000000000000000000;;		serviceController cache.Controller
0000000000000000000000000000000000000000;;		workQueue         workqueue.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServiceDNSController returns a new service dns controller to manage DNS records for federated services
0000000000000000000000000000000000000000;;	func NewServiceDNSController(client fedclientset.Interface, dnsProvider, dnsProviderConfig, federationName,
0000000000000000000000000000000000000000;;		serviceDNSSuffix, zoneName, zoneID string) (*ServiceDNSController, error) {
0000000000000000000000000000000000000000;;		dns, err := dnsprovider.InitDnsProvider(dnsProvider, dnsProviderConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("DNS provider could not be initialized: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d := &ServiceDNSController{
0000000000000000000000000000000000000000;;			federationClient: client,
0000000000000000000000000000000000000000;;			dns:              dns,
0000000000000000000000000000000000000000;;			federationName:   federationName,
0000000000000000000000000000000000000000;;			serviceDNSSuffix: serviceDNSSuffix,
0000000000000000000000000000000000000000;;			zoneName:         zoneName,
0000000000000000000000000000000000000000;;			zoneID:           zoneID,
0000000000000000000000000000000000000000;;			workQueue:        workqueue.New(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := d.validateConfig(); err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Invalid configuration passed to DNS provider: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := d.retrieveOrCreateDNSZone(); err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to retrieve DNS zone: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start informer in federated API servers on federated services
0000000000000000000000000000000000000000;;		var serviceIndexer cache.Indexer
0000000000000000000000000000000000000000;;		serviceIndexer, d.serviceController = cache.NewIndexerInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;					return client.Core().Services(metav1.NamespaceAll).List(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					return client.Core().Services(metav1.NamespaceAll).Watch(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&v1.Service{},
0000000000000000000000000000000000000000;;			serviceSyncPeriod,
0000000000000000000000000000000000000000;;			util.NewTriggerOnAllChanges(func(obj pkgruntime.Object) { d.workQueue.Add(obj) }),
0000000000000000000000000000000000000000;;			cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		d.serviceStore = corelisters.NewServiceLister(serviceIndexer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return d, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) DNSControllerRun(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;		defer s.workQueue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting federation service dns controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Stopping federation service dns controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go s.serviceController.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(s.worker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wantsDNSRecords(service *v1.Service) bool {
0000000000000000000000000000000000000000;;		return service.Spec.Type == v1.ServiceTypeLoadBalancer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) workerFunction() bool {
0000000000000000000000000000000000000000;;		item, quit := s.workQueue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.workQueue.Done(item)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := item.(*v1.Service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !wantsDNSRecords(service) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ingress, err := ingress.ParseFederatedServiceIngress(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Error in parsing lb ingress for service %s/%s: %v", service.Namespace, service.Name, err))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, clusterIngress := range ingress.Items {
0000000000000000000000000000000000000000;;			s.ensureDNSRecords(clusterIngress.Cluster, service)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) worker() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if quit := s.workerFunction(); quit {
0000000000000000000000000000000000000000;;				glog.Infof("service dns controller worker queue shutting down")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) validateConfig() error {
0000000000000000000000000000000000000000;;		if s.federationName == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("DNSController should not be run without federationName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.zoneName == "" && s.zoneID == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("DNSController must be run with either zoneName or zoneID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.serviceDNSSuffix == "" {
0000000000000000000000000000000000000000;;			if s.zoneName == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("DNSController must be run with zoneName, if serviceDnsSuffix is not set")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.serviceDNSSuffix = s.zoneName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.dns == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("DNSController should not be run without a dnsprovider")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zones, ok := s.dns.Zones()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("the dns provider does not support zone enumeration, which is required for creating dns records")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.dnsZones = zones
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) retrieveOrCreateDNSZone() error {
0000000000000000000000000000000000000000;;		matchingZones, err := getDNSZones(s.zoneName, s.zoneID, s.dnsZones)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error querying for DNS zones: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch len(matchingZones) {
0000000000000000000000000000000000000000;;		case 0: // No matching zones for s.zoneName, so create one
0000000000000000000000000000000000000000;;			if s.zoneName == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("DNSController must be run with zoneName to create zone automatically")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("DNS zone %q not found.  Creating DNS zone %q.", s.zoneName, s.zoneName)
0000000000000000000000000000000000000000;;			managedZone, err := s.dnsZones.New(s.zoneName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			zone, err := s.dnsZones.Add(managedZone)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("DNS zone %q successfully created.  Note that DNS resolution will not work until you have registered this name with "+
0000000000000000000000000000000000000000;;				"a DNS registrar and they have changed the authoritative name servers for your domain to point to your DNS provider", zone.Name())
0000000000000000000000000000000000000000;;		case 1: // s.zoneName matches exactly one DNS zone
0000000000000000000000000000000000000000;;			s.dnsZone = matchingZones[0]
0000000000000000000000000000000000000000;;		default: // s.zoneName matches more than one DNS zone
0000000000000000000000000000000000000000;;			return fmt.Errorf("Multiple matching DNS zones found for %q; please specify zoneID", s.zoneName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getHealthyEndpoints returns the hostnames and/or IP addresses of healthy endpoints for the service, at a zone, region and global level (or an error)
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) getHealthyEndpoints(clusterName string, service *v1.Service) (zoneEndpoints, regionEndpoints, globalEndpoints []string, err error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			zoneNames  []string
0000000000000000000000000000000000000000;;			regionName string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if zoneNames, regionName, err = s.getClusterZoneNames(clusterName); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If federated service is deleted, return empty endpoints, so that DNS records are removed
0000000000000000000000000000000000000000;;		if service.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			return zoneEndpoints, regionEndpoints, globalEndpoints, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceIngress, err := ingress.ParseFederatedServiceIngress(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, lbClusterIngress := range serviceIngress.Items {
0000000000000000000000000000000000000000;;			lbClusterName := lbClusterIngress.Cluster
0000000000000000000000000000000000000000;;			lbZoneNames, lbRegionName, err := s.getClusterZoneNames(lbClusterName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ingress := range lbClusterIngress.Items {
0000000000000000000000000000000000000000;;				var address string
0000000000000000000000000000000000000000;;				// We should get either an IP address or a hostname - use whichever one we get
0000000000000000000000000000000000000000;;				if ingress.IP != "" {
0000000000000000000000000000000000000000;;					address = ingress.IP
0000000000000000000000000000000000000000;;				} else if ingress.Hostname != "" {
0000000000000000000000000000000000000000;;					address = ingress.Hostname
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(address) <= 0 {
0000000000000000000000000000000000000000;;					return nil, nil, nil, fmt.Errorf("Service %s/%s in cluster %s has neither LoadBalancerStatus.ingress.ip nor LoadBalancerStatus.ingress.hostname. Cannot use it as endpoint for federated service",
0000000000000000000000000000000000000000;;						service.Name, service.Namespace, clusterName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, lbZoneName := range lbZoneNames {
0000000000000000000000000000000000000000;;					for _, zoneName := range zoneNames {
0000000000000000000000000000000000000000;;						if lbZoneName == zoneName {
0000000000000000000000000000000000000000;;							zoneEndpoints = append(zoneEndpoints, address)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if lbRegionName == regionName {
0000000000000000000000000000000000000000;;					regionEndpoints = append(regionEndpoints, address)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				globalEndpoints = append(globalEndpoints, address)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return zoneEndpoints, regionEndpoints, globalEndpoints, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getClusterZoneNames returns the name of the zones (and the region) where the specified cluster exists (e.g. zones "us-east1-c" on GCE, or "us-east-1b" on AWS)
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) getClusterZoneNames(clusterName string) ([]string, string, error) {
0000000000000000000000000000000000000000;;		cluster, err := s.federationClient.Federation().Clusters().Get(clusterName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cluster.Status.Zones, cluster.Status.Region, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDNSZones returns the DNS zones matching dnsZoneName and dnsZoneID (if specified)
0000000000000000000000000000000000000000;;	func getDNSZones(dnsZoneName string, dnsZoneID string, dnsZonesInterface dnsprovider.Zones) ([]dnsprovider.Zone, error) {
0000000000000000000000000000000000000000;;		// TODO: We need query-by-name and query-by-id functions
0000000000000000000000000000000000000000;;		dnsZones, err := dnsZonesInterface.List()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var matches []dnsprovider.Zone
0000000000000000000000000000000000000000;;		findName := strings.TrimSuffix(dnsZoneName, ".")
0000000000000000000000000000000000000000;;		for _, dnsZone := range dnsZones {
0000000000000000000000000000000000000000;;			if dnsZoneID != "" {
0000000000000000000000000000000000000000;;				if dnsZoneID != dnsZone.ID() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if findName != "" {
0000000000000000000000000000000000000000;;				if strings.TrimSuffix(dnsZone.Name(), ".") != findName {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			matches = append(matches, dnsZone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matches, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NOTE: that if the named resource record set does not exist, but no
0000000000000000000000000000000000000000;;	// error occurred, the returned list will be empty, and the error will
0000000000000000000000000000000000000000;;	// be nil
0000000000000000000000000000000000000000;;	func getRrset(dnsName string, rrsetsInterface dnsprovider.ResourceRecordSets) ([]dnsprovider.ResourceRecordSet, error) {
0000000000000000000000000000000000000000;;		return rrsetsInterface.Get(dnsName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findRrset(list []dnsprovider.ResourceRecordSet, rrset dnsprovider.ResourceRecordSet) dnsprovider.ResourceRecordSet {
0000000000000000000000000000000000000000;;		for i, elem := range list {
0000000000000000000000000000000000000000;;			if dnsprovider.ResourceRecordSetsEquivalent(rrset, elem) {
0000000000000000000000000000000000000000;;				return list[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* getResolvedEndpoints performs DNS resolution on the provided slice of endpoints (which might be DNS names or IPv4 addresses)
0000000000000000000000000000000000000000;;	   and returns a list of IPv4 addresses.  If any of the endpoints are neither valid IPv4 addresses nor resolvable DNS names,
0000000000000000000000000000000000000000;;	   non-nil error is also returned (possibly along with a partially complete list of resolved endpoints.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func getResolvedEndpoints(endpoints []string) ([]string, error) {
0000000000000000000000000000000000000000;;		resolvedEndpoints := sets.String{}
0000000000000000000000000000000000000000;;		for _, endpoint := range endpoints {
0000000000000000000000000000000000000000;;			if net.ParseIP(endpoint) == nil {
0000000000000000000000000000000000000000;;				// It's not a valid IP address, so assume it's a DNS name, and try to resolve it,
0000000000000000000000000000000000000000;;				// replacing its DNS name with its IP addresses in expandedEndpoints
0000000000000000000000000000000000000000;;				ipAddrs, err := net.LookupHost(endpoint)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return resolvedEndpoints.List(), err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, ip := range ipAddrs {
0000000000000000000000000000000000000000;;					resolvedEndpoints = resolvedEndpoints.Union(sets.NewString(ip))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				resolvedEndpoints = resolvedEndpoints.Union(sets.NewString(endpoint))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resolvedEndpoints.List(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* ensureDNSRrsets ensures (idempotently, and with minimum mutations) that all of the DNS resource record sets for dnsName are consistent with endpoints.
0000000000000000000000000000000000000000;;	   if endpoints is nil or empty, a CNAME record to uplevelCname is ensured.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) ensureDNSRrsets(dnsZone dnsprovider.Zone, dnsName string, endpoints []string, uplevelCname string) error {
0000000000000000000000000000000000000000;;		rrsets, supported := dnsZone.ResourceRecordSets()
0000000000000000000000000000000000000000;;		if !supported {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to ensure DNS records for %s. DNS provider does not support the ResourceRecordSets interface", dnsName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rrsetList, err := getRrset(dnsName, rrsets) // TODO: rrsets.Get(dnsName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rrsetList) == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("No recordsets found for DNS name %q.  Need to add either A records (if we have healthy endpoints), or a CNAME record to %q", dnsName, uplevelCname)
0000000000000000000000000000000000000000;;			if len(endpoints) < 1 {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("There are no healthy endpoint addresses at level %q, so CNAME to %q, if provided", dnsName, uplevelCname)
0000000000000000000000000000000000000000;;				if uplevelCname != "" {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Creating CNAME to %q for %q", uplevelCname, dnsName)
0000000000000000000000000000000000000000;;					newRrset := rrsets.New(dnsName, []string{uplevelCname}, minDNSTTL, rrstype.CNAME)
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Adding recordset %v", newRrset)
0000000000000000000000000000000000000000;;					err = rrsets.StartChangeset().Add(newRrset).Apply()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Successfully created CNAME to %q for %q", uplevelCname, dnsName)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("We want no record for %q, and we have no record, so we're all good.", dnsName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// We have valid endpoint addresses, so just add them as A records.
0000000000000000000000000000000000000000;;				// But first resolve DNS names, as some cloud providers (like AWS) expose
0000000000000000000000000000000000000000;;				// load balancers behind DNS names, not IP addresses.
0000000000000000000000000000000000000000;;				glog.V(4).Infof("We have valid endpoint addresses %v at level %q, so add them as A records, after resolving DNS names", endpoints, dnsName)
0000000000000000000000000000000000000000;;				resolvedEndpoints, err := getResolvedEndpoints(endpoints)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err // TODO: We could potentially add the ones we did get back, even if some of them failed to resolve.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newRrset := rrsets.New(dnsName, resolvedEndpoints, minDNSTTL, rrstype.A)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Adding recordset %v", newRrset)
0000000000000000000000000000000000000000;;				err = rrsets.StartChangeset().Add(newRrset).Apply()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Successfully added recordset %v", newRrset)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// the rrsets already exists, so make it right.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Recordset %v already exists. Ensuring that it is correct.", rrsetList)
0000000000000000000000000000000000000000;;			if len(endpoints) < 1 {
0000000000000000000000000000000000000000;;				// Need an appropriate CNAME record.  Check that we have it.
0000000000000000000000000000000000000000;;				newRrset := rrsets.New(dnsName, []string{uplevelCname}, minDNSTTL, rrstype.CNAME)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("No healthy endpoints for %s. Have recordsets %v. Need recordset %v", dnsName, rrsetList, newRrset)
0000000000000000000000000000000000000000;;				found := findRrset(rrsetList, newRrset)
0000000000000000000000000000000000000000;;				if found != nil {
0000000000000000000000000000000000000000;;					// The existing rrset is equivalent to the required one - our work is done here
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Existing recordset %v is equivalent to needed recordset %v, our work is done here.", rrsetList, newRrset)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Need to replace the existing one with a better one (or just remove it if we have no healthy endpoints).
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Existing recordset %v not equivalent to needed recordset %v removing existing and adding needed.", rrsetList, newRrset)
0000000000000000000000000000000000000000;;					changeSet := rrsets.StartChangeset()
0000000000000000000000000000000000000000;;					for i := range rrsetList {
0000000000000000000000000000000000000000;;						changeSet = changeSet.Remove(rrsetList[i])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if uplevelCname != "" {
0000000000000000000000000000000000000000;;						changeSet = changeSet.Add(newRrset)
0000000000000000000000000000000000000000;;						if err := changeSet.Apply(); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Successfully replaced needed recordset %v -> %v", found, newRrset)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if err := changeSet.Apply(); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Successfully removed existing recordset %v", found)
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Uplevel CNAME is empty string. Not adding recordset %v", newRrset)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// We have an rrset in DNS, possibly with some missing addresses and some unwanted addresses.
0000000000000000000000000000000000000000;;				// And we have healthy endpoints.  Just replace what's there with the healthy endpoints, if it's not already correct.
0000000000000000000000000000000000000000;;				glog.V(4).Infof("%s: Healthy endpoints %v exist. Recordset %v exists.  Reconciling.", dnsName, endpoints, rrsetList)
0000000000000000000000000000000000000000;;				resolvedEndpoints, err := getResolvedEndpoints(endpoints)
0000000000000000000000000000000000000000;;				if err != nil { // Some invalid addresses or otherwise unresolvable DNS names.
0000000000000000000000000000000000000000;;					return err // TODO: We could potentially add the ones we did get back, even if some of them failed to resolve.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newRrset := rrsets.New(dnsName, resolvedEndpoints, minDNSTTL, rrstype.A)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Have recordset %v. Need recordset %v", rrsetList, newRrset)
0000000000000000000000000000000000000000;;				found := findRrset(rrsetList, newRrset)
0000000000000000000000000000000000000000;;				if found != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Existing recordset %v is equivalent to needed recordset %v, our work is done here.", found, newRrset)
0000000000000000000000000000000000000000;;					// TODO: We could be more thorough about checking for equivalence to avoid unnecessary updates, but in the
0000000000000000000000000000000000000000;;					//       worst case we'll just replace what's there with an equivalent, if not exactly identical record set.
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Need to replace the existing one with a better one
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Existing recordset %v is not equivalent to needed recordset %v, removing existing and adding needed.", found, newRrset)
0000000000000000000000000000000000000000;;					changeSet := rrsets.StartChangeset()
0000000000000000000000000000000000000000;;					for i := range rrsetList {
0000000000000000000000000000000000000000;;						changeSet = changeSet.Remove(rrsetList[i])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					changeSet = changeSet.Add(newRrset)
0000000000000000000000000000000000000000;;					if err = changeSet.Apply(); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Successfully replaced recordset %v -> %v", found, newRrset)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* ensureDNSRecords ensures (idempotently, and with minimum mutations) that all of the DNS records for a service in a given cluster are correct,
0000000000000000000000000000000000000000;;	given the current state of that service in that cluster.  This should be called every time the state of a service might have changed
0000000000000000000000000000000000000000;;	(either w.r.t. its loadbalancer address, or if the number of healthy backend endpoints for that service transitioned from zero to non-zero
0000000000000000000000000000000000000000;;	(or vice versa).  Only shards of the service which have both a loadbalancer ingress IP address or hostname AND at least one healthy backend endpoint
0000000000000000000000000000000000000000;;	are included in DNS records for that service (at all of zone, region and global levels). All other addresses are removed.  Also, if no shards exist
0000000000000000000000000000000000000000;;	in the zone or region of the cluster, a CNAME reference to the next higher level is ensured to exist. */
0000000000000000000000000000000000000000;;	func (s *ServiceDNSController) ensureDNSRecords(clusterName string, service *v1.Service) error {
0000000000000000000000000000000000000000;;		// Quinton: Pseudocode....
0000000000000000000000000000000000000000;;		// See https://github.com/kubernetes/kubernetes/pull/25107#issuecomment-218026648
0000000000000000000000000000000000000000;;		// For each service we need the following DNS names:
0000000000000000000000000000000000000000;;		// mysvc.myns.myfed.svc.z1.r1.mydomain.com  (for zone z1 in region r1)
0000000000000000000000000000000000000000;;		//         - an A record to IP address of specific shard in that zone (if that shard exists and has healthy endpoints)
0000000000000000000000000000000000000000;;		//         - OR a CNAME record to the next level up, i.e. mysvc.myns.myfed.svc.r1.mydomain.com  (if a healthy shard does not exist in zone z1)
0000000000000000000000000000000000000000;;		// mysvc.myns.myfed.svc.r1.mydomain.com
0000000000000000000000000000000000000000;;		//         - a set of A records to IP addresses of all healthy shards in region r1, if one or more of these exist
0000000000000000000000000000000000000000;;		//         - OR a CNAME record to the next level up, i.e. mysvc.myns.myfed.svc.mydomain.com (if no healthy shards exist in region r1)
0000000000000000000000000000000000000000;;		// mysvc.myns.myfed.svc.mydomain.com
0000000000000000000000000000000000000000;;		//         - a set of A records to IP addresses of all healthy shards in all regions, if one or more of these exist.
0000000000000000000000000000000000000000;;		//         - no record (NXRECORD response) if no healthy shards exist in any regions
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Each service has the current known state of loadbalancer ingress for the federated cluster stored in annotations.
0000000000000000000000000000000000000000;;		// So generate the DNS records based on the current state and ensure those desired DNS records match the
0000000000000000000000000000000000000000;;		// actual DNS records (add new records, remove deleted records, and update changed records).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		serviceName := service.Name
0000000000000000000000000000000000000000;;		namespaceName := service.Namespace
0000000000000000000000000000000000000000;;		zoneNames, regionName, err := s.getClusterZoneNames(clusterName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if zoneNames == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get cluster zone names")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zoneEndpoints, regionEndpoints, globalEndpoints, err := s.getHealthyEndpoints(clusterName, service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		commonPrefix := serviceName + "." + namespaceName + "." + s.federationName + ".svc"
0000000000000000000000000000000000000000;;		// dnsNames is the path up the DNS search tree, starting at the leaf
0000000000000000000000000000000000000000;;		dnsNames := []string{
0000000000000000000000000000000000000000;;			strings.Join([]string{commonPrefix, zoneNames[0], regionName, s.serviceDNSSuffix}, "."), // zone level - TODO might need other zone names for multi-zone clusters
0000000000000000000000000000000000000000;;			strings.Join([]string{commonPrefix, regionName, s.serviceDNSSuffix}, "."),               // region level, one up from zone level
0000000000000000000000000000000000000000;;			strings.Join([]string{commonPrefix, s.serviceDNSSuffix}, "."),                           // global level, one up from region level
0000000000000000000000000000000000000000;;			"", // nowhere to go up from global level
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoints := [][]string{zoneEndpoints, regionEndpoints, globalEndpoints}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, endpoint := range endpoints {
0000000000000000000000000000000000000000;;			if err = s.ensureDNSRrsets(s.dnsZone, dnsNames[i], endpoint, dnsNames[i+1]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
