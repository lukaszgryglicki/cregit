0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
4841fce6d0942f460e9a4ffcb66947c6f591418a;federation/pkg/federation-controller/service/ingress.go[federation/pkg/federation-controller/service/ingress.go][federation/pkg/federation-controller/service/ingress/ingress.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ingress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		fedapi "k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compile time check for interface adherence
0000000000000000000000000000000000000000;;	var _ sort.Interface = &FederatedServiceIngress{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FederatedServiceIngressAnnotation = "federation.kubernetes.io/service-ingresses"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederatedServiceIngress implements sort.Interface.
0000000000000000000000000000000000000000;;	type FederatedServiceIngress struct {
0000000000000000000000000000000000000000;;		fedapi.FederatedServiceIngress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFederatedServiceIngress() *FederatedServiceIngress {
0000000000000000000000000000000000000000;;		return &FederatedServiceIngress{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ingress *FederatedServiceIngress) String() string {
0000000000000000000000000000000000000000;;		annotationBytes, _ := json.Marshal(ingress)
0000000000000000000000000000000000000000;;		return string(annotationBytes[:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len is to satisfy of sort.Interface.
0000000000000000000000000000000000000000;;	func (ingress *FederatedServiceIngress) Len() int {
0000000000000000000000000000000000000000;;		return len(ingress.Items)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Less is to satisfy of sort.Interface.
0000000000000000000000000000000000000000;;	func (ingress *FederatedServiceIngress) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return (strings.Compare(ingress.Items[i].Cluster, ingress.Items[j].Cluster) < 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Swap is to satisfy of sort.Interface.
0000000000000000000000000000000000000000;;	func (ingress *FederatedServiceIngress) Swap(i, j int) {
0000000000000000000000000000000000000000;;		ingress.Items[i].Cluster, ingress.Items[j].Cluster = ingress.Items[j].Cluster, ingress.Items[i].Cluster
0000000000000000000000000000000000000000;;		ingress.Items[i].Items, ingress.Items[j].Items = ingress.Items[j].Items, ingress.Items[i].Items
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetClusterLoadBalancerIngresses returns loadbalancer ingresses for given cluster if exist otherwise returns an empty slice
0000000000000000000000000000000000000000;;	func (ingress *FederatedServiceIngress) GetClusterLoadBalancerIngresses(cluster string) []v1.LoadBalancerIngress {
0000000000000000000000000000000000000000;;		for _, clusterIngress := range ingress.Items {
0000000000000000000000000000000000000000;;			if cluster == clusterIngress.Cluster {
0000000000000000000000000000000000000000;;				return clusterIngress.Items
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []v1.LoadBalancerIngress{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddClusterLoadBalancerIngresses adds the ladbalancer ingresses for a given cluster to federated service ingress
0000000000000000000000000000000000000000;;	func (ingress *FederatedServiceIngress) AddClusterLoadBalancerIngresses(cluster string, loadbalancerIngresses []v1.LoadBalancerIngress) {
0000000000000000000000000000000000000000;;		for i, clusterIngress := range ingress.Items {
0000000000000000000000000000000000000000;;			if cluster == clusterIngress.Cluster {
0000000000000000000000000000000000000000;;				ingress.Items[i].Items = append(ingress.Items[i].Items, loadbalancerIngresses...)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterNewIngress := fedapi.ClusterServiceIngress{Cluster: cluster, Items: loadbalancerIngresses}
0000000000000000000000000000000000000000;;		ingress.Items = append(ingress.Items, clusterNewIngress)
0000000000000000000000000000000000000000;;		sort.Sort(ingress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddEndpoints add one or more endpoints to federated service ingress.
0000000000000000000000000000000000000000;;	// endpoints are federated cluster's loadbalancer ip/hostname for the service
0000000000000000000000000000000000000000;;	func (ingress *FederatedServiceIngress) AddEndpoints(cluster string, endpoints []string) *FederatedServiceIngress {
0000000000000000000000000000000000000000;;		lbIngress := []v1.LoadBalancerIngress{}
0000000000000000000000000000000000000000;;		for _, endpoint := range endpoints {
0000000000000000000000000000000000000000;;			lbIngress = append(lbIngress, v1.LoadBalancerIngress{IP: endpoint})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ingress.AddClusterLoadBalancerIngresses(cluster, lbIngress)
0000000000000000000000000000000000000000;;		return ingress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveEndpoint removes a single endpoint (ip/hostname) from the federated service ingress
0000000000000000000000000000000000000000;;	func (ingress *FederatedServiceIngress) RemoveEndpoint(cluster string, endpoint string) *FederatedServiceIngress {
0000000000000000000000000000000000000000;;		for i, clusterIngress := range ingress.Items {
0000000000000000000000000000000000000000;;			if cluster == clusterIngress.Cluster {
0000000000000000000000000000000000000000;;				for j, lbIngress := range clusterIngress.Items {
0000000000000000000000000000000000000000;;					if lbIngress.IP == endpoint {
0000000000000000000000000000000000000000;;						ingress.Items[i].Items = append(ingress.Items[i].Items[:j], ingress.Items[i].Items[j+1:]...)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ingress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseFederatedServiceIngress extracts federated service ingresses from a federated service
0000000000000000000000000000000000000000;;	func ParseFederatedServiceIngress(service *v1.Service) (*FederatedServiceIngress, error) {
0000000000000000000000000000000000000000;;		ingress := FederatedServiceIngress{}
0000000000000000000000000000000000000000;;		if service.Annotations == nil {
0000000000000000000000000000000000000000;;			return &ingress, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		federatedServiceIngressString, found := service.Annotations[FederatedServiceIngressAnnotation]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return &ingress, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal([]byte(federatedServiceIngressString), &ingress); err != nil {
0000000000000000000000000000000000000000;;			return &ingress, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ingress, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateIngressAnnotation updates the federated service with service ingress annotation
0000000000000000000000000000000000000000;;	func UpdateIngressAnnotation(service *v1.Service, ingress *FederatedServiceIngress) *v1.Service {
0000000000000000000000000000000000000000;;		if service.Annotations == nil {
0000000000000000000000000000000000000000;;			service.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		service.Annotations[FederatedServiceIngressAnnotation] = ingress.String()
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
