0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1353dc55051227671112e5ec5975b863b6ce64af;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		fakefedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/service/ingress"
0000000000000000000000000000000000000000;;		fedutil "k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/deletionhelper"
0000000000000000000000000000000000000000;;		. "k8s.io/kubernetes/federation/pkg/federation-controller/util/test"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		fakekubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/kubernetes/pkg/client/listers/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		retryInterval = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusters  string = "clusters"
0000000000000000000000000000000000000000;;		services  string = "services"
0000000000000000000000000000000000000000;;		endpoints string = "endpoints"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lbIngress1       = "10.20.30.40"
0000000000000000000000000000000000000000;;		lbIngress2       = "10.20.30.50"
0000000000000000000000000000000000000000;;		serviceEndpoint1 = "192.168.0.1"
0000000000000000000000000000000000000000;;		serviceEndpoint2 = "192.168.1.1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var awfulError error = errors.NewGone("Something bad happened")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServiceController(t *testing.T) {
0000000000000000000000000000000000000000;;		glog.Infof("Creating fake infrastructure")
0000000000000000000000000000000000000000;;		fedClient := &fakefedclientset.Clientset{}
0000000000000000000000000000000000000000;;		cluster1 := NewCluster("cluster1", v1.ConditionTrue)
0000000000000000000000000000000000000000;;		cluster2 := NewCluster("cluster2", v1.ConditionTrue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RegisterFakeClusterGet(&fedClient.Fake, &v1beta1.ClusterList{Items: []v1beta1.Cluster{*cluster1, *cluster2}})
0000000000000000000000000000000000000000;;		RegisterFakeList(clusters, &fedClient.Fake, &v1beta1.ClusterList{Items: []v1beta1.Cluster{*cluster1, *cluster2}})
0000000000000000000000000000000000000000;;		fedclusterWatch := RegisterFakeWatch(clusters, &fedClient.Fake)
0000000000000000000000000000000000000000;;		RegisterFakeList(services, &fedClient.Fake, &v1.ServiceList{Items: []v1.Service{}})
0000000000000000000000000000000000000000;;		fedServiceWatch := RegisterFakeWatch(services, &fedClient.Fake)
0000000000000000000000000000000000000000;;		RegisterFakeOnCreate(clusters, &fedClient.Fake, fedclusterWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnUpdate(clusters, &fedClient.Fake, fedclusterWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnCreate(services, &fedClient.Fake, fedServiceWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnUpdate(services, &fedClient.Fake, fedServiceWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnDelete(services, &fedClient.Fake, fedServiceWatch, serviceObjectGetter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster1Client := &fakekubeclientset.Clientset{}
0000000000000000000000000000000000000000;;		RegisterFakeList(services, &cluster1Client.Fake, &v1.ServiceList{Items: []v1.Service{}})
0000000000000000000000000000000000000000;;		c1ServiceWatch := RegisterFakeWatch(services, &cluster1Client.Fake)
0000000000000000000000000000000000000000;;		RegisterFakeList(endpoints, &cluster1Client.Fake, &v1.EndpointsList{Items: []v1.Endpoints{}})
0000000000000000000000000000000000000000;;		c1EndpointWatch := RegisterFakeWatch(endpoints, &cluster1Client.Fake)
0000000000000000000000000000000000000000;;		RegisterFakeOnCreate(services, &cluster1Client.Fake, c1ServiceWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnUpdate(services, &cluster1Client.Fake, c1ServiceWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnDelete(services, &cluster1Client.Fake, c1ServiceWatch, serviceObjectGetter)
0000000000000000000000000000000000000000;;		RegisterFakeOnCreate(endpoints, &cluster1Client.Fake, c1EndpointWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnUpdate(endpoints, &cluster1Client.Fake, c1EndpointWatch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster2Client := &fakekubeclientset.Clientset{}
0000000000000000000000000000000000000000;;		RegisterFakeList(services, &cluster2Client.Fake, &v1.ServiceList{Items: []v1.Service{}})
0000000000000000000000000000000000000000;;		c2ServiceWatch := RegisterFakeWatch(services, &cluster2Client.Fake)
0000000000000000000000000000000000000000;;		RegisterFakeList(endpoints, &cluster2Client.Fake, &v1.EndpointsList{Items: []v1.Endpoints{}})
0000000000000000000000000000000000000000;;		c2EndpointWatch := RegisterFakeWatch(endpoints, &cluster2Client.Fake)
0000000000000000000000000000000000000000;;		RegisterFakeOnCreate(services, &cluster2Client.Fake, c2ServiceWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnUpdate(services, &cluster2Client.Fake, c2ServiceWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnDelete(services, &cluster2Client.Fake, c2ServiceWatch, serviceObjectGetter)
0000000000000000000000000000000000000000;;		RegisterFakeOnCreate(endpoints, &cluster2Client.Fake, c2EndpointWatch)
0000000000000000000000000000000000000000;;		RegisterFakeOnUpdate(endpoints, &cluster2Client.Fake, c2EndpointWatch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fedInformerClientFactory := func(cluster *v1beta1.Cluster) (kubeclientset.Interface, error) {
0000000000000000000000000000000000000000;;			switch cluster.Name {
0000000000000000000000000000000000000000;;			case cluster1.Name:
0000000000000000000000000000000000000000;;				return cluster1Client, nil
0000000000000000000000000000000000000000;;			case cluster2.Name:
0000000000000000000000000000000000000000;;				return cluster2Client, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Unknown cluster: %v", cluster.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc := New(fedClient)
0000000000000000000000000000000000000000;;		ToFederatedInformerForTestOnly(sc.federatedInformer).SetClientFactory(fedInformerClientFactory)
0000000000000000000000000000000000000000;;		ToFederatedInformerForTestOnly(sc.endpointFederatedInformer).SetClientFactory(fedInformerClientFactory)
0000000000000000000000000000000000000000;;		sc.clusterAvailableDelay = 100 * time.Millisecond
0000000000000000000000000000000000000000;;		sc.reviewDelay = 50 * time.Millisecond
0000000000000000000000000000000000000000;;		sc.updateTimeout = 5 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		glog.Infof("Running Service Controller")
0000000000000000000000000000000000000000;;		go sc.Run(5, stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Adding cluster 1")
0000000000000000000000000000000000000000;;		fedclusterWatch.Add(cluster1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := NewService("test-service-1", 80)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Adding federated service")
0000000000000000000000000000000000000000;;		fedServiceWatch.Add(service)
0000000000000000000000000000000000000000;;		key := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test service was correctly created in cluster 1")
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForClusterService(t, sc.federatedInformer.GetTargetStore(), cluster1.Name,
0000000000000000000000000000000000000000;;			key, service, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Adding cluster 2")
0000000000000000000000000000000000000000;;		fedclusterWatch.Add(cluster2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test service was correctly created in cluster 2")
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForClusterService(t, sc.federatedInformer.GetTargetStore(), cluster2.Name,
0000000000000000000000000000000000000000;;			key, service, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test federation service is updated when cluster1 service status is updated")
0000000000000000000000000000000000000000;;		service.Status = v1.ServiceStatus{
0000000000000000000000000000000000000000;;			LoadBalancer: v1.LoadBalancerStatus{
0000000000000000000000000000000000000000;;				Ingress: []v1.LoadBalancerIngress{
0000000000000000000000000000000000000000;;					{IP: lbIngress1},
0000000000000000000000000000000000000000;;				}}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desiredStatus := service.Status
0000000000000000000000000000000000000000;;		desiredService := &v1.Service{Status: desiredStatus}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c1ServiceWatch.Modify(service)
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForClusterService(t, sc.federatedInformer.GetTargetStore(), cluster1.Name,
0000000000000000000000000000000000000000;;			key, service, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForFederatedServiceUpdate(t, sc.serviceStore,
0000000000000000000000000000000000000000;;			key, desiredService, serviceStatusCompare, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test federation service is updated when cluster1 endpoint for the service is created")
0000000000000000000000000000000000000000;;		desiredIngressAnnotation := ingress.NewFederatedServiceIngress().
0000000000000000000000000000000000000000;;			AddEndpoints("cluster1", []string{lbIngress1}).
0000000000000000000000000000000000000000;;			String()
0000000000000000000000000000000000000000;;		desiredService = &v1.Service{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{ingress.FederatedServiceIngressAnnotation: desiredIngressAnnotation}}}
0000000000000000000000000000000000000000;;		c1EndpointWatch.Add(NewEndpoint("test-service-1", serviceEndpoint1))
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForFederatedServiceUpdate(t, sc.serviceStore,
0000000000000000000000000000000000000000;;			key, desiredService, serviceIngressCompare, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test federation service is updated when cluster2 service status is updated")
0000000000000000000000000000000000000000;;		service.Status = v1.ServiceStatus{
0000000000000000000000000000000000000000;;			LoadBalancer: v1.LoadBalancerStatus{
0000000000000000000000000000000000000000;;				Ingress: []v1.LoadBalancerIngress{
0000000000000000000000000000000000000000;;					{IP: lbIngress2},
0000000000000000000000000000000000000000;;				}}}
0000000000000000000000000000000000000000;;		desiredStatus.LoadBalancer.Ingress = append(desiredStatus.LoadBalancer.Ingress, v1.LoadBalancerIngress{IP: lbIngress2})
0000000000000000000000000000000000000000;;		desiredService = &v1.Service{Status: desiredStatus}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c2ServiceWatch.Modify(service)
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForClusterService(t, sc.federatedInformer.GetTargetStore(), cluster2.Name,
0000000000000000000000000000000000000000;;			key, service, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForFederatedServiceUpdate(t, sc.serviceStore,
0000000000000000000000000000000000000000;;			key, desiredService, serviceStatusCompare, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test federation service is updated when cluster2 endpoint for the service is created")
0000000000000000000000000000000000000000;;		desiredIngressAnnotation = ingress.NewFederatedServiceIngress().
0000000000000000000000000000000000000000;;			AddEndpoints("cluster1", []string{lbIngress1}).
0000000000000000000000000000000000000000;;			AddEndpoints("cluster2", []string{lbIngress2}).
0000000000000000000000000000000000000000;;			String()
0000000000000000000000000000000000000000;;		desiredService = &v1.Service{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{ingress.FederatedServiceIngressAnnotation: desiredIngressAnnotation}}}
0000000000000000000000000000000000000000;;		c2EndpointWatch.Add(NewEndpoint("test-service-1", serviceEndpoint2))
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForFederatedServiceUpdate(t, sc.serviceStore,
0000000000000000000000000000000000000000;;			key, desiredService, serviceIngressCompare, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test federation service is updated when cluster1 endpoint for the service is deleted")
0000000000000000000000000000000000000000;;		desiredIngressAnnotation = ingress.NewFederatedServiceIngress().
0000000000000000000000000000000000000000;;			AddEndpoints("cluster2", []string{lbIngress2}).
0000000000000000000000000000000000000000;;			String()
0000000000000000000000000000000000000000;;		desiredService = &v1.Service{ObjectMeta: metav1.ObjectMeta{Annotations: map[string]string{ingress.FederatedServiceIngressAnnotation: desiredIngressAnnotation}}}
0000000000000000000000000000000000000000;;		c1EndpointWatch.Delete(NewEndpoint("test-service-1", serviceEndpoint1))
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForFederatedServiceUpdate(t, sc.serviceStore,
0000000000000000000000000000000000000000;;			key, desiredService, serviceIngressCompare, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test modifying federated service by changing the port")
0000000000000000000000000000000000000000;;		service.Spec.Ports[0].Port = 9090
0000000000000000000000000000000000000000;;		fedServiceWatch.Modify(service)
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForClusterService(t, sc.federatedInformer.GetTargetStore(), cluster1.Name,
0000000000000000000000000000000000000000;;			key, service, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test cluster service is recreated when deleted")
0000000000000000000000000000000000000000;;		c1Service := NewService("test-service-1", 80)
0000000000000000000000000000000000000000;;		c1Service.DeletionTimestamp = &metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		c1ServiceWatch.Delete(c1Service)
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForClusterService(t, sc.federatedInformer.GetTargetStore(), cluster1.Name,
0000000000000000000000000000000000000000;;			key, service, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Test cluster services are deleted when federated service is deleted")
0000000000000000000000000000000000000000;;		service.ObjectMeta.Finalizers = append(service.ObjectMeta.Finalizers, deletionhelper.FinalizerDeleteFromUnderlyingClusters)
0000000000000000000000000000000000000000;;		service.DeletionTimestamp = &metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		fedServiceWatch.Modify(service)
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForClusterServiceDelete(t, sc.federatedInformer.GetTargetStore(), cluster1.Name,
0000000000000000000000000000000000000000;;			key, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;		require.NoError(t, WaitForClusterServiceDelete(t, sc.federatedInformer.GetTargetStore(), cluster2.Name,
0000000000000000000000000000000000000000;;			key, wait.ForeverTestTimeout))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(stop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetOperationsToPerformOnCluster(t *testing.T) {
0000000000000000000000000000000000000000;;		obj := NewService("test-service-1", 80)
0000000000000000000000000000000000000000;;		cluster1 := NewCluster("cluster1", v1.ConditionTrue)
0000000000000000000000000000000000000000;;		fedClient := &fakefedclientset.Clientset{}
0000000000000000000000000000000000000000;;		sc := New(fedClient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			expectedSendErr bool
0000000000000000000000000000000000000000;;			sendToCluster   bool
0000000000000000000000000000000000000000;;			operationType   fedutil.FederatedOperationType
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"sendToCluster error returned": {
0000000000000000000000000000000000000000;;				expectedSendErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Missing object and not matching ClusterSelector should result in no operations": {
0000000000000000000000000000000000000000;;				sendToCluster: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Missing object and matching ClusterSelector should result in add operation": {
0000000000000000000000000000000000000000;;				operationType: fedutil.OperationTypeAdd,
0000000000000000000000000000000000000000;;				sendToCluster: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Update and Delete scenarios are tested in TestServiceController
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			t.Run(testName, func(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				operations, err := getOperationsToPerformOnCluster(sc.federatedInformer, cluster1, obj, func(map[string]string, map[string]string) (bool, error) {
0000000000000000000000000000000000000000;;					if testCase.expectedSendErr {
0000000000000000000000000000000000000000;;						return false, awfulError
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return testCase.sendToCluster, nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if testCase.expectedSendErr {
0000000000000000000000000000000000000000;;					require.Error(t, err, "An error was expected")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					require.NoError(t, err, "An error was not expected")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(testCase.operationType) == 0 {
0000000000000000000000000000000000000000;;					require.Nil(t, operations, "An operation was not expected")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					require.NotNil(t, operations, "A single operation was expected")
0000000000000000000000000000000000000000;;					require.Equal(t, testCase.operationType, operations.Type, "Unexpected operation returned")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serviceObjectGetter gives dummy service objects to use with RegisterFakeOnDelete
0000000000000000000000000000000000000000;;	// This is just so that federated informer can be tested for delete scenarios.
0000000000000000000000000000000000000000;;	func serviceObjectGetter(name, namespace string) runtime.Object {
0000000000000000000000000000000000000000;;		service := new(v1.Service)
0000000000000000000000000000000000000000;;		service.Namespace = namespace
0000000000000000000000000000000000000000;;		service.Name = name
0000000000000000000000000000000000000000;;		return service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewService(name string, port int32) *v1.Service {
0000000000000000000000000000000000000000;;		return &v1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: v1.NamespaceDefault,
0000000000000000000000000000000000000000;;				SelfLink:  "/api/v1/namespaces/default/services/" + name,
0000000000000000000000000000000000000000;;				Labels:    map[string]string{"app": name},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: []v1.ServicePort{{Port: port}},
0000000000000000000000000000000000000000;;				Type:  v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewEndpoint(name, ip string) *v1.Endpoints {
0000000000000000000000000000000000000000;;		return &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: v1.NamespaceDefault,
0000000000000000000000000000000000000000;;				SelfLink:  "/api/v1/namespaces/default/endpoints/" + name,
0000000000000000000000000000000000000000;;				Labels:    map[string]string{"app": name},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{
0000000000000000000000000000000000000000;;					IP: ip,
0000000000000000000000000000000000000000;;				}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForClusterService waits for the cluster service to be created matching the desiredService.
0000000000000000000000000000000000000000;;	func WaitForClusterService(t *testing.T, store fedutil.FederatedReadOnlyStore, clusterName, key string, desiredService *v1.Service, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			obj, found, err := store.GetByKey(clusterName, key)
0000000000000000000000000000000000000000;;			if !found || err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			service := obj.(*v1.Service)
0000000000000000000000000000000000000000;;			if !Equivalent(service, desiredService) {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Waiting for clustered service, Desired: %v, Current: %v", desiredService, service)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Clustered service is up to date: %v", service)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForClusterServiceDelete waits for the cluster service to be deleted.
0000000000000000000000000000000000000000;;	func WaitForClusterServiceDelete(t *testing.T, store fedutil.FederatedReadOnlyStore, clusterName, key string, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, found, _ := store.GetByKey(clusterName, key)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serviceCompare func(current, desired *v1.Service) (match bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serviceStatusCompare(current, desired *v1.Service) bool {
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(current.Status.LoadBalancer, desired.Status.LoadBalancer) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Waiting for loadbalancer status, Current: %v, Desired: %v", current.Status.LoadBalancer, desired.Status.LoadBalancer)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Loadbalancer status match: %v", current.Status.LoadBalancer)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serviceIngressCompare(current, desired *v1.Service) bool {
0000000000000000000000000000000000000000;;		if strings.Compare(current.Annotations[ingress.FederatedServiceIngressAnnotation], desired.Annotations[ingress.FederatedServiceIngressAnnotation]) != 0 {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Waiting for loadbalancer ingress, Current: %v, Desired: %v", current.Annotations[ingress.FederatedServiceIngressAnnotation], desired.Annotations[ingress.FederatedServiceIngressAnnotation])
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Loadbalancer ingress match: %v", current.Annotations[ingress.FederatedServiceIngressAnnotation])
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForFederatedServiceUpdate waits for federated service updates to match the desiredService.
0000000000000000000000000000000000000000;;	func WaitForFederatedServiceUpdate(t *testing.T, store corelisters.ServiceLister, key string, desiredService *v1.Service, match serviceCompare, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			namespace, name, err := cache.SplitMetaNamespaceKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			service, err := store.Services(namespace).Get(name)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			case !match(service, desiredService):
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
