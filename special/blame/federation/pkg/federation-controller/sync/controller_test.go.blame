0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b816413f087329c40e99bcbe1252de787d031e72;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package sync
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federatedtypes"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		fedtest "k8s.io/kubernetes/federation/pkg/federation-controller/util/test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var awfulError error = errors.New("Something bad happened")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSyncToClusters(t *testing.T) {
0000000000000000000000000000000000000000;;		adapter := &federatedtypes.SecretAdapter{}
0000000000000000000000000000000000000000;;		obj := adapter.NewTestObject("foo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			clusterError    bool
0000000000000000000000000000000000000000;;			operationsError bool
0000000000000000000000000000000000000000;;			executionError  bool
0000000000000000000000000000000000000000;;			operations      []util.FederatedOperation
0000000000000000000000000000000000000000;;			status          reconciliationStatus
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"Error listing clusters redelivers with cluster delay": {
0000000000000000000000000000000000000000;;				clusterError: true,
0000000000000000000000000000000000000000;;				status:       statusNotSynced,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Error retrieving cluster operations redelivers": {
0000000000000000000000000000000000000000;;				operationsError: true,
0000000000000000000000000000000000000000;;				status:          statusError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"No operations returns ok": {
0000000000000000000000000000000000000000;;				status: statusAllOK,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Execution error redelivers": {
0000000000000000000000000000000000000000;;				executionError: true,
0000000000000000000000000000000000000000;;				operations:     []util.FederatedOperation{{}},
0000000000000000000000000000000000000000;;				status:         statusError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Successful update indicates recheck": {
0000000000000000000000000000000000000000;;				operations: []util.FederatedOperation{{}},
0000000000000000000000000000000000000000;;				status:     statusNeedsRecheck,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			t.Run(testName, func(t *testing.T) {
0000000000000000000000000000000000000000;;				status := syncToClusters(
0000000000000000000000000000000000000000;;					func() ([]*federationapi.Cluster, error) {
0000000000000000000000000000000000000000;;						if testCase.clusterError {
0000000000000000000000000000000000000000;;							return nil, awfulError
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					func(federatedtypes.FederatedTypeAdapter, []*federationapi.Cluster, []*federationapi.Cluster, pkgruntime.Object, *federatedtypes.SchedulingInfo) ([]util.FederatedOperation, error) {
0000000000000000000000000000000000000000;;						if testCase.operationsError {
0000000000000000000000000000000000000000;;							return nil, awfulError
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return testCase.operations, nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					func(objMeta *metav1.ObjectMeta, selector func(map[string]string, map[string]string) (bool, error), clusters []*federationapi.Cluster) ([]*federationapi.Cluster, []*federationapi.Cluster, error) {
0000000000000000000000000000000000000000;;						return clusters, []*federationapi.Cluster{}, nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					func([]util.FederatedOperation) error {
0000000000000000000000000000000000000000;;						if testCase.executionError {
0000000000000000000000000000000000000000;;							return awfulError
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					adapter,
0000000000000000000000000000000000000000;;					nil,
0000000000000000000000000000000000000000;;					obj,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				require.Equal(t, testCase.status, status, "Unexpected status!")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectedClusters(t *testing.T) {
0000000000000000000000000000000000000000;;		clusterOne := fedtest.NewCluster("cluster1", apiv1.ConditionTrue)
0000000000000000000000000000000000000000;;		clusterOne.Labels = map[string]string{"name": "cluster1"}
0000000000000000000000000000000000000000;;		clusterTwo := fedtest.NewCluster("cluster2", apiv1.ConditionTrue)
0000000000000000000000000000000000000000;;		clusterTwo.Labels = map[string]string{"name": "cluster2"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusters := []*federationapi.Cluster{clusterOne, clusterTwo}
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			expectedSelectorError      bool
0000000000000000000000000000000000000000;;			clusterOneSelected         bool
0000000000000000000000000000000000000000;;			clusterTwoSelected         bool
0000000000000000000000000000000000000000;;			expectedSelectedClusters   []*federationapi.Cluster
0000000000000000000000000000000000000000;;			expectedUnselectedClusters []*federationapi.Cluster
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"Selector returned error": {
0000000000000000000000000000000000000000;;				expectedSelectorError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"All clusters selected": {
0000000000000000000000000000000000000000;;				clusterOneSelected:         true,
0000000000000000000000000000000000000000;;				clusterTwoSelected:         true,
0000000000000000000000000000000000000000;;				expectedSelectedClusters:   clusters,
0000000000000000000000000000000000000000;;				expectedUnselectedClusters: []*federationapi.Cluster{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"One cluster selected": {
0000000000000000000000000000000000000000;;				clusterOneSelected:         true,
0000000000000000000000000000000000000000;;				expectedSelectedClusters:   []*federationapi.Cluster{clusterOne},
0000000000000000000000000000000000000000;;				expectedUnselectedClusters: []*federationapi.Cluster{clusterTwo},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"No clusters selected": {
0000000000000000000000000000000000000000;;				expectedSelectedClusters:   []*federationapi.Cluster{},
0000000000000000000000000000000000000000;;				expectedUnselectedClusters: clusters,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			t.Run(testName, func(t *testing.T) {
0000000000000000000000000000000000000000;;				selectedClusters, unselectedClusters, err := selectedClusters(&metav1.ObjectMeta{}, func(labels map[string]string, annotations map[string]string) (bool, error) {
0000000000000000000000000000000000000000;;					if testCase.expectedSelectorError {
0000000000000000000000000000000000000000;;						return false, awfulError
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if labels["name"] == "cluster1" {
0000000000000000000000000000000000000000;;						return testCase.clusterOneSelected, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if labels["name"] == "cluster2" {
0000000000000000000000000000000000000000;;						return testCase.clusterTwoSelected, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected cluster")
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}, clusters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if testCase.expectedSelectorError {
0000000000000000000000000000000000000000;;					require.Error(t, err, "An error was expected")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					require.NoError(t, err, "An error was not expected")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				require.Equal(t, testCase.expectedSelectedClusters, selectedClusters, "Expected the correct clusters to be selected.")
0000000000000000000000000000000000000000;;				require.Equal(t, testCase.expectedUnselectedClusters, unselectedClusters, "Expected the correct clusters to be unselected.")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClusterOperations(t *testing.T) {
0000000000000000000000000000000000000000;;		adapter := &federatedtypes.SecretAdapter{}
0000000000000000000000000000000000000000;;		obj := adapter.NewTestObject("foo")
0000000000000000000000000000000000000000;;		differingObj := adapter.Copy(obj)
0000000000000000000000000000000000000000;;		federatedtypes.SetAnnotation(adapter, differingObj, "foo", "bar")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			clusterObject pkgruntime.Object
0000000000000000000000000000000000000000;;			expectedErr   bool
0000000000000000000000000000000000000000;;			sendToCluster bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			operationType util.FederatedOperationType
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"Accessor error returned": {
0000000000000000000000000000000000000000;;				expectedErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Missing cluster object should result in add operation": {
0000000000000000000000000000000000000000;;				operationType: util.OperationTypeAdd,
0000000000000000000000000000000000000000;;				sendToCluster: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Differing cluster object should result in update operation": {
0000000000000000000000000000000000000000;;				clusterObject: differingObj,
0000000000000000000000000000000000000000;;				operationType: util.OperationTypeUpdate,
0000000000000000000000000000000000000000;;				sendToCluster: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Matching object and not matching ClusterSelector should result in delete operation": {
0000000000000000000000000000000000000000;;				clusterObject: obj,
0000000000000000000000000000000000000000;;				operationType: util.OperationTypeDelete,
0000000000000000000000000000000000000000;;				sendToCluster: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"Matching cluster object should not result in an operation": {
0000000000000000000000000000000000000000;;				clusterObject: obj,
0000000000000000000000000000000000000000;;				sendToCluster: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for testName, testCase := range testCases {
0000000000000000000000000000000000000000;;			t.Run(testName, func(t *testing.T) {
0000000000000000000000000000000000000000;;				clusters := []*federationapi.Cluster{fedtest.NewCluster("cluster1", apiv1.ConditionTrue)}
0000000000000000000000000000000000000000;;				key := federatedtypes.ObjectKey(adapter, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var selectedClusters, unselectedClusters []*federationapi.Cluster
0000000000000000000000000000000000000000;;				if testCase.sendToCluster {
0000000000000000000000000000000000000000;;					selectedClusters = clusters
0000000000000000000000000000000000000000;;					unselectedClusters = []*federationapi.Cluster{}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					selectedClusters = []*federationapi.Cluster{}
0000000000000000000000000000000000000000;;					unselectedClusters = clusters
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO: Tests for ScheduleObject on type adapter
0000000000000000000000000000000000000000;;				operations, err := clusterOperations(adapter, selectedClusters, unselectedClusters, obj, key, nil, func(string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;					if testCase.expectedErr {
0000000000000000000000000000000000000000;;						return nil, false, awfulError
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return testCase.clusterObject, (testCase.clusterObject != nil), nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if testCase.expectedErr {
0000000000000000000000000000000000000000;;					require.Error(t, err, "An error was expected")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					require.NoError(t, err, "An error was not expected")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(testCase.operationType) == 0 {
0000000000000000000000000000000000000000;;					require.True(t, len(operations) == 0, "An operation was not expected")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					require.True(t, len(operations) == 1, "A single operation was expected")
0000000000000000000000000000000000000000;;					require.Equal(t, testCase.operationType, operations[0].Type, "Unexpected operation returned")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
