0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
088a0e52e2f34399f175ec90809763db374973da;federation/pkg/federation-controller/secret/secret_controller.go[federation/pkg/federation-controller/secret/secret_controller.go][federation/pkg/federation-controller/sync/controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package sync
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		federationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federatedtypes"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/clusterselector"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/deletionhelper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/eventsink"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		allClustersKey = "ALL_CLUSTERS"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederationSyncController synchronizes the state of a federated type
0000000000000000000000000000000000000000;;	// to clusters that are members of the federation.
0000000000000000000000000000000000000000;;	type FederationSyncController struct {
0000000000000000000000000000000000000000;;		// For triggering reconciliation of a single resource. This is
0000000000000000000000000000000000000000;;		// used when there is an add/update/delete operation on a resource
0000000000000000000000000000000000000000;;		// in either federated API server or in some member of the
0000000000000000000000000000000000000000;;		// federation.
0000000000000000000000000000000000000000;;		deliverer *util.DelayingDeliverer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For triggering reconciliation of all target resources. This is
0000000000000000000000000000000000000000;;		// used when a new cluster becomes available.
0000000000000000000000000000000000000000;;		clusterDeliverer *util.DelayingDeliverer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Contains resources present in members of federation.
0000000000000000000000000000000000000000;;		informer util.FederatedInformer
0000000000000000000000000000000000000000;;		// For updating members of federation.
0000000000000000000000000000000000000000;;		updater util.FederatedUpdater
0000000000000000000000000000000000000000;;		// Definitions of resources that should be federated.
0000000000000000000000000000000000000000;;		store cache.Store
0000000000000000000000000000000000000000;;		// Informer controller for resources that should be federated.
0000000000000000000000000000000000000000;;		controller cache.Controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Work queue allowing parallel processing of resources
0000000000000000000000000000000000000000;;		workQueue workqueue.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Backoff manager
0000000000000000000000000000000000000000;;		backoff *flowcontrol.Backoff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For events
0000000000000000000000000000000000000000;;		eventRecorder record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deletionHelper *deletionhelper.DeletionHelper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reviewDelay             time.Duration
0000000000000000000000000000000000000000;;		clusterAvailableDelay   time.Duration
0000000000000000000000000000000000000000;;		clusterUnavailableDelay time.Duration
0000000000000000000000000000000000000000;;		smallDelay              time.Duration
0000000000000000000000000000000000000000;;		updateTimeout           time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		adapter federatedtypes.FederatedTypeAdapter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartFederationSyncController starts a new sync controller for a type adapter
0000000000000000000000000000000000000000;;	func StartFederationSyncController(kind string, adapterFactory federatedtypes.AdapterFactory, config *restclient.Config, stopChan <-chan struct{}, minimizeLatency bool) {
0000000000000000000000000000000000000000;;		restclient.AddUserAgent(config, fmt.Sprintf("federation-%s-controller", kind))
0000000000000000000000000000000000000000;;		client := federationclientset.NewForConfigOrDie(config)
0000000000000000000000000000000000000000;;		adapter := adapterFactory(client, config)
0000000000000000000000000000000000000000;;		controller := newFederationSyncController(client, adapter)
0000000000000000000000000000000000000000;;		if minimizeLatency {
0000000000000000000000000000000000000000;;			controller.minimizeLatency()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof(fmt.Sprintf("Starting federated sync controller for %s resources", kind))
0000000000000000000000000000000000000000;;		controller.Run(stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newFederationSyncController returns a new sync controller for the given client and type adapter
0000000000000000000000000000000000000000;;	func newFederationSyncController(client federationclientset.Interface, adapter federatedtypes.FederatedTypeAdapter) *FederationSyncController {
0000000000000000000000000000000000000000;;		broadcaster := record.NewBroadcaster()
0000000000000000000000000000000000000000;;		broadcaster.StartRecordingToSink(eventsink.NewFederatedEventSink(client))
0000000000000000000000000000000000000000;;		recorder := broadcaster.NewRecorder(api.Scheme, clientv1.EventSource{Component: fmt.Sprintf("federation-%v-controller", adapter.Kind())})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &FederationSyncController{
0000000000000000000000000000000000000000;;			reviewDelay:             time.Second * 10,
0000000000000000000000000000000000000000;;			clusterAvailableDelay:   time.Second * 20,
0000000000000000000000000000000000000000;;			clusterUnavailableDelay: time.Second * 60,
0000000000000000000000000000000000000000;;			smallDelay:              time.Second * 3,
0000000000000000000000000000000000000000;;			updateTimeout:           time.Second * 30,
0000000000000000000000000000000000000000;;			workQueue:               workqueue.New(),
0000000000000000000000000000000000000000;;			backoff:                 flowcontrol.NewBackOff(5*time.Second, time.Minute),
0000000000000000000000000000000000000000;;			eventRecorder:           recorder,
0000000000000000000000000000000000000000;;			adapter:                 adapter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build delivereres for triggering reconciliations.
0000000000000000000000000000000000000000;;		s.deliverer = util.NewDelayingDeliverer()
0000000000000000000000000000000000000000;;		s.clusterDeliverer = util.NewDelayingDeliverer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start informer in federated API servers on the resource type that should be federated.
0000000000000000000000000000000000000000;;		s.store, s.controller = cache.NewInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;					return adapter.FedList(metav1.NamespaceAll, options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					return adapter.FedWatch(metav1.NamespaceAll, options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			adapter.ObjectType(),
0000000000000000000000000000000000000000;;			controller.NoResyncPeriodFunc(),
0000000000000000000000000000000000000000;;			util.NewTriggerOnAllChanges(func(obj pkgruntime.Object) { s.deliverObj(obj, 0, false) }))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Federated informer on the resource type in members of federation.
0000000000000000000000000000000000000000;;		s.informer = util.NewFederatedInformer(
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			func(cluster *federationapi.Cluster, targetClient kubeclientset.Interface) (cache.Store, cache.Controller) {
0000000000000000000000000000000000000000;;				return cache.NewInformer(
0000000000000000000000000000000000000000;;					&cache.ListWatch{
0000000000000000000000000000000000000000;;						ListFunc: func(options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;							return adapter.ClusterList(targetClient, metav1.NamespaceAll, options)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;							return adapter.ClusterWatch(targetClient, metav1.NamespaceAll, options)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					adapter.ObjectType(),
0000000000000000000000000000000000000000;;					controller.NoResyncPeriodFunc(),
0000000000000000000000000000000000000000;;					// Trigger reconciliation whenever something in federated cluster is changed. In most cases it
0000000000000000000000000000000000000000;;					// would be just confirmation that some operation on the target resource type had succeeded.
0000000000000000000000000000000000000000;;					util.NewTriggerOnAllChanges(
0000000000000000000000000000000000000000;;						func(obj pkgruntime.Object) {
0000000000000000000000000000000000000000;;							s.deliverObj(obj, s.reviewDelay, false)
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			&util.ClusterLifecycleHandlerFuncs{
0000000000000000000000000000000000000000;;				ClusterAvailable: func(cluster *federationapi.Cluster) {
0000000000000000000000000000000000000000;;					// When new cluster becomes available process all the target resources again.
0000000000000000000000000000000000000000;;					s.clusterDeliverer.DeliverAt(allClustersKey, nil, time.Now().Add(s.clusterAvailableDelay))
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// When a cluster becomes unavailable process all the target resources again.
0000000000000000000000000000000000000000;;				ClusterUnavailable: func(cluster *federationapi.Cluster, _ []interface{}) {
0000000000000000000000000000000000000000;;					s.clusterDeliverer.DeliverAt(allClustersKey, nil, time.Now().Add(s.clusterUnavailableDelay))
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Federated updeater along with Create/Update/Delete operations.
0000000000000000000000000000000000000000;;		s.updater = util.NewFederatedUpdater(s.informer, adapter.Kind(), s.updateTimeout, s.eventRecorder,
0000000000000000000000000000000000000000;;			func(client kubeclientset.Interface, obj pkgruntime.Object) error {
0000000000000000000000000000000000000000;;				_, err := adapter.ClusterCreate(client, obj)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(client kubeclientset.Interface, obj pkgruntime.Object) error {
0000000000000000000000000000000000000000;;				_, err := adapter.ClusterUpdate(client, obj)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(client kubeclientset.Interface, obj pkgruntime.Object) error {
0000000000000000000000000000000000000000;;				qualifiedName := adapter.QualifiedName(obj)
0000000000000000000000000000000000000000;;				orphanDependents := false
0000000000000000000000000000000000000000;;				err := adapter.ClusterDelete(client, qualifiedName, &metav1.DeleteOptions{OrphanDependents: &orphanDependents})
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.deletionHelper = deletionhelper.NewDeletionHelper(
0000000000000000000000000000000000000000;;			s.updateObject,
0000000000000000000000000000000000000000;;			// objNameFunc
0000000000000000000000000000000000000000;;			func(obj pkgruntime.Object) string {
0000000000000000000000000000000000000000;;				return adapter.QualifiedName(obj).String()
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			s.informer,
0000000000000000000000000000000000000000;;			s.updater,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// minimizeLatency reduces delays and timeouts to make the controller more responsive (useful for testing).
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) minimizeLatency() {
0000000000000000000000000000000000000000;;		s.clusterAvailableDelay = time.Second
0000000000000000000000000000000000000000;;		s.clusterUnavailableDelay = time.Second
0000000000000000000000000000000000000000;;		s.reviewDelay = 50 * time.Millisecond
0000000000000000000000000000000000000000;;		s.smallDelay = 20 * time.Millisecond
0000000000000000000000000000000000000000;;		s.updateTimeout = 5 * time.Second
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sends the given updated object to apiserver.
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) updateObject(obj pkgruntime.Object) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		return s.adapter.FedUpdate(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) Run(stopChan <-chan struct{}) {
0000000000000000000000000000000000000000;;		go s.controller.Run(stopChan)
0000000000000000000000000000000000000000;;		s.informer.Start()
0000000000000000000000000000000000000000;;		s.deliverer.StartWithHandler(func(item *util.DelayingDelivererItem) {
0000000000000000000000000000000000000000;;			s.workQueue.Add(item)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		s.clusterDeliverer.StartWithHandler(func(_ *util.DelayingDelivererItem) {
0000000000000000000000000000000000000000;;			s.reconcileOnClusterChange()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Allow multiple workers.
0000000000000000000000000000000000000000;;		go wait.Until(s.worker, time.Second, stopChan)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		util.StartBackoffGC(s.backoff, stopChan)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure all goroutines are cleaned up when the stop channel closes
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-stopChan
0000000000000000000000000000000000000000;;			s.informer.Stop()
0000000000000000000000000000000000000000;;			s.workQueue.ShutDown()
0000000000000000000000000000000000000000;;			s.deliverer.Stop()
0000000000000000000000000000000000000000;;			s.clusterDeliverer.Stop()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reconciliationStatus int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		statusAllOK reconciliationStatus = iota
0000000000000000000000000000000000000000;;		statusNeedsRecheck
0000000000000000000000000000000000000000;;		statusError
0000000000000000000000000000000000000000;;		statusNotSynced
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) worker() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			obj, quit := s.workQueue.Get()
0000000000000000000000000000000000000000;;			if quit {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			item := obj.(*util.DelayingDelivererItem)
0000000000000000000000000000000000000000;;			qualifiedName := item.Value.(*federatedtypes.QualifiedName)
0000000000000000000000000000000000000000;;			status := s.reconcile(*qualifiedName)
0000000000000000000000000000000000000000;;			s.workQueue.Done(item)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch status {
0000000000000000000000000000000000000000;;			case statusAllOK:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case statusError:
0000000000000000000000000000000000000000;;				s.deliver(*qualifiedName, 0, true)
0000000000000000000000000000000000000000;;			case statusNeedsRecheck:
0000000000000000000000000000000000000000;;				s.deliver(*qualifiedName, s.reviewDelay, false)
0000000000000000000000000000000000000000;;			case statusNotSynced:
0000000000000000000000000000000000000000;;				s.deliver(*qualifiedName, s.clusterAvailableDelay, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) deliverObj(obj pkgruntime.Object, delay time.Duration, failed bool) {
0000000000000000000000000000000000000000;;		qualifiedName := s.adapter.QualifiedName(obj)
0000000000000000000000000000000000000000;;		s.deliver(qualifiedName, delay, failed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds backoff to delay if this delivery is related to some failure. Resets backoff if there was no failure.
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) deliver(qualifiedName federatedtypes.QualifiedName, delay time.Duration, failed bool) {
0000000000000000000000000000000000000000;;		key := qualifiedName.String()
0000000000000000000000000000000000000000;;		if failed {
0000000000000000000000000000000000000000;;			s.backoff.Next(key, time.Now())
0000000000000000000000000000000000000000;;			delay = delay + s.backoff.Get(key)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.backoff.Reset(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.deliverer.DeliverAfter(key, &qualifiedName, delay)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check whether all data stores are in sync. False is returned if any of the informer/stores is not yet
0000000000000000000000000000000000000000;;	// synced with the corresponding api server.
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) isSynced() bool {
0000000000000000000000000000000000000000;;		if !s.informer.ClustersSynced() {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Cluster list not synced")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusters, err := s.informer.GetReadyClusters()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get ready clusters: %v", err))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.informer.GetTargetStore().ClustersSynced(clusters) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The function triggers reconciliation of all target federated resources.
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) reconcileOnClusterChange() {
0000000000000000000000000000000000000000;;		if !s.isSynced() {
0000000000000000000000000000000000000000;;			s.clusterDeliverer.DeliverAt(allClustersKey, nil, time.Now().Add(s.clusterAvailableDelay))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, obj := range s.store.List() {
0000000000000000000000000000000000000000;;			qualifiedName := s.adapter.QualifiedName(obj.(pkgruntime.Object))
0000000000000000000000000000000000000000;;			s.deliver(qualifiedName, s.smallDelay, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) reconcile(qualifiedName federatedtypes.QualifiedName) reconciliationStatus {
0000000000000000000000000000000000000000;;		if !s.isSynced() {
0000000000000000000000000000000000000000;;			return statusNotSynced
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kind := s.adapter.Kind()
0000000000000000000000000000000000000000;;		key := qualifiedName.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Starting to reconcile %v %v", kind, key)
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer glog.V(4).Infof("Finished reconciling %v %v (duration: %v)", kind, key, time.Now().Sub(startTime))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := s.objFromCache(kind, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return statusError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			return statusAllOK
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		meta := s.adapter.ObjectMeta(obj)
0000000000000000000000000000000000000000;;		if meta.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;			err := s.delete(obj, kind, qualifiedName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				msg := "Failed to delete %s %q: %v"
0000000000000000000000000000000000000000;;				args := []interface{}{kind, qualifiedName, err}
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf(msg, args...))
0000000000000000000000000000000000000000;;				s.eventRecorder.Eventf(obj, api.EventTypeWarning, "DeleteFailed", msg, args...)
0000000000000000000000000000000000000000;;				return statusError
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return statusAllOK
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Ensuring finalizers exist on %s %q", kind, key)
0000000000000000000000000000000000000000;;		obj, err = s.deletionHelper.EnsureFinalizers(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to ensure finalizers for %s %q: %v", kind, key, err))
0000000000000000000000000000000000000000;;			return statusError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operationsAccessor := func(adapter federatedtypes.FederatedTypeAdapter, selectedClusters []*federationapi.Cluster, unselectedClusters []*federationapi.Cluster, obj pkgruntime.Object, schedulingInfo *federatedtypes.SchedulingInfo) ([]util.FederatedOperation, error) {
0000000000000000000000000000000000000000;;			operations, err := clusterOperations(adapter, selectedClusters, unselectedClusters, obj, key, schedulingInfo, func(clusterName string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;				return s.informer.GetTargetStore().GetByKey(clusterName, key)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				s.eventRecorder.Eventf(obj, api.EventTypeWarning, "FedClusterOperationsError", "Error obtaining sync operations for %s: %s error: %s", kind, key, err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return operations, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return syncToClusters(
0000000000000000000000000000000000000000;;			s.informer.GetReadyClusters,
0000000000000000000000000000000000000000;;			operationsAccessor,
0000000000000000000000000000000000000000;;			selectedClusters,
0000000000000000000000000000000000000000;;			s.updater.Update,
0000000000000000000000000000000000000000;;			s.adapter,
0000000000000000000000000000000000000000;;			s.informer,
0000000000000000000000000000000000000000;;			obj,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) objFromCache(kind, key string) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		cachedObj, exist, err := s.store.GetByKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			wrappedErr := fmt.Errorf("Failed to query %s store for %q: %v", kind, key, err)
0000000000000000000000000000000000000000;;			runtime.HandleError(wrappedErr)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exist {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a copy before modifying the resource to prevent racing with other readers.
0000000000000000000000000000000000000000;;		copiedObj, err := api.Scheme.DeepCopy(cachedObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			wrappedErr := fmt.Errorf("Error in retrieving %s %q from store: %v", kind, key, err)
0000000000000000000000000000000000000000;;			runtime.HandleError(wrappedErr)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.adapter.IsExpectedType(copiedObj) {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Object is not the expected type: %v", copiedObj)
0000000000000000000000000000000000000000;;			runtime.HandleError(err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copiedObj.(pkgruntime.Object), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delete deletes the given resource or returns error if the deletion was not complete.
0000000000000000000000000000000000000000;;	func (s *FederationSyncController) delete(obj pkgruntime.Object, kind string, qualifiedName federatedtypes.QualifiedName) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Handling deletion of %s %q", kind, qualifiedName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform pre-deletion cleanup for the namespace adapter
0000000000000000000000000000000000000000;;		namespaceAdapter, ok := s.adapter.(*federatedtypes.NamespaceAdapter)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			obj, err = namespaceAdapter.CleanUpNamespace(obj, s.eventRecorder)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := s.deletionHelper.HandleObjectInUnderlyingClusters(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = s.adapter.FedDelete(qualifiedName, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Its all good if the error is not found error. That means it is deleted already and we do not have to do anything.
0000000000000000000000000000000000000000;;			// This is expected when we are processing an update as a result of finalizer deletion.
0000000000000000000000000000000000000000;;			// The process that deleted the last finalizer is also going to delete the resource and we do not have to do anything.
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clustersAccessorFunc func() ([]*federationapi.Cluster, error)
0000000000000000000000000000000000000000;;	type operationsFunc func(federatedtypes.FederatedTypeAdapter, []*federationapi.Cluster, []*federationapi.Cluster, pkgruntime.Object, *federatedtypes.SchedulingInfo) ([]util.FederatedOperation, error)
0000000000000000000000000000000000000000;;	type clusterSelectorFunc func(*metav1.ObjectMeta, func(map[string]string, map[string]string) (bool, error), []*federationapi.Cluster) ([]*federationapi.Cluster, []*federationapi.Cluster, error)
0000000000000000000000000000000000000000;;	type executionFunc func([]util.FederatedOperation) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncToClusters ensures that the state of the given object is synchronized to member clusters.
0000000000000000000000000000000000000000;;	func syncToClusters(clustersAccessor clustersAccessorFunc, operationsAccessor operationsFunc, selector clusterSelectorFunc, execute executionFunc, adapter federatedtypes.FederatedTypeAdapter, informer util.FederatedInformer, obj pkgruntime.Object) reconciliationStatus {
0000000000000000000000000000000000000000;;		kind := adapter.Kind()
0000000000000000000000000000000000000000;;		key := federatedtypes.ObjectKey(adapter, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Syncing %s %q in underlying clusters", kind, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusters, err := clustersAccessor()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to get cluster list: %v", err))
0000000000000000000000000000000000000000;;			return statusNotSynced
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selectedClusters, unselectedClusters, err := selector(adapter.ObjectMeta(obj), clusterselector.SendToCluster, clusters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return statusError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var schedulingInfo *federatedtypes.SchedulingInfo
0000000000000000000000000000000000000000;;		if adapter.IsSchedulingAdapter() {
0000000000000000000000000000000000000000;;			schedulingAdapter, ok := adapter.(federatedtypes.SchedulingAdapter)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Fatalf("Adapter for kind %q does not properly implement SchedulingAdapter.", kind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			schedulingInfo, err = schedulingAdapter.GetSchedule(obj, key, selectedClusters, informer)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("adapter.GetSchedule() failed on adapter for %s %q: %v", kind, key, err))
0000000000000000000000000000000000000000;;				return statusError
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operations, err := operationsAccessor(adapter, selectedClusters, unselectedClusters, obj, schedulingInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return statusError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if adapter.IsSchedulingAdapter() {
0000000000000000000000000000000000000000;;			schedulingAdapter, ok := adapter.(federatedtypes.SchedulingAdapter)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Fatalf("Adapter for kind %q does not properly implement SchedulingAdapter.", kind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = schedulingAdapter.UpdateFederatedStatus(obj, schedulingInfo.Status)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("adapter.UpdateFinished() failed on adapter for %s %q: %v", kind, key, err))
0000000000000000000000000000000000000000;;				return statusError
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(operations) == 0 {
0000000000000000000000000000000000000000;;			return statusAllOK
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = execute(operations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Failed to execute updates for %s %q: %v", kind, key, err))
0000000000000000000000000000000000000000;;			return statusError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Everything is in order but let's be double sure
0000000000000000000000000000000000000000;;		return statusNeedsRecheck
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// selectedClusters filters the provided clusters into two slices, one containing the clusters selected by selector and the other containing the rest of the provided clusters.
0000000000000000000000000000000000000000;;	func selectedClusters(objMeta *metav1.ObjectMeta, selector func(map[string]string, map[string]string) (bool, error), clusters []*federationapi.Cluster) ([]*federationapi.Cluster, []*federationapi.Cluster, error) {
0000000000000000000000000000000000000000;;		selectedClusters := []*federationapi.Cluster{}
0000000000000000000000000000000000000000;;		unselectedClusters := []*federationapi.Cluster{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cluster := range clusters {
0000000000000000000000000000000000000000;;			send, err := selector(cluster.Labels, objMeta.Annotations)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			} else if !send {
0000000000000000000000000000000000000000;;				unselectedClusters = append(unselectedClusters, cluster)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				selectedClusters = append(selectedClusters, cluster)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selectedClusters, unselectedClusters, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clusterObjectAccessorFunc func(clusterName string) (interface{}, bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clusterOperations returns the list of operations needed to synchronize the state of the given object to the provided clusters
0000000000000000000000000000000000000000;;	func clusterOperations(adapter federatedtypes.FederatedTypeAdapter, selectedClusters []*federationapi.Cluster, unselectedClusters []*federationapi.Cluster, obj pkgruntime.Object, key string, schedulingInfo *federatedtypes.SchedulingInfo, accessor clusterObjectAccessorFunc) ([]util.FederatedOperation, error) {
0000000000000000000000000000000000000000;;		operations := make([]util.FederatedOperation, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kind := adapter.Kind()
0000000000000000000000000000000000000000;;		for _, cluster := range selectedClusters {
0000000000000000000000000000000000000000;;			// The data should not be modified.
0000000000000000000000000000000000000000;;			desiredObj := adapter.Copy(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clusterObj, found, err := accessor(cluster.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				wrappedErr := fmt.Errorf("Failed to get %s %q from cluster %q: %v", kind, key, cluster.Name, err)
0000000000000000000000000000000000000000;;				runtime.HandleError(wrappedErr)
0000000000000000000000000000000000000000;;				return nil, wrappedErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			shouldCreateIfNeeded := true
0000000000000000000000000000000000000000;;			if adapter.IsSchedulingAdapter() {
0000000000000000000000000000000000000000;;				schedulingAdapter, ok := adapter.(federatedtypes.SchedulingAdapter)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("adapter for kind %s does not properly implement SchedulingAdapter.", kind)
0000000000000000000000000000000000000000;;					glog.Fatalf("Error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var clusterTypedObj pkgruntime.Object = nil
0000000000000000000000000000000000000000;;				if clusterObj != nil {
0000000000000000000000000000000000000000;;					clusterTypedObj = clusterObj.(pkgruntime.Object)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				desiredObj, shouldCreateIfNeeded, err = schedulingAdapter.ScheduleObject(cluster, clusterTypedObj, desiredObj, schedulingInfo)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					runtime.HandleError(err)
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var operationType util.FederatedOperationType = ""
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				clusterObj := clusterObj.(pkgruntime.Object)
0000000000000000000000000000000000000000;;				if !adapter.Equivalent(desiredObj, clusterObj) {
0000000000000000000000000000000000000000;;					operationType = util.OperationTypeUpdate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if shouldCreateIfNeeded {
0000000000000000000000000000000000000000;;				operationType = util.OperationTypeAdd
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(operationType) > 0 {
0000000000000000000000000000000000000000;;				operations = append(operations, util.FederatedOperation{
0000000000000000000000000000000000000000;;					Type:        operationType,
0000000000000000000000000000000000000000;;					Obj:         desiredObj,
0000000000000000000000000000000000000000;;					ClusterName: cluster.Name,
0000000000000000000000000000000000000000;;					Key:         key,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cluster := range unselectedClusters {
0000000000000000000000000000000000000000;;			clusterObj, found, err := accessor(cluster.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				wrappedErr := fmt.Errorf("Failed to get %s %q from cluster %q: %v", kind, key, cluster.Name, err)
0000000000000000000000000000000000000000;;				runtime.HandleError(wrappedErr)
0000000000000000000000000000000000000000;;				return nil, wrappedErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				operations = append(operations, util.FederatedOperation{
0000000000000000000000000000000000000000;;					Type:        util.OperationTypeDelete,
0000000000000000000000000000000000000000;;					Obj:         clusterObj.(pkgruntime.Object),
0000000000000000000000000000000000000000;;					ClusterName: cluster.Name,
0000000000000000000000000000000000000000;;					Key:         key,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return operations, nil
0000000000000000000000000000000000000000;;	}
