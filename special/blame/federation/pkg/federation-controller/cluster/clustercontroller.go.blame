0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6759dd73aec9ff5b9611f3a1cacb87f980b10742;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		federationv1beta1 "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		clustercache "k8s.io/kubernetes/federation/client/cache"
0000000000000000000000000000000000000000;;		federationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClusterController struct {
0000000000000000000000000000000000000000;;		knownClusterSet sets.String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// federationClient used to operate cluster
0000000000000000000000000000000000000000;;		federationClient federationclientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clusterMonitorPeriod is the period for updating status of cluster
0000000000000000000000000000000000000000;;		clusterMonitorPeriod time.Duration
0000000000000000000000000000000000000000;;		// clusterClusterStatusMap is a mapping of clusterName and cluster status of last sampling
0000000000000000000000000000000000000000;;		clusterClusterStatusMap map[string]federationv1beta1.ClusterStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clusterKubeClientMap is a mapping of clusterName and restclient
0000000000000000000000000000000000000000;;		clusterKubeClientMap map[string]ClusterClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cluster framework and store
0000000000000000000000000000000000000000;;		clusterController cache.Controller
0000000000000000000000000000000000000000;;		clusterStore      clustercache.StoreToClusterLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartClusterController starts a new cluster controller
0000000000000000000000000000000000000000;;	func StartClusterController(config *restclient.Config, stopChan <-chan struct{}, clusterMonitorPeriod time.Duration) {
0000000000000000000000000000000000000000;;		restclient.AddUserAgent(config, "cluster-controller")
0000000000000000000000000000000000000000;;		client := federationclientset.NewForConfigOrDie(config)
0000000000000000000000000000000000000000;;		controller := newClusterController(client, clusterMonitorPeriod)
0000000000000000000000000000000000000000;;		glog.Infof("Starting cluster controller")
0000000000000000000000000000000000000000;;		controller.Run(stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newClusterController returns a new cluster controller
0000000000000000000000000000000000000000;;	func newClusterController(federationClient federationclientset.Interface, clusterMonitorPeriod time.Duration) *ClusterController {
0000000000000000000000000000000000000000;;		cc := &ClusterController{
0000000000000000000000000000000000000000;;			knownClusterSet:         make(sets.String),
0000000000000000000000000000000000000000;;			federationClient:        federationClient,
0000000000000000000000000000000000000000;;			clusterMonitorPeriod:    clusterMonitorPeriod,
0000000000000000000000000000000000000000;;			clusterClusterStatusMap: make(map[string]federationv1beta1.ClusterStatus),
0000000000000000000000000000000000000000;;			clusterKubeClientMap:    make(map[string]ClusterClient),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.clusterStore.Store, cc.clusterController = cache.NewInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					return cc.federationClient.Federation().Clusters().List(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					return cc.federationClient.Federation().Clusters().Watch(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&federationv1beta1.Cluster{},
0000000000000000000000000000000000000000;;			controller.NoResyncPeriodFunc(),
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				DeleteFunc: cc.delFromClusterSet,
0000000000000000000000000000000000000000;;				AddFunc:    cc.addToClusterSet,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return cc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delFromClusterSet delete a cluster from clusterSet and
0000000000000000000000000000000000000000;;	// delete the corresponding restclient from the map clusterKubeClientMap
0000000000000000000000000000000000000000;;	func (cc *ClusterController) delFromClusterSet(obj interface{}) {
0000000000000000000000000000000000000000;;		cluster := obj.(*federationv1beta1.Cluster)
0000000000000000000000000000000000000000;;		cc.delFromClusterSetByName(cluster.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delFromClusterSetByName delete a cluster from clusterSet by name and
0000000000000000000000000000000000000000;;	// delete the corresponding restclient from the map clusterKubeClientMap
0000000000000000000000000000000000000000;;	func (cc *ClusterController) delFromClusterSetByName(clusterName string) {
0000000000000000000000000000000000000000;;		glog.V(1).Infof("ClusterController observed a cluster deletion: %v", clusterName)
0000000000000000000000000000000000000000;;		cc.knownClusterSet.Delete(clusterName)
0000000000000000000000000000000000000000;;		delete(cc.clusterKubeClientMap, clusterName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addToClusterSet insert the new cluster to clusterSet and create a corresponding
0000000000000000000000000000000000000000;;	// restclient to map clusterKubeClientMap
0000000000000000000000000000000000000000;;	func (cc *ClusterController) addToClusterSet(obj interface{}) {
0000000000000000000000000000000000000000;;		cluster := obj.(*federationv1beta1.Cluster)
0000000000000000000000000000000000000000;;		glog.V(1).Infof("ClusterController observed a new cluster: %v", cluster.Name)
0000000000000000000000000000000000000000;;		cc.knownClusterSet.Insert(cluster.Name)
0000000000000000000000000000000000000000;;		// create the restclient of cluster
0000000000000000000000000000000000000000;;		restClient, err := NewClusterClientSet(cluster)
0000000000000000000000000000000000000000;;		if err != nil || restClient == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to create corresponding restclient of kubernetes cluster: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.clusterKubeClientMap[cluster.Name] = *restClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run begins watching and syncing.
0000000000000000000000000000000000000000;;	func (cc *ClusterController) Run(stopChan <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		go cc.clusterController.Run(stopChan)
0000000000000000000000000000000000000000;;		// monitor cluster status periodically, in phase 1 we just get the health state from "/healthz"
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			if err := cc.UpdateClusterStatus(); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error monitoring cluster status: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, cc.clusterMonitorPeriod, stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClusterController) GetClusterClient(cluster *federationv1beta1.Cluster) (*ClusterClient, error) {
0000000000000000000000000000000000000000;;		clusterClient, found := cc.clusterKubeClientMap[cluster.Name]
0000000000000000000000000000000000000000;;		client := &clusterClient
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			glog.Infof("It's a new cluster, a cluster client will be created")
0000000000000000000000000000000000000000;;			client, err := NewClusterClientSet(cluster)
0000000000000000000000000000000000000000;;			if err != nil || client == nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to create cluster client, err: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClusterController) GetClusterStatus(cluster *federationv1beta1.Cluster) (*federationv1beta1.ClusterStatus, error) {
0000000000000000000000000000000000000000;;		// just get the status of cluster, by requesting the restapi "/healthz"
0000000000000000000000000000000000000000;;		clusterClient, err := cc.GetClusterClient(cluster)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterStatus := clusterClient.GetClusterHealthStatus()
0000000000000000000000000000000000000000;;		return clusterStatus, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateClusterStatus checks cluster status and get the metrics from cluster's restapi
0000000000000000000000000000000000000000;;	func (cc *ClusterController) UpdateClusterStatus() error {
0000000000000000000000000000000000000000;;		clusters, err := cc.federationClient.Federation().Clusters().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cluster := range clusters.Items {
0000000000000000000000000000000000000000;;			if !cc.knownClusterSet.Has(cluster.Name) {
0000000000000000000000000000000000000000;;				cc.addToClusterSet(&cluster)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there's a difference between lengths of known clusters and observed clusters
0000000000000000000000000000000000000000;;		if len(cc.knownClusterSet) != len(clusters.Items) {
0000000000000000000000000000000000000000;;			observedSet := make(sets.String)
0000000000000000000000000000000000000000;;			for _, cluster := range clusters.Items {
0000000000000000000000000000000000000000;;				observedSet.Insert(cluster.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			deleted := cc.knownClusterSet.Difference(observedSet)
0000000000000000000000000000000000000000;;			for clusterName := range deleted {
0000000000000000000000000000000000000000;;				cc.delFromClusterSetByName(clusterName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cluster := range clusters.Items {
0000000000000000000000000000000000000000;;			clusterStatusNew, err := cc.GetClusterStatus(&cluster)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Infof("Failed to Get the status of cluster: %v", cluster.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clusterStatusOld, found := cc.clusterClusterStatusMap[cluster.Name]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				glog.Infof("There is no status stored for cluster: %v before", cluster.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				hasTransition := false
0000000000000000000000000000000000000000;;				if len(clusterStatusNew.Conditions) != len(clusterStatusOld.Conditions) {
0000000000000000000000000000000000000000;;					hasTransition = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					for i := 0; i < len(clusterStatusNew.Conditions); i++ {
0000000000000000000000000000000000000000;;						if !(strings.EqualFold(string(clusterStatusNew.Conditions[i].Type), string(clusterStatusOld.Conditions[i].Type)) &&
0000000000000000000000000000000000000000;;							strings.EqualFold(string(clusterStatusNew.Conditions[i].Status), string(clusterStatusOld.Conditions[i].Status))) {
0000000000000000000000000000000000000000;;							hasTransition = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !hasTransition {
0000000000000000000000000000000000000000;;					for j := 0; j < len(clusterStatusNew.Conditions); j++ {
0000000000000000000000000000000000000000;;						clusterStatusNew.Conditions[j].LastTransitionTime = clusterStatusOld.Conditions[j].LastTransitionTime
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clusterClient, found := cc.clusterKubeClientMap[cluster.Name]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to get client for cluster %s", cluster.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			zones, region, err := clusterClient.GetClusterZones()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to get zones and region for cluster %s: %v", cluster.Name, err)
0000000000000000000000000000000000000000;;				// Don't return err here, as we want the rest of the status update to proceed.
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				clusterStatusNew.Zones = zones
0000000000000000000000000000000000000000;;				clusterStatusNew.Region = region
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.clusterClusterStatusMap[cluster.Name] = *clusterStatusNew
0000000000000000000000000000000000000000;;			cluster.Status = *clusterStatusNew
0000000000000000000000000000000000000000;;			cluster, err := cc.federationClient.Federation().Clusters().UpdateStatus(&cluster)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to update the status of cluster: %v ,error is : %v", cluster.Name, err)
0000000000000000000000000000000000000000;;				// Don't return err here, as we want to continue processing remaining clusters.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
