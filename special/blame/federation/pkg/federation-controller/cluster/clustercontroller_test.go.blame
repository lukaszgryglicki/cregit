0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6759dd73aec9ff5b9611f3a1cacb87f980b10742;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		federationv1beta1 "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		federationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		controllerutil "k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCluster(clusterName string, serverUrl string) *federationv1beta1.Cluster {
0000000000000000000000000000000000000000;;		cluster := federationv1beta1.Cluster{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: testapi.Federation.GroupVersion().String()},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				UID:  uuid.NewUUID(),
0000000000000000000000000000000000000000;;				Name: clusterName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: federationv1beta1.ClusterSpec{
0000000000000000000000000000000000000000;;				ServerAddressByClientCIDRs: []federationv1beta1.ServerAddressByClientCIDR{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ClientCIDR:    "0.0.0.0/0",
0000000000000000000000000000000000000000;;						ServerAddress: serverUrl,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &cluster
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClusterList(cluster *federationv1beta1.Cluster) *federationv1beta1.ClusterList {
0000000000000000000000000000000000000000;;		clusterList := federationv1beta1.ClusterList{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: testapi.Federation.GroupVersion().String()},
0000000000000000000000000000000000000000;;			ListMeta: metav1.ListMeta{
0000000000000000000000000000000000000000;;				SelfLink: "foobar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Items: []federationv1beta1.Cluster{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterList.Items = append(clusterList.Items, *cluster)
0000000000000000000000000000000000000000;;		return &clusterList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init a fake http handler, simulate a federation apiserver, response the "DELETE" "PUT" "GET" "UPDATE"
0000000000000000000000000000000000000000;;	// when "canBeGotten" is false, means that user can not get the cluster cluster from apiserver
0000000000000000000000000000000000000000;;	func createHttptestFakeHandlerForFederation(clusterList *federationv1beta1.ClusterList, canBeGotten bool) *http.HandlerFunc {
0000000000000000000000000000000000000000;;		fakeHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			clusterListString, _ := json.Marshal(*clusterList)
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			switch r.Method {
0000000000000000000000000000000000000000;;			case "PUT":
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, string(clusterListString))
0000000000000000000000000000000000000000;;			case "GET":
0000000000000000000000000000000000000000;;				if canBeGotten {
0000000000000000000000000000000000000000;;					fmt.Fprintln(w, string(clusterListString))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprintln(w, "")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return &fakeHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init a fake http handler, simulate a cluster apiserver, response the "/healthz"
0000000000000000000000000000000000000000;;	// when "canBeGotten" is false, means that user can not get response from apiserver
0000000000000000000000000000000000000000;;	func createHttptestFakeHandlerForCluster(canBeGotten bool) *http.HandlerFunc {
0000000000000000000000000000000000000000;;		fakeHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			switch r.Method {
0000000000000000000000000000000000000000;;			case "GET":
0000000000000000000000000000000000000000;;				if canBeGotten {
0000000000000000000000000000000000000000;;					fmt.Fprintln(w, "ok")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fmt.Fprintln(w, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return &fakeHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateClusterStatusOK(t *testing.T) {
0000000000000000000000000000000000000000;;		clusterName := "foobarCluster"
0000000000000000000000000000000000000000;;		// create dummy httpserver
0000000000000000000000000000000000000000;;		testClusterServer := httptest.NewServer(createHttptestFakeHandlerForCluster(true))
0000000000000000000000000000000000000000;;		defer testClusterServer.Close()
0000000000000000000000000000000000000000;;		federationCluster := newCluster(clusterName, testClusterServer.URL)
0000000000000000000000000000000000000000;;		federationClusterList := newClusterList(federationCluster)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testFederationServer := httptest.NewServer(createHttptestFakeHandlerForFederation(federationClusterList, true))
0000000000000000000000000000000000000000;;		defer testFederationServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restClientCfg, err := clientcmd.BuildConfigFromFlags(testFederationServer.URL, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to build client config")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		federationClientSet := federationclientset.NewForConfigOrDie(restclient.AddUserAgent(restClientCfg, "cluster-controller"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Override KubeconfigGetterForSecret to avoid having to setup service accounts and mount files with secret tokens.
0000000000000000000000000000000000000000;;		originalGetter := controllerutil.KubeconfigGetterForSecret
0000000000000000000000000000000000000000;;		controllerutil.KubeconfigGetterForSecret = func(s *api.Secret) clientcmd.KubeconfigGetter {
0000000000000000000000000000000000000000;;			return func() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;				return &clientcmdapi.Config{}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manager := newClusterController(federationClientSet, 5)
0000000000000000000000000000000000000000;;		err = manager.UpdateClusterStatus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to Update Cluster Status: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterStatus, found := manager.clusterClusterStatusMap[clusterName]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to Update Cluster Status")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if (clusterStatus.Conditions[1].Status != v1.ConditionFalse) || (clusterStatus.Conditions[1].Type != federationv1beta1.ClusterOffline) {
0000000000000000000000000000000000000000;;				t.Errorf("Failed to Update Cluster Status")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset KubeconfigGetterForSecret
0000000000000000000000000000000000000000;;		controllerutil.KubeconfigGetterForSecret = originalGetter
0000000000000000000000000000000000000000;;	}
