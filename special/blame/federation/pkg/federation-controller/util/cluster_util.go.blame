0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ee40fb51086b3d196e27bf92169c95361716c723;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		federation_v1beta1 "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		KubeAPIQPS              = 20.0
0000000000000000000000000000000000000000;;		KubeAPIBurst            = 30
0000000000000000000000000000000000000000;;		KubeconfigSecretDataKey = "kubeconfig"
0000000000000000000000000000000000000000;;		getSecretTimeout        = 1 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BuildClusterConfig(c *federation_v1beta1.Cluster) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		var serverAddress string
0000000000000000000000000000000000000000;;		var clusterConfig *restclient.Config
0000000000000000000000000000000000000000;;		hostIP, err := utilnet.ChooseHostInterface()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range c.Spec.ServerAddressByClientCIDRs {
0000000000000000000000000000000000000000;;			_, cidrnet, err := net.ParseCIDR(item.ClientCIDR)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			myaddr := net.ParseIP(hostIP.String())
0000000000000000000000000000000000000000;;			if cidrnet.Contains(myaddr) == true {
0000000000000000000000000000000000000000;;				serverAddress = item.ServerAddress
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if serverAddress != "" {
0000000000000000000000000000000000000000;;			if c.Spec.SecretRef == nil {
0000000000000000000000000000000000000000;;				glog.Infof("didn't find secretRef for cluster %s. Trying insecure access", c.Name)
0000000000000000000000000000000000000000;;				clusterConfig, err = clientcmd.BuildConfigFromFlags(serverAddress, "")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if c.Spec.SecretRef.Name == "" {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("found secretRef but no secret name for cluster %s", c.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				secret, err := getSecret(c.Spec.SecretRef.Name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Pre-1.7, the secret contained a serialized kubeconfig which contained appropriate credentials.
0000000000000000000000000000000000000000;;				// Post-1.7, the secret contains credentials for a service account.
0000000000000000000000000000000000000000;;				// Check for the service account credentials, and use them if they exist; if not, use the
0000000000000000000000000000000000000000;;				// serialized kubeconfig.
0000000000000000000000000000000000000000;;				token, tokenFound := secret.Data["token"]
0000000000000000000000000000000000000000;;				ca, caFound := secret.Data["ca.crt"]
0000000000000000000000000000000000000000;;				if tokenFound != caFound {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("secret should have values for either both 'ca.crt' and 'token' in its Data, or neither: %v", secret)
0000000000000000000000000000000000000000;;				} else if tokenFound && caFound {
0000000000000000000000000000000000000000;;					clusterConfig, err = clientcmd.BuildConfigFromFlags(serverAddress, "")
0000000000000000000000000000000000000000;;					clusterConfig.CAData = ca
0000000000000000000000000000000000000000;;					clusterConfig.BearerToken = string(token)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					kubeconfigGetter := KubeconfigGetterForSecret(secret)
0000000000000000000000000000000000000000;;					clusterConfig, err = clientcmd.BuildConfigFromKubeconfigGetter(serverAddress, kubeconfigGetter)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clusterConfig.QPS = KubeAPIQPS
0000000000000000000000000000000000000000;;			clusterConfig.Burst = KubeAPIBurst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clusterConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSecret gets a secret from the cluster.
0000000000000000000000000000000000000000;;	func getSecret(secretName string) (*api.Secret, error) {
0000000000000000000000000000000000000000;;		// Get the namespace this is running in from the env variable.
0000000000000000000000000000000000000000;;		namespace := os.Getenv("POD_NAMESPACE")
0000000000000000000000000000000000000000;;		if namespace == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected: POD_NAMESPACE env var returned empty string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get a client to talk to the k8s apiserver, to fetch secrets from it.
0000000000000000000000000000000000000000;;		cc, err := restclient.InClusterConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error in creating in-cluster config: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := clientset.NewForConfig(cc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error in creating in-cluster client: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var secret *api.Secret
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(1*time.Second, getSecretTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			secret, err = client.Core().Secrets(namespace).Get(secretName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Warningf("error in fetching secret: %s", err)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("timed out waiting for secret: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if secret == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected: received null secret %s", secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return secret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KubeconfigGetterForSecret gets the kubeconfig from the given secret.
0000000000000000000000000000000000000000;;	// This is to inject a different KubeconfigGetter in tests. We don't use
0000000000000000000000000000000000000000;;	// the standard one which calls NewInCluster in tests to avoid having to
0000000000000000000000000000000000000000;;	// set up service accounts and mount files with secret tokens.
0000000000000000000000000000000000000000;;	var KubeconfigGetterForSecret = func(secret *api.Secret) clientcmd.KubeconfigGetter {
0000000000000000000000000000000000000000;;		return func() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;			data, ok := secret.Data[KubeconfigSecretDataKey]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("secret does not have data with key %s", KubeconfigSecretDataKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return clientcmd.Load(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
