0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
641ef3dc5eacb35c227a51dc754df51ce6d0326a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package to help federation controllers to delete federated resources from
0000000000000000000000000000000000000000;;	// underlying clusters when the resource is deleted from federation control
0000000000000000000000000000000000000000;;	// plane.
0000000000000000000000000000000000000000;;	package deletionhelper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		finalizersutil "k8s.io/kubernetes/federation/pkg/federation-controller/util/finalizers"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Add this finalizer to a federation resource if the resource should be
0000000000000000000000000000000000000000;;		// deleted from all underlying clusters before being deleted from
0000000000000000000000000000000000000000;;		// federation control plane.
0000000000000000000000000000000000000000;;		// This is ignored if FinalizerOrphan is also present on the resource.
0000000000000000000000000000000000000000;;		// In that case, both finalizers are removed from the resource and the
0000000000000000000000000000000000000000;;		// resource is deleted from federation control plane without affecting
0000000000000000000000000000000000000000;;		// the underlying clusters.
0000000000000000000000000000000000000000;;		FinalizerDeleteFromUnderlyingClusters string = "federation.kubernetes.io/delete-from-underlying-clusters"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UpdateObjFunc func(runtime.Object) (runtime.Object, error)
0000000000000000000000000000000000000000;;	type ObjNameFunc func(runtime.Object) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeletionHelper struct {
0000000000000000000000000000000000000000;;		updateObjFunc UpdateObjFunc
0000000000000000000000000000000000000000;;		objNameFunc   ObjNameFunc
0000000000000000000000000000000000000000;;		informer      util.FederatedInformer
0000000000000000000000000000000000000000;;		updater       util.FederatedUpdater
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDeletionHelper(
0000000000000000000000000000000000000000;;		updateObjFunc UpdateObjFunc, objNameFunc ObjNameFunc,
0000000000000000000000000000000000000000;;		informer util.FederatedInformer, updater util.FederatedUpdater) *DeletionHelper {
0000000000000000000000000000000000000000;;		return &DeletionHelper{
0000000000000000000000000000000000000000;;			updateObjFunc: updateObjFunc,
0000000000000000000000000000000000000000;;			objNameFunc:   objNameFunc,
0000000000000000000000000000000000000000;;			informer:      informer,
0000000000000000000000000000000000000000;;			updater:       updater,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensures that the given object has both FinalizerDeleteFromUnderlyingClusters
0000000000000000000000000000000000000000;;	// and FinalizerOrphan finalizers.
0000000000000000000000000000000000000000;;	// We do this so that the controller is always notified when a federation resource is deleted.
0000000000000000000000000000000000000000;;	// If user deletes the resource with nil DeleteOptions or
0000000000000000000000000000000000000000;;	// DeletionOptions.OrphanDependents = true then the apiserver removes the orphan finalizer
0000000000000000000000000000000000000000;;	// and deletion helper does a cascading deletion.
0000000000000000000000000000000000000000;;	// Otherwise, deletion helper just removes the federation resource and orphans
0000000000000000000000000000000000000000;;	// the corresponding resources in underlying clusters.
0000000000000000000000000000000000000000;;	// This method should be called before creating objects in underlying clusters.
0000000000000000000000000000000000000000;;	func (dh *DeletionHelper) EnsureFinalizers(obj runtime.Object) (
0000000000000000000000000000000000000000;;		runtime.Object, error) {
0000000000000000000000000000000000000000;;		finalizers := sets.String{}
0000000000000000000000000000000000000000;;		hasFinalizer, err := finalizersutil.HasFinalizer(obj, FinalizerDeleteFromUnderlyingClusters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return obj, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasFinalizer {
0000000000000000000000000000000000000000;;			finalizers.Insert(FinalizerDeleteFromUnderlyingClusters)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hasFinalizer, err = finalizersutil.HasFinalizer(obj, metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return obj, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasFinalizer {
0000000000000000000000000000000000000000;;			finalizers.Insert(metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if finalizers.Len() != 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Adding finalizers %v to %s", finalizers.List(), dh.objNameFunc(obj))
0000000000000000000000000000000000000000;;			return dh.addFinalizers(obj, finalizers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes the resources corresponding to the given federated resource from
0000000000000000000000000000000000000000;;	// all underlying clusters, unless it has the FinalizerOrphan finalizer.
0000000000000000000000000000000000000000;;	// Removes FinalizerOrphan and FinalizerDeleteFromUnderlyingClusters finalizers
0000000000000000000000000000000000000000;;	// when done.
0000000000000000000000000000000000000000;;	// Callers are expected to keep calling this (with appropriate backoff) until
0000000000000000000000000000000000000000;;	// it succeeds.
0000000000000000000000000000000000000000;;	func (dh *DeletionHelper) HandleObjectInUnderlyingClusters(obj runtime.Object) (
0000000000000000000000000000000000000000;;		runtime.Object, error) {
0000000000000000000000000000000000000000;;		objName := dh.objNameFunc(obj)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Handling deletion of federated dependents for object: %s", objName)
0000000000000000000000000000000000000000;;		hasFinalizer, err := finalizersutil.HasFinalizer(obj, FinalizerDeleteFromUnderlyingClusters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return obj, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasFinalizer {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("obj does not have %s finalizer. Nothing to do", FinalizerDeleteFromUnderlyingClusters)
0000000000000000000000000000000000000000;;			return obj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hasOrphanFinalizer, err := finalizersutil.HasFinalizer(obj, metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return obj, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasOrphanFinalizer {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Found finalizer orphan. Nothing to do, just remove the finalizer")
0000000000000000000000000000000000000000;;			// If the obj has FinalizerOrphan finalizer, then we need to orphan the
0000000000000000000000000000000000000000;;			// corresponding objects in underlying clusters.
0000000000000000000000000000000000000000;;			// Just remove both the finalizers in that case.
0000000000000000000000000000000000000000;;			finalizers := sets.NewString(FinalizerDeleteFromUnderlyingClusters, metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;			return dh.removeFinalizers(obj, finalizers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Deleting obj %s from underlying clusters", objName)
0000000000000000000000000000000000000000;;		// Else, we need to delete the obj from all underlying clusters.
0000000000000000000000000000000000000000;;		unreadyClusters, err := dh.informer.GetUnreadyClusters()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get a list of unready clusters: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Handle the case when cluster resource is watched after this is executed.
0000000000000000000000000000000000000000;;		// This can happen if a namespace is deleted before its creation had been
0000000000000000000000000000000000000000;;		// observed in all underlying clusters.
0000000000000000000000000000000000000000;;		storeKey := dh.informer.GetTargetStore().GetKeyFor(obj)
0000000000000000000000000000000000000000;;		clusterNsObjs, err := dh.informer.GetTargetStore().GetFromAllClusters(storeKey)
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Found %d objects in underlying clusters", len(clusterNsObjs))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get object %s from underlying clusters: %v", objName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operations := make([]util.FederatedOperation, 0)
0000000000000000000000000000000000000000;;		for _, clusterNsObj := range clusterNsObjs {
0000000000000000000000000000000000000000;;			operations = append(operations, util.FederatedOperation{
0000000000000000000000000000000000000000;;				Type:        util.OperationTypeDelete,
0000000000000000000000000000000000000000;;				ClusterName: clusterNsObj.ClusterName,
0000000000000000000000000000000000000000;;				Obj:         clusterNsObj.Object.(runtime.Object),
0000000000000000000000000000000000000000;;				Key:         objName,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = dh.updater.Update(operations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to execute updates for obj %s: %v", objName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(operations) > 0 {
0000000000000000000000000000000000000000;;			// We have deleted a bunch of resources.
0000000000000000000000000000000000000000;;			// Wait for the store to observe all the deletions.
0000000000000000000000000000000000000000;;			var clusterNames []string
0000000000000000000000000000000000000000;;			for _, op := range operations {
0000000000000000000000000000000000000000;;				clusterNames = append(clusterNames, op.ClusterName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("waiting for object %s to be deleted from clusters: %s", objName, strings.Join(clusterNames, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have now deleted the object from all *ready* clusters.
0000000000000000000000000000000000000000;;		// But still need to wait for clusters that are not ready to ensure that
0000000000000000000000000000000000000000;;		// the object has been deleted from *all* clusters.
0000000000000000000000000000000000000000;;		if len(unreadyClusters) != 0 {
0000000000000000000000000000000000000000;;			var clusterNames []string
0000000000000000000000000000000000000000;;			for _, cluster := range unreadyClusters {
0000000000000000000000000000000000000000;;				clusterNames = append(clusterNames, cluster.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("waiting for clusters %s to become ready to verify that obj %s has been deleted", strings.Join(clusterNames, ", "), objName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All done. Just remove the finalizer.
0000000000000000000000000000000000000000;;		return dh.removeFinalizers(obj, sets.NewString(FinalizerDeleteFromUnderlyingClusters))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds the given finalizers to the given objects ObjectMeta.
0000000000000000000000000000000000000000;;	func (dh *DeletionHelper) addFinalizers(obj runtime.Object, finalizers sets.String) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		isUpdated, err := finalizersutil.AddFinalizers(obj, finalizers)
0000000000000000000000000000000000000000;;		if err != nil || !isUpdated {
0000000000000000000000000000000000000000;;			return obj, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Send the update to apiserver.
0000000000000000000000000000000000000000;;		updatedObj, err := dh.updateObjFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to add finalizers %v to object %s: %v", finalizers, dh.objNameFunc(obj), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedObj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes the given finalizers from the given objects ObjectMeta.
0000000000000000000000000000000000000000;;	func (dh *DeletionHelper) removeFinalizers(obj runtime.Object, finalizers sets.String) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		isUpdated, err := finalizersutil.RemoveFinalizers(obj, finalizers)
0000000000000000000000000000000000000000;;		if err != nil || !isUpdated {
0000000000000000000000000000000000000000;;			return obj, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Send the update to apiserver.
0000000000000000000000000000000000000000;;		updatedObj, err := dh.updateObjFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to remove finalizers %v from object %s: %v", finalizers, dh.objNameFunc(obj), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updatedObj, nil
0000000000000000000000000000000000000000;;	}
