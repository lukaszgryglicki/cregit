0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
eef5fecefa78385e3336ae091dccecdceeeacc37;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		fakefederationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset/fake"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		fakekubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Basic test for Federated Informer. Checks whether the subinformer are added and deleted
0000000000000000000000000000000000000000;;	// when the corresponding cluster entries appear and disappear from etcd.
0000000000000000000000000000000000000000;;	func TestFederatedInformer(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeFederationClient := &fakefederationclientset.Clientset{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add a single cluster to federation and remove it when needed.
0000000000000000000000000000000000000000;;		cluster := federationapi.Cluster{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "mycluster",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: federationapi.ClusterStatus{
0000000000000000000000000000000000000000;;				Conditions: []federationapi.ClusterCondition{
0000000000000000000000000000000000000000;;					{Type: federationapi.ClusterReady, Status: apiv1.ConditionTrue},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeFederationClient.AddReactor("list", "clusters", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, &federationapi.ClusterList{Items: []federationapi.Cluster{cluster}}, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		deleteChan := make(chan struct{})
0000000000000000000000000000000000000000;;		fakeFederationClient.AddWatchReactor("clusters", func(action core.Action) (bool, watch.Interface, error) {
0000000000000000000000000000000000000000;;			fakeWatch := watch.NewFake()
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				<-deleteChan
0000000000000000000000000000000000000000;;				fakeWatch.Delete(&cluster)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			return true, fakeWatch, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeKubeClient := &fakekubeclientset.Clientset{}
0000000000000000000000000000000000000000;;		// There is a single service ns1/s1 in cluster mycluster.
0000000000000000000000000000000000000000;;		service := apiv1.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "ns1",
0000000000000000000000000000000000000000;;				Name:      "s1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeKubeClient.AddReactor("list", "services", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, &apiv1.ServiceList{Items: []apiv1.Service{service}}, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fakeKubeClient.AddWatchReactor("services", func(action core.Action) (bool, watch.Interface, error) {
0000000000000000000000000000000000000000;;			return true, watch.NewFake(), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		targetInformerFactory := func(cluster *federationapi.Cluster, clientset kubeclientset.Interface) (cache.Store, cache.Controller) {
0000000000000000000000000000000000000000;;			return cache.NewInformer(
0000000000000000000000000000000000000000;;				&cache.ListWatch{
0000000000000000000000000000000000000000;;					ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;						return clientset.Core().Services(metav1.NamespaceAll).List(options)
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;						return clientset.Core().Services(metav1.NamespaceAll).Watch(options)
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&apiv1.Service{},
0000000000000000000000000000000000000000;;				10*time.Second,
0000000000000000000000000000000000000000;;				cache.ResourceEventHandlerFuncs{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addedClusters := make(chan string, 1)
0000000000000000000000000000000000000000;;		deletedClusters := make(chan string, 1)
0000000000000000000000000000000000000000;;		lifecycle := ClusterLifecycleHandlerFuncs{
0000000000000000000000000000000000000000;;			ClusterAvailable: func(cluster *federationapi.Cluster) {
0000000000000000000000000000000000000000;;				addedClusters <- cluster.Name
0000000000000000000000000000000000000000;;				close(addedClusters)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ClusterUnavailable: func(cluster *federationapi.Cluster, _ []interface{}) {
0000000000000000000000000000000000000000;;				deletedClusters <- cluster.Name
0000000000000000000000000000000000000000;;				close(deletedClusters)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informer := NewFederatedInformer(fakeFederationClient, targetInformerFactory, &lifecycle).(*federatedInformerImpl)
0000000000000000000000000000000000000000;;		informer.clientFactory = func(cluster *federationapi.Cluster) (kubeclientset.Interface, error) {
0000000000000000000000000000000000000000;;			return fakeKubeClient, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		assert.NotNil(t, informer)
0000000000000000000000000000000000000000;;		informer.Start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait until mycluster is synced.
0000000000000000000000000000000000000000;;		for !informer.GetTargetStore().ClustersSynced([]*federationapi.Cluster{&cluster}) {
0000000000000000000000000000000000000000;;			time.Sleep(time.Millisecond * 100)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readyClusters, err := informer.GetReadyClusters()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Contains(t, readyClusters, &cluster)
0000000000000000000000000000000000000000;;		serviceList, err := informer.GetTargetStore().List()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		federatedService := FederatedObject{ClusterName: "mycluster", Object: &service}
0000000000000000000000000000000000000000;;		assert.Contains(t, serviceList, federatedService)
0000000000000000000000000000000000000000;;		service1, found, err := informer.GetTargetStore().GetByKey("mycluster", "ns1/s1")
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.True(t, found)
0000000000000000000000000000000000000000;;		assert.EqualValues(t, &service, service1)
0000000000000000000000000000000000000000;;		assert.Equal(t, "mycluster", <-addedClusters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All checked, lets delete the cluster.
0000000000000000000000000000000000000000;;		deleteChan <- struct{}{}
0000000000000000000000000000000000000000;;		for !informer.GetTargetStore().ClustersSynced([]*federationapi.Cluster{}) {
0000000000000000000000000000000000000000;;			time.Sleep(time.Millisecond * 100)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readyClusters, err = informer.GetReadyClusters()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Empty(t, readyClusters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceList, err = informer.GetTargetStore().List()
0000000000000000000000000000000000000000;;		assert.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Empty(t, serviceList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Equal(t, "mycluster", <-deletedClusters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test complete.
0000000000000000000000000000000000000000;;		informer.Stop()
0000000000000000000000000000000000000000;;	}
