0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bb1d3bda29e0df7a00ac33a5986e8555fdc0bbfa;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type of the operation that can be executed in Federated.
0000000000000000000000000000000000000000;;	type FederatedOperationType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		OperationTypeAdd    = "add"
0000000000000000000000000000000000000000;;		OperationTypeUpdate = "update"
0000000000000000000000000000000000000000;;		OperationTypeDelete = "delete"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederatedOperation definition contains type (add/update/delete) and the object itself.
0000000000000000000000000000000000000000;;	type FederatedOperation struct {
0000000000000000000000000000000000000000;;		Type        FederatedOperationType
0000000000000000000000000000000000000000;;		ClusterName string
0000000000000000000000000000000000000000;;		Obj         pkgruntime.Object
0000000000000000000000000000000000000000;;		Key         string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A helper that executes the given set of updates on federation, in parallel.
0000000000000000000000000000000000000000;;	type FederatedUpdater interface {
0000000000000000000000000000000000000000;;		// Executes the given set of operations.
0000000000000000000000000000000000000000;;		Update([]FederatedOperation) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A function that executes some operation using the passed client and object.
0000000000000000000000000000000000000000;;	type FederatedOperationHandler func(kubeclientset.Interface, pkgruntime.Object) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type federatedUpdaterImpl struct {
0000000000000000000000000000000000000000;;		federation FederationView
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kind string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventRecorder record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addFunction    FederatedOperationHandler
0000000000000000000000000000000000000000;;		updateFunction FederatedOperationHandler
0000000000000000000000000000000000000000;;		deleteFunction FederatedOperationHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFederatedUpdater(federation FederationView, kind string, timeout time.Duration, recorder record.EventRecorder, add, update, del FederatedOperationHandler) FederatedUpdater {
0000000000000000000000000000000000000000;;		return &federatedUpdaterImpl{
0000000000000000000000000000000000000000;;			federation:     federation,
0000000000000000000000000000000000000000;;			kind:           kind,
0000000000000000000000000000000000000000;;			timeout:        timeout,
0000000000000000000000000000000000000000;;			eventRecorder:  recorder,
0000000000000000000000000000000000000000;;			addFunction:    add,
0000000000000000000000000000000000000000;;			updateFunction: update,
0000000000000000000000000000000000000000;;			deleteFunction: del,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fu *federatedUpdaterImpl) recordEvent(obj runtime.Object, eventType, eventVerb string, args ...interface{}) {
0000000000000000000000000000000000000000;;		messageFmt := eventVerb + " %s %q in cluster %s"
0000000000000000000000000000000000000000;;		fu.eventRecorder.Eventf(obj, api.EventTypeNormal, eventType, messageFmt, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update executes the given set of operations within the timeout specified for
0000000000000000000000000000000000000000;;	// the instance. Timeout is best-effort. There is no guarantee that the
0000000000000000000000000000000000000000;;	// underlying operations are stopped when it is reached. However the function
0000000000000000000000000000000000000000;;	// will return after the timeout with a non-nil error.
0000000000000000000000000000000000000000;;	func (fu *federatedUpdaterImpl) Update(ops []FederatedOperation) error {
0000000000000000000000000000000000000000;;		done := make(chan error, len(ops))
0000000000000000000000000000000000000000;;		for _, op := range ops {
0000000000000000000000000000000000000000;;			go func(op FederatedOperation) {
0000000000000000000000000000000000000000;;				clusterName := op.ClusterName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: Ensure that the clientset has reasonable timeout.
0000000000000000000000000000000000000000;;				clientset, err := fu.federation.GetClientsetForCluster(clusterName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					done <- err
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				eventArgs := []interface{}{fu.kind, op.Key, clusterName}
0000000000000000000000000000000000000000;;				baseEventType := fmt.Sprintf("%s", op.Type)
0000000000000000000000000000000000000000;;				eventType := fmt.Sprintf("%sInCluster", strings.Title(baseEventType))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				switch op.Type {
0000000000000000000000000000000000000000;;				case OperationTypeAdd:
0000000000000000000000000000000000000000;;					// TODO s+OperationTypeAdd+OperationTypeCreate+
0000000000000000000000000000000000000000;;					baseEventType = "create"
0000000000000000000000000000000000000000;;					eventType := "CreateInCluster"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					fu.recordEvent(op.Obj, eventType, "Creating", eventArgs...)
0000000000000000000000000000000000000000;;					err = fu.addFunction(clientset, op.Obj)
0000000000000000000000000000000000000000;;				case OperationTypeUpdate:
0000000000000000000000000000000000000000;;					fu.recordEvent(op.Obj, eventType, "Updating", eventArgs...)
0000000000000000000000000000000000000000;;					err = fu.updateFunction(clientset, op.Obj)
0000000000000000000000000000000000000000;;				case OperationTypeDelete:
0000000000000000000000000000000000000000;;					fu.recordEvent(op.Obj, eventType, "Deleting", eventArgs...)
0000000000000000000000000000000000000000;;					err = fu.deleteFunction(clientset, op.Obj)
0000000000000000000000000000000000000000;;					// IsNotFound error is fine since that means the object is deleted already.
0000000000000000000000000000000000000000;;					if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;						err = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					eventType := eventType + "Failed"
0000000000000000000000000000000000000000;;					messageFmt := "Failed to " + baseEventType + " %s %q in cluster %s: %v"
0000000000000000000000000000000000000000;;					eventArgs = append(eventArgs, err)
0000000000000000000000000000000000000000;;					fu.eventRecorder.Eventf(op.Obj, api.EventTypeWarning, eventType, messageFmt, eventArgs...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				done <- err
0000000000000000000000000000000000000000;;			}(op)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		for i := 0; i < len(ops); i++ {
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			if !now.Before(start.Add(fu.timeout)) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to finish all operations in %v", fu.timeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case err := <-done:
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(start.Add(fu.timeout).Sub(now)):
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to finish all operations in %v", fu.timeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// All operations finished in time.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
