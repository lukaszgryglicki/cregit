0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7af426d0f396f6aac91df545bf5b86a3240d5219;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime/pprof"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		finalizersutil "k8s.io/kubernetes/federation/pkg/federation-controller/util/finalizers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		pushTimeout = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A structure that distributes events to multiple watchers.
0000000000000000000000000000000000000000;;	type WatcherDispatcher struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		watchers       []*watch.RaceFreeFakeWatcher
0000000000000000000000000000000000000000;;		eventsSoFar    []*watch.Event
0000000000000000000000000000000000000000;;		orderExecution chan func()
0000000000000000000000000000000000000000;;		stopChan       chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wd *WatcherDispatcher) register(watcher *watch.RaceFreeFakeWatcher) {
0000000000000000000000000000000000000000;;		wd.Lock()
0000000000000000000000000000000000000000;;		defer wd.Unlock()
0000000000000000000000000000000000000000;;		wd.watchers = append(wd.watchers, watcher)
0000000000000000000000000000000000000000;;		for _, event := range wd.eventsSoFar {
0000000000000000000000000000000000000000;;			watcher.Action(event.Type, event.Object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wd *WatcherDispatcher) Stop() {
0000000000000000000000000000000000000000;;		wd.Lock()
0000000000000000000000000000000000000000;;		defer wd.Unlock()
0000000000000000000000000000000000000000;;		close(wd.stopChan)
0000000000000000000000000000000000000000;;		glog.Infof("Stopping WatcherDispatcher")
0000000000000000000000000000000000000000;;		for _, watcher := range wd.watchers {
0000000000000000000000000000000000000000;;			watcher.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copy(obj runtime.Object) runtime.Object {
0000000000000000000000000000000000000000;;		objCopy, err := api.Scheme.DeepCopy(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return objCopy.(runtime.Object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add sends an add event.
0000000000000000000000000000000000000000;;	func (wd *WatcherDispatcher) Add(obj runtime.Object) {
0000000000000000000000000000000000000000;;		wd.Lock()
0000000000000000000000000000000000000000;;		defer wd.Unlock()
0000000000000000000000000000000000000000;;		wd.eventsSoFar = append(wd.eventsSoFar, &watch.Event{Type: watch.Added, Object: copy(obj)})
0000000000000000000000000000000000000000;;		for _, watcher := range wd.watchers {
0000000000000000000000000000000000000000;;			if !watcher.IsStopped() {
0000000000000000000000000000000000000000;;				watcher.Add(copy(obj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Modify sends a modify event.
0000000000000000000000000000000000000000;;	func (wd *WatcherDispatcher) Modify(obj runtime.Object) {
0000000000000000000000000000000000000000;;		wd.Lock()
0000000000000000000000000000000000000000;;		defer wd.Unlock()
0000000000000000000000000000000000000000;;		glog.V(4).Infof("->WatcherDispatcher.Modify(%v)", obj)
0000000000000000000000000000000000000000;;		wd.eventsSoFar = append(wd.eventsSoFar, &watch.Event{Type: watch.Modified, Object: copy(obj)})
0000000000000000000000000000000000000000;;		for i, watcher := range wd.watchers {
0000000000000000000000000000000000000000;;			if !watcher.IsStopped() {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("->Watcher(%d).Modify(%v)", i, obj)
0000000000000000000000000000000000000000;;				watcher.Modify(copy(obj))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("->Watcher(%d) is stopped.  Not calling Modify(%v)", i, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete sends a delete event.
0000000000000000000000000000000000000000;;	func (wd *WatcherDispatcher) Delete(lastValue runtime.Object) {
0000000000000000000000000000000000000000;;		wd.Lock()
0000000000000000000000000000000000000000;;		defer wd.Unlock()
0000000000000000000000000000000000000000;;		wd.eventsSoFar = append(wd.eventsSoFar, &watch.Event{Type: watch.Deleted, Object: copy(lastValue)})
0000000000000000000000000000000000000000;;		for _, watcher := range wd.watchers {
0000000000000000000000000000000000000000;;			if !watcher.IsStopped() {
0000000000000000000000000000000000000000;;				watcher.Delete(copy(lastValue))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error sends an Error event.
0000000000000000000000000000000000000000;;	func (wd *WatcherDispatcher) Error(errValue runtime.Object) {
0000000000000000000000000000000000000000;;		wd.Lock()
0000000000000000000000000000000000000000;;		defer wd.Unlock()
0000000000000000000000000000000000000000;;		wd.eventsSoFar = append(wd.eventsSoFar, &watch.Event{Type: watch.Error, Object: copy(errValue)})
0000000000000000000000000000000000000000;;		for _, watcher := range wd.watchers {
0000000000000000000000000000000000000000;;			if !watcher.IsStopped() {
0000000000000000000000000000000000000000;;				watcher.Error(copy(errValue))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Action sends an event of the requested type, for table-based testing.
0000000000000000000000000000000000000000;;	func (wd *WatcherDispatcher) Action(action watch.EventType, obj runtime.Object) {
0000000000000000000000000000000000000000;;		wd.Lock()
0000000000000000000000000000000000000000;;		defer wd.Unlock()
0000000000000000000000000000000000000000;;		wd.eventsSoFar = append(wd.eventsSoFar, &watch.Event{Type: action, Object: copy(obj)})
0000000000000000000000000000000000000000;;		for _, watcher := range wd.watchers {
0000000000000000000000000000000000000000;;			if !watcher.IsStopped() {
0000000000000000000000000000000000000000;;				watcher.Action(action, copy(obj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFakeWatch adds a new fake watcher for the specified resource in the given fake client.
0000000000000000000000000000000000000000;;	// All subsequent requests for a watch on the client will result in returning this fake watcher.
0000000000000000000000000000000000000000;;	func RegisterFakeWatch(resource string, client *core.Fake) *WatcherDispatcher {
0000000000000000000000000000000000000000;;		dispatcher := &WatcherDispatcher{
0000000000000000000000000000000000000000;;			watchers:       make([]*watch.RaceFreeFakeWatcher, 0),
0000000000000000000000000000000000000000;;			eventsSoFar:    make([]*watch.Event, 0),
0000000000000000000000000000000000000000;;			orderExecution: make(chan func(), 100),
0000000000000000000000000000000000000000;;			stopChan:       make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case fun := <-dispatcher.orderExecution:
0000000000000000000000000000000000000000;;					fun()
0000000000000000000000000000000000000000;;				case <-dispatcher.stopChan:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.AddWatchReactor(resource, func(action core.Action) (bool, watch.Interface, error) {
0000000000000000000000000000000000000000;;			watcher := watch.NewRaceFreeFake()
0000000000000000000000000000000000000000;;			dispatcher.register(watcher)
0000000000000000000000000000000000000000;;			return true, watcher, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return dispatcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFakeList registers a list response for the specified resource inside the given fake client.
0000000000000000000000000000000000000000;;	// The passed value will be returned with every list call.
0000000000000000000000000000000000000000;;	func RegisterFakeList(resource string, client *core.Fake, obj runtime.Object) {
0000000000000000000000000000000000000000;;		client.AddReactor("list", resource, func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFakeClusterGet registers a get response for the cluster resource inside the given fake client.
0000000000000000000000000000000000000000;;	func RegisterFakeClusterGet(client *core.Fake, obj runtime.Object) {
0000000000000000000000000000000000000000;;		clusterList, ok := obj.(*federationapi.ClusterList)
0000000000000000000000000000000000000000;;		client.AddReactor("get", "clusters", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			name := action.(core.GetAction).GetName()
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				for _, cluster := range clusterList.Items {
0000000000000000000000000000000000000000;;					if cluster.Name == name {
0000000000000000000000000000000000000000;;						return true, &cluster, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil, fmt.Errorf("could not find the requested cluster: %s", name)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFakeOnCreate registers a reactor in the given fake client that passes
0000000000000000000000000000000000000000;;	// all created objects to the given watcher.
0000000000000000000000000000000000000000;;	func RegisterFakeOnCreate(resource string, client *core.Fake, watcher *WatcherDispatcher) {
0000000000000000000000000000000000000000;;		client.AddReactor("create", resource, func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			createAction := action.(core.CreateAction)
0000000000000000000000000000000000000000;;			originalObj := createAction.GetObject()
0000000000000000000000000000000000000000;;			// Create a copy of the object here to prevent data races while reading the object in go routine.
0000000000000000000000000000000000000000;;			obj := copy(originalObj)
0000000000000000000000000000000000000000;;			watcher.orderExecution <- func() {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Object created: %v", obj)
0000000000000000000000000000000000000000;;				watcher.Add(obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, originalObj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFakeCopyOnCreate registers a reactor in the given fake client that passes
0000000000000000000000000000000000000000;;	// all created objects to the given watcher and also copies them to a channel for
0000000000000000000000000000000000000000;;	// in-test inspection.
0000000000000000000000000000000000000000;;	func RegisterFakeCopyOnCreate(resource string, client *core.Fake, watcher *WatcherDispatcher) chan runtime.Object {
0000000000000000000000000000000000000000;;		objChan := make(chan runtime.Object, 100)
0000000000000000000000000000000000000000;;		client.AddReactor("create", resource, func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			createAction := action.(core.CreateAction)
0000000000000000000000000000000000000000;;			originalObj := createAction.GetObject()
0000000000000000000000000000000000000000;;			// Create a copy of the object here to prevent data races while reading the object in go routine.
0000000000000000000000000000000000000000;;			obj := copy(originalObj)
0000000000000000000000000000000000000000;;			watcher.orderExecution <- func() {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Object created. Writing to channel: %v", obj)
0000000000000000000000000000000000000000;;				watcher.Add(obj)
0000000000000000000000000000000000000000;;				objChan <- obj
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, originalObj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return objChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFakeOnUpdate registers a reactor in the given fake client that passes
0000000000000000000000000000000000000000;;	// all updated objects to the given watcher.
0000000000000000000000000000000000000000;;	func RegisterFakeOnUpdate(resource string, client *core.Fake, watcher *WatcherDispatcher) {
0000000000000000000000000000000000000000;;		client.AddReactor("update", resource, func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			updateAction := action.(core.UpdateAction)
0000000000000000000000000000000000000000;;			originalObj := updateAction.GetObject()
0000000000000000000000000000000000000000;;			glog.V(7).Infof("Updating %s: %v", resource, updateAction.GetObject())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a copy of the object here to prevent data races while reading the object in go routine.
0000000000000000000000000000000000000000;;			obj := copy(originalObj)
0000000000000000000000000000000000000000;;			operation := func() {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Object updated %v", obj)
0000000000000000000000000000000000000000;;				watcher.Modify(obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case watcher.orderExecution <- operation:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case <-time.After(pushTimeout):
0000000000000000000000000000000000000000;;				glog.Errorf("Fake client execution channel blocked")
0000000000000000000000000000000000000000;;				glog.Errorf("Tried to push %v", updateAction)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, originalObj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFakeCopyOnUpdate registers a reactor in the given fake client that passes
0000000000000000000000000000000000000000;;	// all updated objects to the given watcher and also copies them to a channel for
0000000000000000000000000000000000000000;;	// in-test inspection.
0000000000000000000000000000000000000000;;	func RegisterFakeCopyOnUpdate(resource string, client *core.Fake, watcher *WatcherDispatcher) chan runtime.Object {
0000000000000000000000000000000000000000;;		objChan := make(chan runtime.Object, 100)
0000000000000000000000000000000000000000;;		client.AddReactor("update", resource, func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			updateAction := action.(core.UpdateAction)
0000000000000000000000000000000000000000;;			originalObj := updateAction.GetObject()
0000000000000000000000000000000000000000;;			glog.V(7).Infof("Updating %s: %v", resource, updateAction.GetObject())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a copy of the object here to prevent data races while reading the object in go routine.
0000000000000000000000000000000000000000;;			obj := copy(originalObj)
0000000000000000000000000000000000000000;;			operation := func() {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Object updated. Writing to channel: %v", obj)
0000000000000000000000000000000000000000;;				watcher.Modify(obj)
0000000000000000000000000000000000000000;;				objChan <- obj
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case watcher.orderExecution <- operation:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case <-time.After(pushTimeout):
0000000000000000000000000000000000000000;;				glog.Errorf("Fake client execution channel blocked")
0000000000000000000000000000000000000000;;				glog.Errorf("Tried to push %v", updateAction)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, originalObj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return objChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFakeOnDelete registers a reactor in the given fake client that passes
0000000000000000000000000000000000000000;;	// all deleted objects to the given watcher. Since we could get only name of the
0000000000000000000000000000000000000000;;	// deleted object from DeleteAction, this register function relies on the getObject
0000000000000000000000000000000000000000;;	// function passed to get the object by name and pass it watcher.
0000000000000000000000000000000000000000;;	func RegisterFakeOnDelete(resource string, client *core.Fake, watcher *WatcherDispatcher, getObject func(name, namespace string) runtime.Object) {
0000000000000000000000000000000000000000;;		client.AddReactor("delete", resource, func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			deleteAction := action.(core.DeleteAction)
0000000000000000000000000000000000000000;;			obj := getObject(deleteAction.GetName(), deleteAction.GetNamespace())
0000000000000000000000000000000000000000;;			glog.V(7).Infof("Deleting %s: %v", resource, obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			operation := func() {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Object deleted %v", obj)
0000000000000000000000000000000000000000;;				watcher.Delete(obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case watcher.orderExecution <- operation:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case <-time.After(pushTimeout):
0000000000000000000000000000000000000000;;				glog.Errorf("Fake client execution channel blocked")
0000000000000000000000000000000000000000;;				glog.Errorf("Tried to push %v", deleteAction)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, obj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds an update reactor to the given fake client.
0000000000000000000000000000000000000000;;	// The reactor just returns the object passed to update action.
0000000000000000000000000000000000000000;;	// This is used as a hack to workaround https://github.com/kubernetes/kubernetes/issues/40939.
0000000000000000000000000000000000000000;;	// Without this, all update actions using fake client return empty objects.
0000000000000000000000000000000000000000;;	func AddFakeUpdateReactor(resource string, client *core.Fake) {
0000000000000000000000000000000000000000;;		client.AddReactor("update", resource, func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			updateAction := action.(core.UpdateAction)
0000000000000000000000000000000000000000;;			originalObj := updateAction.GetObject()
0000000000000000000000000000000000000000;;			return true, originalObj, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetObjectFromChan tries to get an api object from the given channel
0000000000000000000000000000000000000000;;	// within a reasonable time.
0000000000000000000000000000000000000000;;	func GetObjectFromChan(c chan runtime.Object) runtime.Object {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case obj := <-c:
0000000000000000000000000000000000000000;;			return obj
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			pprof.Lookup("goroutine").WriteTo(os.Stderr, 1)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CheckingFunction func(runtime.Object) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckObjectFromChan tries to get an object matching the given check function
0000000000000000000000000000000000000000;;	// within a reasonable time.
0000000000000000000000000000000000000000;;	func CheckObjectFromChan(c chan runtime.Object, checkFunction CheckingFunction) error {
0000000000000000000000000000000000000000;;		delay := 20 * time.Second
0000000000000000000000000000000000000000;;		var lastError error
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case obj := <-c:
0000000000000000000000000000000000000000;;				if lastError = checkFunction(obj); lastError == nil {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Infof("Check function failed with %v", lastError)
0000000000000000000000000000000000000000;;				delay = 5 * time.Second
0000000000000000000000000000000000000000;;			case <-time.After(delay):
0000000000000000000000000000000000000000;;				pprof.Lookup("goroutine").WriteTo(os.Stderr, 1)
0000000000000000000000000000000000000000;;				if lastError == nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Failed to get an object from channel")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return lastError
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompareObjectMeta returns an error when the given objects are not equivalent.
0000000000000000000000000000000000000000;;	func CompareObjectMeta(a, b metav1.ObjectMeta) error {
0000000000000000000000000000000000000000;;		if a.Namespace != b.Namespace {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Different namespace expected:%s observed:%s", a.Namespace, b.Namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.Name != b.Name {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Different name expected:%s observed:%s", a.Name, b.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(a.Labels, b.Labels) && (len(a.Labels) != 0 || len(b.Labels) != 0) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Labels are different expected:%v observed:%v", a.Labels, b.Labels)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(a.Annotations, b.Annotations) && (len(a.Annotations) != 0 || len(b.Annotations) != 0) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Annotations are different expected:%v observed:%v", a.Annotations, b.Annotations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ToFederatedInformerForTestOnly(informer util.FederatedInformer) util.FederatedInformerForTestOnly {
0000000000000000000000000000000000000000;;		inter := informer.(interface{})
0000000000000000000000000000000000000000;;		return inter.(util.FederatedInformerForTestOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCluster builds a new cluster object.
0000000000000000000000000000000000000000;;	func NewCluster(name string, readyStatus apiv1.ConditionStatus) *federationapi.Cluster {
0000000000000000000000000000000000000000;;		return &federationapi.Cluster{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:        name,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{},
0000000000000000000000000000000000000000;;				Labels:      map[string]string{"cluster": name},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: federationapi.ClusterStatus{
0000000000000000000000000000000000000000;;				Conditions: []federationapi.ClusterCondition{
0000000000000000000000000000000000000000;;					{Type: federationapi.ClusterReady, Status: readyStatus},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Zones:  []string{"foozone"},
0000000000000000000000000000000000000000;;				Region: "fooregion",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure a key is in the store before returning (or timeout w/ error)
0000000000000000000000000000000000000000;;	func WaitForStoreUpdate(store util.FederatedReadOnlyStore, clusterName, key string, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		retryInterval := 100 * time.Millisecond
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, found, err := store.GetByKey(clusterName, key)
0000000000000000000000000000000000000000;;			return found, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure a key is in the store before returning (or timeout w/ error)
0000000000000000000000000000000000000000;;	func WaitForStoreUpdateChecking(store util.FederatedReadOnlyStore, clusterName, key string, timeout time.Duration,
0000000000000000000000000000000000000000;;		checkFunction CheckingFunction) error {
0000000000000000000000000000000000000000;;		retryInterval := 500 * time.Millisecond
0000000000000000000000000000000000000000;;		var lastError error
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(retryInterval, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			item, found, err := store.GetByKey(clusterName, key)
0000000000000000000000000000000000000000;;			if err != nil || !found {
0000000000000000000000000000000000000000;;				return found, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			runtimeObj := item.(runtime.Object)
0000000000000000000000000000000000000000;;			lastError = checkFunction(runtimeObj)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Check function failed for %s %v %v", key, runtimeObj, lastError)
0000000000000000000000000000000000000000;;			return lastError == nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MetaAndSpecCheckingFunction(expected runtime.Object) CheckingFunction {
0000000000000000000000000000000000000000;;		return func(obj runtime.Object) error {
0000000000000000000000000000000000000000;;			if util.ObjectMetaAndSpecEquivalent(obj, expected) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("Object different expected=%#v received=%#v", expected, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AssertHasFinalizer(t *testing.T, obj runtime.Object, finalizer string) {
0000000000000000000000000000000000000000;;		hasFinalizer, err := finalizersutil.HasFinalizer(obj, finalizer)
0000000000000000000000000000000000000000;;		require.Nil(t, err)
0000000000000000000000000000000000000000;;		assert.True(t, hasFinalizer)
0000000000000000000000000000000000000000;;	}
