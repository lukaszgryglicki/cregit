0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c5071fc886c1402e8b03f62bb1f678f50cdf3069;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: consider moving it to a more generic package.
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/heap"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TODO: Investigate what capacity is right.
0000000000000000000000000000000000000000;;		delayingDelivererUpdateChanCapacity = 1000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelayingDelivererItem is structure delivered by DelayingDeliverer to the
0000000000000000000000000000000000000000;;	// target channel.
0000000000000000000000000000000000000000;;	type DelayingDelivererItem struct {
0000000000000000000000000000000000000000;;		// Key under which the value was added to deliverer.
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;		// Value of the item.
0000000000000000000000000000000000000000;;		Value interface{}
0000000000000000000000000000000000000000;;		// When the item should be delivered.
0000000000000000000000000000000000000000;;		DeliveryTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type delivererHeap struct {
0000000000000000000000000000000000000000;;		keyPosition map[string]int
0000000000000000000000000000000000000000;;		data        []*DelayingDelivererItem
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Functions required by container.Heap.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dh *delivererHeap) Len() int { return len(dh.data) }
0000000000000000000000000000000000000000;;	func (dh *delivererHeap) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return dh.data[i].DeliveryTime.Before(dh.data[j].DeliveryTime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (dh *delivererHeap) Swap(i, j int) {
0000000000000000000000000000000000000000;;		dh.keyPosition[dh.data[i].Key] = j
0000000000000000000000000000000000000000;;		dh.keyPosition[dh.data[j].Key] = i
0000000000000000000000000000000000000000;;		dh.data[i], dh.data[j] = dh.data[j], dh.data[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dh *delivererHeap) Push(x interface{}) {
0000000000000000000000000000000000000000;;		item := x.(*DelayingDelivererItem)
0000000000000000000000000000000000000000;;		dh.data = append(dh.data, item)
0000000000000000000000000000000000000000;;		dh.keyPosition[item.Key] = len(dh.data) - 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dh *delivererHeap) Pop() interface{} {
0000000000000000000000000000000000000000;;		n := len(dh.data)
0000000000000000000000000000000000000000;;		item := dh.data[n-1]
0000000000000000000000000000000000000000;;		dh.data = dh.data[:n-1]
0000000000000000000000000000000000000000;;		delete(dh.keyPosition, item.Key)
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A structure that pushes the items to the target channel at a given time.
0000000000000000000000000000000000000000;;	type DelayingDeliverer struct {
0000000000000000000000000000000000000000;;		// Channel to deliver the data when their time comes.
0000000000000000000000000000000000000000;;		targetChannel chan *DelayingDelivererItem
0000000000000000000000000000000000000000;;		// Store for data
0000000000000000000000000000000000000000;;		heap *delivererHeap
0000000000000000000000000000000000000000;;		// Channel to feed the main goroutine with updates.
0000000000000000000000000000000000000000;;		updateChannel chan *DelayingDelivererItem
0000000000000000000000000000000000000000;;		// To stop the main goroutine.
0000000000000000000000000000000000000000;;		stopChannel chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDelayingDeliverer() *DelayingDeliverer {
0000000000000000000000000000000000000000;;		return NewDelayingDelivererWithChannel(make(chan *DelayingDelivererItem, 100))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDelayingDelivererWithChannel(targetChannel chan *DelayingDelivererItem) *DelayingDeliverer {
0000000000000000000000000000000000000000;;		return &DelayingDeliverer{
0000000000000000000000000000000000000000;;			targetChannel: targetChannel,
0000000000000000000000000000000000000000;;			heap: &delivererHeap{
0000000000000000000000000000000000000000;;				keyPosition: make(map[string]int),
0000000000000000000000000000000000000000;;				data:        make([]*DelayingDelivererItem, 0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			updateChannel: make(chan *DelayingDelivererItem, delayingDelivererUpdateChanCapacity),
0000000000000000000000000000000000000000;;			stopChannel:   make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deliver all items due before or equal to timestamp.
0000000000000000000000000000000000000000;;	func (d *DelayingDeliverer) deliver(timestamp time.Time) {
0000000000000000000000000000000000000000;;		for d.heap.Len() > 0 {
0000000000000000000000000000000000000000;;			if timestamp.Before(d.heap.data[0].DeliveryTime) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			item := heap.Pop(d.heap).(*DelayingDelivererItem)
0000000000000000000000000000000000000000;;			d.targetChannel <- item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *DelayingDeliverer) run() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			d.deliver(now)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nextWakeUp := now.Add(time.Hour)
0000000000000000000000000000000000000000;;			if d.heap.Len() > 0 {
0000000000000000000000000000000000000000;;				nextWakeUp = d.heap.data[0].DeliveryTime
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sleepTime := nextWakeUp.Sub(now)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(sleepTime):
0000000000000000000000000000000000000000;;				break // just wake up and process the data
0000000000000000000000000000000000000000;;			case item := <-d.updateChannel:
0000000000000000000000000000000000000000;;				if position, found := d.heap.keyPosition[item.Key]; found {
0000000000000000000000000000000000000000;;					if item.DeliveryTime.Before(d.heap.data[position].DeliveryTime) {
0000000000000000000000000000000000000000;;						d.heap.data[position] = item
0000000000000000000000000000000000000000;;						heap.Fix(d.heap, position)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Ignore if later.
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					heap.Push(d.heap, item)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-d.stopChannel:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Starts the DelayingDeliverer.
0000000000000000000000000000000000000000;;	func (d *DelayingDeliverer) Start() {
0000000000000000000000000000000000000000;;		go d.run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stops the DelayingDeliverer. Undelivered items are discarded.
0000000000000000000000000000000000000000;;	func (d *DelayingDeliverer) Stop() {
0000000000000000000000000000000000000000;;		close(d.stopChannel)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delivers value at the given time.
0000000000000000000000000000000000000000;;	func (d *DelayingDeliverer) DeliverAt(key string, value interface{}, deliveryTime time.Time) {
0000000000000000000000000000000000000000;;		d.updateChannel <- &DelayingDelivererItem{
0000000000000000000000000000000000000000;;			Key:          key,
0000000000000000000000000000000000000000;;			Value:        value,
0000000000000000000000000000000000000000;;			DeliveryTime: deliveryTime,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delivers value after the given delay.
0000000000000000000000000000000000000000;;	func (d *DelayingDeliverer) DeliverAfter(key string, value interface{}, delay time.Duration) {
0000000000000000000000000000000000000000;;		d.DeliverAt(key, value, time.Now().Add(delay))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets target channel of the deliverer.
0000000000000000000000000000000000000000;;	func (d *DelayingDeliverer) GetTargetChannel() chan *DelayingDelivererItem {
0000000000000000000000000000000000000000;;		return d.targetChannel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Starts Delaying deliverer with a handler listening on the target channel.
0000000000000000000000000000000000000000;;	func (d *DelayingDeliverer) StartWithHandler(handler func(*DelayingDelivererItem)) {
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case item := <-d.targetChannel:
0000000000000000000000000000000000000000;;					handler(item)
0000000000000000000000000000000000000000;;				case <-d.stopChannel:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		d.Start()
0000000000000000000000000000000000000000;;	}
