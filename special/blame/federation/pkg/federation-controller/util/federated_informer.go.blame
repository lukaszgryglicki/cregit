0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
eef5fecefa78385e3336ae091dccecdceeeacc37;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		federationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		clusterSyncPeriod = 10 * time.Minute
0000000000000000000000000000000000000000;;		userAgentName     = "federation-controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An object with an origin information.
0000000000000000000000000000000000000000;;	type FederatedObject struct {
0000000000000000000000000000000000000000;;		Object      interface{}
0000000000000000000000000000000000000000;;		ClusterName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederatedReadOnlyStore is an overlay over multiple stores created in federated clusters.
0000000000000000000000000000000000000000;;	type FederatedReadOnlyStore interface {
0000000000000000000000000000000000000000;;		// Returns all items in the store.
0000000000000000000000000000000000000000;;		List() ([]FederatedObject, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns all items from a cluster.
0000000000000000000000000000000000000000;;		ListFromCluster(clusterName string) ([]interface{}, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetKeyFor returns the key under which the item would be put in the store.
0000000000000000000000000000000000000000;;		GetKeyFor(item interface{}) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetByKey returns the item stored under the given key in the specified cluster (if exist).
0000000000000000000000000000000000000000;;		GetByKey(clusterName string, key string) (interface{}, bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns the items stored under the given key in all clusters.
0000000000000000000000000000000000000000;;		GetFromAllClusters(key string) ([]FederatedObject, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Checks whether stores for all clusters form the lists (and only these) are there and
0000000000000000000000000000000000000000;;		// are synced. This is only a basic check whether the data inside of the store is usable.
0000000000000000000000000000000000000000;;		// It is not a full synchronization/locking mechanism it only tries to ensure that out-of-sync
0000000000000000000000000000000000000000;;		// issues occur less often.	All users of the interface should assume
0000000000000000000000000000000000000000;;		// that there may be significant delays in content updates of all kinds and write their
0000000000000000000000000000000000000000;;		// code that it doesn't break if something is slightly out-of-sync.
0000000000000000000000000000000000000000;;		ClustersSynced(clusters []*federationapi.Cluster) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An interface to access federation members and clients.
0000000000000000000000000000000000000000;;	type FederationView interface {
0000000000000000000000000000000000000000;;		// GetClientsetForCluster returns a clientset for the cluster, if present.
0000000000000000000000000000000000000000;;		GetClientsetForCluster(clusterName string) (kubeclientset.Interface, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetUnreadyClusters returns a list of all clusters that are not ready yet.
0000000000000000000000000000000000000000;;		GetUnreadyClusters() ([]*federationapi.Cluster, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetReadyClusters returns all clusters for which the sub-informers are run.
0000000000000000000000000000000000000000;;		GetReadyClusters() ([]*federationapi.Cluster, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetReadyCluster returns the cluster with the given name, if found.
0000000000000000000000000000000000000000;;		GetReadyCluster(name string) (*federationapi.Cluster, bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClustersSynced returns true if the view is synced (for the first time).
0000000000000000000000000000000000000000;;		ClustersSynced() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A structure that combines an informer running against federated api server and listening for cluster updates
0000000000000000000000000000000000000000;;	// with multiple Kubernetes API informers (called target informers) running against federation members. Whenever a new
0000000000000000000000000000000000000000;;	// cluster is added to the federation an informer is created for it using TargetInformerFactory. Informers are stopped
0000000000000000000000000000000000000000;;	// when a cluster is either put offline of deleted. It is assumed that some controller keeps an eye on the cluster list
0000000000000000000000000000000000000000;;	// and thus the clusters in ETCD are up to date.
0000000000000000000000000000000000000000;;	type FederatedInformer interface {
0000000000000000000000000000000000000000;;		FederationView
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a store created over all stores from target informers.
0000000000000000000000000000000000000000;;		GetTargetStore() FederatedReadOnlyStore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Starts all the processes.
0000000000000000000000000000000000000000;;		Start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stops all the processes inside the informer.
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederatedInformer with extra method for setting fake clients.
0000000000000000000000000000000000000000;;	type FederatedInformerForTestOnly interface {
0000000000000000000000000000000000000000;;		FederatedInformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SetClientFactory(func(*federationapi.Cluster) (kubeclientset.Interface, error))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A function that should be used to create an informer on the target object. Store should use
0000000000000000000000000000000000000000;;	// cache.DeletionHandlingMetaNamespaceKeyFunc as a keying function.
0000000000000000000000000000000000000000;;	type TargetInformerFactory func(*federationapi.Cluster, kubeclientset.Interface) (cache.Store, cache.Controller)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A structure with cluster lifecycle handler functions. Cluster is available (and ClusterAvailable is fired)
0000000000000000000000000000000000000000;;	// when it is created in federated etcd and ready. Cluster becomes unavailable (and ClusterUnavailable is fired)
0000000000000000000000000000000000000000;;	// when it is either deleted or becomes not ready. When cluster spec (IP)is modified both ClusterAvailable
0000000000000000000000000000000000000000;;	// and ClusterUnavailable are fired.
0000000000000000000000000000000000000000;;	type ClusterLifecycleHandlerFuncs struct {
0000000000000000000000000000000000000000;;		// Fired when the cluster becomes available.
0000000000000000000000000000000000000000;;		ClusterAvailable func(*federationapi.Cluster)
0000000000000000000000000000000000000000;;		// Fired when the cluster becomes unavailable. The second arg contains data that was present
0000000000000000000000000000000000000000;;		// in the cluster before deletion.
0000000000000000000000000000000000000000;;		ClusterUnavailable func(*federationapi.Cluster, []interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Builds a FederatedInformer for the given federation client and factory.
0000000000000000000000000000000000000000;;	func NewFederatedInformer(
0000000000000000000000000000000000000000;;		federationClient federationclientset.Interface,
0000000000000000000000000000000000000000;;		targetInformerFactory TargetInformerFactory,
0000000000000000000000000000000000000000;;		clusterLifecycle *ClusterLifecycleHandlerFuncs) FederatedInformer {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		federatedInformer := &federatedInformerImpl{
0000000000000000000000000000000000000000;;			targetInformerFactory: targetInformerFactory,
0000000000000000000000000000000000000000;;			clientFactory: func(cluster *federationapi.Cluster) (kubeclientset.Interface, error) {
0000000000000000000000000000000000000000;;				clusterConfig, err := BuildClusterConfig(cluster)
0000000000000000000000000000000000000000;;				if err == nil && clusterConfig != nil {
0000000000000000000000000000000000000000;;					clientset := kubeclientset.NewForConfigOrDie(restclient.AddUserAgent(clusterConfig, userAgentName))
0000000000000000000000000000000000000000;;					return clientset, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			targetInformers: make(map[string]informer),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getClusterData := func(name string) []interface{} {
0000000000000000000000000000000000000000;;			data, err := federatedInformer.GetTargetStore().ListFromCluster(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to list %s content: %v", name, err)
0000000000000000000000000000000000000000;;				return make([]interface{}, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		federatedInformer.clusterInformer.store, federatedInformer.clusterInformer.controller = cache.NewInformer(
0000000000000000000000000000000000000000;;			&cache.ListWatch{
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;					return federationClient.Federation().Clusters().List(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					return federationClient.Federation().Clusters().Watch(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&federationapi.Cluster{},
0000000000000000000000000000000000000000;;			clusterSyncPeriod,
0000000000000000000000000000000000000000;;			cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				DeleteFunc: func(old interface{}) {
0000000000000000000000000000000000000000;;					oldCluster, ok := old.(*federationapi.Cluster)
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						var data []interface{}
0000000000000000000000000000000000000000;;						if clusterLifecycle.ClusterUnavailable != nil {
0000000000000000000000000000000000000000;;							data = getClusterData(oldCluster.Name)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						federatedInformer.deleteCluster(oldCluster)
0000000000000000000000000000000000000000;;						if clusterLifecycle.ClusterUnavailable != nil {
0000000000000000000000000000000000000000;;							clusterLifecycle.ClusterUnavailable(oldCluster, data)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				AddFunc: func(cur interface{}) {
0000000000000000000000000000000000000000;;					curCluster, ok := cur.(*federationapi.Cluster)
0000000000000000000000000000000000000000;;					if ok && isClusterReady(curCluster) {
0000000000000000000000000000000000000000;;						federatedInformer.addCluster(curCluster)
0000000000000000000000000000000000000000;;						if clusterLifecycle.ClusterAvailable != nil {
0000000000000000000000000000000000000000;;							clusterLifecycle.ClusterAvailable(curCluster)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.Errorf("Cluster %v not added.  Not of correct type, or cluster not ready.", cur)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				UpdateFunc: func(old, cur interface{}) {
0000000000000000000000000000000000000000;;					oldCluster, ok := old.(*federationapi.Cluster)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						glog.Errorf("Internal error: Cluster %v not updated.  Old cluster not of correct type.", old)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					curCluster, ok := cur.(*federationapi.Cluster)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						glog.Errorf("Internal error: Cluster %v not updated.  New cluster not of correct type.", cur)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if isClusterReady(oldCluster) != isClusterReady(curCluster) || !reflect.DeepEqual(oldCluster.Spec, curCluster.Spec) || !reflect.DeepEqual(oldCluster.ObjectMeta.Annotations, curCluster.ObjectMeta.Annotations) {
0000000000000000000000000000000000000000;;						var data []interface{}
0000000000000000000000000000000000000000;;						if clusterLifecycle.ClusterUnavailable != nil {
0000000000000000000000000000000000000000;;							data = getClusterData(oldCluster.Name)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						federatedInformer.deleteCluster(oldCluster)
0000000000000000000000000000000000000000;;						if clusterLifecycle.ClusterUnavailable != nil {
0000000000000000000000000000000000000000;;							clusterLifecycle.ClusterUnavailable(oldCluster, data)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if isClusterReady(curCluster) {
0000000000000000000000000000000000000000;;							federatedInformer.addCluster(curCluster)
0000000000000000000000000000000000000000;;							if clusterLifecycle.ClusterAvailable != nil {
0000000000000000000000000000000000000000;;								clusterLifecycle.ClusterAvailable(curCluster)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Cluster %v not updated to %v as ready status and specs are identical", oldCluster, curCluster)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return federatedInformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isClusterReady(cluster *federationapi.Cluster) bool {
0000000000000000000000000000000000000000;;		for _, condition := range cluster.Status.Conditions {
0000000000000000000000000000000000000000;;			if condition.Type == federationapi.ClusterReady {
0000000000000000000000000000000000000000;;				if condition.Status == apiv1.ConditionTrue {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type informer struct {
0000000000000000000000000000000000000000;;		controller cache.Controller
0000000000000000000000000000000000000000;;		store      cache.Store
0000000000000000000000000000000000000000;;		stopChan   chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type federatedInformerImpl struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Informer on federated clusters.
0000000000000000000000000000000000000000;;		clusterInformer informer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Target informers factory
0000000000000000000000000000000000000000;;		targetInformerFactory TargetInformerFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Structures returned by targetInformerFactory
0000000000000000000000000000000000000000;;		targetInformers map[string]informer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A function to build clients.
0000000000000000000000000000000000000000;;		clientFactory func(*federationapi.Cluster) (kubeclientset.Interface, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// *federatedInformerImpl implements FederatedInformer interface.
0000000000000000000000000000000000000000;;	var _ FederatedInformer = &federatedInformerImpl{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type federatedStoreImpl struct {
0000000000000000000000000000000000000000;;		federatedInformer *federatedInformerImpl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) Stop() {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Stopping federated informer.")
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("... Closing cluster informer channel.")
0000000000000000000000000000000000000000;;		close(f.clusterInformer.stopChan)
0000000000000000000000000000000000000000;;		for key, informer := range f.targetInformers {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("... Closing informer channel for %q.", key)
0000000000000000000000000000000000000000;;			close(informer.stopChan)
0000000000000000000000000000000000000000;;			// Remove each informer after it has been stopped to prevent
0000000000000000000000000000000000000000;;			// subsequent cluster deletion from attempting to double close
0000000000000000000000000000000000000000;;			// an informer's stop channel.
0000000000000000000000000000000000000000;;			delete(f.targetInformers, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) Start() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.clusterInformer.stopChan = make(chan struct{})
0000000000000000000000000000000000000000;;		go f.clusterInformer.controller.Run(f.clusterInformer.stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) SetClientFactory(clientFactory func(*federationapi.Cluster) (kubeclientset.Interface, error)) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.clientFactory = clientFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetClientsetForCluster returns a clientset for the cluster, if present.
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) GetClientsetForCluster(clusterName string) (kubeclientset.Interface, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		return f.getClientsetForClusterUnlocked(clusterName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) getClientsetForClusterUnlocked(clusterName string) (kubeclientset.Interface, error) {
0000000000000000000000000000000000000000;;		// No locking needed. Will happen in f.GetCluster.
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Getting clientset for cluster %q", clusterName)
0000000000000000000000000000000000000000;;		if cluster, found, err := f.getReadyClusterUnlocked(clusterName); found && err == nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Got clientset for cluster %q", clusterName)
0000000000000000000000000000000000000000;;			return f.clientFactory(cluster)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("cluster %q not found", clusterName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) GetUnreadyClusters() ([]*federationapi.Cluster, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items := f.clusterInformer.store.List()
0000000000000000000000000000000000000000;;		result := make([]*federationapi.Cluster, 0, len(items))
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if cluster, ok := item.(*federationapi.Cluster); ok {
0000000000000000000000000000000000000000;;				if !isClusterReady(cluster) {
0000000000000000000000000000000000000000;;					result = append(result, cluster)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("wrong data in FederatedInformerImpl cluster store: %v", item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetReadyClusters returns all clusters for which the sub-informers are run.
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) GetReadyClusters() ([]*federationapi.Cluster, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items := f.clusterInformer.store.List()
0000000000000000000000000000000000000000;;		result := make([]*federationapi.Cluster, 0, len(items))
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if cluster, ok := item.(*federationapi.Cluster); ok {
0000000000000000000000000000000000000000;;				if isClusterReady(cluster) {
0000000000000000000000000000000000000000;;					result = append(result, cluster)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("wrong data in FederatedInformerImpl cluster store: %v", item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCluster returns the cluster with the given name, if found.
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) GetReadyCluster(name string) (*federationapi.Cluster, bool, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		return f.getReadyClusterUnlocked(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) getReadyClusterUnlocked(name string) (*federationapi.Cluster, bool, error) {
0000000000000000000000000000000000000000;;		if obj, exist, err := f.clusterInformer.store.GetByKey(name); exist && err == nil {
0000000000000000000000000000000000000000;;			if cluster, ok := obj.(*federationapi.Cluster); ok {
0000000000000000000000000000000000000000;;				if isClusterReady(cluster) {
0000000000000000000000000000000000000000;;					return cluster, true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, false, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("wrong data in FederatedInformerImpl cluster store: %v", obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Synced returns true if the view is synced (for the first time)
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) ClustersSynced() bool {
0000000000000000000000000000000000000000;;		return f.clusterInformer.controller.HasSynced()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds the given cluster to federated informer.
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) addCluster(cluster *federationapi.Cluster) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		name := cluster.Name
0000000000000000000000000000000000000000;;		if client, err := f.getClientsetForClusterUnlocked(name); err == nil {
0000000000000000000000000000000000000000;;			store, controller := f.targetInformerFactory(cluster, client)
0000000000000000000000000000000000000000;;			targetInformer := informer{
0000000000000000000000000000000000000000;;				controller: controller,
0000000000000000000000000000000000000000;;				store:      store,
0000000000000000000000000000000000000000;;				stopChan:   make(chan struct{}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.targetInformers[name] = targetInformer
0000000000000000000000000000000000000000;;			go targetInformer.controller.Run(targetInformer.stopChan)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: create also an event for cluster.
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to create a client for cluster: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes the cluster from federated informer.
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) deleteCluster(cluster *federationapi.Cluster) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		name := cluster.Name
0000000000000000000000000000000000000000;;		if targetInformer, found := f.targetInformers[name]; found {
0000000000000000000000000000000000000000;;			close(targetInformer.stopChan)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(f.targetInformers, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a store created over all stores from target informers.
0000000000000000000000000000000000000000;;	func (f *federatedInformerImpl) GetTargetStore() FederatedReadOnlyStore {
0000000000000000000000000000000000000000;;		return &federatedStoreImpl{
0000000000000000000000000000000000000000;;			federatedInformer: f,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns all items in the store.
0000000000000000000000000000000000000000;;	func (fs *federatedStoreImpl) List() ([]FederatedObject, error) {
0000000000000000000000000000000000000000;;		fs.federatedInformer.Lock()
0000000000000000000000000000000000000000;;		defer fs.federatedInformer.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([]FederatedObject, 0)
0000000000000000000000000000000000000000;;		for clusterName, targetInformer := range fs.federatedInformer.targetInformers {
0000000000000000000000000000000000000000;;			for _, value := range targetInformer.store.List() {
0000000000000000000000000000000000000000;;				result = append(result, FederatedObject{ClusterName: clusterName, Object: value})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns all items in the given cluster.
0000000000000000000000000000000000000000;;	func (fs *federatedStoreImpl) ListFromCluster(clusterName string) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		fs.federatedInformer.Lock()
0000000000000000000000000000000000000000;;		defer fs.federatedInformer.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([]interface{}, 0)
0000000000000000000000000000000000000000;;		if targetInformer, found := fs.federatedInformer.targetInformers[clusterName]; found {
0000000000000000000000000000000000000000;;			values := targetInformer.store.List()
0000000000000000000000000000000000000000;;			result = append(result, values...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByKey returns the item stored under the given key in the specified cluster (if exist).
0000000000000000000000000000000000000000;;	func (fs *federatedStoreImpl) GetByKey(clusterName string, key string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;		fs.federatedInformer.Lock()
0000000000000000000000000000000000000000;;		defer fs.federatedInformer.Unlock()
0000000000000000000000000000000000000000;;		if targetInformer, found := fs.federatedInformer.targetInformers[clusterName]; found {
0000000000000000000000000000000000000000;;			return targetInformer.store.GetByKey(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the items stored under the given key in all clusters.
0000000000000000000000000000000000000000;;	func (fs *federatedStoreImpl) GetFromAllClusters(key string) ([]FederatedObject, error) {
0000000000000000000000000000000000000000;;		fs.federatedInformer.Lock()
0000000000000000000000000000000000000000;;		defer fs.federatedInformer.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([]FederatedObject, 0)
0000000000000000000000000000000000000000;;		for clusterName, targetInformer := range fs.federatedInformer.targetInformers {
0000000000000000000000000000000000000000;;			value, exist, err := targetInformer.store.GetByKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exist {
0000000000000000000000000000000000000000;;				result = append(result, FederatedObject{ClusterName: clusterName, Object: value})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetKeyFor returns the key under which the item would be put in the store.
0000000000000000000000000000000000000000;;	func (fs *federatedStoreImpl) GetKeyFor(item interface{}) string {
0000000000000000000000000000000000000000;;		// TODO: support other keying functions.
0000000000000000000000000000000000000000;;		key, _ := cache.DeletionHandlingMetaNamespaceKeyFunc(item)
0000000000000000000000000000000000000000;;		return key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks whether stores for all clusters form the lists (and only these) are there and
0000000000000000000000000000000000000000;;	// are synced.
0000000000000000000000000000000000000000;;	func (fs *federatedStoreImpl) ClustersSynced(clusters []*federationapi.Cluster) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the list of informers to check under a lock and check it outside.
0000000000000000000000000000000000000000;;		okSoFar, informersToCheck := func() (bool, []informer) {
0000000000000000000000000000000000000000;;			fs.federatedInformer.Lock()
0000000000000000000000000000000000000000;;			defer fs.federatedInformer.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(fs.federatedInformer.targetInformers) != len(clusters) {
0000000000000000000000000000000000000000;;				return false, []informer{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			informersToCheck := make([]informer, 0, len(clusters))
0000000000000000000000000000000000000000;;			for _, cluster := range clusters {
0000000000000000000000000000000000000000;;				if targetInformer, found := fs.federatedInformer.targetInformers[cluster.Name]; found {
0000000000000000000000000000000000000000;;					informersToCheck = append(informersToCheck, targetInformer)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return false, []informer{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, informersToCheck
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !okSoFar {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, informerToCheck := range informersToCheck {
0000000000000000000000000000000000000000;;			if !informerToCheck.controller.HasSynced() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
