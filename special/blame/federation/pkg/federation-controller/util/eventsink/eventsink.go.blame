0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
242ff660f1729a7b61952df9281a42628b9d1f28;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package eventsink
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		kubev1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements k8s.io/client-go/tools/record.EventSink.
0000000000000000000000000000000000000000;;	type FederatedEventSink struct {
0000000000000000000000000000000000000000;;		clientset fedclientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// To check if all required functions are implemented.
0000000000000000000000000000000000000000;;	var _ record.EventSink = &FederatedEventSink{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFederatedEventSink(clientset fedclientset.Interface) *FederatedEventSink {
0000000000000000000000000000000000000000;;		return &FederatedEventSink{
0000000000000000000000000000000000000000;;			clientset: clientset,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO this is uses a reflection conversion path and is very expensive.  federation should update to use client-go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var scheme = runtime.NewScheme()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// register client-go's and kube's Event type under two different GroupVersions
0000000000000000000000000000000000000000;;		// TODO: switch to client-go client for events
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(clientv1.SchemeGroupVersion, &clientv1.Event{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(schema.GroupVersion{Group: "fake-kube-" + kubev1.SchemeGroupVersion.Group, Version: kubev1.SchemeGroupVersion.Version}, &kubev1.Event{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := scheme.AddConversionFuncs(
0000000000000000000000000000000000000000;;			metav1.Convert_unversioned_Time_To_unversioned_Time,
0000000000000000000000000000000000000000;;		); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scheme.AddGeneratedDeepCopyFuncs(
0000000000000000000000000000000000000000;;			conversion.GeneratedDeepCopyFunc{
0000000000000000000000000000000000000000;;				Fn:     metav1.DeepCopy_v1_Time,
0000000000000000000000000000000000000000;;				InType: reflect.TypeOf(&metav1.Time{}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fes *FederatedEventSink) Create(event *clientv1.Event) (*clientv1.Event, error) {
0000000000000000000000000000000000000000;;		kubeEvent := &kubev1.Event{}
0000000000000000000000000000000000000000;;		if err := scheme.Convert(event, kubeEvent, nil); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, err := fes.clientset.Core().Events(kubeEvent.Namespace).Create(kubeEvent)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retEvent := &clientv1.Event{}
0000000000000000000000000000000000000000;;		if err := scheme.Convert(ret, retEvent, nil); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return retEvent, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fes *FederatedEventSink) Update(event *clientv1.Event) (*clientv1.Event, error) {
0000000000000000000000000000000000000000;;		kubeEvent := &kubev1.Event{}
0000000000000000000000000000000000000000;;		if err := scheme.Convert(event, kubeEvent, nil); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, err := fes.clientset.Core().Events(kubeEvent.Namespace).Update(kubeEvent)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retEvent := &clientv1.Event{}
0000000000000000000000000000000000000000;;		if err := scheme.Convert(ret, retEvent, nil); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return retEvent, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fes *FederatedEventSink) Patch(event *clientv1.Event, data []byte) (*clientv1.Event, error) {
0000000000000000000000000000000000000000;;		kubeEvent := &kubev1.Event{}
0000000000000000000000000000000000000000;;		if err := scheme.Convert(event, kubeEvent, nil); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, err := fes.clientset.Core().Events(kubeEvent.Namespace).Patch(kubeEvent.Name, types.StrategicMergePatchType, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retEvent := &clientv1.Event{}
0000000000000000000000000000000000000000;;		if err := scheme.Convert(ret, retEvent, nil); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return retEvent, nil
0000000000000000000000000000000000000000;;	}
