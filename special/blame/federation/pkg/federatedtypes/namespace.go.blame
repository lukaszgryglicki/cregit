0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
024f2b725528653688ac567c48a234c1819ad9af;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package federatedtypes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		federationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller/namespace/deletion"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NamespaceKind           = "namespace"
0000000000000000000000000000000000000000;;		NamespaceControllerName = "namespaces"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		RegisterFederatedType(NamespaceKind, NamespaceControllerName, []schema.GroupVersionResource{apiv1.SchemeGroupVersion.WithResource(NamespaceControllerName)}, NewNamespaceAdapter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NamespaceAdapter struct {
0000000000000000000000000000000000000000;;		client  federationclientset.Interface
0000000000000000000000000000000000000000;;		deleter deletion.NamespacedResourcesDeleterInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamespaceAdapter(client federationclientset.Interface, config *restclient.Config) FederatedTypeAdapter {
0000000000000000000000000000000000000000;;		dynamicClientPool := dynamic.NewDynamicClientPool(config)
0000000000000000000000000000000000000000;;		discoverResourcesFunc := client.Discovery().ServerPreferredNamespacedResources
0000000000000000000000000000000000000000;;		deleter := deletion.NewNamespacedResourcesDeleter(
0000000000000000000000000000000000000000;;			client.Core().Namespaces(),
0000000000000000000000000000000000000000;;			dynamicClientPool,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			discoverResourcesFunc,
0000000000000000000000000000000000000000;;			apiv1.FinalizerKubernetes,
0000000000000000000000000000000000000000;;			false)
0000000000000000000000000000000000000000;;		return &NamespaceAdapter{client: client, deleter: deleter}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) Kind() string {
0000000000000000000000000000000000000000;;		return NamespaceKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) ObjectType() pkgruntime.Object {
0000000000000000000000000000000000000000;;		return &apiv1.Namespace{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) IsExpectedType(obj interface{}) bool {
0000000000000000000000000000000000000000;;		_, ok := obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) Copy(obj pkgruntime.Object) pkgruntime.Object {
0000000000000000000000000000000000000000;;		namespace := obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;		return &apiv1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: util.DeepCopyRelevantObjectMeta(namespace.ObjectMeta),
0000000000000000000000000000000000000000;;			Spec:       *(util.DeepCopyApiTypeOrPanic(&namespace.Spec).(*apiv1.NamespaceSpec)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) Equivalent(obj1, obj2 pkgruntime.Object) bool {
0000000000000000000000000000000000000000;;		return util.ObjectMetaAndSpecEquivalent(obj1, obj2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) QualifiedName(obj pkgruntime.Object) QualifiedName {
0000000000000000000000000000000000000000;;		namespace := obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;		return QualifiedName{Name: namespace.Name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) ObjectMeta(obj pkgruntime.Object) *metav1.ObjectMeta {
0000000000000000000000000000000000000000;;		return &obj.(*apiv1.Namespace).ObjectMeta
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) FedCreate(obj pkgruntime.Object) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		namespace := obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;		return a.client.CoreV1().Namespaces().Create(namespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) FedDelete(qualifiedName QualifiedName, options *metav1.DeleteOptions) error {
0000000000000000000000000000000000000000;;		return a.client.CoreV1().Namespaces().Delete(qualifiedName.Name, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) FedGet(qualifiedName QualifiedName) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		return a.client.CoreV1().Namespaces().Get(qualifiedName.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) FedList(namespace string, options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		return a.client.CoreV1().Namespaces().List(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) FedUpdate(obj pkgruntime.Object) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		namespace := obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;		return a.client.CoreV1().Namespaces().Update(namespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) FedWatch(namespace string, options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return a.client.CoreV1().Namespaces().Watch(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) ClusterCreate(client kubeclientset.Interface, obj pkgruntime.Object) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		namespace := obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;		return client.CoreV1().Namespaces().Create(namespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) ClusterDelete(client kubeclientset.Interface, qualifiedName QualifiedName, options *metav1.DeleteOptions) error {
0000000000000000000000000000000000000000;;		return client.CoreV1().Namespaces().Delete(qualifiedName.Name, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) ClusterGet(client kubeclientset.Interface, qualifiedName QualifiedName) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		return client.CoreV1().Namespaces().Get(qualifiedName.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) ClusterList(client kubeclientset.Interface, namespace string, options metav1.ListOptions) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		return client.CoreV1().Namespaces().List(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) ClusterUpdate(client kubeclientset.Interface, obj pkgruntime.Object) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		namespace := obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;		return client.CoreV1().Namespaces().Update(namespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) ClusterWatch(client kubeclientset.Interface, namespace string, options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return client.CoreV1().Namespaces().Watch(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) IsSchedulingAdapter() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) NewTestObject(namespace string) pkgruntime.Object {
0000000000000000000000000000000000000000;;		return &apiv1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "test-namespace-",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: apiv1.NamespaceSpec{
0000000000000000000000000000000000000000;;				Finalizers: []apiv1.FinalizerName{apiv1.FinalizerKubernetes},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CleanUpNamespace deletes all resources in a given namespace.
0000000000000000000000000000000000000000;;	func (a *NamespaceAdapter) CleanUpNamespace(obj pkgruntime.Object, eventRecorder record.EventRecorder) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		namespace := obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;		name := namespace.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set Terminating status.
0000000000000000000000000000000000000000;;		updatedNamespace := &apiv1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: namespace.ObjectMeta,
0000000000000000000000000000000000000000;;			Spec:       namespace.Spec,
0000000000000000000000000000000000000000;;			Status: apiv1.NamespaceStatus{
0000000000000000000000000000000000000000;;				Phase: apiv1.NamespaceTerminating,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if namespace.Status.Phase != apiv1.NamespaceTerminating {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Marking ns %s as terminating", name)
0000000000000000000000000000000000000000;;			eventRecorder.Event(namespace, api.EventTypeNormal, "DeleteNamespace", fmt.Sprintf("Marking for deletion"))
0000000000000000000000000000000000000000;;			_, err = a.FedUpdate(updatedNamespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to update namespace: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasFinalizerInSpec(updatedNamespace, apiv1.FinalizerKubernetes) {
0000000000000000000000000000000000000000;;			// Delete resources in this namespace.
0000000000000000000000000000000000000000;;			err = a.deleter.Delete(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error in deleting resources in namespace %s: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Removed kubernetes finalizer from ns %s", name)
0000000000000000000000000000000000000000;;			// Fetch the updated Namespace.
0000000000000000000000000000000000000000;;			obj, err = a.FedGet(QualifiedName{Name: name})
0000000000000000000000000000000000000000;;			updatedNamespace = obj.(*apiv1.Namespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error in fetching updated namespace %s: %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return updatedNamespace, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasFinalizerInSpec(namespace *apiv1.Namespace, finalizer apiv1.FinalizerName) bool {
0000000000000000000000000000000000000000;;		for i := range namespace.Spec.Finalizers {
0000000000000000000000000000000000000000;;			if namespace.Spec.Finalizers[i] == finalizer {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
