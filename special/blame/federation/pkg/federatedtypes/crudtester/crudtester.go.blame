0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c507aab7c3e12a6fd7aae5913db7610c2cbc52a4;federation/pkg/typeadapters/crudtester/crudtester.go[federation/pkg/typeadapters/crudtester/crudtester.go][federation/pkg/federatedtypes/crudtester/crudtester.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package crudtester
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federatedtypes"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AnnotationTestFederationCRUDUpdate string = "federation.kubernetes.io/test-federation-crud-update"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestLogger defines operations common across different types of testing
0000000000000000000000000000000000000000;;	type TestLogger interface {
0000000000000000000000000000000000000000;;		Fatalf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		Fatal(msg string)
0000000000000000000000000000000000000000;;		Logf(format string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FederatedTypeCRUDTester exercises Create/Read/Update/Delete operations for
0000000000000000000000000000000000000000;;	// federated types via the Federation API and validates that the
0000000000000000000000000000000000000000;;	// results of those operations are propagated to clusters that are
0000000000000000000000000000000000000000;;	// members of a federation.
0000000000000000000000000000000000000000;;	type FederatedTypeCRUDTester struct {
0000000000000000000000000000000000000000;;		tl             TestLogger
0000000000000000000000000000000000000000;;		adapter        federatedtypes.FederatedTypeAdapter
0000000000000000000000000000000000000000;;		kind           string
0000000000000000000000000000000000000000;;		clusterClients []clientset.Interface
0000000000000000000000000000000000000000;;		waitInterval   time.Duration
0000000000000000000000000000000000000000;;		// Federation operations will use wait.ForeverTestTimeout.  Any
0000000000000000000000000000000000000000;;		// operation that involves member clusters may take longer due to
0000000000000000000000000000000000000000;;		// propagation latency.
0000000000000000000000000000000000000000;;		clusterWaitTimeout time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFederatedTypeCRUDTester(testLogger TestLogger, adapter federatedtypes.FederatedTypeAdapter, clusterClients []clientset.Interface, waitInterval, clusterWaitTimeout time.Duration) *FederatedTypeCRUDTester {
0000000000000000000000000000000000000000;;		return &FederatedTypeCRUDTester{
0000000000000000000000000000000000000000;;			tl:                 testLogger,
0000000000000000000000000000000000000000;;			adapter:            adapter,
0000000000000000000000000000000000000000;;			kind:               adapter.Kind(),
0000000000000000000000000000000000000000;;			clusterClients:     clusterClients,
0000000000000000000000000000000000000000;;			waitInterval:       waitInterval,
0000000000000000000000000000000000000000;;			clusterWaitTimeout: clusterWaitTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) CheckLifecycle(desiredObject pkgruntime.Object) {
0000000000000000000000000000000000000000;;		obj := c.CheckCreate(desiredObject)
0000000000000000000000000000000000000000;;		c.CheckUpdate(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate the golden path - removal of dependents
0000000000000000000000000000000000000000;;		orphanDependents := false
0000000000000000000000000000000000000000;;		c.CheckDelete(obj, &orphanDependents)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) Create(desiredObject pkgruntime.Object) pkgruntime.Object {
0000000000000000000000000000000000000000;;		namespace := c.adapter.ObjectMeta(desiredObject).Namespace
0000000000000000000000000000000000000000;;		resourceMsg := fmt.Sprintf("federated %s", c.kind)
0000000000000000000000000000000000000000;;		if len(namespace) > 0 {
0000000000000000000000000000000000000000;;			resourceMsg = fmt.Sprintf("%s in namespace %q", resourceMsg, namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.tl.Logf("Creating new %s", resourceMsg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := c.adapter.FedCreate(desiredObject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c.tl.Fatalf("Error creating %s: %v", resourceMsg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		qualifiedName := c.adapter.QualifiedName(obj)
0000000000000000000000000000000000000000;;		c.tl.Logf("Created new federated %s %q", c.kind, qualifiedName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) CheckCreate(desiredObject pkgruntime.Object) pkgruntime.Object {
0000000000000000000000000000000000000000;;		obj := c.Create(desiredObject)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.CheckPropagation(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) CheckUpdate(obj pkgruntime.Object) {
0000000000000000000000000000000000000000;;		qualifiedName := c.adapter.QualifiedName(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var initialAnnotation string
0000000000000000000000000000000000000000;;		meta := c.adapter.ObjectMeta(obj)
0000000000000000000000000000000000000000;;		if meta.Annotations != nil {
0000000000000000000000000000000000000000;;			initialAnnotation = meta.Annotations[AnnotationTestFederationCRUDUpdate]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.tl.Logf("Updating federated %s %q", c.kind, qualifiedName)
0000000000000000000000000000000000000000;;		updatedObj, err := c.updateFedObject(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c.tl.Fatalf("Error updating federated %s %q: %v", c.kind, qualifiedName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// updateFedObject is expected to have changed the value of the annotation
0000000000000000000000000000000000000000;;		meta = c.adapter.ObjectMeta(updatedObj)
0000000000000000000000000000000000000000;;		updatedAnnotation := meta.Annotations[AnnotationTestFederationCRUDUpdate]
0000000000000000000000000000000000000000;;		if updatedAnnotation == initialAnnotation {
0000000000000000000000000000000000000000;;			c.tl.Fatalf("Federated %s %q not mutated", c.kind, qualifiedName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.CheckPropagation(updatedObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) CheckDelete(obj pkgruntime.Object, orphanDependents *bool) {
0000000000000000000000000000000000000000;;		qualifiedName := c.adapter.QualifiedName(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.tl.Logf("Deleting federated %s %q", c.kind, qualifiedName)
0000000000000000000000000000000000000000;;		err := c.adapter.FedDelete(qualifiedName, &metav1.DeleteOptions{OrphanDependents: orphanDependents})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c.tl.Fatalf("Error deleting federated %s %q: %v", c.kind, qualifiedName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deletingInCluster := (orphanDependents != nil && *orphanDependents == false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitTimeout := wait.ForeverTestTimeout
0000000000000000000000000000000000000000;;		if deletingInCluster {
0000000000000000000000000000000000000000;;			// May need extra time to delete both federation and cluster resources
0000000000000000000000000000000000000000;;			waitTimeout = c.clusterWaitTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for deletion.  The federation resource will only be removed once orphan deletion has been
0000000000000000000000000000000000000000;;		// completed or deemed unnecessary.
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(c.waitInterval, waitTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := c.adapter.FedGet(qualifiedName)
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c.tl.Fatalf("Error deleting federated %s %q: %v", c.kind, qualifiedName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var stateMsg string = "present"
0000000000000000000000000000000000000000;;		if deletingInCluster {
0000000000000000000000000000000000000000;;			stateMsg = "not present"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, client := range c.clusterClients {
0000000000000000000000000000000000000000;;			_, err := c.adapter.ClusterGet(client, qualifiedName)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case !deletingInCluster && errors.IsNotFound(err):
0000000000000000000000000000000000000000;;				c.tl.Fatalf("Federated %s %q was unexpectedly deleted from a member cluster", c.kind, qualifiedName)
0000000000000000000000000000000000000000;;			case deletingInCluster && err == nil:
0000000000000000000000000000000000000000;;				c.tl.Fatalf("Federated %s %q was unexpectedly orphaned in a member cluster", c.kind, qualifiedName)
0000000000000000000000000000000000000000;;			case err != nil && !errors.IsNotFound(err):
0000000000000000000000000000000000000000;;				c.tl.Fatalf("Error while checking whether %s %q is %s in member clusters: %v", c.kind, qualifiedName, stateMsg, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckPropagation checks propagation for the crud tester's clients
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) CheckPropagation(obj pkgruntime.Object) {
0000000000000000000000000000000000000000;;		c.CheckPropagationForClients(obj, c.clusterClients, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckPropagationForClients checks propagation for the provided clients
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) CheckPropagationForClients(obj pkgruntime.Object, clusterClients []clientset.Interface, objExpected bool) {
0000000000000000000000000000000000000000;;		qualifiedName := c.adapter.QualifiedName(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.tl.Logf("Waiting for %s %q in %d clusters", c.kind, qualifiedName, len(clusterClients))
0000000000000000000000000000000000000000;;		for _, client := range clusterClients {
0000000000000000000000000000000000000000;;			err := c.waitForResource(client, obj)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == wait.ErrWaitTimeout:
0000000000000000000000000000000000000000;;				if objExpected {
0000000000000000000000000000000000000000;;					c.tl.Fatalf("Timeout verifying %s %q in a member cluster: %v", c.kind, qualifiedName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				c.tl.Fatalf("Failed to verify %s %q in a member cluster: %v", c.kind, qualifiedName, err)
0000000000000000000000000000000000000000;;			case err == nil && !objExpected:
0000000000000000000000000000000000000000;;				c.tl.Fatalf("Found unexpected object %s %q in a member cluster: %v", c.kind, qualifiedName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) waitForResource(client clientset.Interface, obj pkgruntime.Object) error {
0000000000000000000000000000000000000000;;		qualifiedName := c.adapter.QualifiedName(obj)
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(c.waitInterval, c.clusterWaitTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			equivalenceFunc := c.adapter.Equivalent
0000000000000000000000000000000000000000;;			if c.adapter.IsSchedulingAdapter() {
0000000000000000000000000000000000000000;;				schedulingAdapter, ok := c.adapter.(federatedtypes.SchedulingAdapter)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					c.tl.Fatalf("Adapter for kind %q does not properly implement SchedulingAdapter.", c.adapter.Kind())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				equivalenceFunc = schedulingAdapter.EquivalentIgnoringSchedule
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clusterObj, err := c.adapter.ClusterGet(client, qualifiedName)
0000000000000000000000000000000000000000;;			if err == nil && equivalenceFunc(clusterObj, obj) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FederatedTypeCRUDTester) updateFedObject(obj pkgruntime.Object) (pkgruntime.Object, error) {
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(c.waitInterval, wait.ForeverTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			// Target the metadata for simplicity (it's type-agnostic)
0000000000000000000000000000000000000000;;			federatedtypes.SetAnnotation(c.adapter, obj, AnnotationTestFederationCRUDUpdate, "updated")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err := c.adapter.FedUpdate(obj)
0000000000000000000000000000000000000000;;			if errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				// The resource was updated by the federation controller.
0000000000000000000000000000000000000000;;				// Get the latest version and retry.
0000000000000000000000000000000000000000;;				qualifiedName := c.adapter.QualifiedName(obj)
0000000000000000000000000000000000000000;;				obj, err = c.adapter.FedGet(qualifiedName)
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Be tolerant of a slow server
0000000000000000000000000000000000000000;;			if errors.IsServerTimeout(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return (err == nil), err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return obj, err
0000000000000000000000000000000000000000;;	}
