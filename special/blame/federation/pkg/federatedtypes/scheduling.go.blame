0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f9107a35f6341243ac0c9acd2e0639e407ef4f1f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package federatedtypes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		fedapi "k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		federationapi "k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		fedutil "k8s.io/kubernetes/federation/pkg/federation-controller/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/planner"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/podanalyzer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federation-controller/util/replicapreferences"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchedulingStatus contains the status of the objects that are being
0000000000000000000000000000000000000000;;	// scheduled into joined clusters.
0000000000000000000000000000000000000000;;	type SchedulingStatus struct {
0000000000000000000000000000000000000000;;		Replicas             int32
0000000000000000000000000000000000000000;;		UpdatedReplicas      int32
0000000000000000000000000000000000000000;;		FullyLabeledReplicas int32
0000000000000000000000000000000000000000;;		ReadyReplicas        int32
0000000000000000000000000000000000000000;;		AvailableReplicas    int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchedulingInfo wraps the information that a SchedulingAdapter needs
0000000000000000000000000000000000000000;;	// to update objects per a schedule.
0000000000000000000000000000000000000000;;	type SchedulingInfo struct {
0000000000000000000000000000000000000000;;		Schedule map[string]int64
0000000000000000000000000000000000000000;;		Status   SchedulingStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchedulingAdapter defines operations for interacting with a
0000000000000000000000000000000000000000;;	// federated type that requires more complex synchronization logic.
0000000000000000000000000000000000000000;;	type SchedulingAdapter interface {
0000000000000000000000000000000000000000;;		GetSchedule(obj pkgruntime.Object, key string, clusters []*federationapi.Cluster, informer fedutil.FederatedInformer) (*SchedulingInfo, error)
0000000000000000000000000000000000000000;;		ScheduleObject(cluster *federationapi.Cluster, clusterObj pkgruntime.Object, federationObjCopy pkgruntime.Object, schedulingInfo *SchedulingInfo) (pkgruntime.Object, bool, error)
0000000000000000000000000000000000000000;;		UpdateFederatedStatus(obj pkgruntime.Object, status SchedulingStatus) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EquivalentIgnoringSchedule returns whether obj1 and obj2 are
0000000000000000000000000000000000000000;;		// equivalent ignoring differences due to scheduling.
0000000000000000000000000000000000000000;;		EquivalentIgnoringSchedule(obj1, obj2 pkgruntime.Object) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// schedulingAdapter is meant to be embedded in other type adapters that require
0000000000000000000000000000000000000000;;	// workload scheduling.
0000000000000000000000000000000000000000;;	type schedulingAdapter struct {
0000000000000000000000000000000000000000;;		preferencesAnnotationName string
0000000000000000000000000000000000000000;;		updateStatusFunc          func(pkgruntime.Object, SchedulingStatus) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *schedulingAdapter) IsSchedulingAdapter() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *schedulingAdapter) GetSchedule(obj pkgruntime.Object, key string, clusters []*federationapi.Cluster, informer fedutil.FederatedInformer) (*SchedulingInfo, error) {
0000000000000000000000000000000000000000;;		var clusterNames []string
0000000000000000000000000000000000000000;;		for _, cluster := range clusters {
0000000000000000000000000000000000000000;;			clusterNames = append(clusterNames, cluster.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Schedule the pods across the existing clusters.
0000000000000000000000000000000000000000;;		objectGetter := func(clusterName, key string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;			return informer.GetTargetStore().GetByKey(clusterName, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podsGetter := func(clusterName string, obj pkgruntime.Object) (*apiv1.PodList, error) {
0000000000000000000000000000000000000000;;			clientset, err := informer.GetClientsetForCluster(clusterName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selectorObj := reflect.ValueOf(obj).Elem().FieldByName("Spec").FieldByName("Selector").Interface().(*metav1.LabelSelector)
0000000000000000000000000000000000000000;;			selector, err := metav1.LabelSelectorAsSelector(selectorObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid selector: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metadata, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return clientset.Core().Pods(metadata.GetNamespace()).List(metav1.ListOptions{LabelSelector: selector.String()})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentReplicasPerCluster, estimatedCapacity, err := clustersReplicaState(clusterNames, key, objectGetter, podsGetter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fedPref, err := replicapreferences.GetAllocationPreferences(obj, a.preferencesAnnotationName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Infof("Invalid workload-type specific preference, using default. object: %v, err: %v", obj, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fedPref == nil {
0000000000000000000000000000000000000000;;			fedPref = &fedapi.ReplicaAllocationPreferences{
0000000000000000000000000000000000000000;;				Clusters: map[string]fedapi.ClusterPreferences{
0000000000000000000000000000000000000000;;					"*": {Weight: 1},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plnr := planner.NewPlanner(fedPref)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &SchedulingInfo{
0000000000000000000000000000000000000000;;			Schedule: schedule(plnr, obj, key, clusterNames, currentReplicasPerCluster, estimatedCapacity),
0000000000000000000000000000000000000000;;			Status:   SchedulingStatus{},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *schedulingAdapter) ScheduleObject(cluster *federationapi.Cluster, clusterObj pkgruntime.Object, federationObjCopy pkgruntime.Object, schedulingInfo *SchedulingInfo) (pkgruntime.Object, bool, error) {
0000000000000000000000000000000000000000;;		replicas, ok := schedulingInfo.Schedule[cluster.Name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			replicas = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		specReplicas := int32(replicas)
0000000000000000000000000000000000000000;;		reflect.ValueOf(federationObjCopy).Elem().FieldByName("Spec").FieldByName("Replicas").Set(reflect.ValueOf(&specReplicas))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if clusterObj != nil {
0000000000000000000000000000000000000000;;			schedulingStatusVal := reflect.ValueOf(schedulingInfo).Elem().FieldByName("Status")
0000000000000000000000000000000000000000;;			objStatusVal := reflect.ValueOf(clusterObj).Elem().FieldByName("Status")
0000000000000000000000000000000000000000;;			for i := 0; i < schedulingStatusVal.NumField(); i++ {
0000000000000000000000000000000000000000;;				schedulingStatusField := schedulingStatusVal.Field(i)
0000000000000000000000000000000000000000;;				schedulingStatusFieldName := schedulingStatusVal.Type().Field(i).Name
0000000000000000000000000000000000000000;;				objStatusField := objStatusVal.FieldByName(schedulingStatusFieldName)
0000000000000000000000000000000000000000;;				if objStatusField.IsValid() {
0000000000000000000000000000000000000000;;					current := schedulingStatusField.Int()
0000000000000000000000000000000000000000;;					additional := objStatusField.Int()
0000000000000000000000000000000000000000;;					schedulingStatusField.SetInt(current + additional)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return federationObjCopy, replicas > 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *schedulingAdapter) UpdateFederatedStatus(obj pkgruntime.Object, status SchedulingStatus) error {
0000000000000000000000000000000000000000;;		return a.updateStatusFunc(obj, status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func schedule(planner *planner.Planner, obj pkgruntime.Object, key string, clusterNames []string, currentReplicasPerCluster map[string]int64, estimatedCapacity map[string]int64) map[string]int64 {
0000000000000000000000000000000000000000;;		// TODO: integrate real scheduler
0000000000000000000000000000000000000000;;		replicas := reflect.ValueOf(obj).Elem().FieldByName("Spec").FieldByName("Replicas").Elem().Int()
0000000000000000000000000000000000000000;;		scheduleResult, overflow := planner.Plan(replicas, clusterNames, currentReplicasPerCluster, estimatedCapacity, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure that all current clusters end up in the scheduling result.
0000000000000000000000000000000000000000;;		result := make(map[string]int64)
0000000000000000000000000000000000000000;;		for clusterName := range currentReplicasPerCluster {
0000000000000000000000000000000000000000;;			result[clusterName] = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for clusterName, replicas := range scheduleResult {
0000000000000000000000000000000000000000;;			result[clusterName] = replicas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for clusterName, replicas := range overflow {
0000000000000000000000000000000000000000;;			result[clusterName] += replicas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if glog.V(4) {
0000000000000000000000000000000000000000;;			buf := bytes.NewBufferString(fmt.Sprintf("Schedule - %q\n", key))
0000000000000000000000000000000000000000;;			sort.Strings(clusterNames)
0000000000000000000000000000000000000000;;			for _, clusterName := range clusterNames {
0000000000000000000000000000000000000000;;				cur := currentReplicasPerCluster[clusterName]
0000000000000000000000000000000000000000;;				target := scheduleResult[clusterName]
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "%s: current: %d target: %d", clusterName, cur, target)
0000000000000000000000000000000000000000;;				if over, found := overflow[clusterName]; found {
0000000000000000000000000000000000000000;;					fmt.Fprintf(buf, " overflow: %d", over)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if capacity, found := estimatedCapacity[clusterName]; found {
0000000000000000000000000000000000000000;;					fmt.Fprintf(buf, " capacity: %d", capacity)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof(buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clusterReplicaState returns information about the scheduling state of the pods running in the federated clusters.
0000000000000000000000000000000000000000;;	func clustersReplicaState(
0000000000000000000000000000000000000000;;		clusterNames []string,
0000000000000000000000000000000000000000;;		key string,
0000000000000000000000000000000000000000;;		objectGetter func(clusterName string, key string) (interface{}, bool, error),
0000000000000000000000000000000000000000;;		podsGetter func(clusterName string, obj pkgruntime.Object) (*apiv1.PodList, error)) (currentReplicasPerCluster map[string]int64, estimatedCapacity map[string]int64, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentReplicasPerCluster = make(map[string]int64)
0000000000000000000000000000000000000000;;		estimatedCapacity = make(map[string]int64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, clusterName := range clusterNames {
0000000000000000000000000000000000000000;;			obj, exists, err := objectGetter(clusterName, key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			replicas := reflect.ValueOf(obj).Elem().FieldByName("Spec").FieldByName("Replicas").Elem().Int()
0000000000000000000000000000000000000000;;			readyReplicas := reflect.ValueOf(obj).Elem().FieldByName("Status").FieldByName("ReadyReplicas").Int()
0000000000000000000000000000000000000000;;			if replicas == readyReplicas {
0000000000000000000000000000000000000000;;				currentReplicasPerCluster[clusterName] = readyReplicas
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pods, err := podsGetter(clusterName, obj.(pkgruntime.Object))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				podStatus := podanalyzer.AnalyzePods(pods, time.Now())
0000000000000000000000000000000000000000;;				currentReplicasPerCluster[clusterName] = int64(podStatus.RunningAndReady) // include pending as well?
0000000000000000000000000000000000000000;;				unschedulable := int64(podStatus.Unschedulable)
0000000000000000000000000000000000000000;;				if unschedulable > 0 {
0000000000000000000000000000000000000000;;					estimatedCapacity[clusterName] = replicas - unschedulable
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return currentReplicasPerCluster, estimatedCapacity, nil
0000000000000000000000000000000000000000;;	}
