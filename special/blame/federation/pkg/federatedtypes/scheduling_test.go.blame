0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0c3be89fb875654ee8e8e309e8adf5bbc66d20b3;federation/pkg/federatedtypes/replicaset_test.go[federation/pkg/federatedtypes/replicaset_test.go][federation/pkg/federatedtypes/scheduling_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package federatedtypes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensionsv1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		pkgruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClusterReplicaState(t *testing.T) {
0000000000000000000000000000000000000000;;		uncalledPodsGetter := func(clusterName string, obj pkgruntime.Object) (*apiv1.PodList, error) {
0000000000000000000000000000000000000000;;			t.Fatal("podsGetter should not be called when workload objects are all ready.")
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podsByReplicaSet := make(map[pkgruntime.Object][]*apiv1.Pod)
0000000000000000000000000000000000000000;;		podsGetter := func(clusterName string, obj pkgruntime.Object) (*apiv1.PodList, error) {
0000000000000000000000000000000000000000;;			pods, ok := podsByReplicaSet[obj]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Fatalf("No pods found in test data for replica set %v", obj)
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Not found")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var podListPods []apiv1.Pod
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				podListPods = append(podListPods, *pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &apiv1.PodList{Items: podListPods}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readyCondition := apiv1.PodCondition{Type: apiv1.PodReady}
0000000000000000000000000000000000000000;;		unschedulableCondition := apiv1.PodCondition{
0000000000000000000000000000000000000000;;			Type:               apiv1.PodScheduled,
0000000000000000000000000000000000000000;;			Status:             apiv1.ConditionFalse,
0000000000000000000000000000000000000000;;			Reason:             apiv1.PodReasonUnschedulable,
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.NewTime(time.Now().Add(-1 * time.Hour)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		one := int64(1)
0000000000000000000000000000000000000000;;		two := int64(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			rs1Replicas                   int32
0000000000000000000000000000000000000000;;			rs2Replicas                   int32
0000000000000000000000000000000000000000;;			rs1ReadyReplicas              int32
0000000000000000000000000000000000000000;;			rs2ReadyReplicas              int32
0000000000000000000000000000000000000000;;			podsGetter                    func(clusterName string, obj pkgruntime.Object) (*apiv1.PodList, error)
0000000000000000000000000000000000000000;;			pod1Phase                     apiv1.PodPhase
0000000000000000000000000000000000000000;;			pod1Condition                 apiv1.PodCondition
0000000000000000000000000000000000000000;;			pod2Phase                     apiv1.PodPhase
0000000000000000000000000000000000000000;;			pod2Condition                 apiv1.PodCondition
0000000000000000000000000000000000000000;;			cluster1Replicas              *int64
0000000000000000000000000000000000000000;;			cluster2Replicas              *int64
0000000000000000000000000000000000000000;;			cluster1UnschedulableReplicas *int64
0000000000000000000000000000000000000000;;			cluster2UnschedulableReplicas *int64
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"All replica sets have an equal number of requested and ready replicas.": {rs1Replicas: 2, rs2Replicas: 2, rs1ReadyReplicas: 2, rs2ReadyReplicas: 2, podsGetter: uncalledPodsGetter, cluster1Replicas: &two, cluster2Replicas: &two},
0000000000000000000000000000000000000000;;			"One replica set has a pending schedulable pod":                          {rs1Replicas: 2, rs2Replicas: 2, rs1ReadyReplicas: 1, rs2ReadyReplicas: 2, podsGetter: podsGetter, pod1Phase: apiv1.PodRunning, pod1Condition: readyCondition, pod2Phase: apiv1.PodPending, cluster1Replicas: &one, cluster2Replicas: &two},
0000000000000000000000000000000000000000;;			"One replica set has an unschedulable pod":                               {rs1Replicas: 2, rs2Replicas: 2, rs1ReadyReplicas: 1, rs2ReadyReplicas: 2, podsGetter: podsGetter, pod1Phase: apiv1.PodRunning, pod1Condition: readyCondition, pod2Phase: apiv1.PodPending, pod2Condition: unschedulableCondition, cluster1Replicas: &one, cluster2Replicas: &two, cluster1UnschedulableReplicas: &one},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, tt := range tests {
0000000000000000000000000000000000000000;;			t.Run(name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				clusters := []string{"one", "two"}
0000000000000000000000000000000000000000;;				replicaSetsByCluster := make(map[string]*extensionsv1.ReplicaSet)
0000000000000000000000000000000000000000;;				replicaSetGetter := func(clusterName string, key string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;					rs, ok := replicaSetsByCluster[clusterName]
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t.Fatalf("No replica set found in test data for %v", clusterName)
0000000000000000000000000000000000000000;;						return nil, false, fmt.Errorf("Not found")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return rs, true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rs1 := newReplicaSetWithReplicas("one", tt.rs1Replicas)
0000000000000000000000000000000000000000;;				rs2 := newReplicaSetWithReplicas("two", tt.rs2Replicas)
0000000000000000000000000000000000000000;;				rs1.Spec.Replicas = &tt.rs1Replicas
0000000000000000000000000000000000000000;;				rs2.Spec.Replicas = &tt.rs2Replicas
0000000000000000000000000000000000000000;;				rs1.Status.ReadyReplicas = tt.rs1ReadyReplicas
0000000000000000000000000000000000000000;;				rs2.Status.ReadyReplicas = tt.rs2ReadyReplicas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				replicaSetsByCluster["one"] = rs1
0000000000000000000000000000000000000000;;				replicaSetsByCluster["two"] = rs2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pod1 := newPod("one")
0000000000000000000000000000000000000000;;				pod2 := newPod("two")
0000000000000000000000000000000000000000;;				podThree := newPod("three")
0000000000000000000000000000000000000000;;				podFour := newPod("four")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pod1.Status.Phase = tt.pod1Phase
0000000000000000000000000000000000000000;;				pod2.Status.Phase = tt.pod2Phase
0000000000000000000000000000000000000000;;				pod1.Status.Conditions = []apiv1.PodCondition{tt.pod1Condition}
0000000000000000000000000000000000000000;;				pod2.Status.Conditions = []apiv1.PodCondition{tt.pod2Condition}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podsByReplicaSet[rs1] = []*apiv1.Pod{pod1, pod2}
0000000000000000000000000000000000000000;;				podsByReplicaSet[rs2] = []*apiv1.Pod{podThree, podFour}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				current, estimatedCapacity, err := clustersReplicaState(clusters, "", replicaSetGetter, tt.podsGetter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				assert.Nil(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wantedCurrent := make(map[string]int64)
0000000000000000000000000000000000000000;;				if tt.cluster1Replicas != nil {
0000000000000000000000000000000000000000;;					wantedCurrent["one"] = *tt.cluster1Replicas
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tt.cluster2Replicas != nil {
0000000000000000000000000000000000000000;;					wantedCurrent["two"] = *tt.cluster2Replicas
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				assert.Equal(t, wantedCurrent, current)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wantedEstimatedCapacity := make(map[string]int64)
0000000000000000000000000000000000000000;;				if tt.cluster1UnschedulableReplicas != nil {
0000000000000000000000000000000000000000;;					wantedEstimatedCapacity["one"] = *tt.cluster1UnschedulableReplicas
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tt.cluster2UnschedulableReplicas != nil {
0000000000000000000000000000000000000000;;					wantedEstimatedCapacity["two"] = *tt.cluster2UnschedulableReplicas
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				assert.Equal(t, wantedEstimatedCapacity, estimatedCapacity)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReplicaSetWithReplicas(name string, replicas int32) *extensionsv1.ReplicaSet {
0000000000000000000000000000000000000000;;		return &extensionsv1.ReplicaSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				SelfLink:  "/api/v1/namespaces/default/replicasets/name",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: extensionsv1.ReplicaSetSpec{
0000000000000000000000000000000000000000;;				Replicas: &replicas,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(name string) *apiv1.Pod {
0000000000000000000000000000000000000000;;		return &apiv1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
