0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1db875b9bbbbff676f771e0e13033de40acecb41;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package stubs implements a stub for the EtcdKeysAPI, used primarily for unit testing purposes
0000000000000000000000000000000000000000;;	package stubs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcd "github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compile time check for interface conformance
0000000000000000000000000000000000000000;;	var _ EtcdKeysAPI = &EtcdKeysAPIStub{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EtcdKeysAPI interface {
0000000000000000000000000000000000000000;;		Set(context context.Context, key, value string, options *etcd.SetOptions) (*etcd.Response, error)
0000000000000000000000000000000000000000;;		Get(context context.Context, key string, options *etcd.GetOptions) (*etcd.Response, error)
0000000000000000000000000000000000000000;;		Delete(context context.Context, key string, options *etcd.DeleteOptions) (*etcd.Response, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EtcdKeysAPIStub struct {
0000000000000000000000000000000000000000;;		writes map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEtcdKeysAPIStub returns an initialized EtcdKeysAPIStub
0000000000000000000000000000000000000000;;	func NewEtcdKeysAPIStub() *EtcdKeysAPIStub {
0000000000000000000000000000000000000000;;		return &EtcdKeysAPIStub{make(map[string]string)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec *EtcdKeysAPIStub) Set(context context.Context, key, value string, options *etcd.SetOptions) (*etcd.Response, error) {
0000000000000000000000000000000000000000;;		ec.writes[key] = value
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec *EtcdKeysAPIStub) Delete(context context.Context, key string, options *etcd.DeleteOptions) (*etcd.Response, error) {
0000000000000000000000000000000000000000;;		for p := range ec.writes {
0000000000000000000000000000000000000000;;			if (options.Recursive && strings.HasPrefix(p, key)) || (!options.Recursive && p == key) {
0000000000000000000000000000000000000000;;				delete(ec.writes, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec *EtcdKeysAPIStub) Get(context context.Context, key string, options *etcd.GetOptions) (*etcd.Response, error) {
0000000000000000000000000000000000000000;;		nodes := ec.GetAll(key)
0000000000000000000000000000000000000000;;		if len(nodes) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(nodes) == 1 && nodes[key] != "" {
0000000000000000000000000000000000000000;;			return &etcd.Response{Node: &etcd.Node{Key: key, Value: nodes[key], Dir: false}}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node := &etcd.Node{Key: key, Dir: true, Nodes: etcd.Nodes{}}
0000000000000000000000000000000000000000;;		for k, v := range nodes {
0000000000000000000000000000000000000000;;			n := &etcd.Node{Key: k, Value: v}
0000000000000000000000000000000000000000;;			node.Nodes = append(node.Nodes, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &etcd.Response{Node: node}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec *EtcdKeysAPIStub) GetAll(key string) map[string]string {
0000000000000000000000000000000000000000;;		nodes := make(map[string]string)
0000000000000000000000000000000000000000;;		key = strings.ToLower(key)
0000000000000000000000000000000000000000;;		for path := range ec.writes {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(path, key) {
0000000000000000000000000000000000000000;;				nodes[path] = ec.writes[path]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
