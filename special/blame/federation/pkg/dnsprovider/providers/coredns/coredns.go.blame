0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1db875b9bbbbff676f771e0e13033de40acecb41;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package coredns is the implementation of pkg/dnsprovider interface for CoreDNS
0000000000000000000000000000000000000000;;	package coredns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		etcdc "github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/dnsprovider"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// "coredns" should be used to use this DNS provider
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProviderName = "coredns"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config to override defaults
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		Global struct {
0000000000000000000000000000000000000000;;			EtcdEndpoints    string `gcfg:"etcd-endpoints"`
0000000000000000000000000000000000000000;;			DNSZones         string `gcfg:"zones"`
0000000000000000000000000000000000000000;;			CoreDNSEndpoints string `gcfg:"coredns-endpoints"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		dnsprovider.RegisterDnsProvider(ProviderName, func(config io.Reader) (dnsprovider.Interface, error) {
0000000000000000000000000000000000000000;;			return newCoreDNSProviderInterface(config)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newCoreDnsProviderInterface creates a new instance of an CoreDNS DNS Interface.
0000000000000000000000000000000000000000;;	func newCoreDNSProviderInterface(config io.Reader) (*Interface, error) {
0000000000000000000000000000000000000000;;		etcdEndpoints := "http://federation-dns-server-etcd:2379"
0000000000000000000000000000000000000000;;		etcdPathPrefix := "skydns"
0000000000000000000000000000000000000000;;		dnsZones := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Possibly override defaults with config below
0000000000000000000000000000000000000000;;		if config != nil {
0000000000000000000000000000000000000000;;			var cfg Config
0000000000000000000000000000000000000000;;			if err := gcfg.ReadInto(&cfg, config); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't read config: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			etcdEndpoints = cfg.Global.EtcdEndpoints
0000000000000000000000000000000000000000;;			dnsZones = cfg.Global.DNSZones
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Using CoreDNS DNS provider")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dnsZones == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Need to provide at least one DNS Zone")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdCfg := etcdc.Config{
0000000000000000000000000000000000000000;;			Endpoints: strings.Split(etcdEndpoints, ","),
0000000000000000000000000000000000000000;;			Transport: etcdc.DefaultTransport,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := etcdc.New(etcdCfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Create etcd client from the config failed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		etcdKeysAPI := etcdc.NewKeysAPI(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		intf := newInterfaceWithStub(etcdKeysAPI)
0000000000000000000000000000000000000000;;		intf.etcdPathPrefix = etcdPathPrefix
0000000000000000000000000000000000000000;;		zoneList := strings.Split(dnsZones, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		intf.zones = Zones{intf: intf}
0000000000000000000000000000000000000000;;		for index, zoneName := range zoneList {
0000000000000000000000000000000000000000;;			zone := Zone{domain: zoneName, id: strconv.Itoa(index), zones: &intf.zones}
0000000000000000000000000000000000000000;;			intf.zones.zoneList = append(intf.zones.zoneList, zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return intf, nil
0000000000000000000000000000000000000000;;	}
