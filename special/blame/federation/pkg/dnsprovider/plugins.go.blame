0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5e13104b34911753aeb4d03a09f907bc53d40e86;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dnsprovider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Factory is a function that returns a dnsprovider.Interface.
0000000000000000000000000000000000000000;;	// The config parameter provides an io.Reader handler to the factory in
0000000000000000000000000000000000000000;;	// order to load specific configurations. If no configuration is provided
0000000000000000000000000000000000000000;;	// the parameter is nil.
0000000000000000000000000000000000000000;;	type Factory func(config io.Reader) (Interface, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All registered dns providers.
0000000000000000000000000000000000000000;;	var providersMutex sync.Mutex
0000000000000000000000000000000000000000;;	var providers = make(map[string]Factory)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterDnsProvider registers a dnsprovider.Factory by name.  This
0000000000000000000000000000000000000000;;	// is expected to happen during startup.
0000000000000000000000000000000000000000;;	func RegisterDnsProvider(name string, cloud Factory) {
0000000000000000000000000000000000000000;;		providersMutex.Lock()
0000000000000000000000000000000000000000;;		defer providersMutex.Unlock()
0000000000000000000000000000000000000000;;		if _, found := providers[name]; found {
0000000000000000000000000000000000000000;;			glog.Fatalf("DNS provider %q was registered twice", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Registered DNS provider %q", name)
0000000000000000000000000000000000000000;;		providers[name] = cloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDnsProvider creates an instance of the named DNS provider, or nil if
0000000000000000000000000000000000000000;;	// the name is not known.  The error return is only used if the named provider
0000000000000000000000000000000000000000;;	// was known but failed to initialize. The config parameter specifies the
0000000000000000000000000000000000000000;;	// io.Reader handler of the configuration file for the DNS provider, or nil
0000000000000000000000000000000000000000;;	// for no configuration.
0000000000000000000000000000000000000000;;	func GetDnsProvider(name string, config io.Reader) (Interface, error) {
0000000000000000000000000000000000000000;;		providersMutex.Lock()
0000000000000000000000000000000000000000;;		defer providersMutex.Unlock()
0000000000000000000000000000000000000000;;		f, found := providers[name]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a list of registered dns providers.
0000000000000000000000000000000000000000;;	func RegisteredDnsProviders() []string {
0000000000000000000000000000000000000000;;		registeredProviders := make([]string, len(providers))
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for provider := range providers {
0000000000000000000000000000000000000000;;			registeredProviders[i] = provider
0000000000000000000000000000000000000000;;			i = i + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return registeredProviders
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitDnsProvider creates an instance of the named DNS provider.
0000000000000000000000000000000000000000;;	func InitDnsProvider(name string, configFilePath string) (Interface, error) {
0000000000000000000000000000000000000000;;		var dns Interface
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			glog.Info("No DNS provider specified.")
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if configFilePath != "" {
0000000000000000000000000000000000000000;;			var config *os.File
0000000000000000000000000000000000000000;;			config, err = os.Open(configFilePath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Couldn't open DNS provider configuration %s: %#v", configFilePath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer config.Close()
0000000000000000000000000000000000000000;;			dns, err = GetDnsProvider(name, config)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Pass explicit nil so plugins can actually check for nil. See
0000000000000000000000000000000000000000;;			// "Why is my nil error value not equal to nil?" in golang.org/doc/faq.
0000000000000000000000000000000000000000;;			dns, err = GetDnsProvider(name, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not init DNS provider %q: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown DNS provider %q", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dns, nil
0000000000000000000000000000000000000000;;	}
