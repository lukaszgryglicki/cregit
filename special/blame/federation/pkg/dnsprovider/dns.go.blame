0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5e13104b34911753aeb4d03a09f907bc53d40e86;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dnsprovider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/dnsprovider/rrstype"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface is an abstract, pluggable interface for DNS providers.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// Zones returns the provider's Zones interface, or false if not supported.
0000000000000000000000000000000000000000;;		Zones() (Zones, bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Zones interface {
0000000000000000000000000000000000000000;;		// List returns the managed Zones, or an error if the list operation failed.
0000000000000000000000000000000000000000;;		List() ([]Zone, error)
0000000000000000000000000000000000000000;;		// Add creates and returns a new managed zone, or an error if the operation failed
0000000000000000000000000000000000000000;;		Add(Zone) (Zone, error)
0000000000000000000000000000000000000000;;		// Remove deletes a managed zone, or returns an error if the operation failed.
0000000000000000000000000000000000000000;;		Remove(Zone) error
0000000000000000000000000000000000000000;;		// New allocates a new Zone, which can then be passed to Add()
0000000000000000000000000000000000000000;;		// Arguments are as per the Zone interface below.
0000000000000000000000000000000000000000;;		New(name string) (Zone, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Zone interface {
0000000000000000000000000000000000000000;;		// Name returns the name of the zone, e.g. "example.com"
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		// ID returns the unique provider identifier for the zone
0000000000000000000000000000000000000000;;		ID() string
0000000000000000000000000000000000000000;;		// ResourceRecordSets returns the provider's ResourceRecordSets interface, or false if not supported.
0000000000000000000000000000000000000000;;		ResourceRecordSets() (ResourceRecordSets, bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceRecordSets interface {
0000000000000000000000000000000000000000;;		// List returns the ResourceRecordSets of the Zone, or an error if the list operation failed.
0000000000000000000000000000000000000000;;		List() ([]ResourceRecordSet, error)
0000000000000000000000000000000000000000;;		// Get returns the ResourceRecordSet list with the name in the Zone.
0000000000000000000000000000000000000000;;		// This is a list because there might be multiple records of different
0000000000000000000000000000000000000000;;		// types for a given name. If the named resource record sets do not
0000000000000000000000000000000000000000;;		// exist, but no error occurred, the returned record set will be empty
0000000000000000000000000000000000000000;;		// and error will be nil.
0000000000000000000000000000000000000000;;		Get(name string) ([]ResourceRecordSet, error)
0000000000000000000000000000000000000000;;		// New allocates a new ResourceRecordSet, which can then be passed to ResourceRecordChangeset Add() or Remove()
0000000000000000000000000000000000000000;;		// Arguments are as per the ResourceRecordSet interface below.
0000000000000000000000000000000000000000;;		New(name string, rrdatas []string, ttl int64, rrstype rrstype.RrsType) ResourceRecordSet
0000000000000000000000000000000000000000;;		// StartChangeset begins a new batch operation of changes against the Zone
0000000000000000000000000000000000000000;;		StartChangeset() ResourceRecordChangeset
0000000000000000000000000000000000000000;;		// Zone returns the parent zone
0000000000000000000000000000000000000000;;		Zone() Zone
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceRecordChangeset accumulates a set of changes, that can then be applied with Apply
0000000000000000000000000000000000000000;;	type ResourceRecordChangeset interface {
0000000000000000000000000000000000000000;;		// Add adds the creation of a ResourceRecordSet in the Zone to the changeset
0000000000000000000000000000000000000000;;		Add(ResourceRecordSet) ResourceRecordChangeset
0000000000000000000000000000000000000000;;		// Remove adds the removal of a ResourceRecordSet in the Zone to the changeset
0000000000000000000000000000000000000000;;		// The supplied ResourceRecordSet must match one of the existing recordsets (obtained via List()) exactly.
0000000000000000000000000000000000000000;;		Remove(ResourceRecordSet) ResourceRecordChangeset
0000000000000000000000000000000000000000;;		// Upsert adds an "create or update" operation for the ResourceRecordSet in the Zone to the changeset
0000000000000000000000000000000000000000;;		// Note: the implementation may translate this into a Remove followed by an Add operation.
0000000000000000000000000000000000000000;;		// If you have the pre-image, it will likely be more efficient to call Remove and Add.
0000000000000000000000000000000000000000;;		Upsert(ResourceRecordSet) ResourceRecordChangeset
0000000000000000000000000000000000000000;;		// Apply applies the accumulated operations to the Zone.
0000000000000000000000000000000000000000;;		Apply() error
0000000000000000000000000000000000000000;;		// IsEmpty returns true if there are no accumulated operations.
0000000000000000000000000000000000000000;;		IsEmpty() bool
0000000000000000000000000000000000000000;;		// ResourceRecordSets returns the parent ResourceRecordSets
0000000000000000000000000000000000000000;;		ResourceRecordSets() ResourceRecordSets
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceRecordSet interface {
0000000000000000000000000000000000000000;;		// Name returns the name of the ResourceRecordSet, e.g. "www.example.com".
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		// Rrdatas returns the Resource Record Datas of the record set.
0000000000000000000000000000000000000000;;		Rrdatas() []string
0000000000000000000000000000000000000000;;		// Ttl returns the time-to-live of the record set, in seconds.
0000000000000000000000000000000000000000;;		Ttl() int64
0000000000000000000000000000000000000000;;		// Type returns the type of the record set (A, CNAME, SRV, etc)
0000000000000000000000000000000000000000;;		Type() rrstype.RrsType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* ResourceRecordSetsEquivalent compares two ResourceRecordSets for semantic equivalence.
0000000000000000000000000000000000000000;;	   Go's equality operator doesn't work the way we want it to in this case,
0000000000000000000000000000000000000000;;	   hence the need for this function.
0000000000000000000000000000000000000000;;	   More specifically (from the Go spec):
0000000000000000000000000000000000000000;;	   "Two struct values are equal if their corresponding non-blank fields are equal."
0000000000000000000000000000000000000000;;	   In our case, there may be some private internal member variables that may not be not equal,
0000000000000000000000000000000000000000;;	   but we want the two structs to be considered equivalent anyway, if the fields exposed
0000000000000000000000000000000000000000;;	   via their interfaces are equal.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func ResourceRecordSetsEquivalent(r1, r2 ResourceRecordSet) bool {
0000000000000000000000000000000000000000;;		if r1.Name() == r2.Name() && reflect.DeepEqual(r1.Rrdatas(), r2.Rrdatas()) && r1.Ttl() == r2.Ttl() && r1.Type() == r2.Type() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
