0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
022d85a97e1d77cd57f50e4d3e1991add9ec7af9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package install
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResourceVersioner(t *testing.T) {
0000000000000000000000000000000000000000;;		accessor := meta.NewAccessor()
0000000000000000000000000000000000000000;;		cluster := federation.Cluster{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "10"}}
0000000000000000000000000000000000000000;;		version, err := accessor.ResourceVersion(&cluster)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if version != "10" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected version %v", version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterList := federation.ClusterList{ListMeta: metav1.ListMeta{ResourceVersion: "10"}}
0000000000000000000000000000000000000000;;		version, err = accessor.ResourceVersion(&clusterList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if version != "10" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected version %v", version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCodec(t *testing.T) {
0000000000000000000000000000000000000000;;		cluster := federation.Cluster{}
0000000000000000000000000000000000000000;;		// We do want to use package registered rather than testapi here, because we
0000000000000000000000000000000000000000;;		// want to test if the package install and package registered work as expected.
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(api.Codecs.LegacyCodec(api.Registry.GroupOrDie(federation.GroupName).GroupVersion), &cluster)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		other := federation.Cluster{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &other); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if other.APIVersion != api.Registry.GroupOrDie(federation.GroupName).GroupVersion.String() || other.Kind != "Cluster" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected unmarshalled object %#v", other)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInterfacesFor(t *testing.T) {
0000000000000000000000000000000000000000;;		if _, err := api.Registry.GroupOrDie(federation.GroupName).InterfacesFor(federation.SchemeGroupVersion); err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected non-error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, version := range api.Registry.GroupOrDie(federation.GroupName).GroupVersions {
0000000000000000000000000000000000000000;;			if vi, err := api.Registry.GroupOrDie(federation.GroupName).InterfacesFor(version); err != nil || vi == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unexpected result: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapper(t *testing.T) {
0000000000000000000000000000000000000000;;		gv := v1beta1.SchemeGroupVersion
0000000000000000000000000000000000000000;;		clusterGVK := gv.WithKind("Cluster")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gvk, err := api.Registry.GroupOrDie(federation.GroupName).RESTMapper.KindFor(gv.WithResource("clusters")); err != nil || gvk != clusterGVK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected version mapping: %v %v", gvk, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m, err := api.Registry.GroupOrDie(federation.GroupName).RESTMapper.RESTMapping(clusterGVK.GroupKind(), ""); err != nil || m.GroupVersionKind != clusterGVK || m.Resource != "clusters" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected version mapping: %#v %v", m, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, version := range api.Registry.GroupOrDie(federation.GroupName).GroupVersions {
0000000000000000000000000000000000000000;;			mapping, err := api.Registry.GroupOrDie(federation.GroupName).RESTMapper.RESTMapping(clusterGVK.GroupKind(), version.Version)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if mapping.Resource != "clusters" {
0000000000000000000000000000000000000000;;				t.Errorf("incorrect resource name: %#v", mapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mapping.GroupVersionKind.GroupVersion() != version {
0000000000000000000000000000000000000000;;				t.Errorf("incorrect groupVersion: %v", mapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			interfaces, _ := api.Registry.GroupOrDie(federation.GroupName).InterfacesFor(version)
0000000000000000000000000000000000000000;;			if mapping.ObjectConvertor != interfaces.ObjectConvertor {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected: %#v, expected: %#v", mapping, interfaces)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rc := &federation.Cluster{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;			name, err := mapping.MetadataAccessor.Name(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if name != "foo" {
0000000000000000000000000000000000000000;;				t.Errorf("unable to retrieve object meta with: %v", mapping.MetadataAccessor)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
