0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
022d85a97e1d77cd57f50e4d3e1991add9ec7af9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package federation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
0000000000000000000000000000000000000000;;	type ServerAddressByClientCIDR struct {
0000000000000000000000000000000000000000;;		// The CIDR with which clients can match their IP to figure out the server address that they should use.
0000000000000000000000000000000000000000;;		ClientCIDR string
0000000000000000000000000000000000000000;;		// Address of this server, suitable for a client that matches the above CIDR.
0000000000000000000000000000000000000000;;		// This can be a hostname, hostname:port, IP or IP:port.
0000000000000000000000000000000000000000;;		ServerAddress string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterSpec describes the attributes of a kubernetes cluster.
0000000000000000000000000000000000000000;;	type ClusterSpec struct {
0000000000000000000000000000000000000000;;		// A map of client CIDR to server address.
0000000000000000000000000000000000000000;;		// This is to help clients reach servers in the most network-efficient way possible.
0000000000000000000000000000000000000000;;		// Clients can use the appropriate server address as per the CIDR that they match.
0000000000000000000000000000000000000000;;		// In case of multiple matches, clients should use the longest matching CIDR.
0000000000000000000000000000000000000000;;		ServerAddressByClientCIDRs []ServerAddressByClientCIDR
0000000000000000000000000000000000000000;;		// Name of the secret containing kubeconfig to access this cluster.
0000000000000000000000000000000000000000;;		// The secret is read from the kubernetes cluster that is hosting federation control plane.
0000000000000000000000000000000000000000;;		// Admin needs to ensure that the required secret exists. Secret should be in the same namespace where federation control plane is hosted and it should have kubeconfig in its data with key "kubeconfig".
0000000000000000000000000000000000000000;;		// This will later be changed to a reference to secret in federation control plane when the federation control plane supports secrets.
0000000000000000000000000000000000000000;;		// This can be left empty if the cluster allows insecure access.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *api.LocalObjectReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClusterConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of a cluster.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ClusterReady means the cluster is ready to accept workloads.
0000000000000000000000000000000000000000;;		ClusterReady ClusterConditionType = "Ready"
0000000000000000000000000000000000000000;;		// ClusterOffline means the cluster is temporarily down or not reachable
0000000000000000000000000000000000000000;;		ClusterOffline ClusterConditionType = "Offline"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterCondition describes current state of a cluster.
0000000000000000000000000000000000000000;;	type ClusterCondition struct {
0000000000000000000000000000000000000000;;		// Type of cluster condition, Complete or Failed.
0000000000000000000000000000000000000000;;		Type ClusterConditionType
0000000000000000000000000000000000000000;;		// Status of the condition, one of True, False, Unknown.
0000000000000000000000000000000000000000;;		Status api.ConditionStatus
0000000000000000000000000000000000000000;;		// Last time the condition was checked.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastProbeTime metav1.Time
0000000000000000000000000000000000000000;;		// Last time the condition transit from one status to another.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time
0000000000000000000000000000000000000000;;		// (brief) reason for the condition's last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// Human readable message indicating details about last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterStatus is information about the current status of a cluster updated by cluster controller periodically.
0000000000000000000000000000000000000000;;	type ClusterStatus struct {
0000000000000000000000000000000000000000;;		// Conditions is an array of current cluster conditions.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Conditions []ClusterCondition
0000000000000000000000000000000000000000;;		// Zones is the list of availability zones in which the nodes of the cluster exist, e.g. 'us-east1-a'.
0000000000000000000000000000000000000000;;		// These will always be in the same region.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Zones []string
0000000000000000000000000000000000000000;;		// Region is the name of the region in which all of the nodes in the cluster exist.  e.g. 'us-east1'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Region string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Information about a registered cluster in a federated kubernetes setup. Clusters are not namespaced and have unique names in the federation.
0000000000000000000000000000000000000000;;	type Cluster struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of the Cluster.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ClusterSpec
0000000000000000000000000000000000000000;;		// Status describes the current status of a Cluster
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ClusterStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A list of all the kubernetes clusters registered to the federation
0000000000000000000000000000000000000000;;	type ClusterList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of Cluster objects.
0000000000000000000000000000000000000000;;		Items []Cluster
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Temporary/alpha structures to support custom replica assignments within Federated workloads.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A set of preferences that can be added to federated version of workloads (deployments, replicasets, ..)
0000000000000000000000000000000000000000;;	// as a json-serialized annotation. The preferences allow the users to express in which clusters they
0000000000000000000000000000000000000000;;	// want to put their replicas within the mentioned workload objects.
0000000000000000000000000000000000000000;;	type ReplicaAllocationPreferences struct {
0000000000000000000000000000000000000000;;		// If set to true then already scheduled and running replicas may be moved to other clusters
0000000000000000000000000000000000000000;;		// in order to match current state to the specified preferences. Otherwise, if set to false,
0000000000000000000000000000000000000000;;		// up and running replicas will not be moved.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Rebalance bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A mapping between cluster names and preferences regarding a local workload object (dep, rs, .. ) in
0000000000000000000000000000000000000000;;		// these clusters.
0000000000000000000000000000000000000000;;		// "*" (if provided) applies to all clusters if an explicit mapping is not provided.
0000000000000000000000000000000000000000;;		// If omitted, clusters without explicit preferences should not have any replicas scheduled.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Clusters map[string]ClusterPreferences
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Preferences regarding number of replicas assigned to a cluster workload object (dep, rs, ..) within
0000000000000000000000000000000000000000;;	// a federated workload object.
0000000000000000000000000000000000000000;;	type ClusterPreferences struct {
0000000000000000000000000000000000000000;;		// Minimum number of replicas that should be assigned to this cluster workload object. 0 by default.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MinReplicas int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximum number of replicas that should be assigned to this cluster workload object.
0000000000000000000000000000000000000000;;		// Unbounded if no value provided (default).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MaxReplicas *int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A number expressing the preference to put an additional replica to this cluster workload object.
0000000000000000000000000000000000000000;;		// 0 by default.
0000000000000000000000000000000000000000;;		Weight int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Annotation for a federated service to keep record of service loadbalancer ingresses in federated cluster
0000000000000000000000000000000000000000;;	type FederatedServiceIngress struct {
0000000000000000000000000000000000000000;;		// List of loadbalancer ingress of a service in all federated clusters
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []ClusterServiceIngress `json:"items,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Loadbalancer ingresses of a service within a federated cluster
0000000000000000000000000000000000000000;;	type ClusterServiceIngress struct {
0000000000000000000000000000000000000000;;		// Cluster is the name of the federated cluster
0000000000000000000000000000000000000000;;		Cluster string `json:"cluster"`
0000000000000000000000000000000000000000;;		// List of loadbalancer ingresses of a federated service within a federated cluster
0000000000000000000000000000000000000000;;		Items []v1.LoadBalancerIngress `json:"items"`
0000000000000000000000000000000000000000;;	}
