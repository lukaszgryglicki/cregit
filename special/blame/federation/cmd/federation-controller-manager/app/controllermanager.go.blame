0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
87e7af804f6a2bf87552ef5940604a1e03de834d;federation/cmd/federated-controller-manager/app/controllermanager.go[federation/cmd/federated-controller-manager/app/controllermanager.go][federation/cmd/federation-controller-manager/app/controllermanager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package app implements a server that runs a set of active
0000000000000000000000000000000000000000;;	// components.  This includes cluster controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/pprof"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		utilflag "k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		federationclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/cmd/federation-controller-manager/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/pkg/federatedtypes"
0000000000000000000000000000000000000000;;		clustercontroller "k8s.io/kubernetes/federation/pkg/federation-controller/cluster"
0000000000000000000000000000000000000000;;		ingresscontroller "k8s.io/kubernetes/federation/pkg/federation-controller/ingress"
0000000000000000000000000000000000000000;;		servicecontroller "k8s.io/kubernetes/federation/pkg/federation-controller/service"
0000000000000000000000000000000000000000;;		servicednscontroller "k8s.io/kubernetes/federation/pkg/federation-controller/service/dns"
0000000000000000000000000000000000000000;;		synccontroller "k8s.io/kubernetes/federation/pkg/federation-controller/sync"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/configz"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewControllerManagerCommand creates a *cobra.Command object with default parameters
0000000000000000000000000000000000000000;;	func NewControllerManagerCommand() *cobra.Command {
0000000000000000000000000000000000000000;;		s := options.NewCMServer()
0000000000000000000000000000000000000000;;		s.AddFlags(pflag.CommandLine)
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Use: "federation-controller-manager",
0000000000000000000000000000000000000000;;			Long: `The federation controller manager is a daemon that embeds
0000000000000000000000000000000000000000;;	the core control loops shipped with federation. In applications of robotics and
0000000000000000000000000000000000000000;;	automation, a control loop is a non-terminating loop that regulates the state of
0000000000000000000000000000000000000000;;	the system. In federation, a controller is a control loop that watches the shared
0000000000000000000000000000000000000000;;	state of the federation cluster through the apiserver and makes changes attempting
0000000000000000000000000000000000000000;;	to move the current state towards the desired state. Examples of controllers that
0000000000000000000000000000000000000000;;	ship with federation today is the cluster controller.`,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs the CMServer.  This should never exit.
0000000000000000000000000000000000000000;;	func Run(s *options.CMServer) error {
0000000000000000000000000000000000000000;;		glog.Infof("%+v", version.Get())
0000000000000000000000000000000000000000;;		if c, err := configz.New("componentconfig"); err == nil {
0000000000000000000000000000000000000000;;			c.Set(s.ControllerManagerConfiguration)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("unable to register configz: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restClientCfg, err := clientcmd.BuildConfigFromFlags(s.Master, s.Kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil || restClientCfg == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Couldn't build the rest client config from flags: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Override restClientCfg qps/burst settings from flags
0000000000000000000000000000000000000000;;		restClientCfg.QPS = s.APIServerQPS
0000000000000000000000000000000000000000;;		restClientCfg.Burst = s.APIServerBurst
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			mux := http.NewServeMux()
0000000000000000000000000000000000000000;;			healthz.InstallHandler(mux)
0000000000000000000000000000000000000000;;			if s.EnableProfiling {
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/", pprof.Index)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
0000000000000000000000000000000000000000;;				mux.HandleFunc("/debug/pprof/trace", pprof.Trace)
0000000000000000000000000000000000000000;;				if s.EnableContentionProfiling {
0000000000000000000000000000000000000000;;					goruntime.SetBlockProfileRate(1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mux.Handle("/metrics", prometheus.Handler())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			server := &http.Server{
0000000000000000000000000000000000000000;;				Addr:    net.JoinHostPort(s.Address, strconv.Itoa(s.Port)),
0000000000000000000000000000000000000000;;				Handler: mux,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Fatal(server.ListenAndServe())
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		run := func() {
0000000000000000000000000000000000000000;;			err := StartControllers(s, restClientCfg)
0000000000000000000000000000000000000000;;			glog.Fatalf("error running controllers: %v", err)
0000000000000000000000000000000000000000;;			panic("unreachable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		run()
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StartControllers(s *options.CMServer, restClientCfg *restclient.Config) error {
0000000000000000000000000000000000000000;;		stopChan := wait.NeverStop
0000000000000000000000000000000000000000;;		minimizeLatency := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discoveryClient := discovery.NewDiscoveryClientForConfigOrDie(restClientCfg)
0000000000000000000000000000000000000000;;		serverResources, err := discoveryClient.ServerResources()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Could not find resources from API Server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clustercontroller.StartClusterController(restClientCfg, stopChan, s.ClusterMonitorPeriod.Duration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if controllerEnabled(s.Controllers, serverResources, servicecontroller.ControllerName, servicecontroller.RequiredResources, true) {
0000000000000000000000000000000000000000;;			if controllerEnabled(s.Controllers, serverResources, servicednscontroller.ControllerName, servicecontroller.RequiredResources, true) {
0000000000000000000000000000000000000000;;				serviceDNScontrollerClientset := federationclientset.NewForConfigOrDie(restclient.AddUserAgent(restClientCfg, servicednscontroller.UserAgentName))
0000000000000000000000000000000000000000;;				serviceDNSController, err := servicednscontroller.NewServiceDNSController(serviceDNScontrollerClientset, s.DnsProvider, s.DnsConfigFile, s.FederationName, s.ServiceDnsSuffix, s.ZoneName, s.ZoneID)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Fatalf("Failed to start service dns controller: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					go serviceDNSController.DNSControllerRun(s.ConcurrentServiceSyncs, wait.NeverStop)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Loading client config for service controller %q", servicecontroller.UserAgentName)
0000000000000000000000000000000000000000;;			scClientset := federationclientset.NewForConfigOrDie(restclient.AddUserAgent(restClientCfg, servicecontroller.UserAgentName))
0000000000000000000000000000000000000000;;			serviceController := servicecontroller.New(scClientset)
0000000000000000000000000000000000000000;;			go serviceController.Run(s.ConcurrentServiceSyncs, wait.NeverStop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for kind, federatedType := range federatedtypes.FederatedTypes() {
0000000000000000000000000000000000000000;;			if controllerEnabled(s.Controllers, serverResources, federatedType.ControllerName, federatedType.RequiredResources, true) {
0000000000000000000000000000000000000000;;				synccontroller.StartFederationSyncController(kind, federatedType.AdapterFactory, restClientCfg, stopChan, minimizeLatency)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if controllerEnabled(s.Controllers, serverResources, ingresscontroller.ControllerName, ingresscontroller.RequiredResources, true) {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Loading client config for ingress controller %q", ingresscontroller.UserAgentName)
0000000000000000000000000000000000000000;;			ingClientset := federationclientset.NewForConfigOrDie(restclient.AddUserAgent(restClientCfg, ingresscontroller.UserAgentName))
0000000000000000000000000000000000000000;;			ingressController := ingresscontroller.NewIngressController(ingClientset)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Running ingress controller")
0000000000000000000000000000000000000000;;			ingressController.Run(wait.NeverStop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func controllerEnabled(controllers utilflag.ConfigurationMap, serverResources []*metav1.APIResourceList, controller string, requiredResources []schema.GroupVersionResource, defaultValue bool) bool {
0000000000000000000000000000000000000000;;		controllerConfig, ok := controllers[controller]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if controllerConfig == "false" {
0000000000000000000000000000000000000000;;				glog.Infof("%s controller disabled by config", controller)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if controllerConfig == "true" {
0000000000000000000000000000000000000000;;				if !hasRequiredResources(serverResources, requiredResources) {
0000000000000000000000000000000000000000;;					glog.Fatalf("%s controller enabled explicitly but API Server does not have required resources", controller)
0000000000000000000000000000000000000000;;					panic("unreachable")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if defaultValue {
0000000000000000000000000000000000000000;;			if !hasRequiredResources(serverResources, requiredResources) {
0000000000000000000000000000000000000000;;				glog.Warningf("%s controller disabled because API Server does not have required resources", controller)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasRequiredResources(serverResources []*metav1.APIResourceList, requiredResources []schema.GroupVersionResource) bool {
0000000000000000000000000000000000000000;;		for _, resource := range requiredResources {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, serverResource := range serverResources {
0000000000000000000000000000000000000000;;				if serverResource.GroupVersion == resource.GroupVersion().String() {
0000000000000000000000000000000000000000;;					for _, apiResource := range serverResource.APIResources {
0000000000000000000000000000000000000000;;						if apiResource.Name == resource.Resource {
0000000000000000000000000000000000000000;;							found = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
