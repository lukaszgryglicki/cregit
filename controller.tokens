begin_unit
COMMENT|/* Copyright 2014 The Kubernetes Authors.  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at      http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */
DECL|package|master
package|package
IDENT|master
;|
import|import
(|(
STRING|"fmt"
;|
STRING|"net"
;|
STRING|"time"
;|
STRING|"github.com/golang/glog"
;|
STRING|"k8s.io/apimachinery/pkg/api/errors"
;|
IDENT|metav1
STRING|"k8s.io/apimachinery/pkg/apis/meta/v1"
;|
STRING|"k8s.io/apimachinery/pkg/util/intstr"
;|
IDENT|utilnet
STRING|"k8s.io/apimachinery/pkg/util/net"
;|
STRING|"k8s.io/apimachinery/pkg/util/runtime"
;|
STRING|"k8s.io/apimachinery/pkg/util/wait"
;|
IDENT|genericapiserver
STRING|"k8s.io/apiserver/pkg/server"
;|
STRING|"k8s.io/kubernetes/pkg/api"
;|
STRING|"k8s.io/kubernetes/pkg/api/endpoints"
;|
IDENT|coreclient
STRING|"k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
;|
STRING|"k8s.io/kubernetes/pkg/registry/core/rangeallocation"
;|
IDENT|corerest
STRING|"k8s.io/kubernetes/pkg/registry/core/rest"
;|
IDENT|servicecontroller
STRING|"k8s.io/kubernetes/pkg/registry/core/service/ipallocator/controller"
;|
IDENT|portallocatorcontroller
STRING|"k8s.io/kubernetes/pkg/registry/core/service/portallocator/controller"
;|
STRING|"k8s.io/kubernetes/pkg/util/async"
;|
)|)
;|
DECL|const|kubernetesServiceName
const|const
IDENT|kubernetesServiceName
=|=
STRING|"kubernetes"
;|
COMMENT|// Controller is the controller manager for the core bootstrap Kubernetes
COMMENT|// controller loops, which manage creating the "kubernetes" service, the
COMMENT|// "default", "kube-system" and "kube-public" namespaces, and provide the IP
COMMENT|// repair check on service IPs
DECL|type|Controller
type|type
IDENT|Controller
struct|struct
{|{
IDENT|ServiceClient
IDENT|coreclient
.|.
IDENT|ServicesGetter
;|
IDENT|NamespaceClient
IDENT|coreclient
.|.
IDENT|NamespacesGetter
;|
IDENT|ServiceClusterIPRegistry
IDENT|rangeallocation
.|.
IDENT|RangeRegistry
;|
IDENT|ServiceClusterIPInterval
IDENT|time
.|.
IDENT|Duration
;|
IDENT|ServiceClusterIPRange
IDENT|net
.|.
IDENT|IPNet
;|
IDENT|ServiceNodePortRegistry
IDENT|rangeallocation
.|.
IDENT|RangeRegistry
;|
IDENT|ServiceNodePortInterval
IDENT|time
.|.
IDENT|Duration
;|
IDENT|ServiceNodePortRange
IDENT|utilnet
.|.
IDENT|PortRange
;|
IDENT|EndpointReconciler
IDENT|EndpointReconciler
;|
IDENT|EndpointInterval
IDENT|time
.|.
IDENT|Duration
;|
IDENT|SystemNamespaces
[|[
]|]
IDENT|string
;|
IDENT|SystemNamespacesInterval
IDENT|time
.|.
IDENT|Duration
;|
IDENT|PublicIP
IDENT|net
.|.
IDENT|IP
;|
COMMENT|// ServiceIP indicates where the kubernetes service will live.  It may not be nil.
IDENT|ServiceIP
IDENT|net
.|.
IDENT|IP
;|
IDENT|ServicePort
IDENT|int
;|
IDENT|ExtraServicePorts
[|[
]|]
IDENT|api
.|.
IDENT|ServicePort
;|
IDENT|ExtraEndpointPorts
[|[
]|]
IDENT|api
.|.
IDENT|EndpointPort
;|
IDENT|PublicServicePort
IDENT|int
;|
IDENT|KubernetesServiceNodePort
IDENT|int
;|
IDENT|runner
*|*
IDENT|async
.|.
IDENT|Runner
;|
}|}
;|
COMMENT|// NewBootstrapController returns a controller for watching the core capabilities of the master
DECL|func|NewBootstrapController
func|func
(|(
IDENT|c
*|*
IDENT|Config
)|)
IDENT|NewBootstrapController
(|(
IDENT|legacyRESTStorage
IDENT|corerest
.|.
IDENT|LegacyRESTStorage
,|,
IDENT|serviceClient
IDENT|coreclient
.|.
IDENT|ServicesGetter
,|,
IDENT|nsClient
IDENT|coreclient
.|.
IDENT|NamespacesGetter
)|)
*|*
IDENT|Controller
{|{
return|return
&|&
IDENT|Controller
{|{
IDENT|ServiceClient
:|:
IDENT|serviceClient
,|,
IDENT|NamespaceClient
:|:
IDENT|nsClient
,|,
IDENT|EndpointReconciler
:|:
IDENT|c
.|.
IDENT|EndpointReconcilerConfig
.|.
IDENT|Reconciler
,|,
IDENT|EndpointInterval
:|:
IDENT|c
.|.
IDENT|EndpointReconcilerConfig
.|.
IDENT|Interval
,|,
IDENT|SystemNamespaces
:|:
[|[
]|]
IDENT|string
{|{
IDENT|metav1
.|.
IDENT|NamespaceSystem
,|,
IDENT|metav1
.|.
IDENT|NamespacePublic
}|}
,|,
IDENT|SystemNamespacesInterval
:|:
INT|1
*|*
IDENT|time
.|.
IDENT|Minute
,|,
IDENT|ServiceClusterIPRegistry
:|:
IDENT|legacyRESTStorage
.|.
IDENT|ServiceClusterIPAllocator
,|,
IDENT|ServiceClusterIPRange
:|:
IDENT|c
.|.
IDENT|ServiceIPRange
,|,
IDENT|ServiceClusterIPInterval
:|:
INT|3
*|*
IDENT|time
.|.
IDENT|Minute
,|,
IDENT|ServiceNodePortRegistry
:|:
IDENT|legacyRESTStorage
.|.
IDENT|ServiceNodePortAllocator
,|,
IDENT|ServiceNodePortRange
:|:
IDENT|c
.|.
IDENT|ServiceNodePortRange
,|,
IDENT|ServiceNodePortInterval
:|:
INT|3
*|*
IDENT|time
.|.
IDENT|Minute
,|,
IDENT|PublicIP
:|:
IDENT|c
.|.
IDENT|GenericConfig
.|.
IDENT|PublicAddress
,|,
IDENT|ServiceIP
:|:
IDENT|c
.|.
IDENT|APIServerServiceIP
,|,
IDENT|ServicePort
:|:
IDENT|c
.|.
IDENT|APIServerServicePort
,|,
IDENT|ExtraServicePorts
:|:
IDENT|c
.|.
IDENT|ExtraServicePorts
,|,
IDENT|ExtraEndpointPorts
:|:
IDENT|c
.|.
IDENT|ExtraEndpointPorts
,|,
IDENT|PublicServicePort
:|:
IDENT|c
.|.
IDENT|GenericConfig
.|.
IDENT|ReadWritePort
,|,
IDENT|KubernetesServiceNodePort
:|:
IDENT|c
.|.
IDENT|KubernetesServiceNodePort
,|,
}|}
;|
}|}
;|
DECL|func|PostStartHook
func|func
(|(
IDENT|c
*|*
IDENT|Controller
)|)
IDENT|PostStartHook
(|(
IDENT|hookContext
IDENT|genericapiserver
.|.
IDENT|PostStartHookContext
)|)
IDENT|error
{|{
IDENT|c
.|.
IDENT|Start
(|(
)|)
;|
return|return
IDENT|nil
;|
}|}
;|
COMMENT|// Start begins the core controller loops that must exist for bootstrapping
COMMENT|// a cluster.
DECL|func|Start
func|func
(|(
IDENT|c
*|*
IDENT|Controller
)|)
IDENT|Start
(|(
)|)
{|{
if|if
IDENT|c
.|.
IDENT|runner
!=|!=
IDENT|nil
{|{
return|return
;|
}|}
;|
IDENT|repairClusterIPs
:=|:=
IDENT|servicecontroller
.|.
IDENT|NewRepair
(|(
IDENT|c
.|.
IDENT|ServiceClusterIPInterval
,|,
IDENT|c
.|.
IDENT|ServiceClient
,|,
&|&
IDENT|c
.|.
IDENT|ServiceClusterIPRange
,|,
IDENT|c
.|.
IDENT|ServiceClusterIPRegistry
)|)
;|
IDENT|repairNodePorts
:=|:=
IDENT|portallocatorcontroller
.|.
IDENT|NewRepair
(|(
IDENT|c
.|.
IDENT|ServiceNodePortInterval
,|,
IDENT|c
.|.
IDENT|ServiceClient
,|,
IDENT|c
.|.
IDENT|ServiceNodePortRange
,|,
IDENT|c
.|.
IDENT|ServiceNodePortRegistry
)|)
;|
COMMENT|// run all of the controllers once prior to returning from Start.
if|if
IDENT|err
:=|:=
IDENT|repairClusterIPs
.|.
IDENT|RunOnce
(|(
)|)
;|;
IDENT|err
!=|!=
IDENT|nil
{|{
COMMENT|// If we fail to repair cluster IPs apiserver is useless. We should restart and retry.
IDENT|glog
.|.
IDENT|Fatalf
(|(
STRING|"Unable to perform initial IP allocation check: %v"
,|,
IDENT|err
)|)
;|
}|}
;|
if|if
IDENT|err
:=|:=
IDENT|repairNodePorts
.|.
IDENT|RunOnce
(|(
)|)
;|;
IDENT|err
!=|!=
IDENT|nil
{|{
COMMENT|// If we fail to repair node ports apiserver is useless. We should restart and retry.
IDENT|glog
.|.
IDENT|Fatalf
(|(
STRING|"Unable to perform initial service nodePort check: %v"
,|,
IDENT|err
)|)
;|
}|}
;|
COMMENT|// Service definition is reconciled during first run to correct port and type per expectations.
if|if
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|UpdateKubernetesService
(|(
IDENT|true
)|)
;|;
IDENT|err
!=|!=
IDENT|nil
{|{
IDENT|glog
.|.
IDENT|Errorf
(|(
STRING|"Unable to perform initial Kubernetes service initialization: %v"
,|,
IDENT|err
)|)
;|
}|}
;|
IDENT|c
.|.
IDENT|runner
=|=
IDENT|async
.|.
IDENT|NewRunner
(|(
IDENT|c
.|.
IDENT|RunKubernetesNamespaces
,|,
IDENT|c
.|.
IDENT|RunKubernetesService
,|,
IDENT|repairClusterIPs
.|.
IDENT|RunUntil
,|,
IDENT|repairNodePorts
.|.
IDENT|RunUntil
)|)
;|
IDENT|c
.|.
IDENT|runner
.|.
IDENT|Start
(|(
)|)
;|
}|}
;|
COMMENT|// RunKubernetesNamespaces periodically makes sure that all internal namespaces exist
DECL|func|RunKubernetesNamespaces
func|func
(|(
IDENT|c
*|*
IDENT|Controller
)|)
IDENT|RunKubernetesNamespaces
(|(
IDENT|ch
chan|chan
struct|struct
{|{
}|}
)|)
{|{
IDENT|wait
.|.
IDENT|Until
(|(
func|func
(|(
)|)
{|{
COMMENT|// Loop the system namespace list, and create them if they do not exist
for|for
IDENT|_
,|,
IDENT|ns
:=|:=
range|range
IDENT|c
.|.
IDENT|SystemNamespaces
{|{
if|if
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|CreateNamespaceIfNeeded
(|(
IDENT|ns
)|)
;|;
IDENT|err
!=|!=
IDENT|nil
{|{
IDENT|runtime
.|.
IDENT|HandleError
(|(
IDENT|fmt
.|.
IDENT|Errorf
(|(
STRING|"unable to create required kubernetes system namespace %s: %v"
,|,
IDENT|ns
,|,
IDENT|err
)|)
)|)
;|
}|}
;|
}|}
;|
}|}
,|,
IDENT|c
.|.
IDENT|SystemNamespacesInterval
,|,
IDENT|ch
)|)
;|
}|}
;|
COMMENT|// RunKubernetesService periodically updates the kubernetes service
DECL|func|RunKubernetesService
func|func
(|(
IDENT|c
*|*
IDENT|Controller
)|)
IDENT|RunKubernetesService
(|(
IDENT|ch
chan|chan
struct|struct
{|{
}|}
)|)
{|{
IDENT|wait
.|.
IDENT|Until
(|(
func|func
(|(
)|)
{|{
COMMENT|// Service definition is not reconciled after first
COMMENT|// run, ports and type will be corrected only during
COMMENT|// start.
if|if
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|UpdateKubernetesService
(|(
IDENT|false
)|)
;|;
IDENT|err
!=|!=
IDENT|nil
{|{
IDENT|runtime
.|.
IDENT|HandleError
(|(
IDENT|fmt
.|.
IDENT|Errorf
(|(
STRING|"unable to sync kubernetes service: %v"
,|,
IDENT|err
)|)
)|)
;|
}|}
;|
}|}
,|,
IDENT|c
.|.
IDENT|EndpointInterval
,|,
IDENT|ch
)|)
;|
}|}
;|
COMMENT|// UpdateKubernetesService attempts to update the default Kube service.
DECL|func|UpdateKubernetesService
func|func
(|(
IDENT|c
*|*
IDENT|Controller
)|)
IDENT|UpdateKubernetesService
(|(
IDENT|reconcile
IDENT|bool
)|)
IDENT|error
{|{
COMMENT|// Update service & endpoint records.
COMMENT|// TODO: when it becomes possible to change this stuff,
COMMENT|// stop polling and start watching.
COMMENT|// TODO: add endpoints of all replicas, not just the elected master.
if|if
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|CreateNamespaceIfNeeded
(|(
IDENT|metav1
.|.
IDENT|NamespaceDefault
)|)
;|;
IDENT|err
!=|!=
IDENT|nil
{|{
return|return
IDENT|err
;|
}|}
;|
IDENT|servicePorts
,|,
IDENT|serviceType
:=|:=
IDENT|createPortAndServiceSpec
(|(
IDENT|c
.|.
IDENT|ServicePort
,|,
IDENT|c
.|.
IDENT|PublicServicePort
,|,
IDENT|c
.|.
IDENT|KubernetesServiceNodePort
,|,
STRING|"https"
,|,
IDENT|c
.|.
IDENT|ExtraServicePorts
)|)
;|
if|if
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|CreateOrUpdateMasterServiceIfNeeded
(|(
IDENT|kubernetesServiceName
,|,
IDENT|c
.|.
IDENT|ServiceIP
,|,
IDENT|servicePorts
,|,
IDENT|serviceType
,|,
IDENT|reconcile
)|)
;|;
IDENT|err
!=|!=
IDENT|nil
{|{
return|return
IDENT|err
;|
}|}
;|
IDENT|endpointPorts
:=|:=
IDENT|createEndpointPortSpec
(|(
IDENT|c
.|.
IDENT|PublicServicePort
,|,
STRING|"https"
,|,
IDENT|c
.|.
IDENT|ExtraEndpointPorts
)|)
;|
if|if
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|EndpointReconciler
.|.
IDENT|ReconcileEndpoints
(|(
IDENT|kubernetesServiceName
,|,
IDENT|c
.|.
IDENT|PublicIP
,|,
IDENT|endpointPorts
,|,
IDENT|reconcile
)|)
;|;
IDENT|err
!=|!=
IDENT|nil
{|{
return|return
IDENT|err
;|
}|}
;|
return|return
IDENT|nil
;|
}|}
;|
COMMENT|// CreateNamespaceIfNeeded will create a namespace if it doesn't already exist
DECL|func|CreateNamespaceIfNeeded
func|func
(|(
IDENT|c
*|*
IDENT|Controller
)|)
IDENT|CreateNamespaceIfNeeded
(|(
IDENT|ns
IDENT|string
)|)
IDENT|error
{|{
if|if
IDENT|_
,|,
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|NamespaceClient
.|.
IDENT|Namespaces
(|(
)|)
.|.
IDENT|Get
(|(
IDENT|ns
,|,
IDENT|metav1
.|.
IDENT|GetOptions
{|{
}|}
)|)
;|;
IDENT|err
==|==
IDENT|nil
{|{
COMMENT|// the namespace already exists
return|return
IDENT|nil
;|
}|}
;|
IDENT|newNs
:=|:=
&|&
IDENT|api
.|.
IDENT|Namespace
{|{
IDENT|ObjectMeta
:|:
IDENT|metav1
.|.
IDENT|ObjectMeta
{|{
IDENT|Name
:|:
IDENT|ns
,|,
IDENT|Namespace
:|:
STRING|""
,|,
}|}
,|,
}|}
;|
IDENT|_
,|,
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|NamespaceClient
.|.
IDENT|Namespaces
(|(
)|)
.|.
IDENT|Create
(|(
IDENT|newNs
)|)
;|
if|if
IDENT|err
!=|!=
IDENT|nil
&&|&&
IDENT|errors
.|.
IDENT|IsAlreadyExists
(|(
IDENT|err
)|)
{|{
IDENT|err
=|=
IDENT|nil
;|
}|}
;|
return|return
IDENT|err
;|
}|}
;|
COMMENT|// createPortAndServiceSpec creates an array of service ports.
COMMENT|// If the NodePort value is 0, just the servicePort is used, otherwise, a node port is exposed.
DECL|func|createPortAndServiceSpec
func|func
IDENT|createPortAndServiceSpec
(|(
IDENT|servicePort
IDENT|int
,|,
IDENT|targetServicePort
IDENT|int
,|,
IDENT|nodePort
IDENT|int
,|,
IDENT|servicePortName
IDENT|string
,|,
IDENT|extraServicePorts
[|[
]|]
IDENT|api
.|.
IDENT|ServicePort
)|)
(|(
[|[
]|]
IDENT|api
.|.
IDENT|ServicePort
,|,
IDENT|api
.|.
IDENT|ServiceType
)|)
{|{
COMMENT|//Use the Cluster IP type for the service port if NodePort isn't provided.
COMMENT|//Otherwise, we will be binding the master service to a NodePort.
IDENT|servicePorts
:=|:=
[|[
]|]
IDENT|api
.|.
IDENT|ServicePort
{|{
{|{
IDENT|Protocol
:|:
IDENT|api
.|.
IDENT|ProtocolTCP
,|,
IDENT|Port
:|:
IDENT|int32
(|(
IDENT|servicePort
)|)
,|,
IDENT|Name
:|:
IDENT|servicePortName
,|,
IDENT|TargetPort
:|:
IDENT|intstr
.|.
IDENT|FromInt
(|(
IDENT|targetServicePort
)|)
}|}
}|}
;|
IDENT|serviceType
:=|:=
IDENT|api
.|.
IDENT|ServiceTypeClusterIP
;|
if|if
IDENT|nodePort
>|>
INT|0
{|{
IDENT|servicePorts
[|[
INT|0
]|]
.|.
IDENT|NodePort
=|=
IDENT|int32
(|(
IDENT|nodePort
)|)
;|
IDENT|serviceType
=|=
IDENT|api
.|.
IDENT|ServiceTypeNodePort
;|
}|}
;|
if|if
IDENT|extraServicePorts
!=|!=
IDENT|nil
{|{
IDENT|servicePorts
=|=
IDENT|append
(|(
IDENT|servicePorts
,|,
IDENT|extraServicePorts
...|...
)|)
;|
}|}
;|
return|return
IDENT|servicePorts
,|,
IDENT|serviceType
;|
}|}
;|
COMMENT|// createEndpointPortSpec creates an array of endpoint ports
DECL|func|createEndpointPortSpec
func|func
IDENT|createEndpointPortSpec
(|(
IDENT|endpointPort
IDENT|int
,|,
IDENT|endpointPortName
IDENT|string
,|,
IDENT|extraEndpointPorts
[|[
]|]
IDENT|api
.|.
IDENT|EndpointPort
)|)
[|[
]|]
IDENT|api
.|.
IDENT|EndpointPort
{|{
IDENT|endpointPorts
:=|:=
[|[
]|]
IDENT|api
.|.
IDENT|EndpointPort
{|{
{|{
IDENT|Protocol
:|:
IDENT|api
.|.
IDENT|ProtocolTCP
,|,
IDENT|Port
:|:
IDENT|int32
(|(
IDENT|endpointPort
)|)
,|,
IDENT|Name
:|:
IDENT|endpointPortName
,|,
}|}
}|}
;|
if|if
IDENT|extraEndpointPorts
!=|!=
IDENT|nil
{|{
IDENT|endpointPorts
=|=
IDENT|append
(|(
IDENT|endpointPorts
,|,
IDENT|extraEndpointPorts
...|...
)|)
;|
}|}
;|
return|return
IDENT|endpointPorts
;|
}|}
;|
COMMENT|// CreateMasterServiceIfNeeded will create the specified service if it
COMMENT|// doesn't already exist.
DECL|func|CreateOrUpdateMasterServiceIfNeeded
func|func
(|(
IDENT|c
*|*
IDENT|Controller
)|)
IDENT|CreateOrUpdateMasterServiceIfNeeded
(|(
IDENT|serviceName
IDENT|string
,|,
IDENT|serviceIP
IDENT|net
.|.
IDENT|IP
,|,
IDENT|servicePorts
[|[
]|]
IDENT|api
.|.
IDENT|ServicePort
,|,
IDENT|serviceType
IDENT|api
.|.
IDENT|ServiceType
,|,
IDENT|reconcile
IDENT|bool
)|)
IDENT|error
{|{
if|if
IDENT|s
,|,
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|ServiceClient
.|.
IDENT|Services
(|(
IDENT|metav1
.|.
IDENT|NamespaceDefault
)|)
.|.
IDENT|Get
(|(
IDENT|serviceName
,|,
IDENT|metav1
.|.
IDENT|GetOptions
{|{
}|}
)|)
;|;
IDENT|err
==|==
IDENT|nil
{|{
COMMENT|// The service already exists.
if|if
IDENT|reconcile
{|{
if|if
IDENT|svc
,|,
IDENT|updated
:=|:=
IDENT|getMasterServiceUpdateIfNeeded
(|(
IDENT|s
,|,
IDENT|servicePorts
,|,
IDENT|serviceType
)|)
;|;
IDENT|updated
{|{
IDENT|glog
.|.
IDENT|Warningf
(|(
STRING|"Resetting master service %q to %#v"
,|,
IDENT|serviceName
,|,
IDENT|svc
)|)
;|
IDENT|_
,|,
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|ServiceClient
.|.
IDENT|Services
(|(
IDENT|metav1
.|.
IDENT|NamespaceDefault
)|)
.|.
IDENT|Update
(|(
IDENT|svc
)|)
;|
return|return
IDENT|err
;|
}|}
;|
}|}
;|
return|return
IDENT|nil
;|
}|}
;|
IDENT|svc
:=|:=
&|&
IDENT|api
.|.
IDENT|Service
{|{
IDENT|ObjectMeta
:|:
IDENT|metav1
.|.
IDENT|ObjectMeta
{|{
IDENT|Name
:|:
IDENT|serviceName
,|,
IDENT|Namespace
:|:
IDENT|metav1
.|.
IDENT|NamespaceDefault
,|,
IDENT|Labels
:|:
map|map
[|[
IDENT|string
]|]
IDENT|string
{|{
STRING|"provider"
:|:
STRING|"kubernetes"
,|,
STRING|"component"
:|:
STRING|"apiserver"
}|}
,|,
}|}
,|,
IDENT|Spec
:|:
IDENT|api
.|.
IDENT|ServiceSpec
{|{
IDENT|Ports
:|:
IDENT|servicePorts
,|,
COMMENT|// maintained by this code, not by the pod selector
IDENT|Selector
:|:
IDENT|nil
,|,
IDENT|ClusterIP
:|:
IDENT|serviceIP
.|.
IDENT|String
(|(
)|)
,|,
IDENT|SessionAffinity
:|:
IDENT|api
.|.
IDENT|ServiceAffinityClientIP
,|,
IDENT|Type
:|:
IDENT|serviceType
,|,
}|}
,|,
}|}
;|
IDENT|_
,|,
IDENT|err
:=|:=
IDENT|c
.|.
IDENT|ServiceClient
.|.
IDENT|Services
(|(
IDENT|metav1
.|.
IDENT|NamespaceDefault
)|)
.|.
IDENT|Create
(|(
IDENT|svc
)|)
;|
if|if
IDENT|errors
.|.
IDENT|IsAlreadyExists
(|(
IDENT|err
)|)
{|{
return|return
IDENT|c
.|.
IDENT|CreateOrUpdateMasterServiceIfNeeded
(|(
IDENT|serviceName
,|,
IDENT|serviceIP
,|,
IDENT|servicePorts
,|,
IDENT|serviceType
,|,
IDENT|reconcile
)|)
;|
}|}
;|
return|return
IDENT|err
;|
}|}
;|
COMMENT|// EndpointReconciler knows how to reconcile the endpoints for the apiserver service.
DECL|type|EndpointReconciler
type|type
IDENT|EndpointReconciler
interface|interface
{|{
COMMENT|// ReconcileEndpoints sets the endpoints for the given apiserver service (ro or rw).
COMMENT|// ReconcileEndpoints expects that the endpoints objects it manages will all be
COMMENT|// managed only by ReconcileEndpoints; therefore, to understand this, you need only
COMMENT|// understand the requirements.
COMMENT|//
COMMENT|// Requirements:
COMMENT|//  * All apiservers MUST use the same ports for their {rw, ro} services.
COMMENT|//  * All apiservers MUST use ReconcileEndpoints and only ReconcileEndpoints to manage the
COMMENT|//      endpoints for their {rw, ro} services.
COMMENT|//  * ReconcileEndpoints is called periodically from all apiservers.
IDENT|ReconcileEndpoints
(|(
IDENT|serviceName
IDENT|string
,|,
IDENT|ip
IDENT|net
.|.
IDENT|IP
,|,
IDENT|endpointPorts
[|[
]|]
IDENT|api
.|.
IDENT|EndpointPort
,|,
IDENT|reconcilePorts
IDENT|bool
)|)
IDENT|error
;|
}|}
;|
COMMENT|// masterCountEndpointReconciler reconciles endpoints based on a specified expected number of
COMMENT|// masters. masterCountEndpointReconciler implements EndpointReconciler.
DECL|type|masterCountEndpointReconciler
type|type
IDENT|masterCountEndpointReconciler
struct|struct
{|{
IDENT|masterCount
IDENT|int
;|
IDENT|endpointClient
IDENT|coreclient
.|.
IDENT|EndpointsGetter
;|
}|}
;|
DECL|var|_
var|var
IDENT|_
IDENT|EndpointReconciler
=|=
&|&
IDENT|masterCountEndpointReconciler
{|{
}|}
;|
COMMENT|// NewMasterCountEndpointReconciler creates a new EndpointReconciler that reconciles based on a
COMMENT|// specified expected number of masters.
DECL|func|NewMasterCountEndpointReconciler
func|func
IDENT|NewMasterCountEndpointReconciler
(|(
IDENT|masterCount
IDENT|int
,|,
IDENT|endpointClient
IDENT|coreclient
.|.
IDENT|EndpointsGetter
)|)
*|*
IDENT|masterCountEndpointReconciler
{|{
return|return
&|&
IDENT|masterCountEndpointReconciler
{|{
IDENT|masterCount
:|:
IDENT|masterCount
,|,
IDENT|endpointClient
:|:
IDENT|endpointClient
,|,
}|}
;|
}|}
;|
COMMENT|// ReconcileEndpoints sets the endpoints for the given apiserver service (ro or rw).
COMMENT|// ReconcileEndpoints expects that the endpoints objects it manages will all be
COMMENT|// managed only by ReconcileEndpoints; therefore, to understand this, you need only
COMMENT|// understand the requirements and the body of this function.
COMMENT|//
COMMENT|// Requirements:
COMMENT|//  * All apiservers MUST use the same ports for their {rw, ro} services.
COMMENT|//  * All apiservers MUST use ReconcileEndpoints and only ReconcileEndpoints to manage the
COMMENT|//      endpoints for their {rw, ro} services.
COMMENT|//  * All apiservers MUST know and agree on the number of apiservers expected
COMMENT|//      to be running (c.masterCount).
COMMENT|//  * ReconcileEndpoints is called periodically from all apiservers.
DECL|func|ReconcileEndpoints
func|func
(|(
IDENT|r
*|*
IDENT|masterCountEndpointReconciler
)|)
IDENT|ReconcileEndpoints
(|(
IDENT|serviceName
IDENT|string
,|,
IDENT|ip
IDENT|net
.|.
IDENT|IP
,|,
IDENT|endpointPorts
[|[
]|]
IDENT|api
.|.
IDENT|EndpointPort
,|,
IDENT|reconcilePorts
IDENT|bool
)|)
IDENT|error
{|{
IDENT|e
,|,
IDENT|err
:=|:=
IDENT|r
.|.
IDENT|endpointClient
.|.
IDENT|Endpoints
(|(
IDENT|metav1
.|.
IDENT|NamespaceDefault
)|)
.|.
IDENT|Get
(|(
IDENT|serviceName
,|,
IDENT|metav1
.|.
IDENT|GetOptions
{|{
}|}
)|)
;|
if|if
IDENT|err
!=|!=
IDENT|nil
{|{
IDENT|e
=|=
&|&
IDENT|api
.|.
IDENT|Endpoints
{|{
IDENT|ObjectMeta
:|:
IDENT|metav1
.|.
IDENT|ObjectMeta
{|{
IDENT|Name
:|:
IDENT|serviceName
,|,
IDENT|Namespace
:|:
IDENT|metav1
.|.
IDENT|NamespaceDefault
,|,
}|}
,|,
}|}
;|
}|}
;|
if|if
IDENT|errors
.|.
IDENT|IsNotFound
(|(
IDENT|err
)|)
{|{
COMMENT|// Simply create non-existing endpoints for the service.
IDENT|e
.|.
IDENT|Subsets
=|=
[|[
]|]
IDENT|api
.|.
IDENT|EndpointSubset
{|{
{|{
IDENT|Addresses
:|:
[|[
]|]
IDENT|api
.|.
IDENT|EndpointAddress
{|{
{|{
IDENT|IP
:|:
IDENT|ip
.|.
IDENT|String
(|(
)|)
}|}
}|}
,|,
IDENT|Ports
:|:
IDENT|endpointPorts
,|,
}|}
}|}
;|
IDENT|_
,|,
IDENT|err
=|=
IDENT|r
.|.
IDENT|endpointClient
.|.
IDENT|Endpoints
(|(
IDENT|metav1
.|.
IDENT|NamespaceDefault
)|)
.|.
IDENT|Create
(|(
IDENT|e
)|)
;|
return|return
IDENT|err
;|
}|}
;|
COMMENT|// First, determine if the endpoint is in the format we expect (one
COMMENT|// subset, ports matching endpointPorts, N IP addresses).
IDENT|formatCorrect
,|,
IDENT|ipCorrect
,|,
IDENT|portsCorrect
:=|:=
IDENT|checkEndpointSubsetFormat
(|(
IDENT|e
,|,
IDENT|ip
.|.
IDENT|String
(|(
)|)
,|,
IDENT|endpointPorts
,|,
IDENT|r
.|.
IDENT|masterCount
,|,
IDENT|reconcilePorts
)|)
;|
if|if
!|!
IDENT|formatCorrect
{|{
COMMENT|// Something is egregiously wrong, just re-make the endpoints record.
IDENT|e
.|.
IDENT|Subsets
=|=
[|[
]|]
IDENT|api
.|.
IDENT|EndpointSubset
{|{
{|{
IDENT|Addresses
:|:
[|[
]|]
IDENT|api
.|.
IDENT|EndpointAddress
{|{
{|{
IDENT|IP
:|:
IDENT|ip
.|.
IDENT|String
(|(
)|)
}|}
}|}
,|,
IDENT|Ports
:|:
IDENT|endpointPorts
,|,
}|}
}|}
;|
IDENT|glog
.|.
IDENT|Warningf
(|(
STRING|"Resetting endpoints for master service %q to %#v"
,|,
IDENT|serviceName
,|,
IDENT|e
)|)
;|
IDENT|_
,|,
IDENT|err
=|=
IDENT|r
.|.
IDENT|endpointClient
.|.
IDENT|Endpoints
(|(
IDENT|metav1
.|.
IDENT|NamespaceDefault
)|)
.|.
IDENT|Update
(|(
IDENT|e
)|)
;|
return|return
IDENT|err
;|
}|}
;|
if|if
IDENT|ipCorrect
&&|&&
IDENT|portsCorrect
{|{
return|return
IDENT|nil
;|
}|}
;|
if|if
!|!
IDENT|ipCorrect
{|{
COMMENT|// We *always* add our own IP address.
IDENT|e
.|.
IDENT|Subsets
[|[
INT|0
]|]
.|.
IDENT|Addresses
=|=
IDENT|append
(|(
IDENT|e
.|.
IDENT|Subsets
[|[
INT|0
]|]
.|.
IDENT|Addresses
,|,
IDENT|api
.|.
IDENT|EndpointAddress
{|{
IDENT|IP
:|:
IDENT|ip
.|.
IDENT|String
(|(
)|)
}|}
)|)
;|
COMMENT|// Lexicographic order is retained by this step.
IDENT|e
.|.
IDENT|Subsets
=|=
IDENT|endpoints
.|.
IDENT|RepackSubsets
(|(
IDENT|e
.|.
IDENT|Subsets
)|)
;|
COMMENT|// If too many IP addresses, remove the ones lexicographically after our
COMMENT|// own IP address.  Given the requirements stated at the top of
COMMENT|// this function, this should cause the list of IP addresses to
COMMENT|// become eventually correct.
if|if
IDENT|addrs
:=|:=
&|&
IDENT|e
.|.
IDENT|Subsets
[|[
INT|0
]|]
.|.
IDENT|Addresses
;|;
IDENT|len
(|(
*|*
IDENT|addrs
)|)
>|>
IDENT|r
.|.
IDENT|masterCount
{|{
COMMENT|// addrs is a pointer because we're going to mutate it.
for|for
IDENT|i
,|,
IDENT|addr
:=|:=
range|range
*|*
IDENT|addrs
{|{
if|if
IDENT|addr
.|.
IDENT|IP
==|==
IDENT|ip
.|.
IDENT|String
(|(
)|)
{|{
for|for
IDENT|len
(|(
*|*
IDENT|addrs
)|)
>|>
IDENT|r
.|.
IDENT|masterCount
{|{
COMMENT|// wrap around if necessary.
IDENT|remove
:=|:=
(|(
IDENT|i
+|+
INT|1
)|)
%|%
IDENT|len
(|(
*|*
IDENT|addrs
)|)
;|
*|*
IDENT|addrs
=|=
IDENT|append
(|(
(|(
*|*
IDENT|addrs
)|)
[|[
:|:
IDENT|remove
]|]
,|,
(|(
*|*
IDENT|addrs
)|)
[|[
IDENT|remove
+|+
INT|1
:|:
]|]
...|...
)|)
;|
}|}
;|
break|break
;|
}|}
;|
}|}
;|
}|}
;|
}|}
;|
if|if
!|!
IDENT|portsCorrect
{|{
COMMENT|// Reset ports.
IDENT|e
.|.
IDENT|Subsets
[|[
INT|0
]|]
.|.
IDENT|Ports
=|=
IDENT|endpointPorts
;|
}|}
;|
IDENT|glog
.|.
IDENT|Warningf
(|(
STRING|"Resetting endpoints for master service %q to %v"
,|,
IDENT|serviceName
,|,
IDENT|e
)|)
;|
IDENT|_
,|,
IDENT|err
=|=
IDENT|r
.|.
IDENT|endpointClient
.|.
IDENT|Endpoints
(|(
IDENT|metav1
.|.
IDENT|NamespaceDefault
)|)
.|.
IDENT|Update
(|(
IDENT|e
)|)
;|
return|return
IDENT|err
;|
}|}
;|
COMMENT|// Determine if the endpoint is in the format ReconcileEndpoints expects.
COMMENT|//
COMMENT|// Return values:
COMMENT|// * formatCorrect is true if exactly one subset is found.
COMMENT|// * ipCorrect is true when current master's IP is found and the number
COMMENT|//     of addresses is less than or equal to the master count.
COMMENT|// * portsCorrect is true when endpoint ports exactly match provided ports.
COMMENT|//     portsCorrect is only evaluated when reconcilePorts is set to true.
DECL|func|checkEndpointSubsetFormat
func|func
IDENT|checkEndpointSubsetFormat
(|(
IDENT|e
*|*
IDENT|api
.|.
IDENT|Endpoints
,|,
IDENT|ip
IDENT|string
,|,
IDENT|ports
[|[
]|]
IDENT|api
.|.
IDENT|EndpointPort
,|,
IDENT|count
IDENT|int
,|,
IDENT|reconcilePorts
IDENT|bool
)|)
(|(
IDENT|formatCorrect
IDENT|bool
,|,
IDENT|ipCorrect
IDENT|bool
,|,
IDENT|portsCorrect
IDENT|bool
)|)
{|{
if|if
IDENT|len
(|(
IDENT|e
.|.
IDENT|Subsets
)|)
!=|!=
INT|1
{|{
return|return
IDENT|false
,|,
IDENT|false
,|,
IDENT|false
;|
}|}
;|
IDENT|sub
:=|:=
&|&
IDENT|e
.|.
IDENT|Subsets
[|[
INT|0
]|]
;|
IDENT|portsCorrect
=|=
IDENT|true
;|
if|if
IDENT|reconcilePorts
{|{
if|if
IDENT|len
(|(
IDENT|sub
.|.
IDENT|Ports
)|)
!=|!=
IDENT|len
(|(
IDENT|ports
)|)
{|{
IDENT|portsCorrect
=|=
IDENT|false
;|
}|}
;|
for|for
IDENT|i
,|,
IDENT|port
:=|:=
range|range
IDENT|ports
{|{
if|if
IDENT|len
(|(
IDENT|sub
.|.
IDENT|Ports
)|)
<=|<=
IDENT|i
barbar|||
IDENT|port
!=|!=
IDENT|sub
.|.
IDENT|Ports
[|[
IDENT|i
]|]
{|{
IDENT|portsCorrect
=|=
IDENT|false
;|
break|break
;|
}|}
;|
}|}
;|
}|}
;|
for|for
IDENT|_
,|,
IDENT|addr
:=|:=
range|range
IDENT|sub
.|.
IDENT|Addresses
{|{
if|if
IDENT|addr
.|.
IDENT|IP
==|==
IDENT|ip
{|{
IDENT|ipCorrect
=|=
IDENT|len
(|(
IDENT|sub
.|.
IDENT|Addresses
)|)
<=|<=
IDENT|count
;|
break|break
;|
}|}
;|
}|}
;|
return|return
IDENT|true
,|,
IDENT|ipCorrect
,|,
IDENT|portsCorrect
;|
}|}
;|
COMMENT|// * getMasterServiceUpdateIfNeeded sets service attributes for the
COMMENT|//     given apiserver service.
COMMENT|// * getMasterServiceUpdateIfNeeded expects that the service object it
COMMENT|//     manages will be managed only by getMasterServiceUpdateIfNeeded;
COMMENT|//     therefore, to understand this, you need only understand the
COMMENT|//     requirements and the body of this function.
COMMENT|// * getMasterServiceUpdateIfNeeded ensures that the correct ports are
COMMENT|//     are set.
COMMENT|//
COMMENT|// Requirements:
COMMENT|// * All apiservers MUST use getMasterServiceUpdateIfNeeded and only
COMMENT|//     getMasterServiceUpdateIfNeeded to manage service attributes
COMMENT|// * updateMasterService is called periodically from all apiservers.
DECL|func|getMasterServiceUpdateIfNeeded
func|func
IDENT|getMasterServiceUpdateIfNeeded
(|(
IDENT|svc
*|*
IDENT|api
.|.
IDENT|Service
,|,
IDENT|servicePorts
[|[
]|]
IDENT|api
.|.
IDENT|ServicePort
,|,
IDENT|serviceType
IDENT|api
.|.
IDENT|ServiceType
)|)
(|(
IDENT|s
*|*
IDENT|api
.|.
IDENT|Service
,|,
IDENT|updated
IDENT|bool
)|)
{|{
COMMENT|// Determine if the service is in the format we expect
COMMENT|// (servicePorts are present and service type matches)
IDENT|formatCorrect
:=|:=
IDENT|checkServiceFormat
(|(
IDENT|svc
,|,
IDENT|servicePorts
,|,
IDENT|serviceType
)|)
;|
if|if
IDENT|formatCorrect
{|{
return|return
IDENT|svc
,|,
IDENT|false
;|
}|}
;|
IDENT|svc
.|.
IDENT|Spec
.|.
IDENT|Ports
=|=
IDENT|servicePorts
;|
IDENT|svc
.|.
IDENT|Spec
.|.
IDENT|Type
=|=
IDENT|serviceType
;|
return|return
IDENT|svc
,|,
IDENT|true
;|
}|}
;|
COMMENT|// Determine if the service is in the correct format
COMMENT|// getMasterServiceUpdateIfNeeded expects (servicePorts are correct
COMMENT|// and service type matches).
DECL|func|checkServiceFormat
func|func
IDENT|checkServiceFormat
(|(
IDENT|s
*|*
IDENT|api
.|.
IDENT|Service
,|,
IDENT|ports
[|[
]|]
IDENT|api
.|.
IDENT|ServicePort
,|,
IDENT|serviceType
IDENT|api
.|.
IDENT|ServiceType
)|)
(|(
IDENT|formatCorrect
IDENT|bool
)|)
{|{
if|if
IDENT|s
.|.
IDENT|Spec
.|.
IDENT|Type
!=|!=
IDENT|serviceType
{|{
return|return
IDENT|false
;|
}|}
;|
if|if
IDENT|len
(|(
IDENT|ports
)|)
!=|!=
IDENT|len
(|(
IDENT|s
.|.
IDENT|Spec
.|.
IDENT|Ports
)|)
{|{
return|return
IDENT|false
;|
}|}
;|
for|for
IDENT|i
,|,
IDENT|port
:=|:=
range|range
IDENT|ports
{|{
if|if
IDENT|port
!=|!=
IDENT|s
.|.
IDENT|Spec
.|.
IDENT|Ports
[|[
IDENT|i
]|]
{|{
return|return
IDENT|false
;|
}|}
;|
}|}
;|
return|return
IDENT|true
;|
}|}
;|
end_unit

